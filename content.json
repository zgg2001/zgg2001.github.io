{"meta":{"title":"小咸鱼的自留地","subtitle":"","description":"河边小咸鱼","author":"Zgg2001","url":"https://zgg2001.github.io","root":"/"},"pages":[{"title":"分类","date":"2024-09-08T00:08:37.000Z","updated":"2024-09-08T00:09:36.789Z","comments":true,"path":"categories/index.html","permalink":"https://zgg2001.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2024-09-08T00:05:02.000Z","updated":"2024-09-08T00:07:40.799Z","comments":true,"path":"tags/index.html","permalink":"https://zgg2001.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"C/C++学习记录：深入理解三种传参方式","slug":"20210823_C_C++学习记录：深入理解三种传参方式","date":"2021-08-22T16:06:44.000Z","updated":"2021-08-22T16:06:44.000Z","comments":true,"path":"2021/08/23/20210823_C_C++学习记录：深入理解三种传参方式/","permalink":"https://zgg2001.github.io/2021/08/23/20210823_C_C++%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B8%89%E7%A7%8D%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F/","excerpt":"&emsp;&emsp;之前对传参这方面的东西一直是知其然不知所以然。概念用法怎么用都知道，但是其真正的内部操作流程确实是理解不足。这两天一直在总结shell脚本的笔记，写累了正好研究一下传参这方面的内容。&emsp;&emsp;这篇笔记中记录了关于这方面我的理解过程和心得。关于本篇笔记的深度，也是到汇编为止不再深入，就我个人理解来看已经是足够了。","text":"&emsp;&emsp;之前对传参这方面的东西一直是知其然不知所以然。概念用法怎么用都知道，但是其真正的内部操作流程确实是理解不足。这两天一直在总结shell脚本的笔记，写累了正好研究一下传参这方面的内容。&emsp;&emsp;这篇笔记中记录了关于这方面我的理解过程和心得。关于本篇笔记的深度，也是到汇编为止不再深入，就我个人理解来看已经是足够了。 一、关于三种传参方式1. 值传参1.1 简单总结&emsp;&emsp;这是我在编程中最早接触的传参方式，也是一开始使用最多的传参方式。它的特点很明确就是简便，非常明了。当然缺点也是被说了很多次，就是慢+占用空间+不能修改实参。因为所谓的值传参是把实参的值复制了一遍，所以会有上面的特点。 1.2 我的疑问&emsp;&emsp;总是说值传参的执行过程会复制实参的值，那么它的流程是怎么样的？ 2. 引用传参2.1 简单总结&emsp;&emsp;这是C++里的概念，C里是没有的。它解决了值传参不能修改实参的问题，另外也比传值要快。就我目前接触到的C++代码中，里面均常常用到&amp;和const &amp;，例如stl的源码。 2.2 我的疑问&emsp;&emsp;我看网上说传引用其实也是传的指针，所以一直对引用的流程很有兴趣。如果真的也是传指针，那么它的意义就是更简单明了的传指针吗？另外很多源码中都使用const &amp;，我一直很好奇传引用究竟能比传值快多少。 3. 指针传参3.1 简单总结&emsp;&emsp;第一次接触传指针，还是在当时学习链表的时候。在此之前，我对于指针作用的印象仅仅是文件指针和一丢丢字符串的内容，而对于学习中碰到的那些什么*p,&amp;p的完全没有实际应用中的感受，甚至产生了疑问，为何大伙都说指针牛p？&emsp;&emsp;在接触到链表头结点的指针后，我首次发现原来传值是不能改变内容的(太菜了当时)，得传指针，所以链表函数传参时，节点得取个地址传进去，由此我打开了新世界的大门，感受到了指针的牛p。以至于后面再接触java的时候感觉浑身难受，感受到了一种局限感，所以后面我决定以C&#x2F;C++为方向。&emsp;&emsp;对我而言，指针传参相当于是一种 **”降维打击”**，相当于“你收拾不了他就去找他爹收拾他”。总而言之，向下层操作性很大(提领指针的内容)，可以修改实参并且速度也很快。但是，传指针相当于把传值的内容改为指针，所以指针层面也是不能被修改的(虽然我也没见过要修改最高层指针)，由于指针的大小是固定的而且很小，传指针的速度也会很快。 3.2 我的疑问&emsp;&emsp;底层流程是什么？是先获取地址，再走值传递那一套流程吗？ 二、汇编层面剖析1. 操作&emsp;&emsp;我的理解方式是通过vs2019的反汇编功能查看低层汇编代码进行比对分析，而下面是我的操作过程。&emsp;&emsp;首先是实验源码如下，可以看到我声明了三个函数，分别用了三种传参方法。 1234567891011121314151617181920212223242526272829303132333435/** 三种传参方式测试* 2021/8/22*/#include&lt;cstdio&gt;//值传参void func_value(int x)&#123; x = 22;&#125;//引用传参void func_ref(int&amp; x_ref)&#123; x_ref = 2222;&#125;//指针传参void func_ptr(int* x_ptr)&#123; *x_ptr = 22222;&#125;int main()&#123; int test_arg = 222; //值传参 func_value(test_arg); //引用传参 func_ref(test_arg); //指针传参 func_ptr(&amp;test_arg); return 0;&#125; &emsp;&emsp;接着，我开启调试反汇编，查看调用三个函数时的汇编源码，结果如下： 2. 总结&emsp;&emsp; 说实话，我没想到传引用和传指针的汇编源码竟然完全一样…而传值和另外两者的唯一区别就是第一条汇编指令。其中传值用的是汇编指令mov，而传引用和传指针用的都是汇编指令lea。&emsp;&emsp;然后我搜了下，mov是把内容复制到寄存器eax，而lea是把地址复制到寄存器里。所以这里传值是把变量test_arg的内容复制到寄存器，而后两者是把变量test_arg的地址复制到寄存器。而内容复制一般复制量都比地址复制要大，这也就造成了效率上的差距。且传值修改的是复制的内容，所以实参不会受影响；但后两者修改的是传入指针里的内容，这两个指针(传参和实参指针)指向的内容是一致的，所以实参会收到影响。 所以总结下，函数传参的流程如下： 执行lea或mov指令将内容或指针拷贝到寄存器上。 执行push指令把寄存器里的内容push进栈。 执行call指令调用函数。 执行add指令确保堆栈平衡，相当于执行pop操作把前面push的内容弹出。而add的值跟参数个数有关(之前push的值)。 三、运行时间对比实践&emsp;&emsp;一直好奇三者之间运行时间的差异，正好借着这次实践测试一下。 1. 传参类型偏小&emsp;&emsp;首先是测试传参类型偏小的情况吧。这里选择的传参类型是int，在32位环境下，int和int*大小是一致的4字节。根据上面的汇编源码来看，我个人认为mov4字节和lea一个地址时间消耗可能是五五开的，于是我进行了以下的测试。 &emsp;&emsp;测试代码如下，其中我使用到了一个自己实现的计时器，计时器内容在这篇博客里C++学习记录：基于chrono库的高精度计时器。 1.1 函数内单运算操作&emsp;&emsp;这部分我在函数内均仅进行单运算操作，如下。&emsp;&emsp;函数执行一定次数TIME后的结果如下。果然在传参实际传入大小差不多的情况下，实际时间消耗也是差不多的。在我理解上，其实引用和指针传参可能也是算一种值传参吧，只不过它们传的值是指针。所以在传值大小相似的情况下时间消耗也相似。 1.2 函数内多运算操作&emsp;&emsp;然后我想到，不同的传参方式，操作传参的时间消耗一致吗？于是在函数内新增了几条运算。既然该情况下传参速度相同，如果执行速度也相同，则说明操作传参的时间消耗一致。 &emsp;&emsp;函数内均修改为如下操作：&emsp;&emsp;函数执行一定次数TIME后的结果如下。果然在操作增多的情况下，实际时间消耗也是差不多的。这说明操作传参的时间消耗是一致的。 2. 传参类型偏大“在我理解上，其实引用和指针传参可能也是算一种值传参吧，只不过它们传的值是指针。所以在传值大小相似的情况下时间消耗也相似。” &emsp;&emsp;为了证明我的这个猜测，我对传参类型进行了改变，这次选择使用的数据类型是c++的数据结构std::string。在32位环境下，std::string的大小是28字节，std::string*的大小还是4字节，即两者大小是七倍的关系。则如果时间消耗差距较大的话，则说明真正影响传参速度是传的大小，就说明我的猜测算是对的吧。 &emsp;&emsp;测试代码如下，还是用到了上文中提到的计时器。&emsp;&emsp;这部分函数的操作如下，仅仅是简单的sizeof操作。&emsp;&emsp;运行结果如下，可以看到时间如下，果然时间差距是非常的大。说明传参时间根本上还是受传参大小影响。不过我好奇的是为何时间差距这么大，我猜测可能是内存分配时间不同或是调用了std::string的构造参数吧。 四、体会&emsp;&emsp;随着和C&#x2F;C++打交道的时间越来越长，我探索的内容也越发深入、复杂。但是当真正理解了之前疑惑的内容，说实话还是很开心的。&emsp;&emsp;另外吐槽下csdn上鱼龙混杂，发的大部分都是很基础没有营养的东西，或者不知道哪抄的错误百出的内容，当然也有很多大佬的内容让我受益匪浅(深表感谢orz)，现在我搜个东西都得“发掘”半天。但是从某种意义上来讲我是有一点开心的，这说明我至少已经算入门了嘛XD","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"C++标准库学习","slug":"C-标准库学习","permalink":"https://zgg2001.github.io/tags/C-%E6%A0%87%E5%87%86%E5%BA%93%E5%AD%A6%E4%B9%A0/"},{"name":"源码阅读","slug":"源码阅读","permalink":"https://zgg2001.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"}]},{"title":"2020 蓝桥杯 Java实现 10月C组省赛","slug":"20210301-02_2020蓝桥杯Java实现10月C组省赛","date":"2021-03-01T14:21:26.000Z","updated":"2021-03-01T14:21:26.000Z","comments":true,"path":"2021/03/01/20210301-02_2020蓝桥杯Java实现10月C组省赛/","permalink":"https://zgg2001.github.io/2021/03/01/20210301-02_2020%E8%93%9D%E6%A1%A5%E6%9D%AFJava%E5%AE%9E%E7%8E%B010%E6%9C%88C%E7%BB%84%E7%9C%81%E8%B5%9B/","excerpt":"几个月没写题了，先找找手感，从简单的C组开始吧。 2020 蓝桥杯 Java实现 10月C组省赛 题目 &amp; 题解","text":"几个月没写题了，先找找手感，从简单的C组开始吧。 2020 蓝桥杯 Java实现 10月C组省赛 题目 &amp; 题解 试题 A: 约数个数本题总分：5 分 问题：对于一个整数，能整除这个整数的数称为这个数的约数。例如：1, 2, 3, 6 都是 6 的约数。请问 78120 有多少个约数。 思路： 暴力 答案： 96 1234567891011121314151617181920public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.printf(&quot;%d&quot;,func(78120)); &#125; public static int func(int a) &#123; int temp = 0; for(int now=1;now&lt;=a;now++) &#123; if(0 == a%now) &#123; temp++; &#125; &#125; return temp; &#125;&#125; 试题 B: 寻找 2020本题总分：5 分 附件在本篇末尾 问题： 小蓝有一个数字矩阵，里面只包含数字 0 和 2。小蓝很喜欢 2020，他想找到这个数字矩阵中有多少个 2020 。小蓝只关注三种构成 2020 的方式： 同一行里面连续四个字符从左到右构成 2020。同一列里面连续四个字符从上到下构成 2020。在一条从左上到右下的斜线上连续四个字符，从左上到右下构成 2020。例如，对于下面的矩阵： 123456220000000000002202000000000022002020 一共有 5 个 2020。其中 1 个是在同一行里的，1 个是在同一列里的，3 个是斜线上的。小蓝的矩阵比上面的矩阵要大，由于太大了，他只好将这个矩阵放在了一个文件里面，在试题目录下有一个文件 2020.txt，里面给出了小蓝的矩阵。请帮助小蓝确定在他的矩阵中有多少个 2020。 思路： 暴力 答案： 16120 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.io.*;public class HelloWorld &#123; public static void main(String[] args) throws IOException &#123; BufferedReader in = new BufferedReader(new InputStreamReader(new FileInputStream(&quot;D:/demo/1.txt&quot;))); char[][] map = new char[300][]; for (int i = 0; i &lt; 300; i++) &#123; map[i] = in.readLine().toCharArray(); &#125; int ans=0; for(int y=0;y&lt;300;y++) &#123; for(int x=0;x&lt;300;x++) &#123; //横排 if(x&lt;=296) &#123; if(map[y][x]==&#x27;2&#x27;&amp;&amp;map[y][x+1]==&#x27;0&#x27;&amp;&amp;map[y][x+2]==&#x27;2&#x27;&amp;&amp;map[y][x+3]==&#x27;0&#x27;) &#123; ans++; &#125; &#125; //竖排 if(y&lt;=296) &#123; if(map[y][x]==&#x27;2&#x27;&amp;&amp;map[y+1][x]==&#x27;0&#x27;&amp;&amp;map[y+2][x]==&#x27;2&#x27;&amp;&amp;map[y+3][x]==&#x27;0&#x27;) &#123; ans++; &#125; &#125; //斜排 if(y&lt;=296&amp;&amp;x&lt;=296) &#123; if(map[y][x]==&#x27;2&#x27;&amp;&amp;map[y+1][x+1]==&#x27;0&#x27;&amp;&amp;map[y+2][x+2]==&#x27;2&#x27;&amp;&amp;map[y+3][x+3]==&#x27;0&#x27;) &#123; ans++; &#125; &#125; &#125; &#125; System.out.print(ans); &#125;&#125; 试题 C: 跑步锻炼本题总分：10 分 问题：小蓝每天都锻炼身体。正常情况下，小蓝每天跑 1 千米。如果某天是周一或者月初（1 日），为了激励自己，小蓝要跑 2 千米。如果同时是周一或月初，小蓝也是跑 2 千米。小蓝跑步已经坚持了很长时间，从 2000 年 1 月 1 日周六（含）到 2020 年10 月 1 日周四（含）。请问这段时间小蓝总共跑步多少千米？ 思路： 根据平年闰年进行暴力 答案： 8879 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class HelloWorld &#123; public static int judge(int year) &#123; if((year%4==0 &amp;&amp; year%100!=0) || year%400==0) &#123; return 1; &#125; return 0; &#125; public static void main(String[] args) &#123; int[] p = &#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;;//平年1月到12月 int[] r = &#123;0,31,29,31,30,31,30,31,31,30,31,30,31&#125;;//闰年1月到12月 //起始日期 int year = 2000; int month = 1; int day = 1; int xq = 6;//星期6 int ans = 0;//公里 while(true) &#123; if(year==2020 &amp;&amp; month==10 &amp;&amp; day==1) &#123; ans+=2;//10月1号也算上 System.out.print(ans); return; &#125; if(day==1 || xq==1) &#123; ans+=2; &#125; else &#123; ans++; &#125; xq = ++xq % 7; day+=1; int state = judge(year);//1为闰年 0为平年 if(state == 1) &#123; if(day&gt;r[month]) &#123; day=1; month++; &#125; &#125; else &#123; if(day&gt;p[month]) &#123; day=1; month++; &#125; &#125; if(month&gt;12) &#123; month=1; year++; &#125; &#125; &#125;&#125; 试题 D: 平面分割本题总分：10 分 问题：20 个圆和 20 条直线最多能把平面分成多少个部分？ 思路： 数学题…不会啊，放一个知乎大佬的回答 答案： 1391大佬在这 点我去看大佬 试题 E: 七段码本题总分：15 分 问题：小蓝要用七段码数码管来表示一种特殊的文字。上图给出了七段码数码管的一个图示，数码管中一共有 7 段可以发光的二极管，分别标记为 a, b, c, d, e, f, g。小蓝要选择一部分二极管（至少要有一个）发光来表达字符。在设计字符的表达时，要求所有发光的二极管是连成一片的。 例如：b 发光，其他二极管不发光可以用来表达一种字符。例如：c 发光，其他二极管不发光可以用来表达一种字符。这种方案与上一行的方案可以用来表示不同的字符，尽管看上去比较相似。 例如：a, b, c, d, e 发光，f, g 不发光可以用来表达一种字符。例如：b, f 发光，其他二极管不发光则不能用来表达一种字符，因为发光的二极管没有连成一片。请问，小蓝可以用七段码数码管表达多少种不同的字符？ 思路： dfs出所有情况，然后用并查集判断是否属于同一子集 答案： 80 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105import java.util.ArrayList;import java.util.Collection;public class test &#123; static int ans = 0; static int[] jl = new int[10]; static int[][] map = new int[10][10]; static int[] father = new int[10]; public static void main(String[] args) &#123; //储存关系 a~g对应1~7 map[1][2] = map[2][1] = 1;//a b map[1][6] = map[6][1] = 1;//a f map[2][7] = map[7][2] = 1;//b g map[2][3] = map[3][2] = 1;//b c map[3][4] = map[4][3] = 1;//c d map[3][7] = map[7][3] = 1;//c g map[4][5] = map[5][4] = 1;//d e map[5][6] = map[6][5] = 1;//e f map[5][7] = map[7][5] = 1;//e g map[6][7] = map[7][6] = 1;//f g //dfs遍历所有情况 dfs(0); // System.out.print(ans); &#125; public static void dfs(int n) &#123; //当7个灯都有状态时 进行判定 if(n==7) &#123; //把亮着的灯统计下来 ArrayList&lt;Integer&gt; a = new ArrayList&lt;&gt;(); for(int i=1;i&lt;=7;i++) &#123; if(jl[i]==1) &#123; a.add(new Integer(i)); &#125; &#125; //判断 if(a.size()!=0) &#123; if(judge(a)==1) &#123; ans++; &#125; &#125; a.clear(); return; &#125; //否则dfs灯情况 jl[n+1] = 1; dfs(n+1); jl[n+1] = 0; dfs(n+1); &#125; public static int judge(ArrayList&lt;Integer&gt; a) &#123; //System.out.println(++js); //并查集父集重置 for(int i=0;i&lt;10;i++) &#123; father[i] = i; &#125; //并集 for(int i=0;i&lt;a.size();i++) &#123; for(int ii=0;ii&lt;a.size();ii++) &#123; //如果两边相连的话 进行并集操作 if(map[a.get(i).intValue()][a.get(ii).intValue()]==1) &#123; int fx = find(a.get(i).intValue()); int fy = find(a.get(ii).intValue()); if(fx!=fy) &#123; father[fx] = fy; &#125; &#125; &#125; &#125; //查看是否都属于一个集合 int temp = find(a.get(0).intValue()); for(int i=1;i&lt;a.size();i++) &#123; if(find(a.get(i).intValue())!=temp) &#123; return 0; &#125; &#125; return 1; &#125; //查集 public static int find(int x) &#123; return father[x]==x ? x : (father[x] = find(father[x])); &#125; &#125; 以下题目部分能通过AcWing和蓝桥杯竞赛的数据测试（有的题没有被录入，无法测试） 试题 F: 成绩统计时间限制: 1.0s 内存限制: 512.0MB本题总分：15 分 问题：小蓝给学生们组织了一场考试，卷面总分为 100 分，每个学生的得分都是一个 0 到 100 的整数。如果得分至少是 60 分，则称为及格。如果得分至少为 85 分，则称为优秀。请计算及格率和优秀率，用百分数表示，百分号前的部分四舍五入保留整数。 输入：输入的第一行包含一个整数 n，表示考试人数。接下来 n 行，每行包含一个 0 至 100 的整数，表示一个学生的得分。 输出：输出两行，每行一个百分数，分别表示及格率和优秀率。百分号前的部分四舍五入保留整数。 样例输入： 123456778092567488100 样例输出： 1271%43% 评测用例规模与约定：对于 50% 的评测用例，1 ≤ n ≤ 100。对于所有评测用例，1 ≤ n ≤ 10000。 思路： 送分题，记得四舍五入保留整数 AC代码： OJ链接 1234567891011121314151617181920212223242526import java.util.Scanner;public class Main&#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); double n = sc.nextDouble(); double a = 0; double b = 0; for(int now=0;now&lt;n;now++) &#123; int temp = sc.nextInt(); if(temp&gt;=60) &#123; a++; &#125; if(temp&gt;=85) &#123; b++; &#125; &#125; System.out.println((int)(a/n*100+0.5)+&quot;%&quot;); System.out.println((int)(b/n*100+0.5)+&quot;%&quot;); &#125;&#125; 试题 G: 单词分析时间限制: 1.0s 内存限制: 512.0MB本题总分：20 分 问题：小蓝正在学习一门神奇的语言，这门语言中的单词都是由小写英文字母组成，有些单词很长，远远超过正常英文单词的长度。小蓝学了很长时间也记不住一些单词，他准备不再完全记忆这些单词，而是根据单词中哪个字母出现得最多来分辨单词。现在，请你帮助小蓝，给了一个单词后，帮助他找到出现最多的字母和这个字母出现的次数。 输入：输入一行包含一个单词，单词只由小写英文字母组成。 问题：输出两行，第一行包含一个英文字母，表示单词中出现得最多的字母是哪个。如果有多个字母出现的次数相等，输出字典序最小的那个。第二行包含一个整数，表示出现得最多的那个字母在单词中出现的次数。 样例输入： 1lanqiao 样例输出： 12a2 样例输入： 1longlonglongistoolong 样例输出： 12o6 评测用例规模与约定：对于所有的评测用例，输入的单词长度不超过 1000。 思路： 暴力统计即可 代码： OJ链接 12345678910111213141516171819202122232425import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); String s = sc.nextLine(); int[] ans = new int[30]; for(int now=0;now&lt;s.length();now++) &#123; ans[(int)(s.charAt(now)-&#x27;a&#x27;)+1]++; &#125; int end = 1; for(int now=1;now&lt;=26;now++) &#123; if(ans[end]&lt;ans[now]) &#123; end = now; &#125; &#125; System.out.println((char)(&#x27;a&#x27;+end-1)); System.out.println(ans[end]); &#125;&#125; 试题 H: 数字三角形时间限制: 1.0s 内存限制: 512.0MB本题总分：20 分问题：上图给出了一个数字三角形。从三角形的顶部到底部有很多条不同的路径。对于每条路径，把路径上面的数加起来可以得到一个和，你的任务就是找到最大的和。路径上的每一步只能从一个数走到下一层和它最近的左边的那个数或者右边的那个数。此外，向左下走的次数与向右下走的次数相差不能超过 1。 输入：输入的第一行包含一个整数 N (1 &lt; N ≤ 100)，表示三角形的行数。下面的N 行给出数字三角形。数字三角形上的数都是 0 至 100 之间的整数。 输出：输出一个整数，表示答案。 样例输入： 123456573 88 1 02 7 4 44 5 2 6 5 样例输出： 127 思路： C组这题是简化过的，数据量少了，也多了条件，所以直接dfs暴力就好。当左右差减一大于剩下行数时，说明走到末尾时必定相差超过1，可以进行剪枝。 AC代码：OJ链接1 链接里是本题版本，用DFS写OJ链接2 链接里是未简化的版本，用DP写 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.Scanner;public class test &#123; static int ans = 0; static int num = 0; static int[][] map = new int[510][510]; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); num = sc.nextInt(); for(int i=1;i&lt;=num;i++) &#123; for(int ii=1;ii&lt;=i;ii++) &#123; map[i][ii]=sc.nextInt(); &#125; &#125; dfs(1,1,0+map[1][1],0); System.out.print(ans); &#125; public static void dfs(int y,int x,int he,int cha)//y x 和 左右差 &#123; if(x&lt;=0||x&gt;y)//剪枝 越界 &#123; return; &#125; if(Math.abs(cha)-1&gt;(num-y))//剪枝 左右差大于剩下行数 &#123; return; &#125; if(y==num)//到达最底层 &#123; if(he&gt;ans&amp;&amp;Math.abs(cha)&lt;=1) &#123; ans = he; &#125; return; &#125; dfs(y+1,x,he+map[y+1][x],cha-1);//左下 dfs(y+1,x+1,he+map[y+1][x+1],cha+1);//右下 &#125;&#125; 试题 I: 作物杂交时间限制: 1.0s 内存限制: 512.0MB本题总分：25 分 问题：作物杂交是作物栽培中重要的一步。已知有 N 种作物 (编号 1 至 N )，第i 种作物从播种到成熟的时间为 Ti。作物之间两两可以进行杂交，杂交时间取两种中时间较长的一方。如作物 A 种植时间为 5 天，作物 B 种植时间为 7 天，则 AB 杂交花费的时间为 7 天。作物杂交会产生固定的作物，新产生的作物仍然属于 N 种作物中的一种。初始时，拥有其中 M 种作物的种子 (数量无限，可以支持多次杂交)。同时可以进行多个杂交过程。求问对于给定的目标种子，最少需要多少天能够得到。如存在 4 种作物 ABCD，各自的成熟时间为 5 天、7 天、3 天、8 天。初始拥有 AB 两种作物的种子，目标种子为 D，已知杂交情况为 A × B → C，A × C → D。则最短的杂交过程为： 第 1 天到第 7 天 (作物 B 的时间)，A × B → C。第 8 天到第 12 天 (作物 A 的时间)，A × C → D。花费 12 天得到作物 D 的种子。 输入：输入的第 1 行包含 4 个整数 N, M, K, T，N 表示作物种类总数 (编号 1 至N)，M 表示初始拥有的作物种子类型数量，K 表示可以杂交的方案数，T 表示目标种子的编号。第 2 行包含 N 个整数，其中第 i 个整数表示第 i 种作物的种植时间Ti(1 ≤ Ti ≤ 100)。第 3 行包含 M 个整数，分别表示已拥有的种子类型 Kj(1 ≤ Kj ≤ M)，Kj两两不同。第 4 至 K + 3 行，每行包含 3 个整数 A, B,C，表示第 A 类作物和第 B 类作物杂交可以获得第 C 类作物的种子。 输出：输出一个整数，表示得到目标种子的最短杂交时间。 样例输入： 12345676 2 4 65 3 4 6 4 91 21 2 31 3 42 3 54 5 6 样例输出： 116 样例说明：第 1 天至第 5 天，将编号 1 与编号 2 的作物杂交，得到编号 3 的作物种子。第 6 天至第 10 天，将编号 1 与编号 3 的作物杂交，得到编号 4 的作物种子。第 6 天至第 9 天，将编号 2 与编号 3 的作物杂交，得到编号 5 的作物种子。第 11 天至第 16 天，将编号 4 与编号 5 的作物杂交，得到编号 6 的作物种子。总共花费 16 天。 评测用例规模与约定：对于所有评测用例，1 ≤ N ≤ 2000, 2 ≤ M ≤ N, 1 ≤ K ≤ 100000, 1 ≤ T ≤ N,保证目标种子一定可以通过杂交得到。 思路： 暴力…感觉应该是过不了全部样例，但是网上也没有判题数据… 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import java.util.Scanner;public class Main &#123; public static boolean f(int arr[],int i,int j) &#123; int count = 0; for (int k = 0; k &lt; arr.length; k++) &#123; if (i==arr[k]||j==arr[k]) &#123; count++; &#125; &#125; return count&gt;=2; &#125; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int N = scanner.nextInt(); int M = scanner.nextInt(); int K = scanner.nextInt(); int T = scanner.nextInt(); int time[]=new int[N]; int Ztime= 0; int s = M; int start[]=new int[N]; int ZJtime[][]=new int[K][3]; for (int i = 0; i &lt;N; i++) &#123; time[i]=scanner.nextInt(); &#125; for (int i = 0; i &lt; M; i++) &#123; start[i]=scanner.nextInt(); &#125; for (int i = 0; i &lt; K; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; ZJtime[i][j]=scanner.nextInt(); &#125; &#125; for (int i = 0; i &lt;K; i++) &#123; if(f(start, ZJtime[i][0],ZJtime[i][1])) &#123; start[s]=ZJtime[i][2]; s++; if (time[ZJtime[i][0]-1]&gt;time[ZJtime[i][1]-1]) &#123; Ztime+=time[ZJtime[i][0]-1]; &#125; else &#123; Ztime+=time[ZJtime[i][1]-1]; &#125; &#125; for (int j = 0; j &lt; start.length; j++) &#123; if (ZJtime[i][2]==T) &#123; break; &#125; &#125; &#125; System.out.println(Ztime); &#125;&#125; 试题 J: 子串分值时间限制: 1.0s 内存限制: 512.0MB本题总分：25 分 问题：对于一个字符串 S，我们定义 S 的分值 f(S ) 为 S 中恰好出现一次的字符个数。例如 f(”aba”) &#x3D; 1，f(”abc”) &#x3D; 3, f(”aaa”) &#x3D; 0。现在给定一个字符串 S [0…n - 1]（长度为 n），请你计算对于所有 S 的非空子串 S [i… j] (0 ≤ i ≤ j &lt; n)，f(S [i… j]) 的和是多少。 输入：输入一行包含一个由小写字母组成的字符串 S。 输出：输出一个整数表示答案。 样例输入： 1ababc 样例输出： 121 样例说明： 子串 f值a 1ab 2aba 1abab 0ababc 1b 1ba 2bab 1babc 2a 1ab 2abc 3b 1bc 2c 1 评测用例规模与约定：对于 20% 的评测用例，1 ≤ n ≤ 10；对于 40% 的评测用例，1 ≤ n ≤ 100；对于 50% 的评测用例，1 ≤ n ≤ 1000；对于 60% 的评测用例，1 ≤ n ≤ 10000；对于所有评测用例，1 ≤ n ≤ 100000。 思路： 这题还是有点难度的。根据题意，我们可以发现每一个字母所提供的f值(权值)，为与上一个相同字母之间的差值乘以与后一个相同字母之间的差值。例如样例中的ababc: 1234567891011121314151617ababc字母a : 无前一个相同字母，前差值为1 与下一个字母a之间的差值为2，后差值为2 总权值为：1*2 = 2字母b : 无前一个相同字母，前差值为2 与下一个字母b之间的差值为2，后差值为2 总权值为：2*2 = 4字母a : 与前一个字母a之间的差值为2，前差值为2 无下一个相同字母，后差值为3 总权值为：2*3 = 6字母b : 与前一个字母b之间的差值为2，前差值为2 无下一个相同字母，后差值为2 总权值为：2*2 = 4字母c : 无前一个相同字母，前差值为5 无下一个相同字母，后差值为1 总权值为：5*1 = 5则答案(权值和)为：2+4+6+4+5 = 21 根据这个思路即可较为容易的解出本题，记得最后要用long类型转换，要不会爆int… 代码： OJ链接 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.util.Scanner;public class Main&#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); String s = sc.nextLine(); //前数组 int[] piror = new int[s.length()+10]; //后数组 int[] next = new int[s.length()+10]; //答案值 long ans = 0; //中间值数组 用来储存每个字母的前后值位置 int[] temp = new int[26]; //初始化 for(int i=0;i&lt;s.length()+10;i++) &#123; piror[i] = 1; next[i] = s.length()+1; &#125; //找每个位置字符的上一位 for(int i=1;i&lt;=s.length();i++) &#123; int t = s.charAt(i-1)-&#x27;a&#x27;;//计算出数组位置 piror[i] = i-temp[t];//计算出与上一位相同字母位置的差值 temp[t] = i; &#125; //初始化中间值数组 for(int i=0;i&lt;26;i++) &#123; temp[i] = 0; &#125; //找每个位置字符的下一位 for(int i=1;i&lt;=s.length();i++) &#123; int t = s.charAt(i-1)-&#x27;a&#x27;;//计算出数组位置 if(temp[t]==0)//说明是第一次碰到 &#123; temp[t] = i;//标记 &#125; else//不是第一次碰到 说明上一个的下一位找到了 &#123; next[temp[t]] = i; temp[t] = i;//标记 &#125; &#125; //计算答案 前差值*后差值等于当前字符的权值 累加即可 for(int i=1;i&lt;=s.length();i++) &#123; ans += (long)piror[i] * (long)(next[i]-i); &#125; System.out.println(ans); &#125;&#125; 试题 B: 寻找 2020 附件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300002000000220202000222000202200222220202202020002220002020022202200220220202002002220020200000000220022200202222022220222000022220220020020222020022220022220220000022022002020220002200220020020022200020222020200200000020220020022002202000202222020220020020022020000202022220222200022220000000020020020000020002002200002022222200222002020000200020220000022020002020200000222000000202202220222000222202200202202200200222222220202022020022002220200022020200222002220202202022202222002000220202200202202022000000222220222200200022220202200200020202222202222220022202220020002000000200022222202020020222220220002002202200022020020202000220002000020220202222020000020022222002000002222220022022020002022200020022020202020022200022200202202220200000202020220022200222020020222020020022200222220222000020202000020022220222022202222002002002000002020202200220200222202002002202002020202222220020002020220200000022200022002022002220002002222022020220002222200002002222002222222022200002022002002200220020002220002020002222222022020220020200000022022022220220222002222220000022200002002020000000022220202020020222202222200200220200220222220020202020002022002222022022022222002200220202202002022000022200020220000202222202222222000000022222022202022220000222002002000022202022002220220220022002002200000222200222002222002220000220022002202220222220222002002220200222200020222000202200022022020002222020022202002000200000222200020222020002020022222222222220202002200200200220020002020200000020022000202002000022000020200222020020222002020000022220022020220002220220220200222222000222222002202002200002000220022220020002200020020220002000020002002200200200000200200220202002020022202002002222222222200222020020000020220002222020202202222220202220200202002202220020220200000022020222002222020200200022202202202200002020222000220220200222000000202020022200022002020222220220200202000200200202222020020200220002200000020000002022000020020002220202002222220222000220220222222000002000000000002220022000220022202202202020222202202200002220200022222002000020020220200002200202220022220020002220020002222220220220200022000022002200222022222020022202000002222200002022002020220000220200000002002022000000022000022202022200002000000020200000020002202200020200002200000202002222002220020220200020222002000022002022020000020200000202020200020222200020022222222000222202020200200222000202020020000200022020202202222002020200002202020200000020002020022202222022220002222022222022200200002002220020220220222202000220022002220020022000202022022222200220020022202020202202222002202222000202200020020222222200202200220002222200220002202202220222022222200002220022002222000220002020220000220220022000020200220200022000202020220200222220002222000220022000222020020202220220002000002200222220002000020000000000202202002222022202220220200020202202200220202202022022222020220202202020002222200002020220202022200002222222200020022022202220000020002022020222020022022222022202220222002020000002022000020220020220222200200002202002220222002200222022022022200200220202202200200220222220022022000022000022022020200222020220000220220020020000020222022222002020220020220222000202200222222200020022002220222222002222200020002000202022202220222202020000020022202022002200020220002022022002002000022020202002020022000000220202200022022200020022220002002202022020200022222220022000022202220002202200000220000020220000020022200200020020222000000200022000202002022200222200222000000000202222200222022020202200020020202220022200200022200222022202202002202020222022002022002222222020202022220202020202002222222022220220002220022022002220022202002222002220022002222002220222000220000002200220020022000220022222220202200020022000222022202220220022202222020002020200202202002222022222020220200020000020022020022200000000000022202022022200220222022220222020000020222000200022202202220202002002222000220202220200220000220202022000202222020222000200000000000002220020002202202002220022220222002220002200022200002222002200020200202000000222222220022222200202220002222220000000220220022200002200022202022020200200002202000022202200002220220020220020022220022200000000220200200020022020222200202002200220222222202220202220002022020022020020200002022200222222020002200202020202220200020220220002002022022020022200202000220202220220222200002000020222022000002220020002002022022200002200000222222200022002222000200000220220220022022020022000200220022220002002200002022020200220000020000002002002020222202000202022220000220200200200020002002200220202000220002222002200200202222000020022220222022022002222220200002022222000020002222220200020220222220022220222220220000202022020222022220202000002222000200220202002202200022020220002220020022002202022022000000222020220002222222002020222000022222220200020000000200020200020220220222220020000222000220222222222200222202000200202020220002002020022020022020000202220202022222220020202220220202022220200002000222200000200200220002222202022200022020222022202002000022002200222222000222000202002022222020220202200020022220222022000002020022002000220220022202220202002200202000200222002000202200202222220222222002202200002220020220002002020000002002220020022022020220022022202202220202222222200020020020222222022020000000220222000220020202022202002020200002002202200200222022022020022000020002000222022000200000020000020002022020020200202200222222022222022000002002220220002202022020222000202002222000022022000000200020022022002002002002022220000022220020022222220002200222002200020202000202222002020020222020002200020002002202022220002022020000020022222200002202000020222220020000022000020220002220000202000220020202002220022000022002202000000220020202002202200202220220022002002202222222020220222222020020000222000000002022000202222220222222002202200200200220002022022000002200020202002020200002002202000220000222002020022020002000022020222000000202220220002022220022222220222002200220222220002020202202022002222202222202222002222200020000220020222002000022002222202220020222202202200202000000002200200222020022220220220202022200200022222020002022002000222000020002002222020002002222222020200022020002022220000200000002000020202002020220200020020002200020222000202200202222220020200020202222220200220200222202222002202200200202002222002002200022200022002200222002002000022022022002220002002002202022002222220020220022000022020020200200000000222202222220222020202202220200220022222202002200022022220002002200000202002002020000000220200222222020022220002000200022220202000002022220200002000000222220200020200002202002200200022220002220002220022202002202020220220200002222002020202020220220202000200020222200200222222000222020022200200200000002220002202002022202202220000222202222220220022002022220022002000022002202202000202002220200002002002000000220202200220202220002200002020000222220222020020202000222200202202020200000022002000022220000200020000202222200222200222022020200220200222200222202022202020222020020020200020222000022022222220222222220222000202200022022002000200022022220002020222222202222020200220200222202220002200002000200202022022022020222020200202020000000020000000220000002002200202200202022020200020000220000200000222002002000022220022220022200202202020002022200202220020222020222002222220020202000202222000022202020202002000222002222222200002220222202222022020200000200202002002202022220000202202020200222022220000202022020020022002220222022020000000020022222022020020200220022220020202202022002220202202202222222200002222020000022022220022200022200002202020022200200020202222000002022200000002222002022000200020020220002020022020020202022022200200020000200222202222000000002000200020222000020002020000202202202000000220202002222200202200222202002220222202002020222000202022022022020000022202200220220222000220020220000020000200200222220000222020002222020220020202020022002202002002022022020200220002000000000020200020200020020002202022020220022202002020022002020020020000202020022022200202202200000202220022222000002020020220202002022002222200200000222022022202000020000220000200200000220220200202200222220220202000200020200020200200202020020002000022000200220222020222022002000022202202222222200220020222200222020220220000202200000002020200202002202020200022002222022022000202022200202200020020202020020222200222200000220002200200000202220020202200222000222202000200020202022222000200022020200202220000220000222202202022020022200022002202020022200200000220002220200002222220200000220202222220020222000202222202000020222222220000022000222022020200000020222020220222222220202002222002200020022002200020002020000220000220200002202202200220220202002020222222000220020202200222002020002020222220222202002020202202200200002202202200022220222002222222000020222022000002022222000022200002000000220200200002000002020200202220222202020222220200222000002202022002200202202200220000222000202022002002200200000200202000200000220200020222222202202002222220000020222202222220002002222002222202222020000220222000200200220020020002022222002000002020220022000022220000022220222222000020000020220022002222202220022202022022000200200000002022222200022220222022220000222202002020222200220020020000220002202022022002222200002002020202220022222000200222002200000002222202202000022000000000222022000020200020200000200000020020002200222220202022222000020022202200202000000220000200200022220200222002000202220002000002020020002002022200002022002202002020220002020202222202220022022020202202200002200220022220202022202000220002002200020222222220020200222020200222020020022220200002022202022200200020002020200222200000020222202020000202022220222222222220200020202000202222220000202222220000200000202222222000222220220200220022202000202200220020002222000002200220222022200000202202220202220022220002002022202022222220002002002002000202002020200202202002022202222020202020000020020220000202202202222200000002022200222220000020000022200202022002202022002020200002020022202022222202020000220022220202002200022202000202000200220202222200022020220002222020000222002022022000020220000220200222022000202000002222200020222202022222000000202020002202202002000200222220002020222220020002200000220222222000222002022222002020200022002000222202220202020202020022200020222002200002222002202222000200020222222002222202000020200022022220020222220202020020000222000022220200022200002220200000220000200002002202022202222022020220000220202000020222022222222000020220020200002222002200202002200000020200202020222020020020002222200022002220200200022002022220022222222002220220000222022020222202000200000000220002002000200022022200002202002002220000022002022220022220220200020220020202022022220000020202002222000222222022002222200220020002222020020020220002200220202222222000202222220022002222220222022002222020222200000022002000220200220222000002022002020222202000020020200022000002200200222202202000020220220202220002222020000020200220200020200020022022002202022220000202020220002020002200220222002002220222000022022200000020020022002020000220202202002000002020020222000022000220000200002020202020022022200020022022202022000020020022000200222222020000220202222200022000200202002020022002000202002202220022020022022220020220220200002202022222022002002200200200020000002200222002202200020200202002220000022200200002020220222200000022200022002000000000002222222202220220220202022000002002222222020220202002222020200020020002220000022020022202002002202220020200222202222002200020222222202220200020202020002002202020002220220002000200200020020022000202202020000022220222222220000200222202220220020222202220000200020200020220202200222200220020200200020202020222202220202020000200220220220000002000200222002002002000022202022202222222002020020220000000220002220022202220002000002002000202220000220000222020200020220020000200020222020002222220200200200022202000202222222222002202202200200200002022020000202000200200002222002200020202020220020222200000000020000222222222202000002020002000020020000000000022000220220000200202202000200020002000202020022020200220202222202000020002002020002220222000202000022200000222222022020200222220002020202220202000020022000020022002020000002220000000002220200000000000002020022200220020002220220022002020200220020000222020020020222200000222002022202020020222020020202202202220200222020022200222000220202202202000222200200220000222200200200022022000022022000202000222222022022220002020202202022202002000220200202022020022000000002002002220220222002200000002000002002000222202220022222020202202200220002022002002202222002202200200220022022200020020022020020000220220002220002220022022222220200200022222020000020000000022002002020002220000220202000222200200000202002220020202002220200222002000220000000022220002222200002200002222222002000202020002022022200022002200220202020002220000002000202020200002002020000002002020002220020222002020200000020000022000022022222002202020020202022222220022000022200222022002000220000220202202002000202200222200220222202002220222220200022222002220200202002020002022020020222000220202222022202000220220020200000220202200222022222202000220202022220220000020202222222022202200202220002022002002202220200002000202022020002202222202220222022022222202222002220002020022022022022000022000202220022220220222202022222002202220022222020222002202200022002220022022020022002202000002220222222022002220000200022200020202220222022202022002022202200000000000202000022202200020002022200000222020000222002002002002200220202002000000202222002000200220222202220020020002220222000002202200022220022020202002220222002200222022220002022000222222000000000000000202220000222000200022202000202200222022000220202202002222002000022200202022222220202020000020000022022022200020220202200002220000222000200002202222220220002222022020222020200020020000020222020202022200020002200222002022200002220202022220022022020200020202020000020022200020000002222200022220022000222022020020020222222220222002202020020202222020002022220202202022002000220022020200220220220020002202222202220222002202200222200020022022200020222202202202200200222000202000002222220202020000202002220200200222020002200022000200020202200220002202222020002000020002000002202202220202220002022222222020220000000022200202002022000202002202200022022002202020020020022020000022202022200000200200022000220020022002022002200220002200200000222200202002000022202200022020022020200222220222200002000200200222000200200222022020022222222200002202200222022000000002000022000002220202020202002222020202000020020002022000200002002000200202222020222202200000222222220022220002202000200002022222022222002022222220020202222222020022220220002222022022022200202000000202002000020202200202200000022022200200220002220020020002200022022220000200002202002002200200222002000220020200200022002202020000202020002002222002220200200200200222022000002002022220002202002002002220000022222220002202020220002002200002020022220000220200222002022202220202202200222202220200222202202202022222020022200200220000022220000000220020022222222002022202022200202222020200022202220222200020022202222222020202200022002222000220002202022020000200222022220022200202002200020202222202000000000222200022002002002020000020022000222202202200220000220220000022200020220200200022000000022022000222022022200020202220002002200200220202200002022220200020222020200202022022002220202000220000202222200020002202022022200222222222020200022222002222200022002222222000202020222022200220002000020000022020000202202002200222202002222220222220220020000020022200220022220222202222202200220222220022222222020222000002202022200200222000000222220002002002222020200022220020020002002202200022222220000222200200202000202200202222202202202222200022200200020020220022202220000202020000020000000000220200020220000000002202000020022022020020020020020202020220202022022200002022022002200002202220202002022002002202200000200202200220222220020200220222000022202222022022020202200222000020020220220202222000220002200000000202202002002022200222200022220002022020002000202000000002002022002020220022020000022200200000000000000202202020000000022022000202020000020022222222002202202202000002000222020022002022020020222220202002000022200202222002000200222002220020202000022000002002202000002002002000222022200000202220020202222000220020000222200200222022000200200222222022220002020000202220222220202220002222022020002022220000022200202220002220022002000220222000002200222202220200200020022222000220020200002022222202002220022000022200220202000220000020020020000220002220202220002002002220020002020000200022020002022220202020220022202022200000220222220002200222022000020020020020200200022200220222222220022002200000220000220000022022020222002002002022000000200022220222020202022202022220000200022022220022222000200022000220020202200202222222020002000220222202002000020222220022020002020020222200020002002020022022200002200020020202202220202022020202020202022222202000202022002022002002022200202022000020202000022022022002222200220200222220200202020020022222020220000000000220222220220202220222000220020220022002222200000200020020202202020002022000000002202200222022020002000202000222022202000020002020220222200200202022202222020022002202022022200020002220222002000220220202220022222002200200000222202202222020000222202220222220202222022222200020200020022200020002202002000002220000202220200002202022200000200202220202200220022022020002200022000002202200000022222022222002022022220202022200220220200020022202202020000002022020000202200200000222020020220002000222200220200220000220220200020202000220020222022220020202000222020022000020220020000002220022222020022200022200020022202000020000200202202220200020002000220000000000220020020002202002222022020200022022000020002220022020020222020002220000222200000020022022020022220220200202022202020200022022020220202000020020220020022220202200000220220002000020000200222020220000222020022220022220200022022200000002020002022222000020220020020200022000020022002220200222202002022020002020202002002202020222002202202002020200020202022200220020200222002222222022200022022200222222220020000002220222000002002022200022020002000202222200200002202202000020200202000020002220002222200022020022202200200020220000002022022200222002220020202222220002002222222022000220220200020220220222202220200202222220000000000202022000020000220220202202200022222200000220200222000200222020220202022200020022000000002200220000220222202000002022222022002020222202202220022220022200022222220022202022202000202022202002020020220022202202022220220222220220000202200202002020000022202222020000002002000200002002000022200200220020022002020200202200200020022020202220202202220200002020200002220002000022200000000220220220022202000002000022202220202202202020002220000002202202220022202020022002200202000022022222002000202222202200222022222202022022222000022020222020020022020022202000020002202220200020200220202022222020202222220022220200202022022200022022002222222002220200222222202200222020202002002222022202222000222222202020200022000222000222200202200000020202020200222220000002002002200002020220220220002022202000020000020220020200220222000200002002002202022220220220222200000022200202222000022002202200000000002200022220000202000000002222200222000020200020000020202022220022002000000002022000002002200022000222220220220202220022022222200002222022222000020200022000000020002020202000222002022220020222002202220200020000022200220202002222000222002000200000002222020202222222220020000202000000220202200202020220020020200022002222220222200222020222222202020220220220202022000020020022220000002220200200002000020220002002000222200220222002222200222000220002020022000220200200200222020220220022222020222220200022002022200022020220002002200222222020222200020202222222200220222202022200222000020020022000000200020200000222002022000200000020022002202222002022020202002020000000022222222222202002222020202002020222000202222222020022220002000200220020202022022202202200020020000222220002202002002000222002200002020022222022202002002222022200222020202220002000020000020202200000022022200000220020202202200202200022200000202200200022202222220220020202020000000202222022222020020000022202022020020222020220020022202000022220020002002202200000220222202022200200220222200220220000020202220202200222000022002020002022200202222022002222220220022220022222000020220022222022220222000002022000222020202200200002022022200202000002000020200002002000000202002202222022200202022002202200222022202002222202022202020202020200222000220022220022000020020200200202200020222000200220020020020020220222022020222000002002220202220020222200020000202222002020022202220022020000022220022222002000022220202220000200022022020002200002222222000022020020222002202200220220022000002002000220200002020000020220020220200020200202200000200220002020020202202020222022022002220020022202202000222222202022022020022202222002020002022022200022200222022022020222020222002202222020020200220202002000000222002000002000202020022222000022002020002222020020020200222000022000220022000022220020002022002220002000002002002202202020222020202202022000202222220022220220222000002000002222200220222222200020020002222000000002002022202020020200220002022202200202220220220020202202002022200202222220202022222002200022002200200222202000202222000020000200000202002022220220220000200022002020220000200022020020222020202220220222220000200002022222002202020222202002020000000200002022222202220022222220200222000202000202222222002202022002202202220020002202220002202222002022220020000002220200022200200220202220022220022022222002220220002020000000002222020222200002022222220220220222222000200002022220200022220220200000002200202220222002002200002220222000020002002220022022202222200000220200000000202220002022202222000222200222020000222000002000222022202022220202022220002020220002222000220002002000222022222020022220022220222002000222000022200020020002020222222020202002200020002202200022022200022200200200200222202200220002200020002220022220222220020220200222222000222220220020000220022222202202022020020022200000022200022022002020220000000000020200200202220022002200020000222200000022002222000220200002000220220000002022202202200022200202000022202000002000002002000022002222000220200022222220202002202000202200002022200202000202000200220000000020200222000002200000020022202022000020020202020222202200022020022002002202220200202200220202202020222220222000000002002000022222200222002202020222220020002000222022200202020022200220200020022202022222202022222022002022220222000202222200220202000220220222222000220022002202022020202000222222222200002020002202020002002002020022220200220020202020220222202222202222222020220020002200000020002222200222200002000220000002200000222020022022220220000002222022002220022222200020222220202202020020220022220200020000200002220220222220000000022000002202022202022002022222022220220000002020200022000220020022200220000202002202020222220022202222000222202022220000220220020222220222222202202020220202220200002200000222020022220200000200022020000020200002220002000202000202202222222022022000000220202202222000020000022022222020222020022020002000200220202200202202202200000200000000200000202202002022220222200002202220222222200200222022020222220222220020222000202020200020022020000222020202002002000202020202200220022202220222000000022000022220222220020002222200222020202000222202222020220000022200000020200202220220200020002002000220222220222020222222202220020222222020002000020020220002220222200002220002020220220200220200020002200220202200220200200000002202020022022222220200222220000220022222222222000222002220020202020002002000020020020200222020220000002002022022222200000202200000222220202020220020220222202022202000002202022220200000220200222200000220222220000220202002220202000020222202200020000200222200200020220002022202020002202222220200000022022222222222002202002202020200202202200220000222020000002200222222002220000220220000202220222220202002200002020022200002022222222202000020202220200200000222200000222002202222222200000220000000022220020222022020020202002022000000002202200220222202200222222200200020000220002222222222202002002022000200200222220222020022000022222002002202222022202000020220020020002022000222202000000002200222020002022200000020222200202202022000022002002200020000022202002022002000202202200002022022000200220000222220222002200020202220220000220202022002200020200222002202220222200202022202002222000022222200220220202002220200002000200000000202002200000222000220000022020220002022202000000022000202222200022020022202000002002002202000200000002222002202022200202202002222002220200222220020222000222020020002222000200002220000002000202000002000222200200020002220202220222200020222220220202200200200020202000202200022020200220222222002202000002000200220222020000200002000200020000222202220202222202002022022202000000022222200220200022000202000222000022202000020222000000002022220202002222222002220220222020020222222222002202002000000202020202220200200022022000200222022220002000000202200020000022002022220020200200222200020022022000000000002002022202022020002202020202202000000220002220200222202022200200002002002200220000200202222220002202220002002220202222002002000020022020022220200220022000022002222220002020222000002022000200020022200022022222000222222220220200002000022222222022200000000220220202200002202002202022202220200020002222220020222022000002020220222002200222220202002202002222000200220200002222020202200022000202202002222220202022202020200020220200222022220022020022202002202002220200020200002222000222002200202202220020022000020000002220220200202202222020002220220200002202222020000020222000222022020000002220200002020000200000222022200000202222002002220020002022002220022000202000220000222002202000000002222202202200000002000000222222000222200222200000022022020202002202220000002020000022000202000200020022002022020200222002022222200202200002022200020202000222202222002002222222202200220220202200020000022222002000200202020002002000222222202002002200202020000022220200000220222000000200000002202222220222022220202020022222002000020220222000002220000200222022202222200220020000202220202222020222000000022220022020000002002020220002222022200000202222002022222200200202200002202002002020200222002202000002000022022200022022220002200200022002220222000022000022202200222022220200220020002200202002220000200202220022222222200222022020222000200002220000020220220222000222200022220202002002002020020200020200220222200002200200222020000000222202202000200220220200202220202222000000022022220022222200000222002022222200202002000200220000222000202000022222002220000202222002000002002020200220002002022020220222000202020020000022000022002020200202022000022000000202002220220202002022222002202000022220020202022022000220202222202000200000002002200022202022002020000222022022002002202000200000000220220002002220202202222000020000200200002220002002020020020202202002202202020222000022000020002220220220000022020220220020220022202020202220020020200222200020020002020222000200202000020200020000000202220020200222220022022020222022002002222020000220220002000222202022020200002202020002020002220022022002222200220002202000220022220020002220022020220220200200222222022220220000222220002000020002020220000202222020002200022202220200000000202002000022200022200220020020220000200020002022220002220002002222022222220222222022020222200202022200000220220002020200002022200002002020002022200222222200000200220200200020020200022020000022220020020222222202002000220222000202002020202220020220022222000220022220220020020220022202000022020200220220220200222200020222220000200022002000200220020002002002220000022202020202022020220202002022200220202202002222220020022200222202002222002200202200222000022200022000000022022020222002220002202202022202020022022202222202022222200002200202022002000200002200202022220200200020200020220202000000222020220222002222222002020002202020220220000002022200200202020200202002022020002022220222002020022222002222202000202002202020200220002220000000222002200020220020202000020002200200022022020002200000000200220222222020222202002022002200022000200002220022022200020220200022002020202220000202002202022020000000000200220222022000002202220000002200020022020000022022220000222022020002222022000202020220202200220200002022020002000022202202022202002000200220002220020222020220222202002020200022000200220002002020022222220220020002200222000200022000020022200222022222220022022222202020220222200200020202020220200020000022220000020202022200000202222222220200202202000020200002202220220000002220020200020020002020200000022202022002020000202022022002002020202200200002222022002020000000002020220002022002220002020002222002020222000202020220000002022202000000022222002200220220002200200000002200222222000000002020002002022202220020202020222222022000000022200020000220220200200200000220020222000202000020000220220220220222220202222000002022020022020000020020222220000000000002202022022002200220220200222202000200020002022222202200200002020202220002222020022022200000220220002022222020020000202022200020000000222222200200020002022020222000022202002020220000220222000000200220000202022022222202222022022200220022222202022000002222000220200222020200002020022202220020200000022202022202222200200222002020222000020020202022220202222202220200002220200022202222202000002202000022220020000020020022020202200000000020022200222200000202022202022000020020202000200002022202200020200200020000200222222000000202020220000022222002000222002220222220000002002220202022020020220020000222220222020000222200002022022222202020220002022002020220002220020020202002202022200220020020002220022200020220002000002020020020020200200002222000020202220002222000000022202002200220222002202022202000202202220000222020202002022022000020002020022220200202202220000000022020222020000000200200002022022200000200222002220202220222002020200020022202002020002222002222020022022000200022000002000222020002202020202200020002000000000000020220220022220000220200002002222200000020222000000020000022202200220022020022220200000020020020022000020022222202022002202200000200022000002022220202020202000022200200002000000000200022002202002022220222000002220000020002022022000200222200020000020000022200222220200000002222200022202202220002002220202000202200220020222000222000020200022202022222222220220020202200200022200020202222202002202020202000022222002222202222000002200202022222000022022020220000000022222200002220000020022202202000022222202020000000220202220020200020002220202202020220222000002020202022202200220020000200000200222200000200022020200002200222022022002000022020202222002202200002202000200220200220220220000222022222200020220022200200220022022200202222202022002222202202202020202020002000002200200222000220022220220202000220222002200000022000000022022200202000002202000220020020000200022002020020200220020222002002202022002000220200000020020000222200200020202200002002022222020200222222020220222200022020022222022222202020222002000200020000220000222022222222220020220220220200202002202002000200220200020022002220222022202020200020020200202002220020000202220020002020222020200220022020202222202220202222020020200002200022002202020000222200022222000222200202022020202002002202002202022222200200022020002020022002222202202022202002222220020222000000000022222222020022000002002002202222002222002222222022220000222002020222022002222020000202202020020222220022020000220220022200002002222222002222002222202222220022202000222222022002200022020020022202000222002000220222000222000200022000202002220022222222200020022202222002000022200000222202202020002222222202200020220222020022202000002222202002222000200002222002022220202022220202000200200020202222220022022220022000020020002022002202202222220000200202002222200220020022000002222020200000200220202200020002200222022222220202222020220222002200000222002220200220000022002202020020200200220202222020202000222020022222020220222020220002220200200022002000022020200020020222222222022200022220000002202220200020202020002022022000002202222002202200222020222202220022200200000002202022222200220200200200220222000202020220202202200002002020000200202202202202022020222020202022000202000022000002202022002220000002202020220200220222022200002002002220200200020200002202020202000022002020000000222022220220022002222000222200222002220020000222222020220220222202220202000022000002202002220022000202022020202000000020022202202020220200222020222000222022200020200200020200022020202002002200200200020222000002220200200220200200002202222020020002002020020022220020222002202220222202002022000202020202020222200002220222002022022222222202022000222000020222000022222202220002220202220020220202002022002022220000200200200202220220002002202000000002222202020022000002220002220000022220200202200022022022020002002220002220200202002002220222020220000000220202222002002020202220000022020220222000000020002222000020002222222022022202222020002002022022002002202202000002022020200222022222020020200022220200222002002022022020202220020000022200200220020002200022020222222020022000220202000200202202020220000000002200220000200202020020202202200020222002202000202200002222022020002220002002002202002202202202202202022000222220200002022020220220000222222222222022222020222022020202002202202020202202002200020200222222000022200022222022220022002202220202022220000200022022222002002002020002000000002000220222222202022222202220200002222202202222202022002222022000022020222022222022222200020222220202002020022022202220202202000020000020020200202002222000020022220220020020002220220200220020022220002202002002020202222200220022002200020200220002200002020000222200200222220020222000220200200000022220000002000020000000222002222022220022202200020022022022222220000222200000222002220200022200220222202002020200220020000220002000222220202200020000020202022000200020200202202000020020020002002002220202200222020222202220222222222002020200220202000202020200202202200200222000222220222222202220000000200022202000020202222202020220200222220222222200002200000220000020200200222200202002022220000220022220222200002222020220222202220220002000000202202200202002222022022002020200202202000222200020200200000222020022002000220002002200002000200202022020222222022020220200022022022002022222022202202200002020022202022220002200020220020222020222222002222002202002000002022200022200022020020002020020002202220202022202000220022002222002020022002022200222202200220002200202222002220200222000222222022002020202022022000220202002000000200000202000220022222222220002200002200022000220222020222200000220220022222000220000022022202220222200020002202220020000022000220200020222220222202022000202220222200202000002220200202220022000200002202200200020000202000222020220222002200202202200200220222022220002202000200220000222022220202200220022200020002200002202000222200022200022220202000020000200202022020220000220200022022020022000222200200200200002000022002000000000222002020002000000220002002022200020022202020022022220002202000020020000202000200002222202002200200002020020002200200020220222000002002000202200202020202002020002220020200000220200200202200220022002222200002022000200020000020020200022002000022000000222202200020200200022022220222200022222220202022200200022000222200000022000222202200020202200222002002002220222002222222222000002002020222020222202202220202000202002020220002000002200222202000000022002200000200000000200020020202020220020202222200000020020222022022220220000022020220022000220002022020000002000220020202002202002200020020000020222220020020220000202200202022222222202022222020200020002220002222222022220000000200002022202222202022222020222220220220002200000022220200020022022020000220202002002002022222022000202020020022020020222220002020000220222220200200200020020002020002200022002020202022022020000200200020220202220200222222200222220000002022200000022002222000220020200020202000022002220220220022020220000002222022220022202000022220020200000220000020202020022200202202222022200000022220200002222200222222020222202020000222000002022200220222220202002022220202222000002222202020200000222000220002220000002022220220022200222000220200020202022002002022002202002200002220022002220222020002002200000200020000202220000000002222002000002000220202000000022222022202022020022000022022022200000022000022002222020000022020220020200220222000202020002200022200000222222220200000220222020022000200220200200000002220220020222022022200200202200220022000022002020022222002202022222220220222002200202220000200002202200222200202000200020220002222022002020000220022002000000022222000002020222020002202000000220200022200000000202000020000200000002202220022222222200202020020000220000022200002000022020020222222020002200200002222000022002020220200202000022220000200222000022022220000022020222000202202020020220022000200000200002202000220020202220022022020022200202002000202000202220022202220022202022002022202002202020220202220222220220000002220222020002220022202000200222002202200200000000202202200022222022202222222222002022202200222200222200200220200200000000022002200022220200002200002202202002022022000222200220000200000022222202000020220000022020200202222202022020020020222002220022200020020222200200202202222220202020020200222220002002000222222020022022020000200220000022002202222220202220002200002202222222020220000020002022202000202000220002220222022022022202002022200020200000222022202000222022222202200200000002202200222022022222220022200020022222000200220202000220022020222200000000022020022020200000220020220020222220002202022020022202220000202200022000220000202020022002020022200000222020002022222002000220202022202220002000020202020020220020022002002202022000002022222200220020020000022020002002222022200020200220002222220022222020200222202000202000002200200200202022000222200000020020220200020222020022022002222222002002200200202000000002000200002200002002200020002220202200020200002020220022202220020002222200020222200000202002000200202200020220220222020222202020220020222022220200202020220002222202202020220200202200020202202222022022000200000022000020022020202000202220022020020202022000222200020002202020202220002222202022200202222022000200202000000202020000000020002002000022020020202000022202020020022200202220200200002202020202200002020022200022200020200000002202000002220002000020000002200022222000020202000202002000002022222002202202200222022220022020020002220220222202200000022222222000202220200002202000020022000200220222020020002202002220222022202002020200000020022020200222020220220222202022202220002002000220222022200020222000002202220200022022022200222000002200020202022222200222002000020002022202002002000200220022000220000202020200202202000022200002202020200202222220202202020002020020220200220220020200202202202022200002000000200022220020200222222202220222002202020000000020002202222202022202220002222220202222022220002002022020022020222002202022020222202020200000002020202002002202220202022022200200222222222022202200220220000000020222222202200220000000020022222020222000000200220000200020200020202022002022222222202020200002002222200000222000000020000020200222220202020222222222022002222220200222002200000222000220222020000222200000222022220022020220020020000220220222202220020202222222002002022002000220200002002000220022002222200002002200000002202200022202202202022202000202200220000000220202220022220022202022222202202020202020022202200200000200220220020200202220020202202002220220220220200220020020200200202222002220220020022000022222200020002022002222002020020200222020202202020222022002020022020220222202220222220222000000202000000002220220000002020222022222220000200002000000000200020020020220002022022022202002020222020202000200002222202000202220000202220002000022020222202020222220202022222200020202002202000220020000020220222202220202020220222222200020022022002222202202022202022020000020222002202022202000000022022020202020002202022022022000000202202020022220222202020220202220020002222020202020002220202022020202022200000002222220202002200002222220002222002220222002000222000022202222000222022002002200200000222222202020020020022020202220220220222020022222200200000000020200022022000000200202200022222000202022000222200020222020002000222222222220200000200202020202220020000202002022000022020222022020220220020002202222220200000002202200000202022002000200002220002002222002200022202222020200220020220200220220200222202222022220020020020202222200022020002000222020020220002202000022020220000002202202202002002202222020222022220000002020002220022000202200002002200020020002020220020022202220200020222200000022222000020202020022200220202022200020202020002200020222220020202222222002200000220222222020200222222000220022202002020020222200220002020220002002220020220220200022020222200220222220202222200202002020002202220202200022200002222002002022200020222020200022000202222202220220222222000020000022000202202022002220020022222002002200000022020022200200000002220222200000220000202020002220000002202022022002000222020222220022020020200222222200202222020000200002222200202002202022000022022222020200220002202022000002200020202202022022000022200002000200020020202000202202002000020000222002000002000022020202020022020002022020000002022222200020202022020220202020002222202200002202000000200222222222002200202022220002000002000220000200020222220020200200020202200020200020200022202020200002000200222020020202022022020202222002020022222200002022000202222222000002002020200000020222022000022020222200200000200202200002000020200222222000220220002200200222200202000222022002022222020000020222000020220200022200220002020002020000200200202202220000202022220022022002200222002000222002200222220002200220022222000022202202220020020002222220220002200020002202220220020222200200200202202020000222220222200222202202200220220020220200002002002020202200000200220200222200222002020202022220200020020022222022222022200222020002200022020200222222022002002220200020202000200000020002202002202020202200202020000020002222202222220222202200002200202202002020002220222020022020222002222220220220000200220022202222222202200222202000022000200220020220002220020222200020002202000202200222202020222202022000220020022200022202222222022200222220000220222022020220222000020020022020200002222220220222020200020220220220220202022220200022220202022002020020200002202002000222220200222002020200200020220202222002022200200002020200002002222000000220022002222022200220000220200220220222002022002222020202222022202220022222220200020200200002202202000002220002220202202022220200202022222202022220202202002020020202002202020020222000202200000220222220002200200200200202220202202202200220000202202020202020220222202202202002002002220200200202022202020002002220022020222220220222202200222020000220002020220022022220000222000000202002022000002000200000220020020002000220220020002020222202020222000220222020202020002202200222220220020202020220022020222020002002022220220220000020220200002220002202202200020020000202000202222220002200002020002202020222200220222022020222222022200222002222002220222220002002000220000222222000200202000002022022200220220000002220220202222022022202002002222002020020200002020002202222202202020002022200222000000020222202222002222020220022000000220000220200000222002200000222202022020022202220202002202200222200002222222002022000220200000202022220222202200202000022022002200022200202020022002222020002202220020200020202020022200002202202220222022200022022222222200000002202002002022002222020222022022000002000002200022022022022202200002022002020222200022220002020200220220202020220020202200020020222002020022002220220220002220000222002002000020022002022222200002200200000020020222020002222220002202220022022200222022020020200022200222020022222002200002020222200020002222200220000220000002202000220022022202200220020200002020222202002202022022022002200020200020222022002200020220000020000202000202020002020202200002022000020200002002200020000200202220002022022222202022020022000200202222220000222222200002202202202020220022200220000200002222020000002000002202222220202002200200202202020202020022200000000200202002000000020000220002200220020222020022222222002220222002220020002220000020200200000200000222222002202022202002222000002222220022202202200200002202002202222222220220000200000220202000200220002222020200020220000202202022200200000200000200022020022000022020220002202000222202222000222022022022222220002020000200200002022020020200020020022220220000202202000200022000000000202222022222202022022002202222220000002200000222222220022220222002202202202222022222020022022022022220202020022000220222002020222000002000220002000200020200000222202200000220200220020020002000200002022002222200222202002000002200000220000020002000020202220020202222220202200200202022000020200222200020200002000222022222022200200002222000020000002202000022002022002200020222202000222202202002000002200002000220202220020020000002220022020222000200022000200220022000022000200220200022022200222202002022200202022020222020002222220222000000022022202022020000202000020202222020020202002200022020222020220222022202222000202202200002000222000202020022222200002220020000220222000202022222222220220020000220222222222220202220220220002020020020000002220020000002002000000000202020200200022000220200022220020002200002222200002200222022000000022222220220000200000002222222220200002220202000202222202202220000202220202000220002202002222022200202220002220000020002020220222202000022202020000022022202002002222000002002000220222020220002022020002022200002000202022000222020002000020222022202220200022022000002222202000222200020222222022222002000220222022020202020000222220200000200000022222020020000002022222002202000202220020000020222200202022222220202000020200200202200222222002000202220020200022022222220200202000222020200002022202220220220200222222222020000220220202000000222202222022200022220200222002202220002222022200022000200222020202222200200222200222000002002022220200022220002200022000020022022002002000022022002020220202000000200200022202200222002022000220220002020202222202220000022222022220002020002002000220002020222000202222022220020020220020002202200200022222222002222222022000022202000200200000002200202200202200022002202222220220220020200220220020200002220020220022002202022000002022020202022220022222202002220000222000020002202000020020000020002202020222202020022202020202200202222002200202000022220020220020020000022222220002200002022202202202200000020202200222022200020002022000000222220220200200022000020222000220202020022220220200020200220220202202222220220202220222022002202222022200020022000202200202002000020020022220000000220022202002000200020202202020002022002002022200000222020200220022222002200200202000002000020020000000000022222022200200200220002220022202200220202002022022202002222020200020022002202222220220200020022220222020220200000202200202200000220202020222000222022022022220222202220022022222200202022022202202202002020020222002222002022000022022020222022020000222002002022020200202220202202202222002222000000020022022022200202222220000002020220222202202220022200220002202020200000220200200000220222200200022200200202220200202222020002002022022202022220222002202002200022002022020202222022020022000002020222200002202222022222200200022002002222220202202220222222202202002002200222222000202022220220002020020220022022000200200222200200020202222022200000222220000002202002200002202222022220220200202000000022200020020000220020222200202222000200000000220202000020220200200002200202002200002220220020202002200022220022220222220202020022020002220200022020022220000000222200200222202202020220200222222020200002202020020022202002020022202220202222222002202220200202002022002200000200202020002020020202000020200200200222000220222202220222222220002220000020020202022000202222002220200200022202022222020220220202220002000020002022020222200222002002000202222202202200022202020002020020200020022000000220222222202020002022220002000020000002220022202200002222020220000002202202022000200020020220220002220200222022000022200000002202002020222002002222200022020200222020022002020000022000000200022220202022000020022000022002002020220222022222220002000202002220202222022222020020222220000220020200220220020020022200220022002202022022002202200202200022202202020000222002020020022002000022222202200022202020022220222000022202020200220000000222000200220000000002020022002202022020202002022202220022000200220222222002022200202022222220220222200222002000020220200020002000222022000220200222022020000202022002002200000222200020220202222022220202222202000220002202022020222220220022200200000002022000202020022222022000222000200000000022022000000002222220002000002222202020220000022200002222220222202202002000000022200020022222200202002220022220000220020222020002002220002202222000200002222202002000202020022022002020220220020222220020020020220200020020220022000002020000220002000202000000000022002022222200000022002020020222220220222022020200022222200200220200202220220222022222002020200000000022222200202000202200202022000220000002220002220002202022000202222220000222220022020202222220020002202222002222202202000002000222202020022202202022002200222000020220020200000202002220020200202220000020000022222000002222002222222020022020222002002222202000220220002220020202000022200000020020220200200202200000022202002020000020202022002202222200220020020020000220202022020000022220002220222002202022020000200200002202202202002020202200020222000200022222202200002220202220002200202022002222202220000202020022000022022200220020202022200222222222022220200202222022202220022222002002222220202220220000202222022200000002202200200200220002200000020022220000022020220020022222022220202222000200202002200220002200000222022202022000002000220202022020000202222002200002000200000222020222220222020220002200022222022000002222000200220202202022020022020222220022002200222202220022200020200222000222002000000020202000002020020202020220000202000200022020022200222002002202000202000220200222200222022222220202200002020000022222200202002002222200022002222020202022222220000220222022220002000002202202220000220220202022002200002200220000222220220002202220200002220020000020220020020000202002022022202220200202222222220002202020022022200020220020022220020002002220200022020022020202200022022020000202020000202200020202202220000000220000202002202220200002020220220220200000000020220222222220000220220020200022202222020220220002000002022202220202020220200000202000002200022000222200020000220022220000222202022002222020222022022222222200200002020002222200020022022222202200202220002022022020220200222220002222202000200202022200202202000022020002022002202220202220002200020002020222002220200002222200202022022222220000002222000222002022222220000020202220222002000022200000200222222222000222022020000202000200022002202000222200000202002202200022000002002000000020020220002020002020002222020000002202200020202020222020220002000200002002000020220020002020002222020002022200220022022020202200020002220020220202200202202002002220002000202222002000022020220202202022000222000000002020022022202022222202220002202022200200020220220222000202022202220220000020222002200020200200220000202002020002220222000022220002222020022020220200222202200220222022022022000002222020002002000002220200022000022200222002220022222020000220222000022000000020222000000222022222200200202202222000202022222022020000022020202002222022020022200020222022000222200220222000222002022222002022000022222020020222002220002002222000002222020022200000020002020002202202000022200200222222002020020200000200200200000020002200202022020002202020002220022202220202222220002220020222222020220022222000022002002220220200202202020002000020200022220002202220200220202022000200200000222022000220020220000002002200202222022002002000002002002220022202002202200002020220002220020202002202020002002000022202020222220200002202222000022200000002020000202020020220002020200220222200020020202200000222002202020000220202000020220022220222200202222000200022220020002002002222000020002222222002202200002222022002000000220222020022002000202220020200002202222220220002022000200022000022202002000202002020222220002200020220000022220022020022222220222020200200222020020022020022000000002000002202000202202002200202222222200022000020220200200222022020022022022022202222202022202222000000000222000202222020200002202222222002020220000202202020000000202022002202022002200020002200000202022202220000002222002000200202200202220000002022020000222020220020200000220222022020220200000000222220220000202220020002000220220000020022222220200222002000020022022020200220022222000000022202000000002002202002202202222200200200020022002000002222222002222000022202020020222020002020020020020200020222202020022020220022200222000220202020022020022220000202200220200000220222202202000020022022202222022020200220200222222220222022202002200200200202222020002020002022022020000200020000202202222202000220020202222000222220002002000022200222022000002200220022202022002222202002002200020202020002020222202000020220222022022222202200222002002202222000000202002022202202020220202020220022002022022002000222222220002002222222022020002000022022222222202220022202222002200202222222200020220000002020202220200022200002020222022202002020020020222022000002202000200022020020220002200022000202220022000000202000022222000202202220222020202020022220200000202202200022022022022000000022220220020222202220020022020222022222222220022022220020002022222202020020200202020020022000220200022202202200222000200020220200200002000202222200000220022002020202220200220220222002222200200220200220022022022000202200222020022002000002202202020022202000202022220000200020222020000222200000000000000022200002200220020022022022220020022000222022020222222222202000200202202222000002020222000222202022222002200022202200022022222022022200000220020222000202002022202020002220220000220000000002000022000200002220002022222020220202002000200222222200022002002020022200220022000200020222002022002002022000202002002202200202220200200022200220002222002022220022020022220202222200002222220222020220022200200220000020222222202220200202002020220222202202022002202002022222022222002202200000202022220222200220002200002020200222020200202002200000200022222220200222200020202002202022020022020222222222220000220220202200222020222200022002022022200222200022000002002020000220020002002022022020222200202020020020202220202222020202202222222200200022202222020022022202200020022220200000222002222200002002022200200022220020000002222022222220200022020000220022220220000002022222222000020202220020022020020222020000002020002022200202202200220020202222200000002200020200000022022222200200200220002222022222022200022020200220222000000020202022200220002002000002222220202220200020002000220200222220202200022202020020020022000020022022220220202000202022222020002002200020020020002220200202022020202202200222222220022200000002020200200002220020002022020200022222020202000220020202022220020222022222000022220002000020202220202202220222022020200000202022200022222002022020020002002202020002000220002000020202022022200202002220000000200222022000202220220202200000002022022002002020000000200220002220022220220200002222200202000000220200202002022020220222022220020222222200200220200202200002220202200020022220022200022200200022222022022022222022000200022202222220202020200022202200000202202200020200000202222220200202202220002022200222220200002220020202020222222220000022222200002200200002200202000200200200020220002000220202202022200200002020022000200020002002000020220220000000222020222022222022222020022022020222020222020020022202022220220020202222202022222002020202000000020202002220000002200002202200220002002020020222202002020020020222022002202022002202202022220002002222202000200202220202000220000000222020200222220022002202002020002200202000202200000000022200000222022022222002222020222000220022222200222200020200002202022200220000022000200200002200200002222202020000002220220022000002002002200222000000220202022020220022200220000000022022222022002022202220220000200222222200220002202220020222020202200002000022020020002020020000202020020002002220200002000202020020222002002022022000000022200002202200200200220220220202022022002002202202002220200000202022000000022022000002220222200002222220020220220002222202002022000020200200220200000200002000222202020020022222002222022200000200220020222020222222022220022220220002200200222022222000002022002220020020000020200222222202200002222202200022020222022222002202020022000000022000202020020000022222222020020220220000022220222220002022000022020222002002000220202020202020220200022000200220200200222202200222200220000020022000202222200002220022222022022002022002220200002222002002002222220022202220020222020202220020022000220000220020002002222222020022000002000022020202200220020220220200220020222220202000020020200200202222202200022222002020020202202200220002200000222002222200002002000200200020202000020200200222220200022202222202200202202020000002202020002202222220002222000200200020000222020202000220202220000222220020002022000000020020020022222200222020202202222022020202000020000022220020222200022222002002200202200020020002222002020200022220200202020222002022022222202222000220002220220200220002000022222220020022222202222022202202002002200202222002022000020222222200002002022022222020020022002200022022220222222222002000020202002002220222002022000022002022020222022202200022220200002222222020000022022000000220020002022220000020020002202202002002022222220222000022000202020220000022002002020200202202000022222020222200022220022220022022020200000200202202022222002020022000202200200022200022022220002000200022020020020000002202200020220200222020202022202000020222000022020022222020000202022022220222200020202022002200022200202200202020222022020200022200222022000200222020000000000002200002220222220000020020022020222002022002222002200020202020200022200020220222200000220002000022200200222002002000000000000022002222022020220002002222220220220200202200222000022020002020220222020000220022200000020022022020000000200222200202000000202022002022020000200200220022002020200022002202202200000000020222002222000220202002022220200200220222000000220202220222002022022022220202202020220202220000022222202200020002000000222020222202022222202022020002022222022000220002222022222000202020002202222220200020200020020200002020020200020200222202200022020202020222022002222022222022000020200002202200002002222222222000222022200222222200222222022200220202020022222202022202020002022000202200222200002222002222202000200222020200220202200002202220220022222202220002222002020220202220022002020002200200220202022202002200202020020002022222200220002220222022200000200200020002200202222200202002022222200020200202202022002222202002220202020002200200220220202200220002022200202022000220200222020022222000020200202002222000200202020000202222220000220222000202220022000222002222022022202000200200020222222002222002022002220002022220002002000200020200002200020200020020200000202022022220022000022022000200000020220000202220022222222200220200200222200002222200000222200220222002000022222022200200222002222000020200022000222000002000022002222222022022022200222222000020222220022000000020000020202222200222220202222000020200220222202202222222222020202202202022002020200220020220202002202220222022000220022002220022222202222200000000002002200220222222202220022002020200020000000000200222220220202220002200220002222022220000202222202000022000202002020000002000200222222202202220220200002002222022222222000002020222022000202200000202220220202000022002202000020020022002200020202222002222200200202222220000020222000200000022020022000022202020222020022022020202202020000220220222202022020000020220020022202022022022222022000000200002000020202202022202000022022202220220022200202200200202000020000220220022202200220202220200022020022002000220022020202000000222202202002022000022200000000200000022022020000002000002002200220222020202220000002200002020200220020222020022020200202020202000200222000222020002022022022022220200220202200022222022220000000022002000222220002002000002200220022022202020200020220220000020000222002220020202222200220200020002220220202202020020022200200202002000000022000000200000020222200202002220202202000200000020020200220020022020200000000202202222022200220200222020200002202202022020200222022200200020002202200222202002020220022022222222220220000222002200200220022202220022020200020020222000002000220202020022000022200200202222020202222002220222220200022220022002000022220020222020020222222020200020022200000000020220022000020222202222202220000022222000002222202222200020200220220022020002002222222220020000220202202220020020220202022220222020220022002202200000202202002002220002020200022200022000022220202220000200200020022020200002002000202020022220222022220022202202020202202200222000202002002022002222002002222200002002222202020220000220020202020220020020202000202022000002202222020220002000202022222220202222000022200200200222022202002000002200022202002002222020222200220222000022202020020200022222020220202222000222220200020022022202020220020000222222002220200020222022022022220000200022220000220022200000002002200222202002222002222222022020020000020020202022202022020202200002220202222200220020000220220202202000002000202220222222000222022202200200000220202022022202200200000020022202200200202202222222202220202200202220020000020022200002222220222202220220222020022000222002200022002200220202200202220002022220002200202022000022000020220202020220222022200200022202022000002022022222020222220220022022200002000000222222220222002200022222002220220022222020200202002000020022022002200220222222002002020002200220000002222002022020022002220222000220020222002200000020222020002002002020220200220022022202002022000222202200200222022222020002000220202222000222202002020020202220222222020020020022202000022222022220202200020000000022202200222202200202220002002022202022222220002002022220220000020020200222022022022222002000002000220202200002202222000020020200002220222222202002020020020022220200022202222000000220202202022220220222020022022220222020002000220202000220000002020202222020002200200222022022202022000222002002200000000022002022000202020222022200020200200202220000020002220202020000022022222022022222220000022202200202022020200200222002222000022000000200022002020000002220220220022022222000020200200220022202222202020200000220222000000222020220022002022222220000000202022002002202202200202222200000002220202220020220222020002200020022222000222200022202022022002002220020222000020220000000002020022202220002222220022002200222220202222200002222202202220022200002020020202202200220022002000220220200002020022020202220222200222000202020022202022002222022222002020020202022022002220000200200000220202222200000000200000200002220022220200220222020022222200022202220202200220002002022200020000000020000022222022200002022020002220020200020202202020020020002002000002000020020002000022002000200200222020202222202002000222002220220220202202002220020220202022200220002222202020200220222222202220002200200202202000200200020020000222000002222000222200202202020220022222220202200202200202220200202000222000000200002000200220222020222222002222220022022222022222020222002000202022020222022202222020202020200002220200222000020020220200202202222222202020002202022222222000222200000202220022002020020000000002002002002220020002222220200220002000022002220000002020200002222000220220220020220200020200222000002200220200022000020000222202000020220000200202222020220200002220220000200200220000020200222220222022200200002022000222200200000220202002000202022222000222020022002222202222002022220202200000202222220220002002220002200200220000202002002220222220020202222222200202200020200220000200000200220020022202200220202020220220220002200020200002000020222020000222222220022000220022200222220220202220002002202202022022000202200020222022200220222222002222200002020202000200022202002220022200000220220220020222000222022200022222220002000222222022020220002200200020200020220220200200200020000202022000202020222000200020022200202022002220000002222222000220202200020202200000022222200200222200000002000022220202002020000202220000220202020022000000220000022222200200000022200220220220000020202202202020022200000200222020200022020000022020002022002022200220222220200022022000002220220002000200200220222022200222200222002222022220222002202002200202022022020020002022000000020000202222220000022022202220200000020000202220022202200002022002000200022220002200002202000222220202020202220222200000202002222020202200222222002200020002022202022222020202022022000200020220222002020202220000002220222020222220222022000022002020022200222200200220000222022002002222002020002020022220220022202000222020222022202202200222222202202002222020020020222200002022200220200000022020002002020220222222002202220220022200000220000202222220222022222000000002220022222202202200202222020222222022000002220020020220020020202002020022020220020002022002200222202200222200020022202002200002220020000202202220220200200202222222020200022020222000002020202200000222020222202002000000222002022000000022000202020200022002020002020000200022220200220020002200222020200022002220200002022020020220000220002022202222020220022022020220222220002000222200220022202020000002202002222000200200002000020020202020020220202202222200202220222200002200220222220202002222220022200202220222220020202022200200200000022220000220022000022220022200000022200222000002000020022020020020200000022200200222002202000220200000000220020202220200000200220000220202202020220222202220202222222022022202220000202022000222220002220220200220222020200002220022000000202000222202020222000020002020200020020200020002220002222220222020202000022020002202200020002002000220022222002022200022200222222022000022002222200222022222222000000202200000222022000020002202022020000220020200220202020020022222002202222200222202000022220022220000200000000222022220022202220020220202222022000002000022000200222020220020022002202022220202222022022202000000000200000020222020202222202020200020022022022022200022000020202202000220222002200202222022202222022222200202022200022202002200000202002020222000222020220002002200200202022022000220202222222200220002202000020000200022220000200220220200020220000220000200222220020022020200222002200220220220002220200020202202222220200220220022002022202000020200220220220020222202020000200002220000222222220220220222220222022002222020000002200022020222202220200222220020222020202222200022222202002000200022200002002202002002202200000000202020020220022000202220020202200022000202002020002000022022200202002202002020022222200000200002202220000202002202220202000002000000220002000220222022222202220000002020220200000200222022002002220020220202022200222022220200202000020222220220000022022222000000220020020222020002220220020202020220002220002202002000202222202020200220002200020220200020220220002200000200022220202022220220000200020002000022022022022222020202002200202200002022022002022020202000000220222020200202222220002220022020022000222022000020020200222000002222022000022000000020002222020022022002200220222000222020222000000020020200220202222220020020000200200022000000222220002222022020222222220000202020220200002000002202200202200200000220202020222020022000020020020000022002200202002022020022220002220200222202000002000000022222220000020002020000222200022022022220002020022000200200220022022002222200002200022000022000222200220022002000200000200022022000202200002220200022202002220020020222000020220002022022202222200002220200020222020220000000000000202022002202202200220222020202222220220022202022022220022220202200020220200022020222220000220020200222000200200202200000022200000022002022002222022200220000220222002220220200222022220222022002202202222202202200202022020220002022022000000000002200020220222220200222000020202002000000202000202202022002000220200202222220020200022000020202202220002002002002222020200022200200202200022222202020220002220022020200000200202202022202202202000020220202200222002222220222222020022220220222000202022000000200022200200200000022222022222222222000220022200220002002002020200002002002222000202220000022022220220200202222002202000220000220222000220222000000200200202220022220022002200020000020220002022222000002222020022020200222200202222222022020022222220022220002020002222022222220202222220222002002220202222002222202022000022000220200202220200022022220022020020222220202222202020202220200002220220000000022200002020202202200022202020220222202220020202002000022020202222002020202222220222020220002000020000222000020000020002202222022000220200200200002022200220022000220220022202020020000002200220220002020202002000022002000022202002220220200000002202002200222000002200222002002000200020000002222000220022000022200222020200222200200220022220202200202220022202020200202200000222000022200220022200020220202000200222022222002200000222022220222222222202002022000020002000200202220202002002200202002020020000020200202002020222000002222020200202020002222000000002220220020002000222220222020020200020220020000020002000200022020222222020022220200220200200002202222002022000200022002200020020020002202200202002002202200200000220020022220022220020020202200020200222200200220220222220200020000022020200220200200022202002200000002220220022000200000022000002220222022202020002000200002020222220220002020022002220200222020020022022022220020202022020220022222200202002220020002220220000222022002020020202220000000220022220002000222002002222200222220200222220220002202220220200022222202220022202022020002200002200022222222202000002200020020202002220220202000220002202220002200020002002022002020200020022020022000000020202020000202020202022000000020000200222000220020022000220002022000022000220022000022000200022200222222002200220220022200220000000202002220220022200020002000200220002000020222020202202002022000020000020200202220222220220020220002222222222220002020020002200200020000200020222220200022202220002002000202022022000022200202000202200222200202020022202000020200022202222222222222000220222002002022000220000200022000222002220002222000022002220202202022222200000000220000002202000222000000222222200200220002222002220002020020202202222002022220002002222000200220200220220000220002222222200202202220220020200002202022002200200000002000202000222020020220020220202222020002200000020222002202020202000202220200200222022020020020220002202022200202000200200002222022220200020022222000220222022020020002222002222200000002220022000022202222200200200220020020220022202200220000222022002222020020202200222220222222022022020200002022202020000222200202202202220222022002200202022200222000022002202202000022220220000200020020022000000202222020000022220222000000202220200200000220000200000200222202020020200020000202022222000022202200202022002002220020200222000220220022002020020022222200020200222000000022020200022220000000202220222222202220202220200200200000220222200022200200000000002200002022202202020200222022020220020220020222202000202020000000220202000200202020000202222022200002222202202200222000002020002220020200020002022022220022002200000022200022202022020000020200202002220220000200020022222020220022022200200220002000202022002202022202200022022202002202000000200000022002002222000220200222022020222222022000220220020020200220020002002000202000000002220220220200000020020222222200200022200220202020002022020202222022002002202200020020020220022220222022200020022202222220222220222020020220202202002200000020000020022222022000200222002020020200022202022000022220020022222202220220020022022022022020000222220000220220000000222002200022002220202022202000022020220200020222002220222022002020000222020020222220220000002222002022220200000220222220022220200222000222202022200220202022000220022220022002022222200220202022002002202000200220022022002000000020200200000020220222200022222222020022202000000200000022002002202202200222020020022222002220202022020202222022002022200222200022020220020222022220020200022222202000200222020000220000000200022002200200000222020202002020022000002000002000022000002220222200220200022022220022000002000220200002002002202022222222002202200020220000200200202020002202220000020222020022022200022220222022000020222022000000020202220020222020000222202222222022220202022020200202220220222002220200022202002202000000220202220202000000202200202200002000022002002202202022000022022002220002220022002200022022022220020020022000222022022002020022000000220200220022220020220202202222222200002000000200020202002000202200220000002022002220020000222022002222202022022020222222200202200000020220000222022202220000202022222020000202222022222200000202220202222002022002202220000222000222000220002022002020200200202222000022020202020200200202022202220200002202200000022200020220002202202222222000222002022020002002000222200002000000200220022020000220022022220022002002022202022000202222022022022222200202002200202000222002222020222200000200020220202022200002202002020202222220022022220000222202220222202000002200002200020020202200202200002200002020002020200020220220202220200022220020000000200000000200022202002220020022022202220020000222020200000002000020202200202200002000222002222022202202020020020020200020202202020222222220222222200222222022002202002202020020202220222200222202222200022022022220000220000220002202002020222020002202000220200020200022000000220202022202000022220002020202022022200022000000002222000200002000020020202222202202022022002020000222202002020202200020000222202020020220220022000200020020222222220220000020020220202200220000220202002020022000202002002000000002222000020222220020000220002220002222002020220002202220202000022222020002222222000022020022202220220200222020220020220202020020002202220222202200002000022222222022202220200022220222020222202002002022222200202022000002202002200002022000200002022020200022202020020020020222220002002200200200022200220200222220222202202200000222200020222000020200220202020220022002022022020020020202200222022222222220202220202220220222002020020200220002022020220022020220220222202020220020002202002002222202000220000022222020220200202022020022000002202222200020020002022220222200222202202222200200202202002200000200202022202220202220202202202020220222022220022202200200020200020022022220002002000000002200220200002200020200200222202002222222020202202022002020202220022000020020022202020002202002220220202020220200002200002222200222002202222202000220202002200022200002022202220202020000022202220020202202000222200222200002002020020220002220022002020220002202222200222000202222000000202222200202000000220200022202000002022220200000000222220022200020020202222220200020200200000000202022000022002220220022002220222020222200222200202222002002002200200202022020200000022200220202002200022020222020200000200002022020202002002202222002002002220000200022000000022220200020022222020000022220002222022222200202202222022222020202202000200002020200000202200022222002020022002202002002200222200022202020022022002202222202202022202222200202220200000002002022000000222220200002000000222022000022000002000020222200200022202202200220220222020000022022222020200220022220000222220000200000022220222220200220022000002000220002020020022202202222222020000002220000200020000222200002022020200002200220220222200222002020020022000002222022020202000220000022202200022002222222000002002022220022222222200020022220202220202222202222220220222002200000202020000022220220002002202022222200222202202220000202200022022202000222022222020220222022020002222020022002022020200222020202000002000220020020202002002222002200220000202020002022200222022002220200000000220202200020202200020220220000202222020002020002202220222020202200002222220200002020222202020000200000000000202220202022202000000222202000000222202222202000000022200000200202200220002022202002200220222000022222002200200020002222202002000202000220000222022020002020000000222022022022022202022020202202002022020002000020202020222220220200222202002002000002222222020002200000222220222220002202020022002020022020202222020220002020000002020222200220000202022002220002022202022202200202000002220020200222000020222200022020020022220200222200202200020022202022222000002220200002020000022222202020222002002022022202200000222020200000220222002222200200000022200022020000022020202220022022200002000202020202020220002220200022002222000022002000022202220200000022000002022220202220020000220200000202020220222200022220000202220002222000202222200222202222022002020002000020020200222200202022220200020000000022220200220202222000022002202022002222220202202020200020220220222000002220022000202202220022020000220000000022000200222200020020200002022202222222200222022022202220020002222002022022000222220022020000220000200202220200220202020020000222220202022000022200000020022000002200220222000020220220200222002200202000000022202000000220022000000200020022000020200002222220022022200202200200022222020022020200002022220220202220022222002202200002002022220200200202000222000020222220202200202220202220220020022002020000222202020200222020222002200200022022000200022220020002222220220220022020222200202002022022222020220200022220022200222202222020202020220020002220220020002020022220220220022202200000020222200202000002220022202202022020220022022202022002000220020220020000220200200202222002020000020022022002202202220222222002200022002002220202202022000222220002202222020200200002222220002220022022222222222000000002000200200202020022222022000000020200202022000020202220220222000222220020220002022022002000220202200002000022002220200000002000202220202020222022002020222000200222022202202220220220022202002020222220000200000000222202200002000200220200002000222202220202220200202002200002200220202202220202020200002000202020222202200200200222222022202200022022022022220002020002000000022020220200222222200222000220002000222022222022022202000222200222200020202220200220222202220200020222000000202202202220002022202000000000022002002002202202222020020222202022202202222000022002220202020200220200002222222220222200000000002022222020222022220220222222222220022200200222202202002022202220222022202020220020202200202000002022220222022020222000200022202022220002222200000020020202200000222020202000202022220220022220220022020222222000222222222000202222222222222020220002200220222000200220022020202200220222200020220220200002222200022020002020220200020220202002002000202200020220002200022200202002002022200002202200222200002202202220020022220020022202022200000020020000222020202002020002022022200202202020020220022222222022022000200200022002222222022222022022200002000220000020202002002200222020022022002000022002002202200220020002220220220020220222200200222000222000220020000000202202220000020222220222222220022022020222000222200202022200002202222202022000220202022000202200022022200222222220000222000002222002222000000022022202020222020020002220022002200202020222000222222022202020202222022020222222022020222000220200022020202222220222220022220020000022002020220202020000000220022220002200020022022200222200202002022022202002200002200200002022000200000202220000022000202202022020222020020220200022200202000020002022200200220202222200202002200020000002022200202020000200222220202000000020002002202000222020022022002000202222022202020020222002000002000200020020000002000022000222020220020020020022220022202000220000200200002020000022002000220000020200022002002220022000220020020220022002022222000200000020022000222202220002220202000200020002020022020002002222222222202022220002002220222020002222200020222200022022022022002200202022022222202000022022202200200002000220220222000200022222002002220000220020202022000200022002200020000222020022200000022222222222222202000222200022202220002022202002200020022200202002022000022022220002202020000000202020222220222220020020002220200202002222000222200022202222002000000200222000020020200020202220220222220200020202020002220222002200022020002222000202020000220020020202220202020222220220002220222222000002220000220022200020020220220200000000200022002020220202000020222020000202002020022022200220020202200200200220222002000002000200022002002200002220220020002220200002002002002202200022202022222000000202020222202022000202202200020222002220022202220202002200222002000020222022220222022222002002000202000222020000000020200222222220002202022020022202022002002220020022002020220220220020222220002020002222202202220022200220220022020022002200222002202222200002202022022220002002220020220020202200000200002222022202202200022202202200020020220000000002222002002200020022222222022220022222000202020202022000020202022220220222020022202222022022202202000020200002002222200000000220000222002022202222020000020000022020000000220202000000020220000200222000020020020002202022222202022022220202002202002222220020002202200222000220220222002220020000222202222002022022002202200022022200220202202220022002020222202020222022000022000202202202202200020022222022020000222002022022022000222220000000222002020200222022002222020220000222200202200022020002000202002002200002000202200002002002020000020220002202200222220000222222200220220000000022020002020002202000020202220002000200002220220002000000020202002220022000022200222002020020222202200020000220002202022002220202000002022222222200002220022022022020222220220022200002002002200222200200222220002220200202202220022222220020022200020020002220202000222022002202200202002222020000202220200020202202020020022000202022200222202000002220222002020020002200000000020202220000022000002220022000000022202020200020002200222022220222220020222202002022002200002022000000200000200220222220220002200220000200002000002002200200000220000000020200022222002020002202200022222200000222022022000020202220000220220222022002002220000000222200002202202022202002202000002002002000002220002202220220200220002000222202020222220222222222200202220200222222222002022220220020020220220220220202020200202020020002222020020022002222002000202022020022022002002222202202002200200000220202200200022220002000020020020202002200022220220200200202000022200222002222222202002022022020002200002220000222020020222022202022222222022020022020200220020222220002202222222222222202002020222222220020022202020222220220000000022002002002022222022200020220022020020220200000202022022220002202000022022202200022000220202022220022222022002022222022022022200020002222202000220202000022200220222200002202200020022202202200000020000222020222202000200000202000222000020020222020000222220002202000222000220022022200200022222002200002000202202220220000022200220202222020000002022000220022220002200202022200222220220220222200222000202000222022022000220222020222202220020222020000202020200220002020002222200200000222002200020022220220220220202202220002200200000000220022002222200222200222220020020200022022022020022222202220000200020202020002020000222202220020000220000022202220022200220202002202000000020222022200200002022022220200000220020222020220200002220222022020220020002222002220220202002000202020020202020202020000002022202020022020022022020002202020022220202022220020020022000002200202200000202202020220220000020200222222222200200000200202000200022200220200220022000002222202220220202002020222020022222222002002200020020222022202022200020002022220222020200200002202202020002000020220022002020020002220222000200022022200200202000220000022002202222200002002000020222200002000200000202000020000002220202220220002220222002022022222000222202000202222002020002222202202000202002200220020020222002220022222002002222220000020000022020020000202020002200200202220220002002020222222020020222202002202222200020220200222022200002200202200222200200202220202022200220200020000220202022200020220022220200220222222000220000020220002220002220220002022220222202202002000202220222022200222222222200220220222002022000020020202220020022220222000220020220200020222000222200002222220220020020220000200202202020002020202220020020200202022220220200220220000202002222200200222022220222202200020200222200020220000220000202220020002222222020222020000022220200220220202220022220220022000202200002022020020222020202022022002020200022002002022020202220202020002200220202200022000000020002220020002200000000220222222000200022222022020002220020222022202000002202222002002022220202202022220222000222000002220020220002002202220200222222020020002200022000220202000000222022000000020022200200202220200200200002000202202000000222222222202020022220222200200202002002220000002222200202200022202200020200202020002220220022222222002200222200200002022222020000020022020200002002000220000220002220000000220002020002022202020002022020220200220002002020000200200000200222202002202022020222220002000020222222022022202222022022220002202200220220022020202202002202220220020202000202002000202222020202222000222022220002222222200200200220002022222022220002000202002002020222000222222002002000220002020220022002202022220020000022022202000002002200020000002020020000022220020200020220220020220002022220222002000202220202200202020000020202000000220000202202020020002220020022000000022000202200000002002200020202022022000020002000022200000002020202220022200022200002202002222220202020202200000222222022022002222020200200200222020002022220222220200220202200200022202222022022002020000200200200002222220002202000022220022002002222222222002220000222202022222222000002200022220202220222220202020000220022022222222020022222022002220022200000200200202000220020000002222000020000022220202220022222220222020202022200022020000220200022002000202220222220002200202022000022200022022202222222000020202000000000220222202022222200202002202020200220220202220022000000200002200020200000002020200200200202020022220220220000222222000202202222022220200222022022200002200200022000002200022200222020220022200202202202200020200200220000020200000202220022020002220020200222022002200000020200002220202000000002200200002020002200022220220220022222202220202222200022020022202222220220022002000022020020202022020222222220000000000002022000020202022020200022202000000020220000222022202200220202020020002002002220220222200000222002022022022200022002222020220000020002022022000020002200020202000222022220222220202002222220020002222200220202002002202002220002222202002202220002000000200220202020222222202000020000020220222220002020020220200020200220220002022220000220222022002002222200200002020002202200200002200200222220202000202002200022220022020222020002202000020022000000200220000220000022220200220000020000200022222020022200020202002202222020020002202022222022220202222022022222202022002000020002202020022002002200020002022000002020002020202020202200022200220000220022220220202202202002220200022202200220220220220200200020020200022222022000202000220200002220222202000022020220002000220020222220000220000022022220000202000222202220020020222002222000000022220020220200022002002200200220022222022022200202222020222220200220200202220202202002222202200222020220202002020200020020022000220220002002022200000002020020020220002000022020222020020002220002200020020020200020200022002000020220202200202022022222200022022222022202020220000022220022020222000020220220202200022220022200220022220000220222020022000222022222022022002002020200020202002020022202000000220000200200022222022222000002200200000002220220222000022222222022020002020220202200222020002002202000200200220202002022020002202000000202020000022002220022002202200002022202000022220222202222202022020000200200222202220022020200222202220020220200020202000200200000222202222020000022002020200002022020222222202222020000002000220000000202200022202022202000000022002020022002002000220222002000222002000022020000220222222000202220002202200202000220000220020000022000200222020222222222000020200002222020000000200200200000022202222020000202220000200202222222002202000200022022002222000200022220222022000220020002000002222200202222222202000222020002000022200002200020222200022222022200020002020000202020000222020200222000022200222022022200020000020220000220000200022022200022220002220220222020200000020202022002220222002002220020002220002202202202200002002200222002220222000220000200000220200202200000022200000200220222200220000002002020020220220002222220002220020022020200222222222220202202202000220022002220222200002222220022000022200202222022200200222222020002002002220002202022220002022222022222022022220022000022200202220000000202022002022202002222020002202022202022202200222222220202200022222002222220220002020022220220202020200002002220020220022022002000202202002200202002020200000200022222222022022220000002200022002020200000220222022200020002202020220002200202220220002020000002020000020022020000200022202000002200202022200200200000022200220022002020020202022200000000002222020222002020222022022020220000202200220202020200200002000002000000020200220222002222220222000002200002222022200222222002222200020220020000200222222000020022000220000002220200000202002020220200220000202220222202222000200200000222222220022222002020002020022020000020000200222222020202220022200220220002200222202022002020200000220002000022200002020000222200200220200000200000002002020200202000202222002222200020220000202222202220020222220202222000222022202022202002000000020020022222200202002000022220222220020000020200020220020222022202200202002202002002002222202222222202222202002022020000200002222002000200000002202200020020200000200000220200022202020202220220020222200020202022022022202020202002200220002000200022222220022220000200000220222000002200020202022200002000020200222220002222220202202000200202220222022022200200000200020200000002000220200000020222022220220200222000200002222000222020200200202200202220222002200202002200202202222222002020220020000000202200000222200220000000000022200022000220202020222022022220220220202200020200222222022020020000002222202002222200000202020200220200200002020002022222002020000202222200202200002222200200000222200202022000202022220200002002220222202200002202220200222020002020222002000000202222220020000000000022002022002020202202002002200222200020222222002200000022000222200200222202000200000202022002222020220002222020000000002022220202000202202222200002222200022002000000002222200222222220000220200020020220202022020022222222002002200200002002200000002202220222200222000000000002022022020022202202200000200020220022220000022022002000020002022220200220220222020022200002022222222002200020222020002222220200002202002020022220022022002220222220002022020022022202002002222020020022202200222200000200022002220202000200222200202020022002220202200022002000200002202020002022000022220000002200200202022000202222022202222222202022002222200022200222220020200222020002022222220022202000002220020220002022222022022002022202222222000022002020002202002022000022000202200000220200022200020220222000022202222000222222022202022222022200002202220222000202000200002220200000200202002202202","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://zgg2001.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}]},{"title":"C++学习记录：内存池设计与实现 及其详细代码","slug":"20210301_C++学习记录：内存池设计与实现 及其详细代码","date":"2021-02-28T16:00:30.000Z","updated":"2021-02-28T16:00:30.000Z","comments":true,"path":"2021/03/01/20210301_C++学习记录：内存池设计与实现 及其详细代码/","permalink":"https://zgg2001.github.io/2021/03/01/20210301_C++%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E5%86%85%E5%AD%98%E6%B1%A0%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20%E5%8F%8A%E5%85%B6%E8%AF%A6%E7%BB%86%E4%BB%A3%E7%A0%81/","excerpt":"&emsp;&emsp;这是我在VS2019上写的第一个项目，使用VS2019的目的是想在更为规范的IDE上写出更加规范的代码。&emsp;&emsp;使用内存池可以减少程序运行中产生的内存碎片，且可以提高程序内存分配效率从而提升程序效率。在这篇笔记中，我将记录下自己关于这个内存池项目的思路与详细代码。同时，在我的C++网络编程学习相关内容的下一步改进中，我将引入这个内存池提高服务端的运行效率。","text":"&emsp;&emsp;这是我在VS2019上写的第一个项目，使用VS2019的目的是想在更为规范的IDE上写出更加规范的代码。&emsp;&emsp;使用内存池可以减少程序运行中产生的内存碎片，且可以提高程序内存分配效率从而提升程序效率。在这篇笔记中，我将记录下自己关于这个内存池项目的思路与详细代码。同时，在我的C++网络编程学习相关内容的下一步改进中，我将引入这个内存池提高服务端的运行效率。 一、内存池设计思路&emsp;&emsp;首先，为什么要使用内存池？&emsp;&emsp;我是这样理解的：不断的使用new/malloc从堆中申请内存，会在内存中留下一些“缝隙”。例如我们申请三份8个字节大小的内存A、B、C，由于内存地址是连续的，则ABC的地址值每个相差8(正常情况)。此时我们delete/free掉B内存，A与C内存之间此时就有了8个字节的空白。假如我们今后申请的内存都比8个字节大，则A与C之间这块内存就会一直为空白，这就是内存碎片。&emsp;&emsp;过多的内存碎片会影响程序的内存分配效率，为了降低内存碎片的影响，我们可以引入内存池来尝试解决它。 &emsp;&emsp;我们可以在程序启动时(或是其他合适的时机)，预先申请足够的、大小相同的内存，把这些内存放在一个容器内。在需要申请内存时，直接从容器中取出一块内存使用；而释放内存时，把这块内存放回容器中即可。这个容器就被称为内存池。而这样操作也可以大大减少内存碎片出现的可能性，提高内存申请&#x2F;释放的效率。 这个项目中内存池的思路图如下：我们需要新建三个类： 首先是底层的内存块类，其中包含了该内存块的信息：内存块编号、引用情况、所属内存池、下一块的位置等。 其次是内存池类，它对成组的内存块进行管理，可以实现把内存块从内存池中取出以及把内存块放回内存池。 最后是内存管理工具类，其中包含一个或多个内存池，所以它要根据用户申请的内存大小找到合适的内存池，调用内存池类的方法申请&#x2F;释放内存。 还需要进行的操作： 对new/delete进行重载，使其直接调用内存管理工具类申请&#x2F;释放内存。 &emsp;&emsp;上面的工作完成后，我们仍是以new/delete来申请&#x2F;释放内存，但是已经是通过内存池来实现的了，这个内存池项目也就暂时结束。下面我将详细记录实现的过程与思路。 二、内存块类MemoryBlock 设计与实现先扔出来思路图：&emsp;&emsp;首先，在内存池中每一块内存是由一个内存头以及其可用内存组成的，其中内存头里储存了这块内存的相关信息，可用内存即为数据域，类似链表中节点的结构。而一块块内存之间正是一种类似链表的结构，即通过内存头中的一个指针进行连接。内存头中包含的信息大概如下： 1、内存块编号 2、引用情况 3、所属内存池 4、下一块位置 5、是否在内存池内 则我们可以通过上面的思路新建内存块类MemoryBlock： 1234567891011121314151617181920212223由于内存头中要标记所属内存池，所以我们先预声明内存池类，在之后再进行实现。建立完成后，内存池内一块内存的大小为：sizeof(MemoryBlock) + 可用内存的大小//预声明内存池类class MemoryAlloc;//内存块类class MemoryBlock&#123;public: //内存块编号 int _nID; //引用情况 int _nRef; //所属内存池 MemoryAlloc* _pAlloc; //下一块位置 MemoryBlock* _pNext; //是否在内存池内 bool _bPool;private:&#125;; 三、内存池类MemoryAlloc 设计与实现还是先扔出来内存池申请&#x2F;释放内存的思路图：&emsp;&emsp;由图可知，整个内存池的管理基本为链表结构，内存池对象一直指向头部内存单元。在申请内存时移除头部单元，类似链表头结点的移除；在释放内存时，类似链表的头插法，把回收回来的内存单元放在内存池链表的头部。 内存池类中大概包含这些东西： 1、方法 1.成员变量初始化 —— 对内存单元可用内存大小以及内存单元数量进行设定 2.初始化 —— 依据内存单元的大小与数量，对内存池内的内存进行malloc申请，完善每一个内存单元的信息 3.申请内存 —— 从内存池链表中取出一块可用内存 4.释放内存 —— 将一块内存放回内存池链表中 2、成员变量 1.内存池地址 —— 指向内存池内的总内存 2.头部内存单元 —— 指向头部内存单元 3.内存块大小 —— 内存单元的可用内存大小 4.内存块数量 —— 内存单元的数量 则我们可以通过上面的思路新建内存块类MemoryAlloc： 1234567891011121314151617181920212223242526272829//导入内存块头文件#include&quot;MemoryBlock.h&quot;class MemoryAlloc&#123;public: MemoryAlloc(); virtual ~MemoryAlloc(); //设置初始化 void setInit(size_t nSize,size_t nBlockSize);//传入的为内存块可用内存大小和内存块数量 //初始化 void initMemory(); //申请内存 void* allocMem(size_t nSize);//传入的为申请可用内存的大小 //释放内存 void freeMem(void* p);protected: //内存池地址 char* _pBuf; //头部内存单元 MemoryBlock* _pHeader; //内存块大小 size_t _nSize; //内存块数量 size_t _nBlockSize; //多线程锁 std::mutex _mutex;//锁上申请内存方法和释放内存方法即可实现多线程操作&#125;; 四、内存管理工具类MemoryMgr 设计与实现仍然是先放思路图：&emsp;&emsp;首先，内存管理工具类用的是单例对象模式，从而能简易的对内存池进行管理。在这次的实现里，我使用的是饿汉式单例对象。其次，为了更简单的判断出申请内存时所需要调用的内存池，我建立了一个数组映射内存池。在工具类构造函数内，首先是对内存池进行初始化，随后便是将其映射到数组上。 1234映射：假如申请一个64字节内存池，申请一个128字节内存池我们新建一个指针数组test，使下标0~64指向64字节内存池，下标65~128指向128字节内存池则我们通过 test[要申请的内存大小] 即可确定合适的内存池 &emsp;&emsp;在随后的申请过程中，我们首先判断申请内存大小是否超过内存池最大可用内存，若没超过，则通过映射数组指向的内存池进行内存申请；若超过了，则直接使用malloc申请，记得多申请一个内存头大小的内存。随后完善内存头内的资料。&emsp;&emsp;在随后的释放过程中，我们通过内存头判断这块内存是否使属于内存池的内存，如果是，则通过其所属内存池进行内存回收；若不是，则直接进行free释放。 内存管理工具类中大概包含这些东西： 1、方法 饿汉式单例模式 —— 调用返回单例对象 申请内存 —— 调用获取一块内存 释放内存 —— 调用释放一块内存 内存初始化 —— 将内存池映射到数组上 2、成员变量 映射数组 —— 映射内存池 内存池1 内存池2 内存池… 则我们可以通过上面的思路新建内存管理工具类MemoryMgr： 12345678910111213141516171819202122232425262728293031//内存池最大申请#define MAX_MEMORY_SIZE 128//导入内存池模板类#include&quot;MemoryAlloc.h&quot;class MemoryMgr&#123;public: //饿汉式单例模式 static MemoryMgr* Instance(); //申请内存 void* allocMem(size_t nSize); //释放内存 void freeMem(void* p); private: MemoryMgr(); virtual ~MemoryMgr(); //内存映射初始化 void init_szAlloc(int begin,int end,MemoryAlloc* pMem);private: //映射数组 MemoryAlloc* _szAlloc[MAX_MEMORY_SIZE + 1]; //64字节内存池 MemoryAlloc _mem64; //128字节内存池 MemoryAlloc _mem128; //内存池...&#125;; 五、重载new/delete重载new/delete就不多说了，直接放代码： 123456void* operator new(size_t size);void operator delete(void* p);void* operator new[](size_t size);void operator delete[](void* p);void* mem_alloc(size_t size);//mallocvoid mem_free(void* p);//free 六、项目代码及其注释1.项目图片) 2.重载new/delete2.1 Alloctor.h1234567891011#ifndef _Alloctor_h_#define _Alloctor_h_void* operator new(size_t size);void operator delete(void* p);void* operator new[](size_t size);void operator delete[](void* p);void* mem_alloc(size_t size);void mem_free(void* p);#endif 2.2 Alloctor.cpp1234567891011121314151617181920212223242526272829303132#include&quot;Alloctor.h&quot;#include&quot;MemoryMgr.h&quot;//内存管理工具void* operator new(size_t size)&#123; return MemoryMgr::Instance()-&gt;allocMem(size);&#125;void operator delete(void* p)&#123; MemoryMgr::Instance()-&gt;freeMem(p);&#125;void* operator new[](size_t size)&#123; return MemoryMgr::Instance()-&gt;allocMem(size);&#125;void operator delete[](void* p)&#123; MemoryMgr::Instance()-&gt;freeMem(p);&#125;void* mem_alloc(size_t size)&#123; return MemoryMgr::Instance()-&gt;allocMem(size);&#125;void mem_free(void* p)&#123; MemoryMgr::Instance()-&gt;freeMem(p);&#125; 3.内存池类MemoryAlloc3.1 MemoryAlloc.h12345678910111213141516171819202122232425262728293031323334353637383940/*内存池类对内存块进行管理2021/2/26*/#ifndef Memory_Alloc_h#define Memory_Alloc_h//导入内存块头文件#include&quot;MemoryBlock.h&quot;class MemoryAlloc&#123;public: MemoryAlloc(); virtual ~MemoryAlloc(); //设置初始化 void setInit(size_t nSize,size_t nBlockSize); //初始化 void initMemory(); //申请内存 void* allocMem(size_t nSize); //释放内存 void freeMem(void* p);protected: //内存池地址 char* _pBuf; //头部内存单元 MemoryBlock* _pHeader; //内存块大小 size_t _nSize; //内存块数量 size_t _nBlockSize; //多线程锁 std::mutex _mutex;&#125;;#endif 3.2 MemoryAlloc.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include&quot;MemoryAlloc.h&quot;MemoryAlloc::MemoryAlloc()&#123; _pBuf = nullptr; _pHeader = nullptr; _nSize = 0; _nBlockSize = 0;&#125;MemoryAlloc::~MemoryAlloc()&#123; if (_pBuf) &#123; free(_pBuf); //现在有一个问题就是内存池外申请的内存不会被主动释放 &#125;&#125;void MemoryAlloc::setInit(size_t nSize, size_t nBlockSize)&#123; /*补全nSize const size_t n = sizeof(void*) _nSize = (nSize/n) * n + (nSize % n ? n : 0); */ _pBuf = nullptr; _pHeader = nullptr; _nSize = nSize; _nBlockSize = nBlockSize; initMemory();&#125;void MemoryAlloc::initMemory()&#123; //断言 assert(nullptr == _pBuf); //若已申请则返回 if (nullptr != _pBuf) &#123; return; &#125; //计算内存池的大小 (块大小+块头) * 块数量 size_t temp_size = _nSize + sizeof(MemoryBlock);//需要偏移的真正大小 size_t bufSize = temp_size * _nBlockSize; //向系统申请池内存 _pBuf = (char*)malloc(bufSize); //初始化内存池 _pHeader = (MemoryBlock*)_pBuf; if (nullptr != _pHeader) &#123; _pHeader-&gt;_bPool = true;//在池中 _pHeader-&gt;_nID = 0;//第0块 _pHeader-&gt;_nRef = 0;//引用次数为0 _pHeader-&gt;_pAlloc = this;//属于当前内存池 _pHeader-&gt;_pNext = nullptr;//下一块 MemoryBlock* pTemp1 = _pHeader; //遍历内存块进行初始化 for (size_t n = 1; n &lt; _nBlockSize; n++) &#123; MemoryBlock* pTemp2 = (MemoryBlock*)(_pBuf + (n * temp_size));//指针偏移到下一块 pTemp2-&gt;_bPool = true;//在池中 pTemp2-&gt;_nID = n;//第n块 pTemp2-&gt;_nRef = 0; pTemp2-&gt;_pAlloc = this; pTemp2-&gt;_pNext = nullptr; pTemp1-&gt;_pNext = pTemp2; pTemp1 = pTemp2; &#125; &#125;&#125;void* MemoryAlloc::allocMem(size_t nSize)&#123; //自解锁 std::lock_guard&lt;std::mutex&gt; lock(_mutex); //若内存池不存在则初始化 if (nullptr == _pBuf) &#123; initMemory(); &#125; MemoryBlock* pReturn = nullptr; if (nullptr == _pHeader)//如内存池已满 重新申请 &#123; pReturn = (MemoryBlock*)malloc(nSize+sizeof(MemoryBlock)); if (nullptr != pReturn) &#123; pReturn-&gt;_bPool = false;//不在池中 pReturn-&gt;_nID = -1; pReturn-&gt;_nRef = 1; pReturn-&gt;_pAlloc = this; pReturn-&gt;_pNext = nullptr; &#125; &#125; else//否则直接使用内存池 &#123; pReturn = _pHeader; _pHeader = _pHeader-&gt;_pNext; assert(0 == pReturn-&gt;_nRef); pReturn-&gt;_nRef = 1; &#125; //debug打印 if (nullptr != pReturn) &#123; xPrintf(&quot;NEW - allocMem:%p,id=%d,size=%d\\n&quot;, pReturn, pReturn-&gt;_nID, nSize); &#125; return ((char*)pReturn + sizeof(MemoryBlock));&#125;void MemoryAlloc::freeMem(void* p)&#123; //传进来的是消息区 需要加上信息头 MemoryBlock* pBlock = (MemoryBlock*)((char*)p - sizeof(MemoryBlock)); assert(1 == pBlock-&gt;_nRef); //判断是否被多次引用 if (--pBlock-&gt;_nRef != 0) &#123; return; &#125; //判断是否在内存池中 if (pBlock-&gt;_bPool) &#123; //自解锁 std::lock_guard&lt;std::mutex&gt; lock(_mutex); //把内存块放入内存池首位 pBlock-&gt;_pNext = _pHeader; _pHeader = pBlock; &#125; else &#123; free(pBlock); &#125;&#125; 4.内存块类MemoryBlock4.1 MemoryBlock.h123456789101112131415161718192021222324252627282930313233343536373839404142/*内存块类内存管理的最小单位2021/2/26*/#ifndef Memory_Block_h#define Memory_Block_h//声明内存池类class MemoryAlloc;//最底层导入内存头文件/断言头文件/锁头文件#include&lt;stdlib.h&gt;#include&lt;assert.h&gt;#include&lt;mutex&gt;//如果为debug模式则加入调试信息#ifdef _DEBUG #include&lt;stdio.h&gt; #define xPrintf(...) printf(__VA_ARGS__)#else #define xPrintf(...)#endif class MemoryBlock&#123;public: //内存块编号 int _nID; //引用情况 int _nRef; //所属内存池 MemoryAlloc* _pAlloc; //下一块位置 MemoryBlock* _pNext; //是否在内存池内 bool _bPool;private:&#125;;#endif 4.2 MemoryBlock.cpp1#include&quot;MemoryBlock.h&quot; 5.内存管理工具类MemoryMgr5.1 MemoryMgr.h123456789101112131415161718192021222324252627282930313233343536373839404142/*内存管理工具类对内存池进行管理2021/2/26*/#ifndef Memory_Mgr_h#define Memory_Mgr_h//内存池最大申请#define MAX_MEMORY_SIZE 128//导入内存池模板类#include&quot;MemoryAlloc.h&quot;class MemoryMgr&#123;public: //饿汉式单例模式 static MemoryMgr* Instance(); //申请内存 void* allocMem(size_t nSize); //释放内存 void freeMem(void* p); //增加内存块引用次数 void addRef(void* p);private: MemoryMgr(); virtual ~MemoryMgr(); //内存映射初始化 void init_szAlloc(int begin,int end,MemoryAlloc* pMem);private: //映射数组 MemoryAlloc* _szAlloc[MAX_MEMORY_SIZE + 1]; //64字节内存池 MemoryAlloc _mem64; //128字节内存池 MemoryAlloc _mem128;&#125;;#endif 5.2 MemoryMgr.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&quot;MemoryMgr.h&quot;MemoryMgr::MemoryMgr()&#123; _mem64.setInit(64, 10); init_szAlloc(0, 64, &amp;_mem64); _mem128.setInit(128, 10); init_szAlloc(65, 128, &amp;_mem128);&#125;MemoryMgr::~MemoryMgr()&#123;&#125;//初始化void MemoryMgr::init_szAlloc(int begin, int end, MemoryAlloc* pMem)&#123; //begin到end大小的内存申请都映射到相关的内存池上 for (int i = begin; i &lt;= end; i++) &#123; _szAlloc[i] = pMem; &#125;&#125;//饿汉式单例模式MemoryMgr* MemoryMgr::Instance()&#123; static MemoryMgr myMemoryMgr; //单例对象 return &amp;myMemoryMgr;&#125;//申请内存void* MemoryMgr::allocMem(size_t nSize)&#123; //若申请的内存大小正常，则直接申请 if (nSize &lt;= MAX_MEMORY_SIZE) &#123; return _szAlloc[nSize]-&gt;allocMem(nSize); &#125; else//否则用malloc申请一个 &#123; MemoryBlock* pReturn = (MemoryBlock*)malloc(nSize + sizeof(MemoryBlock)); if (nullptr != pReturn) &#123; pReturn-&gt;_bPool = false;//不在池中 pReturn-&gt;_nID = -1; pReturn-&gt;_nRef = 1; pReturn-&gt;_pAlloc = nullptr; pReturn-&gt;_pNext = nullptr; //debug打印 xPrintf(&quot;NEW - allocMem:%p,id=%d,size=%d\\n&quot;,pReturn,pReturn-&gt;_nID,nSize); &#125; return ((char*)pReturn + sizeof(MemoryBlock)); &#125;&#125;//释放内存void MemoryMgr::freeMem(void* p)&#123; //传进来的是消息区 需要加上信息头 MemoryBlock* pBlock = (MemoryBlock*)((char*)p - sizeof(MemoryBlock)); //debug打印 xPrintf(&quot;DELETE - allocMem:%p,id=%d\\n&quot;, pBlock, pBlock-&gt;_nID); //内存池内的内存块/内存池外的内存块 不同的处理方式 if (pBlock-&gt;_bPool == true) &#123; pBlock-&gt;_pAlloc-&gt;freeMem(p); &#125; else &#123; if (--pBlock-&gt;_nRef == 0) &#123; free(pBlock); &#125; &#125;&#125;//增加内存块引用次数void MemoryMgr::addRef(void* p)&#123; MemoryBlock* pBlock = (MemoryBlock*)((char*)p - sizeof(MemoryBlock)); ++pBlock-&gt;_nRef;&#125; 6.main文件6.1 main.cpp12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&quot;Alloctor.h&quot;#ifdef _DEBUG#endifint main()&#123; char* data2 = new char; delete data2; char* data1 = new char[129]; delete[] data1; char* data3 = new char[65]; delete[] data3; printf(&quot;--------------------------\\n&quot;); char* data[15]; for (size_t i = 0; i &lt; 12; i++) &#123; data[i] = new char[64]; delete[] data[i]; &#125; return 0;&#125; 七、小结 在申请与释放内存时，返回给用户和用户传进来的都是可用内存的地址，并不是内存头的地址。我们需要对地址进行偏移，从而返回&#x2F;接收正确的地址。具体为可用内存地址向前偏移一个内存头大小即为内存头地址；内存头地址向后偏移一个内存头大小即为可用内存地址。 内存池初始化时，申请总地址大小为：(可用地址大小+内存头大小) * 内存单元数量 内存池外申请的内存，不会在内存池析构函数内被释放，需要手动释放。（不过一般触发析构函数的时候，也不用手动释放了） 在这次的项目中，我对地址、内存等有了更深刻的理解，同时也能熟练使用VS的调试功能。希望未来能有更大的发展。","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"}]},{"title":"C++网络编程学习：消息接收与发送分离","slug":"20210221_C++网络编程学习：消息接收与发送分离","date":"2021-02-21T06:24:33.000Z","updated":"2021-02-21T06:24:33.000Z","comments":true,"path":"2021/02/21/20210221_C++网络编程学习：消息接收与发送分离/","permalink":"https://zgg2001.github.io/2021/02/21/20210221_C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%B6%88%E6%81%AF%E6%8E%A5%E6%94%B6%E4%B8%8E%E5%8F%91%E9%80%81%E5%88%86%E7%A6%BB/","excerpt":"使用的语言为C&#x2F;C++ 源码支持的平台为：Windows &#x2F; Linux 一、思路与准备&emsp;&emsp;在之前的 C++网络编程学习：服务端多线程分离业务处理高负载 笔记中，我将业务处理相关内容从主线程中分离，大大提高了服务端的效率。随着服务端的进一步完善，我会把各个模块进行分离，从而使代码的结构更加便于修改与完善，同时也可以提高代码的运行效率。&emsp;&emsp;本篇笔记中，我会记录自己如何把消息发送的相关内容从业务处理线程中分离出来。","text":"使用的语言为C&#x2F;C++ 源码支持的平台为：Windows &#x2F; Linux 一、思路与准备&emsp;&emsp;在之前的 C++网络编程学习：服务端多线程分离业务处理高负载 笔记中，我将业务处理相关内容从主线程中分离，大大提高了服务端的效率。随着服务端的进一步完善，我会把各个模块进行分离，从而使代码的结构更加便于修改与完善，同时也可以提高代码的运行效率。&emsp;&emsp;本篇笔记中，我会记录自己如何把消息发送的相关内容从业务处理线程中分离出来。 首先下面是我的思路图。 大致思路如下：处理事件线程 &gt;&gt; 发送线程缓冲区 &gt;&gt; 发送线程 &emsp;&emsp;我会在新建业务子线程时创建一条发送子线程。其中由主线程创建子线程对象，子线程对象中包含两条子线程，一条为业务子线程，一条为发送子线程。这样两条线程可以在一个对象中进行相关操作，便于实现。同时，主线程只需声明一个对象即可，封装性良好且低耦合。&emsp;&emsp;在业务线程需要发送消息时，首先创建一个消息发送对象，其中包含发送的目标和内容。随后把该对象加入缓冲区。在发送线程中，首先把缓冲区内的对象提取到正式发送队列中，随后把正式发送队列中的待发送事件挨个进行处理即可。 二、代码实现1.发送线程类文件相关&emsp;&emsp;首先，我们得新建两个类，一个是发送任务基类，一个是发送线程类。&emsp;&emsp;发送任务基类中，含有一个虚方法DoTask用来执行发送任务。该方法在服务端源码中被重载。&emsp;&emsp;发送线程类中，含有一条发送线程，同时有一个Start方法用来启动该线程。含有两条链表，一条为缓冲区链表，一条为正式消息链表，同时有一个addTask方法用来把消息任务加入缓冲区。线程执行OnRun方法把缓冲区中的任务加入正式队列并执行该任务的DoTask方法。 发送线程类文件 celltask.hpp 大致代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#ifndef _CELL_Task_hpp_#define _CELL_Task_hpp_#include&lt;thread&gt;#include&lt;mutex&gt;#include&lt;list&gt;//任务基类class CellTask&#123;public: //执行任务 virtual void DoTask() = 0; &#125;;//发送线程类class CellTaskServer&#123;public: CellTaskServer() &#123; &#125; virtual ~CellTaskServer() &#123; &#125; //添加任务 void addTask(CellTask* ptask) &#123; std::lock_guard&lt;std::mutex&gt;lock(_mutex); _tasksBuf.push_back(ptask); &#125; //启动服务 void Start() &#123; //线程 std::thread t(std::mem_fn(&amp;CellTaskServer::OnRun),this); t.detach(); &#125; protected: //工作函数 void OnRun() &#123; while(1) &#123; //将缓冲区内数据加入 if(!_tasksBuf.empty())//不为空 &#123; std::lock_guard&lt;std::mutex&gt;lock(_mutex); for(auto pTask : _tasksBuf) &#123; _tasks.push_back(pTask); &#125; _tasksBuf.clear(); &#125; //如果无任务 if(_tasks.empty()) &#123; //休息一毫秒 std::chrono::milliseconds t(1); std::this_thread::sleep_for(t); continue; &#125; //处理任务 for(auto pTask:_tasks) &#123; pTask-&gt;DoTask(); delete pTask; &#125; //清空任务 _tasks.clear(); &#125; &#125; private: //任务数据 std::list&lt;CellTask*&gt;_tasks; //任务数据缓冲区 std::list&lt;CellTask*&gt;_tasksBuf; //锁 锁数据缓冲区 std::mutex _mutex; &#125;;#endif 其中的缓冲区加入操作涉及到临界操作，所以加个自解锁。 因为缓冲区以及正式队列涉及到频繁进出，所以用的是链表list。 当没有发送任务时，会进行一毫秒的休息，防止消耗太多的内存。 2.主文件相关&emsp;&emsp;在导入上述celltask.hpp头文件后，我们需要重载DoTask方法，从而实现把主文件内的相关类型数据进行发送。&emsp;&emsp;我们可以创建一个新类，使他继承CellTask任务基类。其中导入主文件内的相关类型。例如下面的例子中就导入了ClientSocket客户端类与DataHeader报文结构体。同时重写了DoTask方法，使其调用ClientSocket客户端类的SendData方法发送报文。 12345678910111213141516171819202122//网络消息发送任务class CellSendMsgTask : public CellTask&#123;public: CellSendMsgTask(ClientSocket* pClient,DataHeader* pHead) &#123; _pClient = pClient; _pHeader = pHead; &#125; //执行任务 virtual void DoTask() &#123; _pClient-&gt;SendData(_pHeader); delete _pHeader; &#125; private: ClientSocket* _pClient; DataHeader* _pHeader; &#125;; &emsp;&emsp;而当我们想要发送报文时，只需要新建上述CellSendMsgTask对象，并调用CellTaskServer任务线程类的addTask方法添加至发送队列即可。 123456//向 pClient 客户端发送 pHead 报文void AddSendTask(ClientSocket* pClient,DataHeader* pHead)&#123; CellSendMsgTask* ptask = new CellSendMsgTask(pClient,pHead); _taskServer.addTask(ptask);&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"网络编程","slug":"网络编程","permalink":"https://zgg2001.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"C++网络编程学习：对socket select网络模型的优化","slug":"20210220_C++网络编程学习：对socket select网络模型的优化","date":"2021-02-20T14:00:28.000Z","updated":"2021-02-20T14:00:28.000Z","comments":true,"path":"2021/02/20/20210220_C++网络编程学习：对socket select网络模型的优化/","permalink":"https://zgg2001.github.io/2021/02/20/20210220_C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%AF%B9socket%20select%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BC%98%E5%8C%96/","excerpt":"使用的语言为C&#x2F;C++ 源码支持的平台为：Windows &#x2F; Linux 东西不多，简单记录一下，今后可能会补充 零、思路与流程select网络模型的大概流程如下：1.获取一个至三个fd_set集合，获取一个timeval2.select函数对fd_set集合进行选择筛选3.FD_ISSET函数依据fd_set集合遍历查找待处理事件","text":"使用的语言为C&#x2F;C++ 源码支持的平台为：Windows &#x2F; Linux 东西不多，简单记录一下，今后可能会补充 零、思路与流程select网络模型的大概流程如下：1.获取一个至三个fd_set集合，获取一个timeval2.select函数对fd_set集合进行选择筛选3.FD_ISSET函数依据fd_set集合遍历查找待处理事件 select相关详细内容点我 12345678WINSOCK_API_LINKAGE int WSAAPI select( int nfds,//是指待监听集合里的范围 即待监听数量最大值+1 fd_set *readfds,//待监听的可读文件集合 fd_set *writefds,//待监听的可写文件集合 fd_set *exceptfds,//待监听的异常文件集合 const PTIMEVAL timeout);//超时设置 传入NULL为阻塞模式 传入timeval结构体为非阻塞模式 返回值为满足条件的待监听socket数量和，如果出错返回-1，如果超时返回0。 一、对fd_set的优化&emsp;&emsp;首先，我们可以对fd_set的相关操作进行优化。&emsp;&emsp;之前，我们每进行一次select操作，都要使用循环把所有的已连接socket放到fd_set集合中，随后进行选择操作。但是当连接数很大、select操作频繁时，不断的新建fd_set并用循环放入socket，很明显会大大增大系统的消耗。&emsp;&emsp;由于fd_set集合中一定存放的是当前所有的socket，由此，我们可以建立两个fd_set集合与一个bool变量。bool变量用来表示socket的组成是否发生了变化，当有客户端加入或断开时，该变量为true，否则为false。&emsp;&emsp;我们使用一个fd_set集合储存”老的”socket集合，当socket集合没有发生变化时，我们另一个新fd_set集合直接使用memcpy函数复制老集合中的内容，从而避免从头循环放入。当socket集合发生变化时，新集合直接循环从头录入，随后老集合使用memcpy函数把新集合内的内容复制过去，方便下一次使用。&emsp;&emsp;这样，我们即可大大减少关于fd_set集合初始化的消耗。 二、对select函数的优化&emsp;&emsp;当前我的代码只对read可读集合进行操作，并没有write可写集合与except异常集合的操作，所以我的select目前第三、第四个参数都传了空。这样可以增加一点select的效率。 1select(_sock+1,&amp;fdRead,0,0,&amp;s_t); &emsp;&emsp;其余因为select函数被封装了，目前就我的水平来言应该没法做进一步的优化，可能以后会有吧。 三、对FD_ISSET的优化&emsp;&emsp;这是select架构里吃资源的大头，当socket连接数很大时，显而易见的是这种O(N^2)的查询方法会极大的消耗资源。对此我们可以引入map加快查找操作。 1std::map&lt;socket,Client&gt; _clients; &emsp;&emsp;socket当键，客户端对象当值。根据select处理后的fd_set集合内的socket进行查找。效率提高为O(lgN)。","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"网络编程","slug":"网络编程","permalink":"https://zgg2001.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"C++网络编程学习：服务端多线程分离业务处理高负载","slug":"20210207_C++网络编程学习：服务端多线程分离业务处理高负载","date":"2021-02-07T06:05:55.000Z","updated":"2021-02-07T06:05:55.000Z","comments":true,"path":"2021/02/07/20210207_C++网络编程学习：服务端多线程分离业务处理高负载/","permalink":"https://zgg2001.github.io/2021/02/07/20210207_C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%86%E7%A6%BB%E4%B8%9A%E5%8A%A1%E5%A4%84%E7%90%86%E9%AB%98%E8%B4%9F%E8%BD%BD/","excerpt":"使用的语言为C&#x2F;C++ 源码支持的平台为：Windows &#x2F; Linux 一、思路与准备之前的服务端思路大概是如下的： 123456789101.建立socket2.绑定端口IP3.监听端口while(true)&#123; 4.使用select函数获取存在待监听事件的socket 5.如果有新的连接则与新的客户端连接 6.如果有待监听事件，则对其进行处理(接受与发送)&#125;7.关闭socket &emsp;&emsp;但是，这样的架构在select处理事件较多时，很容易效率低下。对于这类问题，我们可以引入生产者与消费者模式，来处理此类并发问题。","text":"使用的语言为C&#x2F;C++ 源码支持的平台为：Windows &#x2F; Linux 一、思路与准备之前的服务端思路大概是如下的： 123456789101.建立socket2.绑定端口IP3.监听端口while(true)&#123; 4.使用select函数获取存在待监听事件的socket 5.如果有新的连接则与新的客户端连接 6.如果有待监听事件，则对其进行处理(接受与发送)&#125;7.关闭socket &emsp;&emsp;但是，这样的架构在select处理事件较多时，很容易效率低下。对于这类问题，我们可以引入生产者与消费者模式，来处理此类并发问题。 &emsp;&emsp;主线程为生产者线程，用来处理新客户端加入事件，把新客户端分配至消费者线程中。消费者线程便是我们建立的新线程，专门用来处理客户端发送的报文。这样就实现了事件处理的分离，从而使服务端处理效率更高。当过多客户端同时涌入时，可以更快的建立连接(因为有专门的线程用来处理这一事件)；而当客户端发送报文频率很快时，多线程处理报文也会大大提高效率。 大致改进思路如下，红色的为此次需要加入的核心，黑色为原本架构 &emsp;&emsp;所以我们首先需要新建一个线程类，用来封装关于消费者线程的内容，从而建立多线程架构。随后，在本次的改进中，我决定加入计时器用来统计数据以及显示数据，主要需要统计的数据为：当前客户端连接数量、数据包的每秒接收数量。同时，我也对报文类型进行了分离，把报文类型放在单独的头文件里，这样既方便更改也方便引用。 1.计时器相关请点这里 &emsp;&emsp; 2.多线程相关请点这里 二、代码的改进1.新建子线程类 首先是新建线程类CellServer，其中包含的基础方法以及相关变量如下： 123456789101112131415161718192021222324252627282930313233343536373839404142//线程类class CellServer&#123;public: //构造 CellServer(SOCKET sock = INVALID_SOCKET); //析构 ~CellServer(); //关闭socket void CloseSocket(); //判断是否工作中 bool IsRun(); //查询是否有待处理消息 bool OnRun(); //接收数据 int RecvData(ClientSocket *t_client); //响应数据 void NetMsg(DataHeader *head,SOCKET temp_socket); //增加客户端 void addClient(ClientSocket* client); //启动线程 void Start(); //获取该线程内客户端数量 int GetClientCount() private: //缓冲区相关 char *_Recv_buf;//接收缓冲区 //socket相关 SOCKET _sock; //正式客户队列 std::vector&lt;ClientSocket*&gt; _clients;//储存客户端 //客户缓冲区队列 std::vector&lt;ClientSocket*&gt; _clientsBuf; std::mutex _mutex;//锁 //线程 std::thread* _pThread;public: std::atomic_int _recvCount;//接收包的数量 &#125;; 大致处理思路如下：12345678910111213141516171819线程外：Start() 首先调用该方法启动线程新客户端加入：GetClientCount() 首先主线程使用这个方法获取各个线程内客户端数量//这个添加客户端的方法内涉及到临界区，需要上锁addClient(ClientSocket* client) 主线程找到客户端数量最少的线程，使用该线程添加客户端至缓冲队列线程内：OnRun()//运行线程&#123; while(IsRun())//判断是否工作中 &#123; 1.将缓冲队列中的客户数据加入正式队列 2.正式客户队列为空的话，continue本次循环 3.select选择出待处理事件，错误的话就关闭所有连接CloseSocket() 4.对待处理事件进行接收RecvData()，接收包的数量加一，随后处理NetMsg() &#125;&#125; 2.客户端主线程类的更改&emsp;&emsp;由于我们处理事件都改为在子线程中，所以首先主线程中是不需要处理报文消息了，所以类中接收消息和处理消息的方法都可以删除了。同时我们加入Start方法用来启动子线程，加入time4msg方法用来显示子线程中的客户端数量、每秒收包数等数据。 主线程类TcpServer，更改后如下： 12345678910111213141516171819202122232425262728293031323334353637class TcpServer : INetEvent&#123;public: //构造 TcpServer(); //析构 ~TcpServer(); //初始化socket 返回1为正常 int InitSocket(); //绑定IP/端口 int Bind(const char* ip,unsigned short port); //监听端口 int Listen(int n); //接受连接 int Accept(); //添加客户端至服务端 void AddClientToServer(ClientSocket* pClient); //线程启动 void Start(); //关闭socket void CloseSocket(); //判断是否工作中 bool IsRun(); //查询是否有待处理消息 bool OnRun(); //显示各线程数据信息 void time4msg(); private: //socket相关 SOCKET _sock; std::vector&lt;ClientSocket*&gt; _clients;//储存客户端 std::vector&lt;CellServer*&gt; _cellServers;//子线程们 //计时器 mytimer _time; &#125;; 大致处理思路如下：计时器相关请点这里12345678910111213141516171819202122232425262728调用TcpServer封装类建立服务端的流程：1.InitSocket() 建立一个socket2.Bind(const char* ip,unsigned short port) 绑定端口和IP3.Listen(int n) 监听4.Start() 线程启动while(5.IsRun()) 主线程循环 &#123; 6.OnRun() 开始select选择处理事件&#125;7.CloseSocket() 关闭socket主线程内：OnRun()&#123; time4msg()显示数据 select选择出新客户端加入事件 如果有新客户端加入，调用Accept()接受连接 Accept()连接成功后，调用AddClientToServer(ClientSocket* pClient)分配客户端到子线程中&#125;AddClientToServer()内：首先调用子线程的GetClientCount()方法获取各条子线程中的客户端数量随后调用子线程的addClient(ClientSocket* client)方法，把新客户端添加至客户端最少的线程中time4msg()内：首先GetSecond()获取计时器的计时如果大于一秒，就统计客户端的情况：子线程内_recvCount为收包数，主线程内_clients.size()获取客户端数量显示后UpDate()重置计时器，并且重置收包数，从而达到统计每秒收包数的作用 3.引入接口，实现子线程向主线程通信&emsp;&emsp;通过前两步的实现，多线程服务端已经初步完成，接下来需要进行一些完善。&emsp;&emsp;我们很容易可以发现，子线程对象是在主线程Start()方法被创建的，随后被加入容器_cellServers储存。这就导致主线程中可以调用子线程类中的方法与成员变量，但是子线程中却无法调用主线程的方法与成员变量。从而导致当子线程中有客户端退出时，主线程无法了解。&emsp;&emsp;对于这种情况，我们可以创建一个接口，让主线程类继承这个接口，子线程即可通过这个接口调用主线程中的特定方法。 接口类INetEvent如下：1234567class INetEvent&#123;public: //有客户端退出 virtual void OnLeave(ClientSocket* pClient) = 0;private: &#125;; 主线程类与子线程类中的相关实现： 1234567891011121314151617181920212223242526272829303132333435363738391.首先是主线程类继承该接口：class TcpServer : INetEvent2.随后实现接口中的虚方法：//客户端退出void OnLeave(ClientSocket* pClient)&#123; //找到退出的客户端 for(int n=0; n&lt;_clients.size(); n++) &#123; if(_clients[n] == pClient) &#123; auto iter = _clients.begin() + n; if(iter != _clients.end()) &#123; _clients.erase(iter);//移除 &#125; &#125; &#125; &#125; 即可实现调用该方法，移除客户端容器中指定客户端3.随后在子线程类中添加私有成员变量： private: INetEvent* _pNetEvent; 创建接口对象4.创建方法，让接口对象指向主线程类void setEventObj(INetEvent* event)&#123; _pNetEvent = event; &#125;event传进去主线程即可，接口对象即指向主线程5.主线程创建、启动子线程类时，调用该方法，传入自身this子线程对象-&gt;setEventObj(this);6.随后即可通过子线程调用主线程的OnLeave()方法删除客户端_pNetEvent-&gt;OnLeave(要删除的客户端); 三、详细代码实现1.计时器头文件 mytimer.hpp12345678910111213141516171819202122232425262728293031323334353637#ifndef MY_TIMER_H_#define MY_TIMER_H_#include&lt;chrono&gt;class mytimer&#123;private: std::chrono::steady_clock::time_point _begin;//起始时间 std::chrono::steady_clock::time_point _end;//终止时间public: mytimer() &#123; _begin = std::chrono::steady_clock::time_point(); _end = std::chrono::steady_clock::time_point(); &#125; virtual ~mytimer()&#123;&#125;; //调用update时，使起始时间等于当前时间 void UpDate() &#123; _begin = std::chrono::steady_clock::now(); &#125; //调用getsecond方法时，经过的时间为当前时间减去之前统计过的起始时间。 double GetSecond() &#123; _end = std::chrono::steady_clock::now(); //使用duration类型变量进行时间的储存 duration_cast是类型转换方法 std::chrono::duration&lt;double&gt; temp = std::chrono::duration_cast&lt;std::chrono::duration&lt;double&gt;&gt;(_end - _begin); return temp.count();//count() 获取当前时间的计数数量 &#125; &#125;;#endif 2.命令头文件 CMD.h12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//枚举类型记录命令 enum cmd &#123; CMD_LOGIN,//登录 CMD_LOGINRESULT,//登录结果 CMD_LOGOUT,//登出 CMD_LOGOUTRESULT,//登出结果 CMD_NEW_USER_JOIN,//新用户登入 CMD_ERROR//错误 &#125;;//定义数据包头 struct DataHeader &#123; short cmd;//命令 short date_length;//数据的长短 &#125;;//包1 登录 传输账号与密码struct Login : public DataHeader &#123; Login()//初始化包头 &#123; this-&gt;cmd = CMD_LOGIN; this-&gt;date_length = sizeof(Login); &#125; char UserName[32];//用户名 char PassWord[32];//密码 &#125;;//包2 登录结果 传输结果struct LoginResult : public DataHeader &#123; LoginResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGINRESULT; this-&gt;date_length = sizeof(LoginResult); &#125; int Result;&#125;;//包3 登出 传输用户名 struct Logout : public DataHeader &#123; Logout()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUT; this-&gt;date_length = sizeof(Logout); &#125; char UserName[32];//用户名 &#125;;//包4 登出结果 传输结果struct LogoutResult : public DataHeader &#123; LogoutResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUTRESULT; this-&gt;date_length = sizeof(LogoutResult); &#125; int Result;&#125;;//包5 新用户登入 传输通告 struct NewUserJoin : public DataHeader &#123; NewUserJoin()//初始化包头 &#123; this-&gt;cmd = CMD_NEW_USER_JOIN; this-&gt;date_length = sizeof(NewUserJoin); &#125; char UserName[32];//用户名 &#125;; 3.服务端头文件 TcpServer.hpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655#ifndef _TcpServer_hpp_#define _TcpServer_hpp_#ifdef _WIN32 #define FD_SETSIZE 10240 #define WIN32_LEAN_AND_MEAN #include&lt;winSock2.h&gt; #include&lt;windows.h&gt; #pragma comment(lib,&quot;ws2_32.lib&quot;)//链接此动态链接库 windows特有 #else #include&lt;arpa/inet.h&gt;//selcet #include&lt;unistd.h&gt;//uni std #include&lt;string.h&gt; #define SOCKET int #define INVALID_SOCKET (SOCKET)(~0) #define SOCKET_ERROR (-1)#endif#include&quot;CMD.h&quot;//命令 #include&quot;mytimer.hpp&quot;//计时器 #include&lt;stdio.h&gt;#include&lt;vector&gt;#include&lt;thread&gt; #include&lt;mutex&gt;#include&lt;atomic&gt;//缓冲区大小 #ifndef RECV_BUFFER_SIZE #define RECV_BUFFER_SIZE 4096#endif //线程数量 #define _THREAD_COUNT 4//客户端类 class ClientSocket&#123;public: //构造 ClientSocket(SOCKET sockfd = INVALID_SOCKET) &#123; _sockfd = sockfd; //缓冲区相关 _Msg_buf = new char[RECV_BUFFER_SIZE*10]; _Len_buf = 0; &#125; //析构 virtual ~ClientSocket() &#123; delete[] _Msg_buf; &#125; //获取socket SOCKET GetSockfd() &#123; return _sockfd; &#125; //获取缓冲区 char* MsgBuf() &#123; return _Msg_buf; &#125; //获取缓冲区尾部变量 int GetLen() &#123; return _Len_buf; &#125; //设置缓冲区尾巴变量 void SetLen(int len) &#123; _Len_buf = len; &#125; private: SOCKET _sockfd; //缓冲区相关 char *_Msg_buf;//消息缓冲区 int _Len_buf;//缓冲区数据尾部变量&#125;; //事件接口class INetEvent&#123;public: //有客户端退出 virtual void OnLeave(ClientSocket* pClient) = 0;private: &#125;;//线程类class CellServer&#123;public: //构造 CellServer(SOCKET sock = INVALID_SOCKET) &#123; _sock = sock; _pThread = nullptr; _pNetEvent = nullptr; _recvCount = 0; //缓冲区相关 _Recv_buf = new char[RECV_BUFFER_SIZE]; &#125; //析构 ~CellServer() &#123; delete[] _Recv_buf; //关闭socket CloseSocket(); _sock = INVALID_SOCKET; &#125; //处理事件 void setEventObj(INetEvent* event) &#123; _pNetEvent = event; &#125; //关闭socket void CloseSocket() &#123; if(INVALID_SOCKET != _sock) &#123;#ifdef _WIN32 //关闭客户端socket for(int n=0; n&lt;_clients.size(); ++n) &#123; closesocket(_clients[n]-&gt;GetSockfd()); delete _clients[n]; &#125; //关闭socket closesocket(_sock); //清除windows socket 环境 WSACleanup(); #else //关闭客户端socket for(int n=0; n&lt;_clients.size(); ++n) &#123; close(_clients[n]-&gt;GetSockfd()); delete _clients[n]; &#125; //关闭socket/LINUX close(_sock);#endif _sock = INVALID_SOCKET; _clients.clear(); &#125; &#125; //判断是否工作中 bool IsRun() &#123; return _sock != INVALID_SOCKET; &#125; //查询是否有待处理消息 bool OnRun() &#123; while(IsRun()) &#123; //将缓冲队列中的客户数据加入正式队列 if(_clientsBuf.size() &gt; 0) &#123; std::lock_guard&lt;std::mutex&gt; lock(_mutex);//上锁 for(auto client :_clientsBuf) &#123; _clients.push_back(client); &#125; _clientsBuf.clear(); &#125; //如果没有需要处理的客户端就跳过 if(_clients.empty()) &#123; std::chrono::milliseconds t(1);//休眠一毫秒 std::this_thread::sleep_for(t); continue; &#125; fd_set fdRead;//建立集合 FD_ZERO(&amp;fdRead);//清空集合 SOCKET maxSock = _clients[0]-&gt;GetSockfd();//最大socket //把连接的客户端 放入read集合 for(int n=_clients.size()-1; n&gt;=0; --n) &#123; FD_SET(_clients[n]-&gt;GetSockfd(),&amp;fdRead); if(maxSock &lt; _clients[n]-&gt;GetSockfd()) &#123; maxSock = _clients[n]-&gt;GetSockfd(); &#125; &#125; //select函数筛选select int ret = select(maxSock+1,&amp;fdRead,0,0,0); if(ret&lt;0) &#123; printf(&quot;select任务结束\\n&quot;); CloseSocket(); return false; &#125; //遍历所有socket 查看是否有待处理事件 for(int n=0; n&lt;_clients.size(); ++n) &#123; if(FD_ISSET(_clients[n]-&gt;GetSockfd(),&amp;fdRead)) &#123; if(-1 == RecvData(_clients[n]))//处理请求 客户端退出的话 &#123; std::vector&lt;ClientSocket*&gt;::iterator iter = _clients.begin()+n;//找到退出客户端的地址 if(iter != _clients.end())//如果是合理值 &#123; if(_pNetEvent)//主线程中删除客户端 &#123; _pNetEvent-&gt;OnLeave(_clients[n]); &#125; delete _clients[n]; _clients.erase(iter);//移除 &#125; &#125; &#125; &#125; //printf(&quot;空闲时间处理其他业务\\n&quot;); &#125; &#125; //接收数据 int RecvData(ClientSocket *t_client)//处理数据 &#123; _recvCount++;//收包数量加一 //接收客户端发送的数据 int buf_len = recv(t_client-&gt;GetSockfd(), _Recv_buf, RECV_BUFFER_SIZE, 0); if(buf_len&lt;=0) &#123; printf(&quot;客户端已退出\\n&quot;); return -1; &#125; //将接收缓冲区的数据拷贝到消息缓冲区 memcpy(t_client-&gt;MsgBuf() + t_client-&gt;GetLen(), _Recv_buf, buf_len); //消息缓冲区的数据末尾后移 t_client-&gt;SetLen(t_client-&gt;GetLen() + buf_len); //判断消息缓冲区的数据长度是否大于等于包头长度 while(t_client-&gt;GetLen() &gt;= sizeof(DataHeader))//处理粘包问题 &#123; //选出包头数据 DataHeader* header = (DataHeader*)t_client-&gt;MsgBuf(); //判断消息缓冲区内数据长度是否大于等于报文长度 避免少包问题 if(t_client-&gt;GetLen() &gt;= header-&gt;date_length) &#123; //计算出消息缓冲区内剩余未处理数据的长度 int size = t_client-&gt;GetLen() - header-&gt;date_length; //响应数据 NetMsg(header,t_client-&gt;GetSockfd()); //将消息缓冲区剩余未处理的数据前移 memcpy(t_client-&gt;MsgBuf(), t_client-&gt;MsgBuf() + header-&gt;date_length, size); //消息缓冲区的数据末尾前移 t_client-&gt;SetLen(size); &#125; else &#123; //消息缓冲区数据不足 break; &#125; &#125; return 0; &#125; //响应数据 void NetMsg(DataHeader *head,SOCKET temp_socket) &#123; //printf(&quot;接收到包头，命令：%d，数据长度：%d\\n&quot;,head-&gt;cmd,head-&gt;date_length); switch(head-&gt;cmd) &#123; case CMD_LOGIN://登录 接收登录包体 &#123; Login *login = (Login*)head; /* 进行判断操作 */ //printf(&quot;%s已登录\\n密码：%s\\n&quot;,login-&gt;UserName,login-&gt;PassWord); LoginResult *result = new LoginResult; result-&gt;Result = 1; //SendData(result,temp_socket); &#125; break; case CMD_LOGOUT://登出 接收登出包体 &#123; Logout *logout = (Logout*)head; /* 进行判断操作 */ //printf(&quot;%s已登出\\n&quot;,logout-&gt;UserName); LogoutResult *result = new LogoutResult(); result-&gt;Result = 1; //SendData(result,temp_socket); &#125; break; default://错误 &#123; head-&gt;cmd = CMD_ERROR; head-&gt;date_length = 0; //SendData(head,temp_socket); &#125; break; &#125; &#125; //增加客户端 void addClient(ClientSocket* client) &#123; std::lock_guard&lt;std::mutex&gt; lock(_mutex); //_mutex.lock(); _clientsBuf.push_back(client); //_mutex.unlock(); &#125; //启动线程 void Start() &#123; _pThread = new std::thread(std::mem_fun(&amp;CellServer::OnRun),this); &#125; //获取该线程内客户端数量 int GetClientCount() &#123; return _clients.size() + _clientsBuf.size(); &#125; private: //缓冲区相关 char *_Recv_buf;//接收缓冲区 //socket相关 SOCKET _sock; //正式客户队列 std::vector&lt;ClientSocket*&gt; _clients;//储存客户端 //客户缓冲区 std::vector&lt;ClientSocket*&gt; _clientsBuf; std::mutex _mutex;//锁 //线程 std::thread* _pThread; //退出事件接口 INetEvent* _pNetEvent; public: std::atomic_int _recvCount;//接收包的数量 &#125;;//服务端类 class TcpServer : INetEvent&#123;public: //构造 TcpServer() &#123; _sock = INVALID_SOCKET; &#125; //析构 virtual ~TcpServer() &#123; //关闭socket CloseSocket(); &#125; //初始化socket 返回1为正常 int InitSocket() &#123;#ifdef _WIN32 //启动windows socket 2,x环境 WORD ver = MAKEWORD(2,2); WSADATA dat; if(0 != WSAStartup(ver,&amp;dat)) &#123; return -1;//-1为环境错误 &#125;#endif //创建socket if(INVALID_SOCKET != _sock) &#123; printf(&quot;&lt;Socket=%d&gt;关闭连接\\n&quot;,_sock); CloseSocket();//如果之前有连接 就关闭连接 &#125; _sock = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP); if(INVALID_SOCKET == _sock) &#123; return 0;//0为socket创建错误 &#125; return 1; &#125; //绑定IP/端口 int Bind(const char* ip,unsigned short port) &#123; //如果为无效套接字 则初始化 if(INVALID_SOCKET == _sock) &#123; InitSocket(); &#125; //绑定网络端口和IP地址 sockaddr_in _myaddr = &#123;&#125;; _myaddr.sin_family = AF_INET;//IPV4 _myaddr.sin_port = htons(port);//端口#ifdef _WIN32 if(ip)//ip为空则监听所有网卡 &#123; _myaddr.sin_addr.S_un.S_addr = inet_addr(ip);//IP &#125; else &#123; _myaddr.sin_addr.S_un.S_addr = INADDR_ANY;//IP &#125;#else if(ip)//ip为空则监听所有网卡 &#123; _myaddr.sin_addr.s_addr = inet_addr(ip);//IP &#125; else &#123; _myaddr.sin_addr.s_addr = INADDR_ANY;//IP &#125;#endif if(SOCKET_ERROR == bind(_sock,(sockaddr*)&amp;_myaddr,sizeof(sockaddr_in)))//socket (强制转换)sockaddr结构体 结构体大小 &#123; printf(&quot;绑定失败\\n&quot;); return 0; &#125; else &#123; printf(&quot;绑定成功\\n绑定端口为%d\\n&quot;,port); return 1; &#125; &#125; //监听端口 int Listen(int n) &#123; //如果为无效套接字 则提示 if(INVALID_SOCKET == _sock) &#123; printf(&quot;请先初始化套接字并绑定IP端口\\n&quot;); return 0; &#125; //监听网络端口 if(SOCKET_ERROR == listen(_sock,n))//最大连接队列 &#123; printf(&quot;监听失败\\n&quot;); return 0; &#125; else &#123; printf(&quot;监听成功\\n&quot;); return 1; &#125; &#125; //接受连接 int Accept() &#123; //等待接收客户端连接 sockaddr_in clientAddr = &#123;&#125;;//新建sockadd结构体接收客户端数据 int addr_len = sizeof(sockaddr_in);//获取sockadd结构体长度 SOCKET temp_socket = INVALID_SOCKET;//声明客户端套接字 #ifdef _WIN32 temp_socket = accept(_sock,(sockaddr*)&amp;clientAddr,&amp;addr_len);//自身套接字 客户端结构体 结构体大小 #else temp_socket = accept(_sock,(sockaddr*)&amp;clientAddr,(socklen_t*)&amp;addr_len);//自身套接字 客户端结构体 结构体大小 #endif if(INVALID_SOCKET == temp_socket)//接收失败 &#123; printf(&quot;&lt;Socket=%d&gt;错误,接受到无效客户端SOCKET\\n&quot;,temp_socket); return 0; &#125; else &#123; //printf(&quot;新客户端加入 count: %d\\nIP地址为：%s \\n&quot;, _clients.size(), inet_ntoa(clientAddr.sin_addr)); //群发所有客户端 通知新用户登录 //NewUserJoin *user_join = new NewUserJoin(); //strcpy(user_join-&gt;UserName,inet_ntoa(clientAddr.sin_addr)); //SendDataToAll(user_join); //将新的客户端加入动态数组 AddClientToServer(new ClientSocket(temp_socket)); return 1; &#125; &#125; //添加客户端至服务端 void AddClientToServer(ClientSocket* pClient) &#123; _clients.push_back(pClient); //找出客户端最少的线程 然后加入 auto pMinServer = _cellServers[0]; for(auto pCellServer : _cellServers) &#123; if(pMinServer-&gt;GetClientCount() &gt; pCellServer-&gt;GetClientCount()) &#123; pMinServer = pCellServer; &#125; &#125; pMinServer-&gt;addClient(pClient); &#125; //线程启动 void Start() &#123; for(int n=0; n&lt;_THREAD_COUNT; n++) &#123; //线程加入容器 auto ser = new CellServer(_sock); _cellServers.push_back(ser); ser-&gt;setEventObj(this); ser-&gt;Start(); &#125; &#125; //关闭socket void CloseSocket() &#123; if(INVALID_SOCKET != _sock) &#123;#ifdef _WIN32 //关闭客户端socket for(int n=0; n&lt;_clients.size(); ++n) &#123; closesocket(_clients[n]-&gt;GetSockfd()); delete _clients[n]; &#125; //关闭socket closesocket(_sock); //清除windows socket 环境 WSACleanup(); #else //关闭客户端socket for(int n=0; n&lt;_clients.size(); ++n) &#123; close(_clients[n]-&gt;GetSockfd()); delete _clients[n]; &#125; //关闭socket/LINUX close(_sock);#endif _sock = INVALID_SOCKET; _clients.clear(); &#125; &#125; //判断是否工作中 bool IsRun() &#123; return _sock != INVALID_SOCKET; &#125; //查询是否有待处理消息 bool OnRun() &#123; if(IsRun()) &#123; time4msg();//查看各线程数据信息 fd_set fdRead;//建立集合 //fd_set fdWrite; //fd_set fdExcept; FD_ZERO(&amp;fdRead);//清空集合 //FD_ZERO(&amp;fdWrite); //FD_ZERO(&amp;fdExcept); FD_SET(_sock,&amp;fdRead);//放入集合 //FD_SET(_sock,&amp;fdWrite); //FD_SET(_sock,&amp;fdExcept); timeval s_t = &#123;0,0&#125;;//select最大响应时间 //select函数筛选select int ret = select(_sock+1,&amp;fdRead,0,0,&amp;s_t); if(ret&lt;0) &#123; printf(&quot;select任务结束\\n&quot;); CloseSocket(); return false; &#125; if(FD_ISSET(_sock,&amp;fdRead))//获取是否有新socket连接 &#123; FD_CLR(_sock,&amp;fdRead);//清理 Accept();//连接 &#125; return true; &#125; return false; &#125; //显示各线程数据信息 void time4msg() &#123; auto t1 = _time.GetSecond(); if(1.0 &lt;= t1) &#123; int recvCount = 0; for(auto ser: _cellServers) &#123; recvCount += ser-&gt;_recvCount; ser-&gt;_recvCount = 0; &#125; //时间间隔 本机socket连接序号 客户端数量 每秒收包数 printf(&quot;time&lt;%lf&gt;,socket&lt;%d&gt;,clients&lt;%d&gt;,recvCount&lt;%d&gt;\\n&quot;, t1, _sock, _clients.size(),(int)(recvCount/t1)); _time.UpDate(); &#125; &#125; //发送数据 int SendData(DataHeader *head,SOCKET temp_socket) &#123; if(IsRun() &amp;&amp; head) &#123; send(temp_socket,(const char*)head,head-&gt;date_length,0); return 1; &#125; return 0; &#125; //向所有人发送数据 void SendDataToAll(DataHeader *head) &#123; for(int n=0;n&lt;_clients.size();++n) &#123; SendData(head, _clients[n]-&gt;GetSockfd()); &#125; &#125; //客户端退出 void OnLeave(ClientSocket* pClient) &#123; //找到退出的客户端 for(int n=0; n&lt;_clients.size(); n++) &#123; if(_clients[n] == pClient) &#123; auto iter = _clients.begin() + n; if(iter != _clients.end()) &#123; _clients.erase(iter);//移除 &#125; &#125; &#125; &#125; private: //socket相关 SOCKET _sock; std::vector&lt;ClientSocket*&gt; _clients;//储存客户端 std::vector&lt;CellServer*&gt; _cellServers;//线程处理 //计时器 mytimer _time; &#125;;#endif 4.服务端样例代码 server.cpp1234567891011121314151617181920212223242526272829#include&quot;TcpServer.hpp&quot; int main() &#123; printf(&quot;Welcome\\n&quot;); //建立tcp对象 TcpServer *tcp1 = new TcpServer(); //建立一个socket tcp1-&gt;InitSocket(); //绑定端口和IP tcp1-&gt;Bind(NULL,8888); //监听 tcp1-&gt;Listen(5); //线程启动 tcp1-&gt;Start(); //循环 while(tcp1-&gt;IsRun()) &#123; tcp1-&gt;OnRun(); &#125; //关闭 tcp1-&gt;CloseSocket(); printf(&quot;任务结束，程序已退出&quot;); getchar(); return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"网络编程","slug":"网络编程","permalink":"https://zgg2001.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"C++学习记录：基于chrono库的高精度计时器","slug":"20210205_C++学习记录：基于chrono库的高精度计时器","date":"2021-02-05T11:25:08.000Z","updated":"2021-02-05T11:25:08.000Z","comments":true,"path":"2021/02/05/20210205_C++学习记录：基于chrono库的高精度计时器/","permalink":"https://zgg2001.github.io/2021/02/05/20210205_C++%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E5%9F%BA%E4%BA%8Echrono%E5%BA%93%E7%9A%84%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%AE%A1%E6%97%B6%E5%99%A8/","excerpt":"&emsp;&emsp;C++11中新引入了std::chrono库，由此可以较为容易的实现一个计时器。同时，休眠操作也可以通过这个库来实现，从而使代码有良好的跨平台性，避免使用Windows&#x2F;Linux的系统休眠函数。&emsp;&emsp;在接下来的网络编程学习中，将引入该计时器，实现对每秒收包、连接等数据的计数显示。&emsp;&emsp;本篇学习记录使用的语言为C++，调用的库为C++11里的std::chrono库。","text":"&emsp;&emsp;C++11中新引入了std::chrono库，由此可以较为容易的实现一个计时器。同时，休眠操作也可以通过这个库来实现，从而使代码有良好的跨平台性，避免使用Windows&#x2F;Linux的系统休眠函数。&emsp;&emsp;在接下来的网络编程学习中，将引入该计时器，实现对每秒收包、连接等数据的计数显示。&emsp;&emsp;本篇学习记录使用的语言为C++，调用的库为C++11里的std::chrono库。 一、简易的计时器类mytimer.hpp代码如下： 123456789101112131415161718192021222324252627282930313233343536#ifndef MY_TIMER_H_#define MY_TIMER_H_#include&lt;chrono&gt;class mytimer&#123;private: std::chrono::steady_clock::time_point _begin;//起始时间 std::chrono::steady_clock::time_point _end;//终止时间public: mytimer() &#123; _begin = std::chrono::steady_clock::time_point(); _end = std::chrono::steady_clock::time_point(); &#125; virtual ~mytimer()&#123;&#125;; //调用update时，使起始时间等于当前时间 void UpDate() &#123; _begin = std::chrono::steady_clock::now(); &#125; //调用getsecond方法时，经过的时间为当前时间减去之前统计过的起始时间。 double GetSecond() &#123; _end = std::chrono::steady_clock::now(); //使用duration类型变量进行时间的储存 duration_cast是类型转换方法 std::chrono::duration&lt;double&gt; temp = std::chrono::duration_cast&lt;std::chrono::duration&lt;double&gt;&gt;(_end - _begin); return temp.count();//count() 获取当前时间的计数数量 &#125;&#125;;#endif 测试该计时器的代码示例 main.cpp 代码如下： 1234567891011121314#include&quot;mytimer.hpp&quot;#include&lt;iostream&gt;int main()&#123; mytimer _time; _time.UpDate(); for(int n=0;n&lt;100000000;n++) &#123; &#125; std::cout&lt;&lt;_time.GetSecond(); return 0;&#125; 二、基于chrono库的休眠使用方法如下： 12std::chrono::milliseconds t(1);//休眠一毫秒 std::this_thread::sleep_for(t);","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"C++标准库学习","slug":"C-标准库学习","permalink":"https://zgg2001.github.io/tags/C-%E6%A0%87%E5%87%86%E5%BA%93%E5%AD%A6%E4%B9%A0/"}]},{"title":"C++学习记录：多线程相关","slug":"20210131_C++学习记录：多线程相关","date":"2021-01-31T06:08:47.000Z","updated":"2021-01-31T06:08:47.000Z","comments":true,"path":"2021/01/31/20210131_C++学习记录：多线程相关/","permalink":"https://zgg2001.github.io/2021/01/31/20210131_C++%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/","excerpt":"&emsp;&emsp;之前学过一点C语言多线程方面的内容(pthread.h)，但是仅仅是会用，对多线程的实现原理什么的基本上算是不了解。接下来，我的网络编程学习要进一步对代码进行优化，其中肯定少不了对多线程的运用，所以在进行下一步之前，先系统的学习一下多线程。&emsp;&emsp;本篇学习记录使用的语言为C++，调用的线程库为C++11里的std::thread库。","text":"&emsp;&emsp;之前学过一点C语言多线程方面的内容(pthread.h)，但是仅仅是会用，对多线程的实现原理什么的基本上算是不了解。接下来，我的网络编程学习要进一步对代码进行优化，其中肯定少不了对多线程的运用，所以在进行下一步之前，先系统的学习一下多线程。&emsp;&emsp;本篇学习记录使用的语言为C++，调用的线程库为C++11里的std::thread库。 零、基本概念&emsp;&emsp;一个进程可以有多个线程，而一个线程只能属于一个进程。 &emsp;&emsp;单核CPU的多线程执行为每条线程代码执行一段时间后进行切换，实际还是为同时进行一条线程，因为切换的速度很快，给人一种同时进行的错觉；而多核CPU的多线程执行为同时进行多条线程，当线程数量大于核数量时，也会进行线程的切换，保证线程的进行。 &emsp;&emsp;多线程的执行是抢占式的，即多条线程下，没有运行顺序的规律， 一、基本线程创建 thread如下所示，新建一个thread对象，构造函数传参第一个为线程执行函数，随后为执行函数的传参。 123456789101112#include&lt;thread&gt;using namespace std;thread *t1 = new thread(work,1111); void work(int a)&#123; for(int n=0;n&lt;a;n++) &#123; printf(&quot;%d\\n&quot;,a); &#125; &#125; 如下所示，新建一个thread数组，构造函数传参第一个为线程执行函数，随后为执行函数的传参。 12345678910111213141516#include&lt;thread&gt;using namespace std;thread *t[4];for(int n=0;n&lt;4;n++)&#123; t[n] = new thread(work,n);&#125;void work(int a)&#123; for(int n=0;n&lt;a;n++) &#123; printf(&quot;%d\\n&quot;,a); &#125; &#125; 二、等待&#x2F;分离 join/detach&emsp;&emsp;join是在main函数中等待线程执行完才继续执行main函数，detach则是把该线程分离出来，不管这个线程执行得怎样，往下继续执行main函数。 join操作会等待线程执行完毕，然后回收该线程资源；detach操作则不会等待线程完成，线程资源的回收由init进程完成。 12345678910#include&lt;thread&gt;using namespace std;thread *t[4];for(int n=0;n&lt;4;n++)&#123; t[n] = new thread(work,n); t[n]-&gt;detach();//线程分离 t[n]-&gt;join();//线程不分离&#125; 三、锁 lock/unlock&emsp;&emsp;由于线程的执行是抢占式的，且变量资源等是共享的，对于多条线程同时执行的情况下，可能对同一段内容同时执行，其中涉及到的变量操作等就会产生错误。类似同时对一个变量进行运算操作，由于赋值前的值不同，结果也就不同，导致数据出现问题。此时就可以使用锁的操作防止此类错误发生。 上锁的区域同时只能被一条线程执行，由此来解决同时执行造成错误的问题。123456789101112131415#include&lt;mutex&gt;//锁的头文件#include&lt;thread&gt;using namespace std;mutex m;//锁的变量void work(int a)&#123; for(int n=0;n&lt;4;n++) &#123; m.lock();//临界区域 开始 锁掉相关区域 避免同时调用printf操作导致打印混乱 printf(&quot;%d\\n&quot;,a); m.unlock();//临界区域 结束 解锁 &#125;&#125; &emsp;&emsp;但是不停的上锁和解锁很容易忘记解锁，就会出现该段代码无法被执行，导致程序出现问题，且不会报错。为了避免这种情况，我们可以使用自解锁。自解锁会自动对所处区间的代码进行上锁和解锁操作，从而防止忘解锁的情况发生。 自解锁的大致原理其实就是构造器进行上锁，析构器进行解锁…1234567891011121314#include&lt;mutex&gt;//锁的头文件#include&lt;thread&gt;using namespace std;mutex m;//锁的变量void work(int a)&#123; for(int n=0;n&lt;4;n++) &#123; lock_guard&lt;mutex&gt;lock1(m); //自解锁 printf(&quot;%d\\n&quot;,a); &#125;&#125; 四、原子操作 atomic&emsp;&emsp;频繁的上锁解锁操作会非常耗时，如果上锁区域执行的代码很少的话会非常不划算。如果我们在多线程中需要对变量操作的话，频繁的给变量操作区域上下锁性价比很低，此时我们可以使用原子变量。 原子变量同时只能被一条线程操作，相比读写锁，速度快了不止一个量级。123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;thread&gt;#include&lt;atomic&gt;//原子操作using namespace std;atomic_int count(0); //原子变量void work(int a)&#123; for(int n=0;n&lt;2;n++) &#123; printf(&quot;other thread:%d\\n&quot;,a); count++; &#125;&#125;int main()&#123; thread *t[4]; for(int n=0;n&lt;4;n++) &#123; t[n] = new thread(work,n); t[n]-&gt;join(); &#125; for(int n=0;n&lt;2;n++) &#123; printf(&quot;main thread\\n&quot;); count++; &#125; while(1) &#123; cout&lt;&lt;count; getchar(); &#125; return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"C++标准库学习","slug":"C-标准库学习","permalink":"https://zgg2001.github.io/tags/C-%E6%A0%87%E5%87%86%E5%BA%93%E5%AD%A6%E4%B9%A0/"}]},{"title":"KeepAlive小项目 基于Qt/C++实现后台自动提醒休息","slug":"20210129_KeepAlive小项目基于Qt-C++实现后台自动提醒休息","date":"2021-01-29T14:29:05.000Z","updated":"2021-01-29T14:29:05.000Z","comments":true,"path":"2021/01/29/20210129_KeepAlive小项目基于Qt-C++实现后台自动提醒休息/","permalink":"https://zgg2001.github.io/2021/01/29/20210129_KeepAlive%E5%B0%8F%E9%A1%B9%E7%9B%AE%E5%9F%BA%E4%BA%8EQt-C++%E5%AE%9E%E7%8E%B0%E5%90%8E%E5%8F%B0%E8%87%AA%E5%8A%A8%E6%8F%90%E9%86%92%E4%BC%91%E6%81%AF/","excerpt":"&emsp;&emsp;前两天在blink上发的思路，花了一天时间给实现了 。不得不说，好久没写Qt程序，手生了不少，要不应该可以更有效率的。 一、功能主要实现以下功能： 显示当前系统时间 给定一个定期提醒时间间隔，显示离提醒还有多久 显示程序运行以来经过的时间 可最小化到托盘，实现后台运行 当达到提醒时间间隔后，弹窗提醒","text":"&emsp;&emsp;前两天在blink上发的思路，花了一天时间给实现了 。不得不说，好久没写Qt程序，手生了不少，要不应该可以更有效率的。 一、功能主要实现以下功能： 显示当前系统时间 给定一个定期提醒时间间隔，显示离提醒还有多久 显示程序运行以来经过的时间 可最小化到托盘，实现后台运行 当达到提醒时间间隔后，弹窗提醒 辅助功能： 可手动输入，调整时间间隔 可自动创建桌面快捷方式 关于 二、详细介绍程序主界面（下图），可见有三个菜单按钮 在点击程序右上角退出键后，程序会进入托盘最小化，在后台运行。（如下图）同时会弹出通知。 此时左键单击托盘图标，弹出提示提醒时间。 左键双击，即可显示主窗口。 鼠标右键单击，显示菜单，可令程序退出。 第一个菜单点开后分别为：创建快捷方式、设置相关参数、退出。 创建快捷方式 点击后弹窗，点击确定后随即在桌面建立快捷方式。（如下图） 设置相关参数 点击后弹窗，可以修改时间间隔参数，范围为1~86400秒。（如下图）输入不正确值后会进行提醒。（如下图）当输入正确值后，计时会重置。 退出，点击退出后，程序彻底退出，不会进入托盘最小化。 第三个菜单内容为显示切换，点击后即可进行切换操作 当前系统时间 提醒时间倒计时 系统(软件)开启时间 当倒计时为0时，显示窗口进行提醒。 三、源码下载点我下载 四、可执行文件下载点我下载 密码：6eo1","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"QT","slug":"QT","permalink":"https://zgg2001.github.io/tags/QT/"}]},{"title":"C++网络编程学习：缓冲区溢出与粘包分包","slug":"20210128_C++网络编程学习：缓冲区溢出与粘包分包","date":"2021-01-28T03:53:13.000Z","updated":"2021-01-28T03:53:13.000Z","comments":true,"path":"2021/01/28/20210128_C++网络编程学习：缓冲区溢出与粘包分包/","permalink":"https://zgg2001.github.io/2021/01/28/20210128_C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E4%B8%8E%E7%B2%98%E5%8C%85%E5%88%86%E5%8C%85/","excerpt":"使用的语言为C&#x2F;C++ 源码支持的平台为：Windows &#x2F; Linux 一、关于缓冲区溢出1.缓冲区溢出的原因&emsp;&emsp;之前我们所编写的服务端与客户端的数据量都是很小的，且操作也不频繁，需要键入指令发送报文。 &emsp;&emsp;我们可以尝试在之前客户端代码的循环里，不断发送一种数据包，且把数据包的大小加大到1000字节，会发现很快服务端和客户端就会出现问题——要么是数据接收出现问题，要么是服务端或者客户端程序直接卡掉。这里出现问题的原因就是socket内核缓冲区溢出。","text":"使用的语言为C&#x2F;C++ 源码支持的平台为：Windows &#x2F; Linux 一、关于缓冲区溢出1.缓冲区溢出的原因&emsp;&emsp;之前我们所编写的服务端与客户端的数据量都是很小的，且操作也不频繁，需要键入指令发送报文。 &emsp;&emsp;我们可以尝试在之前客户端代码的循环里，不断发送一种数据包，且把数据包的大小加大到1000字节，会发现很快服务端和客户端就会出现问题——要么是数据接收出现问题，要么是服务端或者客户端程序直接卡掉。这里出现问题的原因就是socket内核缓冲区溢出。 &emsp;&emsp;首先，send和recv函数并不是直接通过网卡操作。在使用send函数时，send函数首先把数据写入到发送缓冲区，随后通过网卡发出；在使用recv函数时，网卡首先把接收到的消息写入接收缓冲区，recv函数再从中copy数据。注意，上文中的两个缓冲区是存在于内核中的，并不是程序中自定义的缓冲区。 &emsp;&emsp;我们在之前的源码中，recv的逻辑是先接收包头，随后根据包头接收包体。而当网卡接收数据太多时，我们接收一个包头的时间，网卡可能就新接收了两个完整的数据包，这就导致内核接收缓冲区里的数据量是在不断增加的，最终导致接收缓冲区溢出，造成无法正常发送以及程序阻塞的问题。 &emsp;&emsp;举个例子，缓冲区就像一个浴缸，而我们是一个拿盆子舀水的人。我们之前先接收一个包头就相当于舀出一个包头那么多的水，随后再舀出包体那么多的水。舀了两次仅仅舀出一个报文那么多的水。如果浴缸放水的速度比较大的话，我们很容易就会处理不过来。最终造成浴缸溢出(缓冲区溢出)。 2.缓冲区溢出的处理方法&emsp;&emsp;接着看上文的例子，我们怎么能阻止浴缸(缓冲区)溢出呢？首先我们不大可能改变浴缸的大小，因为太过麻烦以及治标不治本，只要浴缸放水的时间够长，总会溢出。接着，舀水的速度我们也不好改变，因为一时半会是改不了的。那我们就只能改变舀水的次数和数量了。 &emsp;&emsp;如何改变舀水的数量和次数？我们可以一次舀出足够多的水，随后再从舀出的水中分出想要数量的水，这样浴缸溢出的可能性就大大减少了。 &emsp;&emsp;从代码层面来看上面的思路，只要我们程序内新建一个足够大的缓冲区，一次从内核缓冲区上recv足够的数据，就可以避免内核缓冲区溢出了。 大概思路如下：123456789101112131415char _Recv_buf[4096];int DataRecv&#123; //接收客户端发送的数据 int recv_len = recv(socket, _Recv_buf, 4096, 0); if(recv_len &lt;= 0) &#123; return -1; &#125; while(_Recv_buf内不为空) &#123; 处理_Recv_buf内的数据 &#125; return 0;&#125; &emsp;&emsp;但是这样会出现新的问题，即粘包与分包问题，请看下文。 二、粘包与分包1.粘包与分包的原因&emsp;&emsp;上文中处理缓冲区溢出的思路是没有问题的，但是上文中的源码写法会存在问题。 &emsp;&emsp;我们一次接收那么多数据，其中数据的界限是没有限定的，比如上文中是想要一次接收4096个字节。假如缓冲区内有5个1000字节大小的数据包，我们这次接收4096字节，等于说接收的数据中有4.096个数据包，其中就包含了新的问题。 &emsp;&emsp;首先是粘包问题。即一次接收中含有多个数据包，这就导致数据包界限不清，粘在了一起。像上文中的4.096个包，接收端是不清楚的，接收端只知道有4096字节的数据，但是它不知道一个包是多大。所以我们可以通过包头来获取一个数据包的大小，由此来处理相应大小的数据以解决粘包问题。 &emsp;&emsp;接着是分包问题。即一次接收中含有不完整的包。例如上文中的4096个字节，其中包含了4个完整的包，和一个包的前96个字节。对此，我们只能处理前4个完整的数据包。那么问题来了，对于上文中的缓冲区，由于recv函数每次都会覆盖这个缓冲区，这就导致缓冲区内无法存放未处理的消息。对于这个问题，我们可以新建一个缓冲区，来存放未处理的消息，实现双缓冲，即可处理分包问题。 TCP是面向数据流的协议，所以会出现粘包分包问题；UDP是面向消息的协议，每一个数据段都是一条消息，所以不会出现粘包分包问题。 2.粘包与分包的处理方法2.1客户端升级思路&emsp;&emsp;首先是新建两个缓冲区，一个用来存放recv到的数据，一个用来存放所有待处理数据。首先第一个缓冲区recv到数据，随后把第一个缓冲区内的数据copy到第二个缓冲区内，即可实现数据的存放。随后处理数据之类的还是先获取包头，随后根据包头处理包体数据。 大致思路如下： 123456789101112131415161718192021222324//接收数据char 接收缓冲区[4096]char 消息缓冲区[40960];int RecvData(SOCKET temp_socket)//处理数据 &#123; //接收客户端发送的数据 int recv_len = recv(temp_socket, 接收缓冲区, 4096, 0); if(recv_len &lt;= 0) &#123; printf(&quot;与服务器断开连接,任务结束\\n&quot;); return -1; &#125; 1.将接收缓冲区的数据拷贝到消息缓冲区 while(2.判断消息缓冲区的数据长度是否大于等于包头长度) &#123; 3.选出包头数据 //解决粘包问题 if(4.判断消息缓冲区内数据长度是否大于等于报文长度) //解决少包问题 &#123; 5.响应数据 6.将处理过的消息移出消息缓冲区 &#125; &#125; return 0; &#125; 2.2服务端升级思路&emsp;&emsp;与客户端整头思路相似，但是需要注意，服务端有多个连接，如果多个连接共用一个缓冲区会存在错误，所以每一个客户端连接都需要有自己的缓冲区。对此，我们可以新建一个客户端连接类，来存放每一个客户端的socket以及它的缓冲区。 大致思路如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class 客户端连接&#123;public: 1.获取socket() 2.获取缓冲区() 3.获取缓冲区长度() 4.设置缓冲区长度()private: 1.socket 2.缓冲区&#125;; std::vector&lt;客户端连接*&gt; _clients;//储存客户端socketchar 接收缓冲区[4096];0.此时前面OnRun函数里的判断过程也需要改变//遍历所有socket 查看是否有待处理事件 for(int n=0; n&lt;_clients.size(); ++n)&#123; if(FD_ISSET(_clients[n]-&gt;获取socket(),&amp;fdRead)) &#123; if(-1 == RecvData(_clients[n]))//处理请求 客户端退出的话 &#123; std::vector&lt;客户端连接*&gt;::iterator iter = _clients.begin()+n;//找到退出客户端的地址 if(iter != _clients.end())//如果是合理值 &#123; delete _clients[n]; _clients.erase(iter);//移除 &#125; &#125; &#125;&#125;int RecvData(客户端连接* client)//处理数据 &#123; //接收客户端发送的数据 int recv_len = recv(client-&gt;获取socket(), 接收缓冲区, 4096, 0); if(recv_len &lt;= 0) &#123; printf(&quot;与服务器断开连接,任务结束\\n&quot;); return -1; &#125; 1.将接收缓冲区的数据拷贝到传入对象的消息缓冲区 client-&gt;获取缓冲区(); while(2.判断消息缓冲区的数据长度是否大于等于包头长度) client-&gt;获取缓冲区长度(); &#123; 3.选出包头数据 //解决粘包问题 if(4.判断消息缓冲区内数据长度是否大于等于报文长度) //解决少包问题 &#123; 5.响应数据 6.将处理过的消息移出消息缓冲区 client-&gt;设置缓冲区长度(); &#125; &#125; return 0; &#125; 三、升级后的源码及其详细注释1.客户端源码 TcpClient.hpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321#ifndef _TcpClient_hpp_#define _TcpClient_hpp_#ifdef _WIN32 #define WIN32_LEAN_AND_MEAN #include&lt;winSock2.h&gt; #include&lt;windows.h&gt; #pragma comment(lib,&quot;ws2_32.lib&quot;) #else #include&lt;arpa/inet.h&gt; #include&lt;unistd.h&gt; #include&lt;string.h&gt; #define SOCKET int #define INVALID_SOCKET (SOCKET)(~0) #define SOCKET_ERROR (-1)#endif//枚举类型记录命令 enum cmd &#123; CMD_LOGIN,//登录 CMD_LOGINRESULT,//登录结果 CMD_LOGOUT,//登出 CMD_LOGOUTRESULT,//登出结果 CMD_NEW_USER_JOIN,//新用户登入 CMD_ERROR//错误 &#125;;//定义数据包头 struct DataHeader &#123; short cmd;//命令 short date_length;//数据的长短 &#125;;//包1 登录 传输账号与密码struct Login : public DataHeader &#123; Login()//初始化包头 &#123; this-&gt;cmd = CMD_LOGIN; this-&gt;date_length = sizeof(Login); &#125; char UserName[32];//用户名 char PassWord[32];//密码 char data[932];&#125;;//包2 登录结果 传输结果struct LoginResult : public DataHeader &#123; LoginResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGINRESULT; this-&gt;date_length = sizeof(LoginResult); &#125; int Result; char Data[992];//无意义数据 &#125;;//包3 登出 传输用户名 struct Logout : public DataHeader &#123; Logout()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUT; this-&gt;date_length = sizeof(Logout); &#125; char UserName[32];//用户名 char data[964];&#125;;//包4 登出结果 传输结果struct LogoutResult : public DataHeader &#123; LogoutResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUTRESULT; this-&gt;date_length = sizeof(LogoutResult); &#125; int Result; char data[992];&#125;;//包5 新用户登入 传输通告 struct NewUserJoin : public DataHeader &#123; NewUserJoin()//初始化包头 &#123; this-&gt;cmd = CMD_NEW_USER_JOIN; this-&gt;date_length = sizeof(NewUserJoin); &#125; char UserName[32];//用户名 &#125;;#include&lt;bits/stdc++.h&gt;#define RECV_BUFFER_SIZE 4096class TcpClient&#123;public: //构造 TcpClient() &#123; _sock = INVALID_SOCKET; //缓冲区相关 _Recv_buf = new char[RECV_BUFFER_SIZE]; _Msg_buf = new char[RECV_BUFFER_SIZE*10]; _Len_buf = 0; &#125; //析构 virtual ~TcpClient() &#123; delete[] _Recv_buf; delete[] _Msg_buf; //关闭socket CloseSocket(); &#125; //初始化socket 返回1为正常 int InitSocket() &#123;#ifdef _WIN32 //启动windows socket 2,x环境 WORD ver = MAKEWORD(2,2); WSADATA dat; if(0 != WSAStartup(ver,&amp;dat)) &#123; return -1;//-1为环境错误 &#125;#endif //创建socket if(INVALID_SOCKET != _sock) &#123; printf(&quot;&lt;Socket=%d&gt;关闭连接\\n&quot;,_sock); CloseSocket();//如果之前有连接 就关闭连接 &#125; _sock = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP); if(INVALID_SOCKET == _sock) &#123; return 0;//0为socket创建错误 &#125; return 1; &#125; //连接服务器 返回1为成功 int Connect(const char *ip,unsigned short port) &#123; //如果为无效套接字 则初始化 if(INVALID_SOCKET == _sock) &#123; InitSocket(); &#125; //连接服务器 sockaddr_in _sin = &#123;&#125;; _sin.sin_family = AF_INET;//IPV4 _sin.sin_port = htons(port);//端口号 #ifdef _WIN32 _sin.sin_addr.S_un.S_addr = inet_addr(ip);//IP #else _sin.sin_addr.s_addr = inet_addr(ip);//IP #endif if(SOCKET_ERROR == connect(_sock,(sockaddr*)&amp;_sin,sizeof(sockaddr_in))) &#123; return 0;//连接失败 &#125; else &#123; return 1;//连接成功 &#125; &#125; //关闭socket void CloseSocket() &#123; if(INVALID_SOCKET != _sock) &#123;#ifdef _WIN32 //关闭socket closesocket(_sock); //清除windows socket 环境 WSACleanup(); #else //关闭socket/LINUX close(_sock);#endif _sock = INVALID_SOCKET; &#125; &#125; //查询是否有待处理消息 bool OnRun() &#123; if(IsRun())//如果有连接则监听事件 &#123; fd_set _fdRead;//建立集合 FD_ZERO(&amp;_fdRead);//清空集合 FD_SET(_sock,&amp;_fdRead);//放入集合 timeval _t = &#123;1,0&#125;;//select最大响应时间 //新建seclect int _ret = select(_sock+1,&amp;_fdRead,NULL,NULL,&amp;_t); if(_ret&lt;0) &#123; printf(&quot;seclect任务结束\\n&quot;); return false; &#125; if(FD_ISSET(_sock,&amp;_fdRead))//获取是否有可读socket &#123; FD_CLR(_sock,&amp;_fdRead);//清理计数器 if(-1 == RecvData(_sock)) &#123; CloseSocket(); return false; &#125; &#125; return true; &#125; return false; &#125; //判断是否工作中 bool IsRun() &#123; return _sock != INVALID_SOCKET; &#125; //发送数据 int SendData(DataHeader *_head) &#123; if(IsRun() &amp;&amp; _head) &#123; send(_sock,(const char*)_head,_head-&gt;date_length,0); return 1; &#125; return 0; &#125; //接收数据 int RecvData(SOCKET temp_socket)//处理数据 &#123; //接收客户端发送的数据 int recv_len = recv(temp_socket, _Recv_buf, RECV_BUFFER_SIZE, 0); if(recv_len &lt;= 0) &#123; printf(&quot;与服务器断开连接,任务结束\\n&quot;); return -1; &#125; //将接收缓冲区的数据拷贝到消息缓冲区 memcpy(_Msg_buf+_Len_buf, _Recv_buf, recv_len); //消息缓冲区的数据末尾后移 _Len_buf += recv_len; //判断消息缓冲区的数据长度是否大于等于包头长度 while(_Len_buf &gt;= sizeof(DataHeader))//处理粘包问题 &#123; //选出包头数据 DataHeader* header = (DataHeader*)_Msg_buf; //判断消息缓冲区内数据长度是否大于等于报文长度 避免少包问题 if(_Len_buf &gt;= header-&gt;date_length) &#123; //计算出消息缓冲区内剩余未处理数据的长度 int size = _Len_buf - header-&gt;date_length; //响应数据 NetMsg(header); //将消息缓冲区剩余未处理的数据前移 memcpy(_Msg_buf, _Msg_buf + header-&gt;date_length, size); //消息缓冲区的数据末尾前移 _Len_buf = size; &#125; else &#123; //消息缓冲区数据不足 break; &#125; &#125; return 0; &#125; //响应数据 virtual void NetMsg(DataHeader *_head) &#123; printf(&quot;接收到包头，命令：%d，数据长度：%d\\n&quot;,_head-&gt;cmd,_head-&gt;date_length); switch(_head-&gt;cmd) &#123; case CMD_LOGINRESULT://登录结果 接收登录包体 &#123; LoginResult *_result = (LoginResult*)_head; printf(&quot;登录结果:%d\\n&quot;,_result-&gt;Result); &#125; break; case CMD_LOGOUTRESULT://登出结果 接收登出包体 &#123; LogoutResult *_result = (LogoutResult*)_head; printf(&quot;登录结果:%d\\n&quot;,_result-&gt;Result); &#125; break; case CMD_NEW_USER_JOIN://新用户登录通知 &#123; NewUserJoin *_result = (NewUserJoin*)_head; printf(&quot;用户:%s已登录\\n&quot;,_result-&gt;UserName); &#125; break; case CMD_ERROR://错误 &#123; printf(&quot;错误数据\\n&quot;); getchar(); &#125; break; default: &#123; printf(&quot;未知数据\\n&quot;); getchar(); &#125; break; &#125; &#125; private: SOCKET _sock; //缓冲区相关 char *_Recv_buf;//接收缓冲区 char *_Msg_buf;//消息缓冲区 int _Len_buf;//缓冲区数据尾部变量 &#125;;#endif 2.服务端源码 TcpServer.hpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487#ifndef _TcpServer_hpp_#define _TcpServer_hpp_#ifdef _WIN32 #define WIN32_LEAN_AND_MEAN #include&lt;winSock2.h&gt; #include&lt;windows.h&gt; #pragma comment(lib,&quot;ws2_32.lib&quot;)//链接此动态链接库 windows特有 #else #include&lt;arpa/inet.h&gt;//selcet #include&lt;unistd.h&gt;//uni std #include&lt;string.h&gt; #define SOCKET int #define INVALID_SOCKET (SOCKET)(~0) #define SOCKET_ERROR (-1)#endif//枚举类型记录命令 enum cmd &#123; CMD_LOGIN,//登录 CMD_LOGINRESULT,//登录结果 CMD_LOGOUT,//登出 CMD_LOGOUTRESULT,//登出结果 CMD_NEW_USER_JOIN,//新用户登入 CMD_ERROR//错误 &#125;;//定义数据包头 struct DataHeader &#123; short cmd;//命令 short date_length;//数据的长短 &#125;;//包1 登录 传输账号与密码struct Login : public DataHeader &#123; Login()//初始化包头 &#123; this-&gt;cmd = CMD_LOGIN; this-&gt;date_length = sizeof(Login); &#125; char UserName[32];//用户名 char PassWord[32];//密码 char data[932];&#125;;//包2 登录结果 传输结果struct LoginResult : public DataHeader &#123; LoginResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGINRESULT; this-&gt;date_length = sizeof(LoginResult); &#125; int Result; char Data[992];//无意义数据 &#125;;//包3 登出 传输用户名 struct Logout : public DataHeader &#123; Logout()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUT; this-&gt;date_length = sizeof(Logout); &#125; char UserName[32];//用户名 char data[964];&#125;;//包4 登出结果 传输结果struct LogoutResult : public DataHeader &#123; LogoutResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUTRESULT; this-&gt;date_length = sizeof(LogoutResult); &#125; int Result; char data[992];&#125;;//包5 新用户登入 传输通告 struct NewUserJoin : public DataHeader &#123; NewUserJoin()//初始化包头 &#123; this-&gt;cmd = CMD_NEW_USER_JOIN; this-&gt;date_length = sizeof(NewUserJoin); &#125; char UserName[32];//用户名 &#125;;#include&lt;bits/stdc++.h&gt;#define RECV_BUFFER_SIZE 4096class ClientSocket&#123;public: //构造 ClientSocket(SOCKET sockfd = INVALID_SOCKET) &#123; _sockfd = sockfd; //缓冲区相关 _Msg_buf = new char[RECV_BUFFER_SIZE*10]; _Len_buf = 0; &#125; //析构 virtual ~ClientSocket() &#123; delete[] _Msg_buf; &#125; //获取socket SOCKET GetSockfd() &#123; return _sockfd; &#125; //获取缓冲区 char* MsgBuf() &#123; return _Msg_buf; &#125; //获取缓冲区尾部变量 int GetLen() &#123; return _Len_buf; &#125; //设置缓冲区尾巴变量 void SetLen(int len) &#123; _Len_buf = len; &#125; private: SOCKET _sockfd; //缓冲区相关 char *_Msg_buf;//消息缓冲区 int _Len_buf;//缓冲区数据尾部变量&#125;; class TcpServer&#123;public: //构造 TcpServer() &#123; _sock = INVALID_SOCKET; //缓冲区相关 _Recv_buf = new char[RECV_BUFFER_SIZE]; &#125; //析构 virtual ~TcpServer() &#123; delete[] _Recv_buf; //关闭socket CloseSocket(); &#125; //初始化socket 返回1为正常 int InitSocket() &#123;#ifdef _WIN32 //启动windows socket 2,x环境 WORD ver = MAKEWORD(2,2); WSADATA dat; if(0 != WSAStartup(ver,&amp;dat)) &#123; return -1;//-1为环境错误 &#125;#endif //创建socket if(INVALID_SOCKET != _sock) &#123; printf(&quot;&lt;Socket=%d&gt;关闭连接\\n&quot;,_sock); CloseSocket();//如果之前有连接 就关闭连接 &#125; _sock = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP); if(INVALID_SOCKET == _sock) &#123; return 0;//0为socket创建错误 &#125; return 1; &#125; //绑定IP/端口 int Bind(const char* ip,unsigned short port) &#123; //如果为无效套接字 则初始化 if(INVALID_SOCKET == _sock) &#123; InitSocket(); &#125; //绑定网络端口和IP地址 sockaddr_in _myaddr = &#123;&#125;; _myaddr.sin_family = AF_INET;//IPV4 _myaddr.sin_port = htons(port);//端口#ifdef _WIN32 if(ip)//ip为空则监听所有网卡 &#123; _myaddr.sin_addr.S_un.S_addr = inet_addr(ip);//IP &#125; else &#123; _myaddr.sin_addr.S_un.S_addr = INADDR_ANY;//IP &#125;#else if(ip)//ip为空则监听所有网卡 &#123; _myaddr.sin_addr.s_addr = inet_addr(ip);//IP &#125; else &#123; _myaddr.sin_addr.s_addr = INADDR_ANY;//IP &#125;#endif if(SOCKET_ERROR == bind(_sock,(sockaddr*)&amp;_myaddr,sizeof(sockaddr_in)))//socket (强制转换)sockaddr结构体 结构体大小 &#123; printf(&quot;绑定失败\\n&quot;); return 0; &#125; else &#123; printf(&quot;绑定成功\\n绑定端口为%d\\n&quot;,port); return 1; &#125; &#125; //监听端口 int Listen(int n) &#123; //如果为无效套接字 则提示 if(INVALID_SOCKET == _sock) &#123; printf(&quot;请先初始化套接字并绑定IP端口\\n&quot;); return 0; &#125; //监听网络端口 if(SOCKET_ERROR == listen(_sock,n))//最大连接队列 &#123; printf(&quot;监听失败\\n&quot;); return 0; &#125; else &#123; printf(&quot;监听成功\\n&quot;); return 1; &#125; &#125; //接受连接 int Accept() &#123; //等待接收客户端连接 sockaddr_in clientAddr = &#123;&#125;;//新建sockadd结构体接收客户端数据 int addr_len = sizeof(sockaddr_in);//获取sockadd结构体长度 SOCKET temp_socket = INVALID_SOCKET;//声明客户端套接字 #ifdef _WIN32 temp_socket = accept(_sock,(sockaddr*)&amp;clientAddr,&amp;addr_len);//自身套接字 客户端结构体 结构体大小 #else temp_socket = accept(_sock,(sockaddr*)&amp;clientAddr,(socklen_t*)&amp;addr_len);//自身套接字 客户端结构体 结构体大小 #endif if(INVALID_SOCKET == temp_socket)//接收失败 &#123; printf(&quot;&lt;Socket=%d&gt;错误,接受到无效客户端SOCKET\\n&quot;,temp_socket); return 0; &#125; else &#123; printf(&quot;新客户端加入\\nIP地址为：%s \\n&quot;, inet_ntoa(clientAddr.sin_addr)); //群发所有客户端 通知新用户登录 NewUserJoin *user_join = new NewUserJoin(); strcpy(user_join-&gt;UserName,inet_ntoa(clientAddr.sin_addr)); SendDataToAll(user_join); //将新的客户端加入动态数组 _clients.push_back(new ClientSocket(temp_socket)); return 1; &#125; &#125; //关闭socket void CloseSocket() &#123; if(INVALID_SOCKET != _sock) &#123;#ifdef _WIN32 //关闭客户端socket for(int n=0; n&lt;_clients.size(); ++n) &#123; closesocket(_clients[n]-&gt;GetSockfd()); delete _clients[n]; &#125; //关闭socket closesocket(_sock); //清除windows socket 环境 WSACleanup(); #else //关闭客户端socket for(int n=0; n&lt;_clients.size(); ++n) &#123; close(_clients[n]-&gt;GetSockfd()); delete _clients[n]; &#125; //关闭socket/LINUX close(_sock);#endif _sock = INVALID_SOCKET; _clients.clear(); &#125; &#125; //查询是否有待处理消息 bool OnRun() &#123; if(IsRun()) &#123; fd_set fdRead;//建立集合 fd_set fdWrite; fd_set fdExcept; FD_ZERO(&amp;fdRead);//清空集合 FD_ZERO(&amp;fdWrite); FD_ZERO(&amp;fdExcept); FD_SET(_sock,&amp;fdRead);//放入集合 FD_SET(_sock,&amp;fdWrite); FD_SET(_sock,&amp;fdExcept); timeval s_t = &#123;2,0&#125;;//select最大响应时间 SOCKET maxSock = _sock;//最大socket //把连接的客户端 放入read集合 for(int n=_clients.size()-1; n&gt;=0; --n) &#123; FD_SET(_clients[n]-&gt;GetSockfd(),&amp;fdRead); if(maxSock &lt; _clients[n]-&gt;GetSockfd()) &#123; maxSock = _clients[n]-&gt;GetSockfd(); &#125; &#125; //select函数筛选select int ret = select(maxSock+1,&amp;fdRead,&amp;fdWrite,&amp;fdExcept,&amp;s_t); if(ret&lt;0) &#123; printf(&quot;select任务结束\\n&quot;); CloseSocket(); return false; &#125; if(FD_ISSET(_sock,&amp;fdRead))//获取是否有新socket连接 &#123; FD_CLR(_sock,&amp;fdRead);//清理 Accept();//连接 &#125; //遍历所有socket 查看是否有待处理事件 for(int n=0; n&lt;_clients.size(); ++n) &#123; if(FD_ISSET(_clients[n]-&gt;GetSockfd(),&amp;fdRead)) &#123; if(-1 == RecvData(_clients[n]))//处理请求 客户端退出的话 &#123; std::vector&lt;ClientSocket*&gt;::iterator iter = _clients.begin()+n;//找到退出客户端的地址 if(iter != _clients.end())//如果是合理值 &#123; delete _clients[n]; _clients.erase(iter);//移除 &#125; &#125; &#125; &#125; //printf(&quot;空闲时间处理其他业务\\n&quot;); return true; &#125; return false; &#125; //判断是否工作中 bool IsRun() &#123; return _sock != INVALID_SOCKET; &#125; //发送数据 int SendData(DataHeader *head,SOCKET temp_socket) &#123; if(IsRun() &amp;&amp; head) &#123; send(temp_socket,(const char*)head,head-&gt;date_length,0); return 1; &#125; return 0; &#125; //向所有人发送数据 void SendDataToAll(DataHeader *head) &#123; for(int n=0;n&lt;_clients.size();++n) &#123; SendData(head, _clients[n]-&gt;GetSockfd()); &#125; &#125; //接收数据 int RecvData(ClientSocket *t_client)//处理数据 &#123; //接收客户端发送的数据 int buf_len = recv(t_client-&gt;GetSockfd(), _Recv_buf, RECV_BUFFER_SIZE, 0); if(buf_len&lt;=0) &#123; printf(&quot;客户端已退出\\n&quot;); return -1; &#125; //将接收缓冲区的数据拷贝到消息缓冲区 memcpy(t_client-&gt;MsgBuf() + t_client-&gt;GetLen(), _Recv_buf, buf_len); //消息缓冲区的数据末尾后移 t_client-&gt;SetLen(t_client-&gt;GetLen() + buf_len); //判断消息缓冲区的数据长度是否大于等于包头长度 while(t_client-&gt;GetLen() &gt;= sizeof(DataHeader))//处理粘包问题 &#123; //选出包头数据 DataHeader* header = (DataHeader*)t_client-&gt;MsgBuf(); //判断消息缓冲区内数据长度是否大于等于报文长度 避免少包问题 if(t_client-&gt;GetLen() &gt;= header-&gt;date_length) &#123; //计算出消息缓冲区内剩余未处理数据的长度 int size = t_client-&gt;GetLen() - header-&gt;date_length; //响应数据 NetMsg(header,t_client-&gt;GetSockfd()); //将消息缓冲区剩余未处理的数据前移 memcpy(t_client-&gt;MsgBuf(), t_client-&gt;MsgBuf() + header-&gt;date_length, size); //消息缓冲区的数据末尾前移 t_client-&gt;SetLen(size); &#125; else &#123; //消息缓冲区数据不足 break; &#125; &#125; return 0; &#125; //响应数据 void NetMsg(DataHeader *head,SOCKET temp_socket) &#123; printf(&quot;接收到包头，命令：%d，数据长度：%d\\n&quot;,head-&gt;cmd,head-&gt;date_length); switch(head-&gt;cmd) &#123; case CMD_LOGIN://登录 接收登录包体 &#123; Login *login = (Login*)head; /* 进行判断操作 */ //printf(&quot;%s已登录\\n密码：%s\\n&quot;,login-&gt;UserName,login-&gt;PassWord); LoginResult *result = new LoginResult; result-&gt;Result = 1; SendData(result,temp_socket); &#125; break; case CMD_LOGOUT://登出 接收登出包体 &#123; Logout *logout = (Logout*)head; /* 进行判断操作 */ //printf(&quot;%s已登出\\n&quot;,logout-&gt;UserName); LogoutResult *result = new LogoutResult(); result-&gt;Result = 1; SendData(result,temp_socket); &#125; break; default://错误 &#123; head-&gt;cmd = CMD_ERROR; head-&gt;date_length = 0; SendData(head,temp_socket); &#125; break; &#125; &#125; private: SOCKET _sock; std::vector&lt;ClientSocket*&gt; _clients;//储存客户端 //缓冲区相关 char *_Recv_buf;//接收缓冲区 &#125;;#endif","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"网络编程","slug":"网络编程","permalink":"https://zgg2001.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"C++网络编程学习：源码的封装","slug":"20210126_C++网络编程学习：源码的封装","date":"2021-01-26T13:42:02.000Z","updated":"2021-01-26T13:42:02.000Z","comments":true,"path":"2021/01/26/20210126_C++网络编程学习：源码的封装/","permalink":"https://zgg2001.github.io/2021/01/26/20210126_C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%BA%90%E7%A0%81%E7%9A%84%E5%B0%81%E8%A3%85/","excerpt":"使用的语言为C&#x2F;C++ 源码支持的平台为：Windows &#x2F; Linux 一、为何要进行封装操作&emsp;&emsp;C++为面向对象编程语言，我们要以面向对象的思路进行源码的编写。&emsp;&emsp;在对主要源码进行封装后，客户端与服务端的代码编写更加清晰明了，逻辑性更强，便于开发维护。且在今后的服务端高并发测试中，便于新建多个连接进行测试。&emsp;&emsp;在本篇笔记中，我会基于笔记四的源码进行封装，并将记录我对客户端与服务端源码进行封装时的思路与步骤。最终源码为客户端封装类文件TcpClient.hpp与服务端封装类文件TcpServer.hpp，以及客户端源码client_test.cpp与服务端源码server_test.cpp。","text":"使用的语言为C&#x2F;C++ 源码支持的平台为：Windows &#x2F; Linux 一、为何要进行封装操作&emsp;&emsp;C++为面向对象编程语言，我们要以面向对象的思路进行源码的编写。&emsp;&emsp;在对主要源码进行封装后，客户端与服务端的代码编写更加清晰明了，逻辑性更强，便于开发维护。且在今后的服务端高并发测试中，便于新建多个连接进行测试。&emsp;&emsp;在本篇笔记中，我会基于笔记四的源码进行封装，并将记录我对客户端与服务端源码进行封装时的思路与步骤。最终源码为客户端封装类文件TcpClient.hpp与服务端封装类文件TcpServer.hpp，以及客户端源码client_test.cpp与服务端源码server_test.cpp。 二、封装的思路与相关1.封装的头文件选择&emsp;&emsp;封装类首先要在头文件中以体现封装性。在本次的封装中，为了能更方便的储存，我选择了hpp头文件。即类声明与类定义都在此文件中。 2.客户端类的封装&emsp;&emsp;首先，客户端的大致流程如下： 123456789101112131415161.建立socket2.连接服务器3.建立新线程 用于发送命令while(true)&#123; 4.使用select函数获取服务器端是否有待处理事件 5.如果有，就处理它(接收/发送)&#125;6.关闭socket新线程：while(1)&#123; 1.键入数据 2.发送数据&#125; &emsp;&emsp;所以，我们需要封装的方法如下： 12345678910111213141516//初始化socketint InitSocket();//连接服务器 int Connect(const char *ip,unsigned short port);//关闭socketvoid CloseSocket();//查询是否有待处理消息 bool OnRun();//判断是否工作中 bool IsRun();//发送数据 int SendData(DataHeader *_head);//接收数据int RecvData(SOCKET _temp_socket);//响应数据virtual void NetMsg(DataHeader *_head); &emsp;&emsp;按照此思路，客户端的源码思路为： 1234567891011121314151.InitSocket();//建立socket2.Connect(const char *ip,unsigned short port);//连接服务器 传入IP与端口3.建立新线程 用于发送命令while(4.IsRun())//检测是否工作中&#123; 5.OnRun();//查询是否有待处理消息&#125;6.CloseSocket();//关闭socket新线程：while(1.IsRun())//检测是否工作中&#123; 2.键入数据 3.SendData(DataHeader *_head);&#125; &emsp;&emsp;其中，OnRun() 方法中使用的是select网络结构，在select筛选出待处理事件后，使用RecvData() 方法进行包头与包体的接收，随后调用NetMsg() 方法，依据包头的报文类型对包体数据进行处理。NetMsg() 方法为虚方法，在之后调用此封装类时，可以进行继承重载操作，便于对数据响应的操作进行变更。 相关源码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//查询是否有待处理消息 bool OnRun()&#123; if(IsRun())//如果有连接则监听事件 &#123; fd_set _fdRead;//建立集合 FD_ZERO(&amp;_fdRead);//清空集合 FD_SET(_sock,&amp;_fdRead);//放入集合 timeval _t = &#123;1,0&#125;;//select最大响应时间 //新建seclect int _ret = select(_sock+1,&amp;_fdRead,NULL,NULL,&amp;_t); if(_ret&lt;0) &#123; printf(&quot;seclect任务结束\\n&quot;); return false; &#125; if(FD_ISSET(_sock,&amp;_fdRead))//获取是否有可读socket &#123; FD_CLR(_sock,&amp;_fdRead);//清理计数器 if(-1 == RecvData(_sock)) &#123; CloseSocket(); return false; &#125; &#125; return true; &#125; return false;&#125; //接收数据int RecvData(SOCKET _temp_socket)//处理数据 &#123; //缓冲区 char buffer[4096] = &#123;&#125;; //接收客户端发送的数据 int _buf_len = recv(_temp_socket,buffer,sizeof(DataHeader),0); DataHeader *_head = (DataHeader*)buffer; if(_buf_len&lt;=0) &#123; printf(&quot;与服务器断开连接,任务结束\\n&quot;); return -1; &#125; recv(_temp_socket,buffer+sizeof(DataHeader),_head-&gt;date_length-sizeof(DataHeader),0); //响应数据 NetMsg(_head); return 0; &#125;//响应数据virtual void NetMsg(DataHeader *_head)&#123; printf(&quot;接收到包头，命令：%d，数据长度：%d\\n&quot;,_head-&gt;cmd,_head-&gt;date_length); switch(_head-&gt;cmd) &#123; case CMD_LOGINRESULT://登录结果 接收登录包体 &#123; LoginResult *_result = (LoginResult*)_head; printf(&quot;登录结果:%d\\n&quot;,_result-&gt;Result); &#125; break; case CMD_LOGOUTRESULT://登出结果 接收登出包体 &#123; LogoutResult *_result = (LogoutResult*)_head; printf(&quot;登录结果:%d\\n&quot;,_result-&gt;Result); &#125; break; case CMD_NEW_USER_JOIN://新用户登录通知 &#123; NewUserJoin *_result = (NewUserJoin*)_head; printf(&quot;用户:%s已登录\\n&quot;,_result-&gt;UserName); &#125; &#125;&#125; &emsp;&emsp;另外，由于已经被封装，所以在调用方法时，可能会出现步骤错误的情况。例如还没进行新建套接字就进行connect连接操作或是关闭套接字操作、传入数据有误等等，此时就会出现问题。&emsp;&emsp;我解决此类问题的方法是多加判定。例如判定套接字是否已经被建立，或是传入数据是否有误等等，随后根据情况进行处理。详细源码请看下文。 3.服务端类的封装&emsp;&emsp;首先，客户端的大致流程如下： 123456789101.建立socket2.绑定端口IP3.监听端口while(true)&#123; 4.使用select函数获取存在待监听事件的socket 5.如果有新的连接则与新的客户端连接 6.如果有待监听事件，则对其进行处理(接受与发送)&#125;7.关闭socket &emsp;&emsp;所以，我们需要封装的方法如下： 1234567891011121314151617181920//初始化socket int InitSocket();//绑定IP/端口int Bind(const char* ip,unsigned short port);//监听端口int Listen(int n);//接受连接int Accept();//关闭socket void CloseSocket();//查询是否有待处理消息 bool OnRun();//判断是否工作中 bool IsRun();//发送数据 int SendData(DataHeader *_head,SOCKET _temp_socket);//接收数据int RecvData(SOCKET _temp_socket);//响应数据void NetMsg(DataHeader *_head,SOCKET _temp_socket); &emsp;&emsp;按照此思路，客户端的源码思路为： 123456781.InitSocket();//建立socket2.Bind(const char* ip,unsigned short port);//绑定端口IP3.Listen(int n);//监听端口while(4.IsRun())//是否工作中&#123; 5.OnRun();//查看是否有待处理消息&#125;6.CloseSocket();//关闭socket &emsp;&emsp;其中，OnRun() 方法中使用的是select网络结构。在select筛选出待处理事件后，如果为新连接，则使用Accept() 方法进行新客户端连接操作；如果为已连接客户端的待接受事件，则使用RecvData() 方法进行包头与包体的接收，随后调用NetMsg() 方法，依据包头的报文类型对包体数据进行处理。NetMsg() 方法为虚方法，在之后调用此封装类时，可以进行继承重载操作，便于对数据响应的操作进行变更。 相关源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115//查询是否有待处理消息 bool OnRun()&#123; if(IsRun()) &#123; fd_set _fdRead;//建立集合 fd_set _fdWrite; fd_set _fdExcept; FD_ZERO(&amp;_fdRead);//清空集合 FD_ZERO(&amp;_fdWrite); FD_ZERO(&amp;_fdExcept); FD_SET(_sock,&amp;_fdRead);//放入集合 FD_SET(_sock,&amp;_fdWrite); FD_SET(_sock,&amp;_fdExcept); timeval _t = &#123;2,0&#125;;//select最大响应时间 SOCKET _maxSock = _sock;//最大socket //把连接的客户端 放入read集合 for(int n=_clients.size()-1; n&gt;=0; --n) &#123; FD_SET(_clients[n],&amp;_fdRead); if(_maxSock &lt; _clients[n]) &#123; _maxSock = _clients[n]; &#125; &#125; //select函数筛选select int _ret = select(_maxSock+1,&amp;_fdRead,&amp;_fdWrite,&amp;_fdExcept,&amp;_t); if(_ret&lt;0) &#123; printf(&quot;select任务结束\\n&quot;); CloseSocket(); return false; &#125; if(FD_ISSET(_sock,&amp;_fdRead))//获取是否有新socket连接 &#123; FD_CLR(_sock,&amp;_fdRead);//清理 Accept();//连接 &#125; //遍历所有socket 查看是否有待处理事件 for(int n=0; n&lt;_clients.size(); ++n) &#123; if(FD_ISSET(_clients[n],&amp;_fdRead)) &#123; if(-1 == RecvData(_clients[n]))//处理请求 客户端退出的话 &#123; std::vector&lt;SOCKET&gt;::iterator iter = _clients.begin()+n;//找到退出客户端的地址 if(iter != _clients.end())//如果是合理值 &#123; _clients.erase(iter);//移除 &#125; &#125; &#125; &#125; //printf(&quot;空闲时间处理其他业务\\n&quot;); return true; &#125; return false;&#125; //接收数据int RecvData(SOCKET _temp_socket)//处理数据 &#123; //缓冲区 char buffer[4096] = &#123;&#125;; //接收客户端发送的数据 int _buf_len = recv(_temp_socket,buffer,sizeof(DataHeader),0); DataHeader *_head = (DataHeader*)buffer; if(_buf_len&lt;=0) &#123; printf(&quot;客户端已退出\\n&quot;); return -1; &#125; recv(_temp_socket,buffer+sizeof(DataHeader),_head-&gt;date_length-sizeof(DataHeader),0); //响应数据 NetMsg(_head,_temp_socket); return 0;&#125;//响应数据void NetMsg(DataHeader *_head,SOCKET _temp_socket)&#123; printf(&quot;接收到包头，命令：%d，数据长度：%d\\n&quot;,_head-&gt;cmd,_head-&gt;date_length); switch(_head-&gt;cmd) &#123; case CMD_LOGIN://登录 接收登录包体 &#123; Login *_login = (Login*)_head; /* 进行判断操作 */ printf(&quot;%s已登录\\n密码：%s\\n&quot;,_login-&gt;UserName,_login-&gt;PassWord); LoginResult *_result = new LoginResult; _result-&gt;Result = 1; SendData(_result,_temp_socket); &#125; break; case CMD_LOGOUT://登出 接收登出包体 &#123; Logout *_logout = (Logout*)_head; /* 进行判断操作 */ printf(&quot;%s已登出\\n&quot;,_logout-&gt;UserName); LogoutResult *_result = new LogoutResult(); _result-&gt;Result = 1; SendData(_result,_temp_socket); &#125; break; default://错误 &#123; _head-&gt;cmd = CMD_ERROR; _head-&gt;date_length = 0; SendData(_head,_temp_socket); &#125; break; &#125;&#125; &emsp;&emsp;另外，由于已经被封装，所以在调用方法时，可能会出现步骤错误的情况。例如还没进行新建套接字就进行bind绑定端口IP或是关闭套接字操作、传入数据有误等等，此时就会出现问题。&emsp;&emsp;我解决此类问题的方法是多加判定。例如判定套接字是否已经被建立，或是传入数据是否有误等等，随后根据情况进行处理。详细源码请看下文。 三、封装后的详细源码及其注释1.客户端TcpClient.hpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272#ifndef _TcpClient_hpp_#define _TcpClient_hpp_#ifdef _WIN32 #define WIN32_LEAN_AND_MEAN #include&lt;winSock2.h&gt; #include&lt;windows.h&gt; #pragma comment(lib,&quot;ws2_32.lib&quot;) #else #include&lt;arpa/inet.h&gt; #include&lt;unistd.h&gt; #include&lt;string.h&gt; #define SOCKET int #define INVALID_SOCKET (SOCKET)(~0) #define SOCKET_ERROR (-1)#endif//枚举类型记录命令 enum cmd &#123; CMD_LOGIN,//登录 CMD_LOGINRESULT,//登录结果 CMD_LOGOUT,//登出 CMD_LOGOUTRESULT,//登出结果 CMD_NEW_USER_JOIN,//新用户登入 CMD_ERROR//错误 &#125;;//定义数据包头 struct DataHeader &#123; short cmd;//命令 short date_length;//数据的长短 &#125;;//包1 登录 传输账号与密码struct Login : public DataHeader &#123; Login()//初始化包头 &#123; this-&gt;cmd = CMD_LOGIN; this-&gt;date_length = sizeof(Login); &#125; char UserName[32];//用户名 char PassWord[32];//密码 &#125;;//包2 登录结果 传输结果struct LoginResult : public DataHeader &#123; LoginResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGINRESULT; this-&gt;date_length = sizeof(LoginResult); &#125; int Result;&#125;;//包3 登出 传输用户名 struct Logout : public DataHeader &#123; Logout()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUT; this-&gt;date_length = sizeof(Logout); &#125; char UserName[32];//用户名 &#125;;//包4 登出结果 传输结果struct LogoutResult : public DataHeader &#123; LogoutResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUTRESULT; this-&gt;date_length = sizeof(LogoutResult); &#125; int Result;&#125;;//包5 新用户登入 传输通告 struct NewUserJoin : public DataHeader &#123; NewUserJoin()//初始化包头 &#123; this-&gt;cmd = CMD_NEW_USER_JOIN; this-&gt;date_length = sizeof(NewUserJoin); &#125; char UserName[32];//用户名 &#125;;#include&lt;bits/stdc++.h&gt;class TcpClient&#123;public: //构造 TcpClient() &#123; _sock = INVALID_SOCKET; &#125; //析构 virtual ~TcpClient() &#123; //关闭socket CloseSocket(); &#125; //初始化socket 返回1为正常 int InitSocket() &#123;#ifdef _WIN32 //启动windows socket 2,x环境 WORD ver = MAKEWORD(2,2); WSADATA dat; if(0 != WSAStartup(ver,&amp;dat)) &#123; return -1;//-1为环境错误 &#125;#endif //创建socket if(INVALID_SOCKET != _sock) &#123; printf(&quot;&lt;Socket=%d&gt;关闭连接\\n&quot;,_sock); CloseSocket();//如果之前有连接 就关闭连接 &#125; _sock = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP); if(INVALID_SOCKET == _sock) &#123; return 0;//0为socket创建错误 &#125; return 1; &#125; //连接服务器 返回1为成功 int Connect(const char *ip,unsigned short port) &#123; //如果为无效套接字 则初始化 if(INVALID_SOCKET == _sock) &#123; InitSocket(); &#125; //连接服务器 sockaddr_in _sin = &#123;&#125;; _sin.sin_family = AF_INET;//IPV4 _sin.sin_port = htons(port);//端口号 #ifdef _WIN32 _sin.sin_addr.S_un.S_addr = inet_addr(ip);//IP #else _sin.sin_addr.s_addr = inet_addr(ip);//IP #endif if(SOCKET_ERROR == connect(_sock,(sockaddr*)&amp;_sin,sizeof(sockaddr_in))) &#123; return 0;//连接失败 &#125; else &#123; return 1;//连接成功 &#125; &#125; //关闭socket void CloseSocket() &#123; if(INVALID_SOCKET != _sock) &#123;#ifdef _WIN32 //关闭socket closesocket(_sock); //清除windows socket 环境 WSACleanup(); #else //关闭socket/LINUX close(_sock);#endif _sock = INVALID_SOCKET; &#125; &#125; //查询是否有待处理消息 bool OnRun() &#123; if(IsRun())//如果有连接则监听事件 &#123; fd_set _fdRead;//建立集合 FD_ZERO(&amp;_fdRead);//清空集合 FD_SET(_sock,&amp;_fdRead);//放入集合 timeval _t = &#123;1,0&#125;;//select最大响应时间 //新建seclect int _ret = select(_sock+1,&amp;_fdRead,NULL,NULL,&amp;_t); if(_ret&lt;0) &#123; printf(&quot;seclect任务结束\\n&quot;); return false; &#125; if(FD_ISSET(_sock,&amp;_fdRead))//获取是否有可读socket &#123; FD_CLR(_sock,&amp;_fdRead);//清理计数器 if(-1 == RecvData(_sock)) &#123; CloseSocket(); return false; &#125; &#125; return true; &#125; return false; &#125; //判断是否工作中 bool IsRun() &#123; return _sock != INVALID_SOCKET; &#125; //发送数据 int SendData(DataHeader *_head) &#123; if(IsRun() &amp;&amp; _head) &#123; send(_sock,(const char*)_head,_head-&gt;date_length,0); return 1; &#125; return 0; &#125; //接收数据 int RecvData(SOCKET _temp_socket)//处理数据 &#123; //缓冲区 char buffer[4096] = &#123;&#125;; //接收客户端发送的数据 int _buf_len = recv(_temp_socket,buffer,sizeof(DataHeader),0); DataHeader *_head = (DataHeader*)buffer; if(_buf_len&lt;=0) &#123; printf(&quot;与服务器断开连接,任务结束\\n&quot;); return -1; &#125; recv(_temp_socket,buffer+sizeof(DataHeader),_head-&gt;date_length-sizeof(DataHeader),0); //响应数据 NetMsg(_head); return 0; &#125; //响应数据 virtual void NetMsg(DataHeader *_head) &#123; printf(&quot;接收到包头，命令：%d，数据长度：%d\\n&quot;,_head-&gt;cmd,_head-&gt;date_length); switch(_head-&gt;cmd) &#123; case CMD_LOGINRESULT://登录结果 接收登录包体 &#123; LoginResult *_result = (LoginResult*)_head; printf(&quot;登录结果:%d\\n&quot;,_result-&gt;Result); &#125; break; case CMD_LOGOUTRESULT://登出结果 接收登出包体 &#123; LogoutResult *_result = (LogoutResult*)_head; printf(&quot;登录结果:%d\\n&quot;,_result-&gt;Result); &#125; break; case CMD_NEW_USER_JOIN://新用户登录通知 &#123; NewUserJoin *_result = (NewUserJoin*)_head; printf(&quot;用户:%s已登录\\n&quot;,_result-&gt;UserName); &#125; &#125; &#125; private: SOCKET _sock;&#125;;#endif client_test.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&quot;TcpClient.hpp&quot;#include&lt;thread&gt;void _cmdThread(TcpClient* tcp)//命令线程 &#123; while(tcp-&gt;IsRun()) &#123; //输入请求 char _msg[256] = &#123;&#125;; scanf(&quot;%s&quot;,_msg); //处理请求 if(0 == strcmp(_msg,&quot;exit&quot;)) &#123; tcp-&gt;CloseSocket(); printf(&quot;程序退出\\n&quot;); break; &#125; else if(0 == strcmp(_msg,&quot;login&quot;)) &#123; //发送 Login _login; strcpy(_login.UserName,&quot;hbxxy&quot;); strcpy(_login.PassWord,&quot;123456&quot;); tcp-&gt;SendData(&amp;_login); &#125; else if(0 == strcmp(_msg,&quot;logout&quot;)) &#123; //发送 Logout _logout; strcpy(_logout.UserName,&quot;hbxxy&quot;); tcp-&gt;SendData(&amp;_logout); &#125; else &#123; printf(&quot;不存在的命令\\n&quot;); &#125; &#125;&#125;int main()&#123; printf(&quot;Welcome\\n&quot;); //建立tcp对象 TcpClient *tcp1 = new TcpClient(); //建立一个socket tcp1-&gt;InitSocket(); //连接服务器 tcp1-&gt;Connect(&quot;127.0.0.1&quot;,8888); //创建UI线程 std::thread t1(_cmdThread,tcp1); t1.detach();//线程分离 //循环 while(tcp1-&gt;IsRun()) &#123; tcp1-&gt;OnRun(); &#125; //关闭 tcp1-&gt;CloseSocket(); return 0;&#125; 2.服务端TcpServer.hpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396#ifndef _TcpServer_hpp_#define _TcpServer_hpp_#ifdef _WIN32 #define WIN32_LEAN_AND_MEAN #include&lt;winSock2.h&gt; #include&lt;windows.h&gt; #pragma comment(lib,&quot;ws2_32.lib&quot;)//链接此动态链接库 windows特有 #else #include&lt;arpa/inet.h&gt;//selcet #include&lt;unistd.h&gt;//uni std #include&lt;string.h&gt; #define SOCKET int #define INVALID_SOCKET (SOCKET)(~0) #define SOCKET_ERROR (-1)#endif//枚举类型记录命令 enum cmd &#123; CMD_LOGIN,//登录 CMD_LOGINRESULT,//登录结果 CMD_LOGOUT,//登出 CMD_LOGOUTRESULT,//登出结果 CMD_NEW_USER_JOIN,//新用户登入 CMD_ERROR//错误 &#125;;//定义数据包头 struct DataHeader &#123; short cmd;//命令 short date_length;//数据的长短 &#125;;//包1 登录 传输账号与密码struct Login : public DataHeader &#123; Login()//初始化包头 &#123; this-&gt;cmd = CMD_LOGIN; this-&gt;date_length = sizeof(Login); &#125; char UserName[32];//用户名 char PassWord[32];//密码 &#125;;//包2 登录结果 传输结果struct LoginResult : public DataHeader &#123; LoginResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGINRESULT; this-&gt;date_length = sizeof(LoginResult); &#125; int Result;&#125;;//包3 登出 传输用户名 struct Logout : public DataHeader &#123; Logout()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUT; this-&gt;date_length = sizeof(Logout); &#125; char UserName[32];//用户名 &#125;;//包4 登出结果 传输结果struct LogoutResult : public DataHeader &#123; LogoutResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUTRESULT; this-&gt;date_length = sizeof(LogoutResult); &#125; int Result;&#125;;//包5 新用户登入 传输通告 struct NewUserJoin : public DataHeader &#123; NewUserJoin()//初始化包头 &#123; this-&gt;cmd = CMD_NEW_USER_JOIN; this-&gt;date_length = sizeof(NewUserJoin); &#125; char UserName[32];//用户名 &#125;;#include&lt;bits/stdc++.h&gt;class TcpServer&#123;public: //构造 TcpServer() &#123; _sock = INVALID_SOCKET; &#125; //析构 virtual ~TcpServer() &#123; //关闭socket CloseSocket(); &#125; //初始化socket 返回1为正常 int InitSocket() &#123;#ifdef _WIN32 //启动windows socket 2,x环境 WORD ver = MAKEWORD(2,2); WSADATA dat; if(0 != WSAStartup(ver,&amp;dat)) &#123; return -1;//-1为环境错误 &#125;#endif //创建socket if(INVALID_SOCKET != _sock) &#123; printf(&quot;&lt;Socket=%d&gt;关闭连接\\n&quot;,_sock); CloseSocket();//如果之前有连接 就关闭连接 &#125; _sock = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP); if(INVALID_SOCKET == _sock) &#123; return 0;//0为socket创建错误 &#125; return 1; &#125; //绑定IP/端口 int Bind(const char* ip,unsigned short port) &#123; //如果为无效套接字 则初始化 if(INVALID_SOCKET == _sock) &#123; InitSocket(); &#125; //绑定网络端口和IP地址 sockaddr_in _myaddr = &#123;&#125;; _myaddr.sin_family = AF_INET;//IPV4 _myaddr.sin_port = htons(port);//端口#ifdef _WIN32 if(ip)//ip为空则监听所有网卡 &#123; _myaddr.sin_addr.S_un.S_addr = inet_addr(ip);//IP &#125; else &#123; _myaddr.sin_addr.S_un.S_addr = INADDR_ANY;//IP &#125;#else if(ip)//ip为空则监听所有网卡 &#123; _myaddr.sin_addr.s_addr = inet_addr(ip);//IP &#125; else &#123; _myaddr.sin_addr.s_addr = INADDR_ANY;//IP &#125;#endif if(SOCKET_ERROR == bind(_sock,(sockaddr*)&amp;_myaddr,sizeof(sockaddr_in)))//socket (强制转换)sockaddr结构体 结构体大小 &#123; printf(&quot;绑定失败\\n&quot;); return 0; &#125; else &#123; printf(&quot;绑定成功\\n绑定端口为%d\\n&quot;,port); return 1; &#125; &#125; //监听端口 int Listen(int n) &#123; //如果为无效套接字 则提示 if(INVALID_SOCKET == _sock) &#123; printf(&quot;请先初始化套接字并绑定IP端口\\n&quot;); return 0; &#125; //监听网络端口 if(SOCKET_ERROR == listen(_sock,n))//最大连接队列 &#123; printf(&quot;监听失败\\n&quot;); return 0; &#125; else &#123; printf(&quot;监听成功\\n&quot;); return 1; &#125; &#125; //接受连接 int Accept() &#123; //等待接收客户端连接 sockaddr_in _clientAddr = &#123;&#125;;//新建sockadd结构体接收客户端数据 int _addr_len = sizeof(sockaddr_in);//获取sockadd结构体长度 SOCKET _temp_socket = INVALID_SOCKET;//声明客户端套接字 #ifdef _WIN32 _temp_socket = accept(_sock,(sockaddr*)&amp;_clientAddr,&amp;_addr_len);//自身套接字 客户端结构体 结构体大小 #else _temp_socket = accept(_sock,(sockaddr*)&amp;_clientAddr,(socklen_t*)&amp;_addr_len);//自身套接字 客户端结构体 结构体大小 #endif if(INVALID_SOCKET == _temp_socket)//接收失败 &#123; printf(&quot;&lt;Socket=%d&gt;错误,接受到无效客户端SOCKET\\n&quot;,_temp_socket); return 0; &#125; else &#123; printf(&quot;新客户端加入\\nIP地址为：%s \\n&quot;, inet_ntoa(_clientAddr.sin_addr)); //群发所有客户端 通知新用户登录 NewUserJoin _user_join; strcpy(_user_join.UserName,inet_ntoa(_clientAddr.sin_addr)); for(int n=0;n&lt;_clients.size();++n) &#123; send(_clients[n],(const char*)&amp;_user_join,sizeof(NewUserJoin),0); &#125; //将新的客户端加入动态数组 _clients.push_back(_temp_socket); return 1; &#125; &#125; //关闭socket void CloseSocket() &#123; if(INVALID_SOCKET != _sock) &#123;#ifdef _WIN32 //关闭客户端socket for(int n=0; n&lt;_clients.size(); ++n) &#123; closesocket(_clients[n]); &#125; //关闭socket closesocket(_sock); //清除windows socket 环境 WSACleanup(); #else //关闭客户端socket for(int n=0; n&lt;_clients.size(); ++n) &#123; close(_clients[n]); &#125; //关闭socket/LINUX close(_sock);#endif _sock = INVALID_SOCKET; &#125; &#125; //查询是否有待处理消息 bool OnRun() &#123; if(IsRun()) &#123; fd_set _fdRead;//建立集合 fd_set _fdWrite; fd_set _fdExcept; FD_ZERO(&amp;_fdRead);//清空集合 FD_ZERO(&amp;_fdWrite); FD_ZERO(&amp;_fdExcept); FD_SET(_sock,&amp;_fdRead);//放入集合 FD_SET(_sock,&amp;_fdWrite); FD_SET(_sock,&amp;_fdExcept); timeval _t = &#123;2,0&#125;;//select最大响应时间 SOCKET _maxSock = _sock;//最大socket //把连接的客户端 放入read集合 for(int n=_clients.size()-1; n&gt;=0; --n) &#123; FD_SET(_clients[n],&amp;_fdRead); if(_maxSock &lt; _clients[n]) &#123; _maxSock = _clients[n]; &#125; &#125; //select函数筛选select int _ret = select(_maxSock+1,&amp;_fdRead,&amp;_fdWrite,&amp;_fdExcept,&amp;_t); if(_ret&lt;0) &#123; printf(&quot;select任务结束\\n&quot;); CloseSocket(); return false; &#125; if(FD_ISSET(_sock,&amp;_fdRead))//获取是否有新socket连接 &#123; FD_CLR(_sock,&amp;_fdRead);//清理 Accept();//连接 &#125; //遍历所有socket 查看是否有待处理事件 for(int n=0; n&lt;_clients.size(); ++n) &#123; if(FD_ISSET(_clients[n],&amp;_fdRead)) &#123; if(-1 == RecvData(_clients[n]))//处理请求 客户端退出的话 &#123; std::vector&lt;SOCKET&gt;::iterator iter = _clients.begin()+n;//找到退出客户端的地址 if(iter != _clients.end())//如果是合理值 &#123; _clients.erase(iter);//移除 &#125; &#125; &#125; &#125; //printf(&quot;空闲时间处理其他业务\\n&quot;); return true; &#125; return false; &#125; //判断是否工作中 bool IsRun() &#123; return _sock != INVALID_SOCKET; &#125; //发送数据 int SendData(DataHeader *_head,SOCKET _temp_socket) &#123; if(IsRun() &amp;&amp; _head) &#123; send(_temp_socket,(const char*)_head,_head-&gt;date_length,0); return 1; &#125; return 0; &#125; //接收数据 int RecvData(SOCKET _temp_socket)//处理数据 &#123; //缓冲区 char buffer[4096] = &#123;&#125;; //接收客户端发送的数据 int _buf_len = recv(_temp_socket,buffer,sizeof(DataHeader),0); DataHeader *_head = (DataHeader*)buffer; if(_buf_len&lt;=0) &#123; printf(&quot;客户端已退出\\n&quot;); return -1; &#125; recv(_temp_socket,buffer+sizeof(DataHeader),_head-&gt;date_length-sizeof(DataHeader),0); //响应数据 NetMsg(_head,_temp_socket); return 0; &#125; //响应数据 void NetMsg(DataHeader *_head,SOCKET _temp_socket) &#123; printf(&quot;接收到包头，命令：%d，数据长度：%d\\n&quot;,_head-&gt;cmd,_head-&gt;date_length); switch(_head-&gt;cmd) &#123; case CMD_LOGIN://登录 接收登录包体 &#123; Login *_login = (Login*)_head; /* 进行判断操作 */ printf(&quot;%s已登录\\n密码：%s\\n&quot;,_login-&gt;UserName,_login-&gt;PassWord); LoginResult *_result = new LoginResult; _result-&gt;Result = 1; SendData(_result,_temp_socket); &#125; break; case CMD_LOGOUT://登出 接收登出包体 &#123; Logout *_logout = (Logout*)_head; /* 进行判断操作 */ printf(&quot;%s已登出\\n&quot;,_logout-&gt;UserName); LogoutResult *_result = new LogoutResult(); _result-&gt;Result = 1; SendData(_result,_temp_socket); &#125; break; default://错误 &#123; _head-&gt;cmd = CMD_ERROR; _head-&gt;date_length = 0; SendData(_head,_temp_socket); &#125; break; &#125; &#125; private: SOCKET _sock; std::vector&lt;SOCKET&gt; _clients;//储存客户端socket&#125;;#endif server_test.cpp123456789101112131415161718192021222324252627#include&quot;TcpServer.hpp&quot; int main() &#123; printf(&quot;Welcome\\n&quot;); //建立tcp对象 TcpServer *tcp1 = new TcpServer(); //建立一个socket tcp1-&gt;InitSocket(); //绑定端口和IP tcp1-&gt;Bind(NULL,8888); //监听 tcp1-&gt;Listen(5); //循环 while(tcp1-&gt;IsRun()) &#123; tcp1-&gt;OnRun(); &#125; //关闭 tcp1-&gt;CloseSocket(); printf(&quot;任务结束，程序已退出&quot;); getchar(); return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"网络编程","slug":"网络编程","permalink":"https://zgg2001.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"C++网络编程学习：跨平台支持Windows、Linux系统","slug":"20210124_C++网络编程学习：跨平台支持Windows、Linux系统","date":"2021-01-24T12:09:34.000Z","updated":"2021-01-24T12:09:34.000Z","comments":true,"path":"2021/01/24/20210124_C++网络编程学习：跨平台支持Windows、Linux系统/","permalink":"https://zgg2001.github.io/2021/01/24/20210124_C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%94%AF%E6%8C%81Windows%E3%80%81Linux%E7%B3%BB%E7%BB%9F/","excerpt":"使用的语言为C&#x2F;C++ 源码支持的平台为：Windows &#x2F; Linux 一、为何要进行跨平台操作&emsp;&emsp;首先，我是想在网络编程学习渐入佳境后，自己尝试做一个网络方面的项目，其中就必须用到服务器。Linux服务器相比Windows服务器更加稳定且高效，所以对于我来说，学会如何编写出可以在Linux系统下运行的网络程序是必不可少的。&emsp;&emsp;其次，就目前来说，企业中的高性能网络编程都是基于Linux的，学会跨平台的网络编程技能，可以在未来就业方面等有很大的好处。&emsp;&emsp;由此，我决定在网络编程学习的第四小阶段，学习如何进行跨平台的网络编程。","text":"使用的语言为C&#x2F;C++ 源码支持的平台为：Windows &#x2F; Linux 一、为何要进行跨平台操作&emsp;&emsp;首先，我是想在网络编程学习渐入佳境后，自己尝试做一个网络方面的项目，其中就必须用到服务器。Linux服务器相比Windows服务器更加稳定且高效，所以对于我来说，学会如何编写出可以在Linux系统下运行的网络程序是必不可少的。&emsp;&emsp;其次，就目前来说，企业中的高性能网络编程都是基于Linux的，学会跨平台的网络编程技能，可以在未来就业方面等有很大的好处。&emsp;&emsp;由此，我决定在网络编程学习的第四小阶段，学习如何进行跨平台的网络编程。 二、关于Win与Linux系统下网络编程的差异差异一 在Linux环境下，程序的头文件与定义与Win环境下存在差异。 1234567891011121314#ifdef _WIN32 #define WIN32_LEAN_AND_MEAN #include&lt;winSock2.h&gt; #include&lt;windows.h&gt; #pragma comment(lib,&quot;ws2_32.lib&quot;)//链接此动态链接库 windows特有 #else #include&lt;arpa/inet.h&gt;//selcet #include&lt;unistd.h&gt;//uni std #include&lt;string.h&gt; #define SOCKET int #define INVALID_SOCKET (SOCKET)(~0) #define SOCKET_ERROR (-1)#endif 这是更改后的程序部分。可以看出： Win环境下的特有头文件 &lt;windows.h&gt; 对应Linux环境下的特有头文件 **&lt;unistd.h&gt;**。 Win环境下的网络头文件 &lt;winSock2.h&gt; 对应Linux环境下的特有头文件 **&lt;arpa&#x2F;inet.h&gt;**。 SOCKET为Win环境下的特有数据类型，其原型为unsigned __int64，所以我们在Linux下，需要简单对SOCKET进行定义。 Linux中同样对INVALID_SOCKET与SOCKET_ERROR也没有定义，所以我们参考Win中的定义，在Linux系统下对其定义。 (此图为Win环境下_socket_types.h头文件中的相关定义) 差异二 在Linux环境下不需要使用WSAStartup与WSACleanup搭建网络环境，这是Win环境特有的。 所以我们只需要加上判断即可，当检测到系统环境为Win时执行即可： 1234567891011121314#ifdef _WIN32 //启动windows socket 2,x环境 windows特有 WORD ver = MAKEWORD(2,2);//WinSock库版本号 WSADATA dat;//网络结构体 储存WSAStartup函数调用后返回的Socket数据 if(0 != WSAStartup(ver,&amp;dat))//正确初始化后返回0 &#123; return 0; &#125;#endif#ifdef _WIN32 //清除windows socket 环境 WSACleanup(); #endif 差异三 Linux环境与Win环境下，网络通信相关结构体 sockaddr_in和sockaddr 存在差异。最明显的差异为存储IP的结构不太一样。 所以我们这样更改即可：12345#ifdef _WIN32 _sin.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);//想要连接的IP #else _sin.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);//想要连接的IP #endif 差异四 Linux环境与Win环境下，关闭套接字的函数存在差异。Win下为**closesocket()，Linux下则简单粗暴为close()**。 所以我们这样更改即可：1234567#ifdef _WIN32 //关闭socket closesocket(_mysocket); #else //关闭socket/LINUX close(_mysocket);#endif 差异五 Linux环境与Win环境下，服务器的accept连接函数参数存在差异。Win下的最后一个参数为int型地址，Linux下则为socklen_t型地址。进行一次强制转换即可。 所以我们这样更改即可：12345#ifdef _WIN32 _temp_socket = accept(_mysocket,(sockaddr*)&amp;_clientAddr,&amp;_addr_len);//自身套接字 客户端结构体 结构体大小 #else _temp_socket = accept(_mysocket,(sockaddr*)&amp;_clientAddr,(socklen_t*)&amp;_addr_len);//自身套接字 客户端结构体 结构体大小 #endif 差异六 Linux环境与Win环境下，fd_set结构体中的参数出现了变化，不再有储存socket数量的fd_count变量，所以我们需要对源码下select函数的第一个参数进行准确的数据传入。 select函数的第一个参数实际为 所有socket的最大值+1，所以我们新建一个变量，用于储存最大值。在每次对fdread集合进行导入时，找到socket的最大值，随后传入select函数即可。 所以我们这样更改即可：123456789101112SOCKET _maxSock = _mysocket;//最大socket for(int n=_clients.size()-1; n&gt;=0; --n)//把连接的客户端 放入read集合 &#123; FD_SET(_clients[n],&amp;_fdRead); if(_maxSock &lt; _clients[n]) &#123; _maxSock = _clients[n];//找最大 &#125;&#125;//select函数筛选select int _ret = select(_maxSock+1,&amp;_fdRead,&amp;_fdWrite,&amp;_fdExcept,&amp;_t); 差异七 Linux环境与Win环境下，fd_set结构体中的参数出现了变化，不再有储存socket数量的fd_count变量，所以我们需要对源码下面关于遍历socket的逻辑进行改变。 首先遍历 _clients 数组中的所有socket，随后使用FD_ISSET函数判定其是否存在待处理事件，如果有，即可按逻辑进行处理。 所以我们这样更改即可：1234567891011121314for(int n=0; n&lt;_clients.size(); ++n)//遍历所有socket&#123; if(FD_ISSET(_clients[n],&amp;_fdRead))//看一下是否在待处理事件列表中 &#123; if(-1 == _handle(_clients[n]))//处理请求 客户端退出的话 &#123; vector&lt;SOCKET&gt;::iterator iter = _clients.begin()+n;//找到退出客户端的地址 if(iter != _clients.end())//如果是合理值 &#123; _clients.erase(iter);//移除 &#125; &#125; &#125;&#125; 三、基于笔记三源码进行 跨平台化升级1.客户端源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250#ifdef _WIN32 #define WIN32_LEAN_AND_MEAN #include&lt;winSock2.h&gt; #include&lt;windows.h&gt; #pragma comment(lib,&quot;ws2_32.lib&quot;)//链接此动态链接库 windows特有 #else #include&lt;arpa/inet.h&gt;//selcet #include&lt;unistd.h&gt;//uni std #include&lt;string.h&gt; #define SOCKET int #define INVALID_SOCKET (SOCKET)(~0) #define SOCKET_ERROR (-1)#endif#include&lt;bits/stdc++.h&gt;#include&lt;thread&gt; using namespace std; //枚举类型记录命令 enum cmd &#123; CMD_LOGIN,//登录 CMD_LOGINRESULT,//登录结果 CMD_LOGOUT,//登出 CMD_LOGOUTRESULT,//登出结果 CMD_NEW_USER_JOIN,//新用户登入 CMD_ERROR//错误 &#125;;//定义数据包头 struct DateHeader &#123; short cmd;//命令 short date_length;//数据的长短 &#125;;//包1 登录 传输账号与密码struct Login : public DateHeader &#123; Login()//初始化包头 &#123; this-&gt;cmd = CMD_LOGIN; this-&gt;date_length = sizeof(Login); &#125; char UserName[32];//用户名 char PassWord[32];//密码 &#125;;//包2 登录结果 传输结果struct LoginResult : public DateHeader &#123; LoginResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGINRESULT; this-&gt;date_length = sizeof(LoginResult); &#125; int Result;&#125;;//包3 登出 传输用户名 struct Logout : public DateHeader &#123; Logout()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUT; this-&gt;date_length = sizeof(Logout); &#125; char UserName[32];//用户名 &#125;;//包4 登出结果 传输结果struct LogoutResult : public DateHeader &#123; LogoutResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUTRESULT; this-&gt;date_length = sizeof(LogoutResult); &#125; int Result;&#125;;//包5 新用户登入 传输通告 struct NewUserJoin : public DateHeader &#123; NewUserJoin()//初始化包头 &#123; this-&gt;cmd = CMD_NEW_USER_JOIN; this-&gt;date_length = sizeof(NewUserJoin); &#125; char UserName[32];//用户名 &#125;; int _handle(SOCKET _temp_socket)//处理数据 &#123; //接收客户端发送的数据 DateHeader _head = &#123;&#125;; int _buf_len = recv(_temp_socket,(char*)&amp;_head,sizeof(DateHeader),0); if(_buf_len&lt;=0) &#123; printf(&quot;与服务器断开连接,任务结束\\n&quot;); return -1; &#125; printf(&quot;接收到包头，命令：%d，数据长度：%d\\n&quot;,_head.cmd,_head.date_length); switch(_head.cmd) &#123; case CMD_LOGINRESULT://登录结果 接收登录包体 &#123; LoginResult _result; recv(_temp_socket,(char*)&amp;_result+sizeof(DateHeader),sizeof(LoginResult)-sizeof(DateHeader),0); printf(&quot;登录结果:%d\\n&quot;,_result.Result); &#125; break; case CMD_LOGOUTRESULT://登出结果 接收登出包体 &#123; LogoutResult _result; recv(_temp_socket,(char*)&amp;_result+sizeof(DateHeader),sizeof(LogoutResult)-sizeof(DateHeader),0); printf(&quot;登录结果:%d\\n&quot;,_result.Result); &#125; break; case CMD_NEW_USER_JOIN://新用户登录通知 &#123; NewUserJoin _result; recv(_temp_socket,(char*)&amp;_result+sizeof(DateHeader),sizeof(NewUserJoin)-sizeof(DateHeader),0); printf(&quot;用户:%s已登录\\n&quot;,_result.UserName); &#125; &#125; return 0; &#125;bool _run = true;//当前程序是否还在运行中 void _cmdThread(SOCKET _mysocket)//命令线程 &#123; while(_run) &#123; //输入请求 char _msg[256] = &#123;&#125;; scanf(&quot;%s&quot;,_msg); //处理请求 if(0 == strcmp(_msg,&quot;exit&quot;)) &#123; _run = false; printf(&quot;程序退出\\n&quot;); break; &#125; else if(0 == strcmp(_msg,&quot;login&quot;)) &#123; //发送 Login _login; strcpy(_login.UserName,&quot;hbxxy&quot;); strcpy(_login.PassWord,&quot;123456&quot;); send(_mysocket,(const char*)&amp;_login,sizeof(_login),0); &#125; else if(0 == strcmp(_msg,&quot;logout&quot;)) &#123; //发送 Logout _logout; strcpy(_logout.UserName,&quot;hbxxy&quot;); send(_mysocket,(const char*)&amp;_logout,sizeof(_logout),0); &#125; else &#123; printf(&quot;不存在的命令\\n&quot;); &#125; &#125;&#125;int main()&#123; printf(&quot;Welcome\\n&quot;); #ifdef _WIN32 //启动windows socket 2,x环境 windows特有 WORD ver = MAKEWORD(2,2);//WinSock库版本号 WSADATA dat;//网络结构体 储存WSAStartup函数调用后返回的Socket数据 if(0 != WSAStartup(ver,&amp;dat))//正确初始化后返回0 &#123; return 0; &#125; #endif //建立一个socket SOCKET _mysocket = socket(AF_INET,SOCK_STREAM,0);//IPV4 数据流类型 类型可以不用写 if(INVALID_SOCKET == _mysocket)//建立失败 &#123; printf(&quot;socket error&quot;); return 0; &#125; //连接服务器 sockaddr_in _sin = &#123;&#125;;//sockaddr结构体 _sin.sin_family = AF_INET;//IPV4 _sin.sin_port = htons(8888);//想要连接的端口号 #ifdef _WIN32 _sin.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);//想要连接的IP #else _sin.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);//想要连接的IP #endif if(SOCKET_ERROR == connect(_mysocket,(sockaddr*)&amp;_sin,sizeof(sockaddr_in))) &#123; cout&lt;&lt;&quot;连接失败&quot;&lt;&lt;endl; #ifdef _WIN32 //关闭socket closesocket(_mysocket); #else //关闭socket/LINUX close(_mysocket); #endif &#125; else &#123; cout&lt;&lt;&quot;连接成功&quot;&lt;&lt;endl; &#125; //创建新线程 thread t1(_cmdThread,_mysocket); t1.detach();//线程分离 while(_run) &#123; fd_set _fdRead;//建立集合 FD_ZERO(&amp;_fdRead);//清空集合 FD_SET(_mysocket,&amp;_fdRead);//放入集合 timeval _t = &#123;1,0&#125;;//select最大响应时间 //新建seclect int _ret = select(_mysocket+1,&amp;_fdRead,NULL,NULL,&amp;_t); if(_ret&lt;0) &#123; printf(&quot;seclect任务结束\\n&quot;); break; &#125; if(FD_ISSET(_mysocket,&amp;_fdRead))//获取是否有可读socket &#123; FD_CLR(_mysocket,&amp;_fdRead);//清理计数器 if(-1 == _handle(_mysocket)) &#123; printf(&quot;seclect任务结束\\n&quot;); break; &#125; &#125; &#125;#ifdef _WIN32 //关闭socket closesocket(_mysocket); //清除windows socket 环境 WSACleanup(); #else //关闭socket/LINUX close(_mysocket);#endif return 0;&#125; 2.服务端源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290#ifdef _WIN32 #define WIN32_LEAN_AND_MEAN #include&lt;winSock2.h&gt; #include&lt;windows.h&gt; #pragma comment(lib,&quot;ws2_32.lib&quot;)//链接此动态链接库 windows特有 #else #include&lt;arpa/inet.h&gt;//selcet #include&lt;unistd.h&gt;//uni std #include&lt;string.h&gt; #define SOCKET int #define INVALID_SOCKET (SOCKET)(~0) #define SOCKET_ERROR (-1)#endif#include&lt;bits/stdc++.h&gt;using namespace std; //枚举类型记录命令 enum cmd &#123; CMD_LOGIN,//登录 CMD_LOGINRESULT,//登录结果 CMD_LOGOUT,//登出 CMD_LOGOUTRESULT,//登出结果 CMD_NEW_USER_JOIN,//新用户登入 CMD_ERROR//错误 &#125;;//定义数据包头 struct DateHeader &#123; short cmd;//命令 short date_length;//数据的长短 &#125;;//包1 登录 传输账号与密码struct Login : public DateHeader &#123; Login()//初始化包头 &#123; this-&gt;cmd = CMD_LOGIN; this-&gt;date_length = sizeof(Login); &#125; char UserName[32];//用户名 char PassWord[32];//密码 &#125;;//包2 登录结果 传输结果struct LoginResult : public DateHeader &#123; LoginResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGINRESULT; this-&gt;date_length = sizeof(LoginResult); &#125; int Result;&#125;;//包3 登出 传输用户名 struct Logout : public DateHeader &#123; Logout()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUT; this-&gt;date_length = sizeof(Logout); &#125; char UserName[32];//用户名 &#125;;//包4 登出结果 传输结果struct LogoutResult : public DateHeader &#123; LogoutResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUTRESULT; this-&gt;date_length = sizeof(LogoutResult); &#125; int Result;&#125;;//包5 新用户登入 传输通告 struct NewUserJoin : public DateHeader &#123; NewUserJoin()//初始化包头 &#123; this-&gt;cmd = CMD_NEW_USER_JOIN; this-&gt;date_length = sizeof(NewUserJoin); &#125; char UserName[32];//用户名 &#125;; vector&lt;SOCKET&gt; _clients;//储存客户端socket int _handle(SOCKET _temp_socket)//处理数据 &#123; //接收客户端发送的数据 DateHeader _head = &#123;&#125;; int _buf_len = recv(_temp_socket,(char*)&amp;_head,sizeof(DateHeader),0); if(_buf_len&lt;=0) &#123; printf(&quot;客户端已退出\\n&quot;); return -1; &#125; printf(&quot;接收到包头，命令：%d，数据长度：%d\\n&quot;,_head.cmd,_head.date_length); switch(_head.cmd) &#123; case CMD_LOGIN://登录 接收登录包体 &#123; Login _login; recv(_temp_socket,(char*)&amp;_login+sizeof(DateHeader),sizeof(Login)-sizeof(DateHeader),0); /* 进行判断操作 */ printf(&quot;%s已登录\\n密码：%s\\n&quot;,_login.UserName,_login.PassWord); LoginResult _result; _result.Result = 1; send(_temp_socket,(char*)&amp;_result,sizeof(LoginResult),0);//发包体 &#125; break; case CMD_LOGOUT://登出 接收登出包体 &#123; Logout _logout; recv(_temp_socket,(char*)&amp;_logout+sizeof(DateHeader),sizeof(Logout)-sizeof(DateHeader),0); /* 进行判断操作 */ printf(&quot;%s已登出\\n&quot;,_logout.UserName); LogoutResult _result; _result.Result = 1; send(_temp_socket,(char*)&amp;_result,sizeof(LogoutResult),0);//发包体 &#125; break; default://错误 &#123; _head.cmd = CMD_ERROR; _head.date_length = 0; send(_temp_socket,(char*)&amp;_head,sizeof(DateHeader),0);//发包头 &#125; break; &#125; return 0; &#125; int main() &#123;#ifdef _WIN32 //启动windows socket 2,x环境 windows特有 WORD ver = MAKEWORD(2,2);//WinSock库版本号 WSADATA dat;//网络结构体 储存WSAStartup函数调用后返回的Socket数据 if(0 != WSAStartup(ver,&amp;dat))//正确初始化后返回0 &#123; return 0; &#125;#endif //建立一个socket SOCKET _mysocket = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);//IPV4 数据流类型 TCP类型 if(INVALID_SOCKET == _mysocket)//建立失败 &#123; return 0; &#125; //绑定网络端口和IP地址 sockaddr_in _myaddr = &#123;&#125;;//建立sockaddr结构体 sockaddr_in结构体方便填写 但是下面要进行类型转换 _myaddr.sin_family = AF_INET;//IPV4 _myaddr.sin_port = htons(8888);//端口 host to net unsigned short#ifdef _WIN32 _myaddr.sin_addr.S_un.S_addr = INADDR_ANY;//inet_addr(&quot;127.0.0.1&quot;);#else _myaddr.sin_addr.s_addr = INADDR_ANY;//想要监听的ip #endif if(SOCKET_ERROR == bind(_mysocket,(sockaddr*)&amp;_myaddr,sizeof(sockaddr_in)))//socket (强制转换)sockaddr结构体 结构体大小 &#123; cout&lt;&lt;&quot;绑定不成功&quot;&lt;&lt;endl; &#125; else &#123; //cout&lt;&lt;&quot;绑定成功&quot;&lt;&lt;endl; &#125; //监听网络端口 if(SOCKET_ERROR == listen(_mysocket,5))//套接字 最大多少人连接 &#123; cout&lt;&lt;&quot;监听失败&quot;&lt;&lt;endl; &#125; else &#123; //cout&lt;&lt;&quot;监听成功&quot;&lt;&lt;endl; &#125; while(true) &#123; fd_set _fdRead;//建立集合 fd_set _fdWrite; fd_set _fdExcept; FD_ZERO(&amp;_fdRead);//清空集合 FD_ZERO(&amp;_fdWrite); FD_ZERO(&amp;_fdExcept); FD_SET(_mysocket,&amp;_fdRead);//放入集合 FD_SET(_mysocket,&amp;_fdWrite); FD_SET(_mysocket,&amp;_fdExcept); timeval _t = &#123;2,0&#125;;//select最大响应时间 SOCKET _maxSock = _mysocket;//最大socket for(int n=_clients.size()-1; n&gt;=0; --n)//把连接的客户端 放入read集合 &#123; FD_SET(_clients[n],&amp;_fdRead); if(_maxSock &lt; _clients[n]) &#123; _maxSock = _clients[n];//找最大 &#125; &#125; //select函数筛选select int _ret = select(_maxSock+1,&amp;_fdRead,&amp;_fdWrite,&amp;_fdExcept,&amp;_t); if(_ret&lt;0) &#123; printf(&quot;select任务结束\\n&quot;); break; &#125; if(FD_ISSET(_mysocket,&amp;_fdRead))//获取是否有新socket连接 &#123; FD_CLR(_mysocket,&amp;_fdRead);//清理 //等待接收客户端连接 sockaddr_in _clientAddr = &#123;&#125;;//新建sockadd结构体接收客户端数据 int _addr_len = sizeof(sockaddr_in);//获取sockadd结构体长度 SOCKET _temp_socket = INVALID_SOCKET;//声明客户端套接字 #ifdef _WIN32 _temp_socket = accept(_mysocket,(sockaddr*)&amp;_clientAddr,&amp;_addr_len);//自身套接字 客户端结构体 结构体大小 #else _temp_socket = accept(_mysocket,(sockaddr*)&amp;_clientAddr,(socklen_t*)&amp;_addr_len);//自身套接字 客户端结构体 结构体大小 #endif if(INVALID_SOCKET == _temp_socket)//接收失败 &#123; cout&lt;&lt;&quot;接收到无效客户端Socket&quot;&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;&quot;新客户端加入&quot;&lt;&lt;endl; printf(&quot;IP地址为：%s \\n&quot;, inet_ntoa(_clientAddr.sin_addr)); //群发所有客户端 通知新用户登录 NewUserJoin _user_join; strcpy(_user_join.UserName,inet_ntoa(_clientAddr.sin_addr)); for(int n=0;n&lt;_clients.size();++n) &#123; send(_clients[n],(const char*)&amp;_user_join,sizeof(NewUserJoin),0); &#125; //将新的客户端加入动态数组 _clients.push_back(_temp_socket); &#125; &#125; for(int n=0; n&lt;_clients.size(); ++n)//遍历所有socket &#123; if(FD_ISSET(_clients[n],&amp;_fdRead))//看一下是否在待处理事件列表中 &#123; if(-1 == _handle(_clients[n]))//处理请求 客户端退出的话 &#123; vector&lt;SOCKET&gt;::iterator iter = _clients.begin()+n;//找到退出客户端的地址 if(iter != _clients.end())//如果是合理值 &#123; _clients.erase(iter);//移除 &#125; &#125; &#125; &#125; printf(&quot;空闲时间处理其他业务\\n&quot;); &#125;#ifdef _WIN32 //关闭客户端socket for(int n=0; n&lt;_clients.size(); ++n) &#123; closesocket(_clients[n]); &#125; //关闭socket closesocket(_mysocket); //清除windows socket 环境 WSACleanup(); #else //关闭客户端socket for(int n=0; n&lt;_clients.size(); ++n) &#123; close(_clients[n]); &#125; //关闭socket/LINUX close(_mysocket);#endif printf(&quot;任务结束，程序已退出&quot;); getchar(); return 0;&#125; 四、移植过程中遇到的一些小问题1.关于IP的问题&emsp;&emsp;如果服务端在本机Windows环境下运行，客户端在VM虚拟机Linux环境下运行，则在Windows命令行上输入ipconfig命令。下面这一块数据下的IPv4地址即为客户端需要连接的IP。 1234567以太网适配器 VMware Network Adapter VMnet8: 连接特定的 DNS 后缀 . . . . . . . : 本地链接 IPv6 地址. . . . . . . . : IPv4 地址 . . . . . . . . . . . . : 子网掩码 . . . . . . . . . . . . : 默认网关. . . . . . . . . . . . . : &emsp;&emsp;如果服务端在VM虚拟机Linux环境下运行，客户端在本机Windows环境下运行，则在Linux命令行上输入ifconfig命令。显示出来的数据中网卡的IP即为客户端需要连接的IP。 2.关于端口的问题&emsp;&emsp;如果你的服务端运行正常，客户端运行正常，本机双开客户端和服务端也运行正常，但本机与虚拟机各开一个却连接不上时，可能是服务端的端口未开放导致的。 Windows环境下会主动提示，点击允许即可，如果还是不行就去网上搜。 Linux环境下相关命令如下：12345678910111213141516171819systemctl status firewalld 查看防火墙状态systemctl start firewalld 开启防火墙 systemctl stop firewalld 关闭防火墙 service firewalld start 开启防火墙 查看对外开放的8888端口状态 yes/nofirewall-cmd --query-port=8888/tcp打开8888端口firewall-cmd --add-port=8888/tcp --permanent重载端口firewall-cmd --reload移除指定的8888端口：firewall-cmd --permanent --remove-port=8888/tcp","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"网络编程","slug":"网络编程","permalink":"https://zgg2001.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"C++网络编程学习：升级为select网络模型","slug":"20210123_C++网络编程学习：升级为select网络模型","date":"2021-01-23T14:36:50.000Z","updated":"2021-01-23T14:36:50.000Z","comments":true,"path":"2021/01/23/20210123_C++网络编程学习：升级为select网络模型/","permalink":"https://zgg2001.github.io/2021/01/23/20210123_C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%8D%87%E7%BA%A7%E4%B8%BAselect%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/","excerpt":"使用的语言为C&#x2F;C++ 源码支持的平台为：Windows 一、为何要使用select网络模型？&emsp;&emsp;通过前面的学习，已经实现了简单的网络报文收发。但是可以很明显的看出其中的缺点，那就是整个程序的运行是阻塞模式的。即服务端在与一个客户端进行socket连接时，只要连接不中断，那么就无法接收新的客户端的消息。而客户端在未输入命令时，是阻塞状态，也无法接收服务端发来的消息。&emsp;&emsp;在之前碰到这个问题时，我的想法是通过多线程来解决程序运行中的阻塞问题，但是在最近的学习中，我了解到可以使用select网络模型来方便快捷的解决小型网络程序运行中的阻塞问题。（I&#x2F;O多路复用模型相关内容）","text":"使用的语言为C&#x2F;C++ 源码支持的平台为：Windows 一、为何要使用select网络模型？&emsp;&emsp;通过前面的学习，已经实现了简单的网络报文收发。但是可以很明显的看出其中的缺点，那就是整个程序的运行是阻塞模式的。即服务端在与一个客户端进行socket连接时，只要连接不中断，那么就无法接收新的客户端的消息。而客户端在未输入命令时，是阻塞状态，也无法接收服务端发来的消息。&emsp;&emsp;在之前碰到这个问题时，我的想法是通过多线程来解决程序运行中的阻塞问题，但是在最近的学习中，我了解到可以使用select网络模型来方便快捷的解决小型网络程序运行中的阻塞问题。（I&#x2F;O多路复用模型相关内容） 二、select系统及其相关select函数如下： 12345678WINSOCK_API_LINKAGE int WSAAPI select( int nfds,//是指待监听集合里的范围 即待监听数量最大值+1 fd_set *readfds,//待监听的可读文件集合 fd_set *writefds,//待监听的可写文件集合 fd_set *exceptfds,//待监听的异常文件集合 const PTIMEVAL timeout);//超时设置 传入NULL为阻塞模式 传入timeval结构体为非阻塞模式返回值为满足条件的待监听socket数量和，如果出错返回-1，如果超时返回0。 通过上面select函数的参数可以发现存在两个特殊的结构体 fd_set 和 timeval，其相关内容如下： 1234567891011typedef struct fd_set//可以存放多个socket &#123; u_int fd_count;//记录放了多少个socket SOCKET fd_array[FD_SETSIZE];//socket数组&#125; fd_set;struct timeval//时间结构体 &#123; long tv_sec;//秒 long tv_usec;//毫秒&#125;; 接下来为select的相关函数 1234void FD_SET(int fd, fd_set *set);//将fd加入set集合void FD_ZERO(fd_set *set);//使set集合清零 不包含任何socketvoid FD_CLR(int fd, fd_set *set);//将fd从set集合中清除int FD_ISSET(int fd, fd_set *set);//测试fd是否在集合中 0是不在 1是在 ★ select相关使用总结与心得&emsp;&emsp;在一开始的select使用中，我以为向select函数中传入fd_set地址，select会把待处理事件的socket放在set集合中，但是发现并不是这样。&emsp;&emsp;经过网络上资料的查询以及我个人的测试，可以发现，用户首先需要把一份socket数组传入到此set中，select函数的作用是移除该set中没有待处理事件的socket，则剩下的socket都存在待处理事件(未决I&#x2F;O操作)。这个过程可以说是一种“选择”的过程，select函数“选择”出需要操作的socket，这或许就是select(选择)的意思吧。&emsp;&emsp;在接下来的源码中，对于需要存储所有已连接socket的服务端，我使用动态数组vector进行socket的储存。在进行select筛选前，先把vector中的socket导入到set中，随后set中筛选剩下的即为有待处理事件的socket。&emsp;&emsp;如果服务端自己的socket提示有待处理事件，则说明有新的客户端尝试进行连接，此时进行accept操作即可。&emsp;&emsp;对于客户端的多线程问题，需要注意使用detach()方法使主线程与新线程分类，否则可能会出现主线程先结束的情况，导致程序出错。&emsp;&emsp;在线程中，我们可以引入一个bool变量，用来记录客户端是否仍在连接中，当输入exit命令退出客户端时，通过此bool变量使主线程停止，跳出循环。 三、升级为select网络模型的思路1.服务端升级（select）在之前，我们的思路是： 123456789101.建立socket2.绑定端口IP3.监听端口4.与客户端连接while(true)&#123; 5.接收数据 6.发送数据&#125;7.关闭socket &emsp;&emsp;这就导致我们只能与一个客户端进行连接，随后便进入循环，只能接收这一个客户端的消息。且由于send与recv函数都是阻塞函数，所以程序也是阻塞模式的。 接下来，我们需要根据select网络模型，对服务端进行升级。思路大致如下： 123456789101.建立socket2.绑定端口IP3.监听端口while(true)&#123; 4.使用select函数获取存在待监听事件的socket 5.如果有新的连接则与新的客户端连接 6.如果有待监听事件，则对其进行处理(接受与发送)&#125;7.关闭socket &emsp;&emsp;按如上思路，即可将程序升级为select网络模型。实现非阻塞模式，可以实现多客户端信息接收。对于select相关的细节与总结，请看上文中的总结。相关代码在下文。 2.客户端升级（select+多线程）在之前，我们的思路是： 123456781.建立socket2.连接服务器while(true)&#123; 3.发送数据 4.接收数据&#125;5.关闭socket &emsp;&emsp;这就导致我们在与一个服务端连接后，无法被动的接收服务器端发来的消息。因为send与recv函数都是阻塞函数，程序也为阻塞模式。如果我们想要客户端能接收服务端发来的消息，那么就可以使用select模型。 接下来，我们需要根据select网络模型，对客户端进行升级。思路大致如下： 123456781.建立socket2.连接服务器while(true)&#123; 3.使用select函数获取服务器端是否有待处理事件 4.如果有，就处理它(接收/发送)&#125;5.关闭socket &emsp;&emsp;按如上思路，即可将程序升级为select网络模型。实现非阻塞模式，可以实现服务器端数据的被动接收。 但是，这样的程序结构也有很明显的缺点，因为scanf等数据接收函数也为阻塞函数，如果我们想要主动输入一些命令发送给服务端，就会阻塞程序运行。对此，我们可以引入多线程解决问题。思路大致如下： 123456789101112131415161.建立socket2.连接服务器3.建立新线程 用于发送命令while(true)&#123; 4.使用select函数获取服务器端是否有待处理事件 5.如果有，就处理它(接收/发送)&#125;5.关闭socket新线程：while(1)&#123; 1.键入数据 2.发送数据&#125; &emsp;&emsp;按如上思路，即可将程序变得更加完善。可以被动接受数据且可以主动向服务端发送键入命令。对于select相关的细节与总结以及线程方面的注意事项，请看上文中的总结。相关代码在下文。 四、代码及其详细注释1.服务端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276#define WIN32_LEAN_AND_MEAN#include&lt;winSock2.h&gt;#include&lt;windows.h&gt;#include&lt;bits/stdc++.h&gt;#pragma comment(lib,&quot;ws2_32.lib&quot;)//链接此动态链接库 windows特有 using namespace std; //枚举类型记录命令 enum cmd &#123; CMD_LOGIN,//登录 CMD_LOGINRESULT,//登录结果 CMD_LOGOUT,//登出 CMD_LOGOUTRESULT,//登出结果 CMD_NEW_USER_JOIN,//新用户登入 CMD_ERROR//错误 &#125;;//定义数据包头 struct DateHeader &#123; short cmd;//命令 short date_length;//数据的长短 &#125;;//包1 登录 传输账号与密码struct Login : public DateHeader &#123; Login()//初始化包头 &#123; this-&gt;cmd = CMD_LOGIN; this-&gt;date_length = sizeof(Login); &#125; char UserName[32];//用户名 char PassWord[32];//密码 &#125;;//包2 登录结果 传输结果struct LoginResult : public DateHeader &#123; LoginResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGINRESULT; this-&gt;date_length = sizeof(LoginResult); &#125; int Result;&#125;;//包3 登出 传输用户名 struct Logout : public DateHeader &#123; Logout()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUT; this-&gt;date_length = sizeof(Logout); &#125; char UserName[32];//用户名 &#125;;//包4 登出结果 传输结果struct LogoutResult : public DateHeader &#123; LogoutResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUTRESULT; this-&gt;date_length = sizeof(LogoutResult); &#125; int Result;&#125;;//包5 新用户登入 传输通告 struct NewUserJoin : public DateHeader &#123; NewUserJoin()//初始化包头 &#123; this-&gt;cmd = CMD_NEW_USER_JOIN; this-&gt;date_length = sizeof(NewUserJoin); &#125; char UserName[32];//用户名 &#125;; vector&lt;SOCKET&gt; _clients;//储存客户端socket int _handle(SOCKET _temp_socket)//处理数据 &#123; //接收客户端发送的数据 DateHeader _head = &#123;&#125;; int _buf_len = recv(_temp_socket,(char*)&amp;_head,sizeof(DateHeader),0); if(_buf_len&lt;=0) &#123; printf(&quot;客户端已退出\\n&quot;); return -1; &#125; printf(&quot;接收到包头，命令：%d，数据长度：%d\\n&quot;,_head.cmd,_head.date_length); switch(_head.cmd) &#123; case CMD_LOGIN://登录 接收登录包体 &#123; Login _login; recv(_temp_socket,(char*)&amp;_login+sizeof(DateHeader),sizeof(Login)-sizeof(DateHeader),0); /* 进行判断操作 */ printf(&quot;%s已登录\\n密码：%s\\n&quot;,_login.UserName,_login.PassWord); LoginResult _result; _result.Result = 1; send(_temp_socket,(char*)&amp;_result,sizeof(LoginResult),0);//发包体 &#125; break; case CMD_LOGOUT://登出 接收登出包体 &#123; Logout _logout; recv(_temp_socket,(char*)&amp;_logout+sizeof(DateHeader),sizeof(Logout)-sizeof(DateHeader),0); /* 进行判断操作 */ printf(&quot;%s已登出\\n&quot;,_logout.UserName); LogoutResult _result; _result.Result = 1; send(_temp_socket,(char*)&amp;_result,sizeof(LogoutResult),0);//发包体 &#125; break; default://错误 &#123; _head.cmd = CMD_ERROR; _head.date_length = 0; send(_temp_socket,(char*)&amp;_head,sizeof(DateHeader),0);//发包头 &#125; break; &#125; return 0; &#125; int main() &#123; //启动windows socket 2,x环境 windows特有 WORD ver = MAKEWORD(2,2);//WinSock库版本号 WSADATA dat;//网络结构体 储存WSAStartup函数调用后返回的Socket数据 if(0 != WSAStartup(ver,&amp;dat))//正确初始化后返回0 &#123; return 0; &#125; //建立一个socket SOCKET _mysocket = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);//IPV4 数据流类型 TCP类型 if(INVALID_SOCKET == _mysocket)//建立失败 &#123; return 0; &#125; //绑定网络端口和IP地址 sockaddr_in _myaddr = &#123;&#125;;//建立sockaddr结构体 sockaddr_in结构体方便填写 但是下面要进行类型转换 _myaddr.sin_family = AF_INET;//IPV4 _myaddr.sin_port = htons(8888);//端口 host to net unsigned short _myaddr.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);//网络地址 INADDR_ANY监听所有网卡的端口 if(SOCKET_ERROR == bind(_mysocket,(sockaddr*)&amp;_myaddr,sizeof(sockaddr_in)))//socket (强制转换)sockaddr结构体 结构体大小 &#123; cout&lt;&lt;&quot;绑定不成功&quot;&lt;&lt;endl; &#125; else &#123; //cout&lt;&lt;&quot;绑定成功&quot;&lt;&lt;endl; &#125; //监听网络端口 if(SOCKET_ERROR == listen(_mysocket,5))//套接字 最大多少人连接 &#123; cout&lt;&lt;&quot;监听失败&quot;&lt;&lt;endl; &#125; else &#123; //cout&lt;&lt;&quot;监听成功&quot;&lt;&lt;endl; &#125; while(true) &#123; //select相关 /* WINSOCK_API_LINKAGE int WSAAPI select( int nfds,//是指待监听集合里的范围 即待监听数量最大值+1 fd_set *readfds,//待监听的可读文件集合 fd_set *writefds,//待监听的可写文件集合 fd_set *exceptfds,//待监听的异常文件集合 const PTIMEVAL timeout);//超时设置 传入NULL为阻塞模式 传入timeval结构体为非阻塞模式 typedef struct fd_set//可以存放多个socket &#123; u_int fd_count;//记录放了多少个socket SOCKET fd_array[FD_SETSIZE];//socket数组 &#125; fd_set; struct timeval//时间结构体 &#123; long tv_sec;//秒 long tv_usec;//毫秒 &#125;; */ fd_set _fdRead;//建立集合 fd_set _fdWrite; fd_set _fdExcept; FD_ZERO(&amp;_fdRead);//清空集合 FD_ZERO(&amp;_fdWrite); FD_ZERO(&amp;_fdExcept); FD_SET(_mysocket,&amp;_fdRead);//放入集合 FD_SET(_mysocket,&amp;_fdWrite); FD_SET(_mysocket,&amp;_fdExcept); timeval _t = &#123;1,0&#125;;//select最大响应时间 for(int n=_clients.size()-1; n&gt;=0; --n)//把连接的客户端 放入read集合 &#123; FD_SET(_clients[n],&amp;_fdRead); &#125; //select函数筛选select int _ret = select(_mysocket+1,&amp;_fdRead,&amp;_fdWrite,&amp;_fdExcept,&amp;_t); if(_ret&lt;0) &#123; printf(&quot;select任务结束\\n&quot;); break; &#125; if(FD_ISSET(_mysocket,&amp;_fdRead))//获取是否有新socket连接 &#123; FD_CLR(_mysocket,&amp;_fdRead);//清理 //等待接收客户端连接 sockaddr_in _clientAddr = &#123;&#125;;//新建sockadd结构体接收客户端数据 int _addr_len = sizeof(sockaddr_in);//获取sockadd结构体长度 SOCKET _temp_socket = INVALID_SOCKET;//声明客户端套接字 _temp_socket = accept(_mysocket,(sockaddr*)&amp;_clientAddr,&amp;_addr_len);//自身套接字 客户端结构体 结构体大小 if(INVALID_SOCKET == _temp_socket)//接收失败 &#123; cout&lt;&lt;&quot;接收到无效客户端Socket&quot;&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;&quot;新客户端加入&quot;&lt;&lt;endl; printf(&quot;IP地址为：%s \\n&quot;, inet_ntoa(_clientAddr.sin_addr)); //群发所有客户端 通知新用户登录 NewUserJoin _user_join; strcpy(_user_join.UserName,inet_ntoa(_clientAddr.sin_addr)); for(int n=0;n&lt;_clients.size();n++) &#123; send(_clients[n],(const char*)&amp;_user_join,sizeof(NewUserJoin),0); &#125; //将新的客户端加入动态数组 _clients.push_back(_temp_socket); &#125; &#125; for(int n=0; n&lt;_fdRead.fd_count; ++n)//在read数组里挨个处理 &#123; if(-1 == _handle(_fdRead.fd_array[n]))//处理请求 客户端退出的话 &#123; vector&lt;SOCKET&gt;::iterator iter = find(_clients.begin(),_clients.end(),_fdRead.fd_array[n]); if(iter != _clients.end())//如果找到了的话 就在动态数组里删除掉 &#123; _clients.erase(iter); &#125; &#125; &#125; printf(&quot;空闲时间处理其他业务\\n&quot;); &#125; //关闭客户端socket for(int n=0; n&lt;_clients.size(); ++n) &#123; closesocket(_clients[n]); &#125; //关闭socket closesocket(_mysocket); //清除windows socket 环境 WSACleanup(); printf(&quot;任务结束，程序已退出&quot;); getchar(); return 0;&#125; 2.客户端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223#define WIN32_LEAN_AND_MEAN#include&lt;winSock2.h&gt;#include&lt;windows.h&gt;#include&lt;bits/stdc++.h&gt;#include&lt;thread&gt;#pragma comment(lib,&quot;ws2_32.lib&quot;)//链接此动态链接库 windows特有 using namespace std; //枚举类型记录命令 enum cmd &#123; CMD_LOGIN,//登录 CMD_LOGINRESULT,//登录结果 CMD_LOGOUT,//登出 CMD_LOGOUTRESULT,//登出结果 CMD_NEW_USER_JOIN,//新用户登入 CMD_ERROR//错误 &#125;;//定义数据包头 struct DateHeader &#123; short cmd;//命令 short date_length;//数据的长短 &#125;;//包1 登录 传输账号与密码struct Login : public DateHeader &#123; Login()//初始化包头 &#123; this-&gt;cmd = CMD_LOGIN; this-&gt;date_length = sizeof(Login); &#125; char UserName[32];//用户名 char PassWord[32];//密码 &#125;;//包2 登录结果 传输结果struct LoginResult : public DateHeader &#123; LoginResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGINRESULT; this-&gt;date_length = sizeof(LoginResult); &#125; int Result;&#125;;//包3 登出 传输用户名 struct Logout : public DateHeader &#123; Logout()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUT; this-&gt;date_length = sizeof(Logout); &#125; char UserName[32];//用户名 &#125;;//包4 登出结果 传输结果struct LogoutResult : public DateHeader &#123; LogoutResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUTRESULT; this-&gt;date_length = sizeof(LogoutResult); &#125; int Result;&#125;;//包5 新用户登入 传输通告 struct NewUserJoin : public DateHeader &#123; NewUserJoin()//初始化包头 &#123; this-&gt;cmd = CMD_NEW_USER_JOIN; this-&gt;date_length = sizeof(NewUserJoin); &#125; char UserName[32];//用户名 &#125;; int _handle(SOCKET _temp_socket)//处理数据 &#123; //接收客户端发送的数据 DateHeader _head = &#123;&#125;; int _buf_len = recv(_temp_socket,(char*)&amp;_head,sizeof(DateHeader),0); if(_buf_len&lt;=0) &#123; printf(&quot;与服务器断开连接,任务结束\\n&quot;); return -1; &#125; printf(&quot;接收到包头，命令：%d，数据长度：%d\\n&quot;,_head.cmd,_head.date_length); switch(_head.cmd) &#123; case CMD_LOGINRESULT://登录结果 接收登录包体 &#123; LoginResult _result; recv(_temp_socket,(char*)&amp;_result+sizeof(DateHeader),sizeof(LoginResult)-sizeof(DateHeader),0); printf(&quot;登录结果:%d\\n&quot;,_result.Result); &#125; break; case CMD_LOGOUTRESULT://登出结果 接收登出包体 &#123; LogoutResult _result; recv(_temp_socket,(char*)&amp;_result+sizeof(DateHeader),sizeof(LogoutResult)-sizeof(DateHeader),0); printf(&quot;登录结果:%d\\n&quot;,_result.Result); &#125; break; case CMD_NEW_USER_JOIN://新用户登录通知 &#123; NewUserJoin _result; recv(_temp_socket,(char*)&amp;_result+sizeof(DateHeader),sizeof(NewUserJoin)-sizeof(DateHeader),0); printf(&quot;用户:%s已登录\\n&quot;,_result.UserName); &#125; &#125; return 0; &#125;bool _run = true;//当前程序是否还在运行中 void _cmdThread(SOCKET _mysocket)//命令线程 &#123; while(true) &#123; //输入请求 char _msg[256] = &#123;&#125;; scanf(&quot;%s&quot;,_msg); //处理请求 if(0 == strcmp(_msg,&quot;exit&quot;)) &#123; _run = false; printf(&quot;程序退出\\n&quot;); break; &#125; else if(0 == strcmp(_msg,&quot;login&quot;)) &#123; //发送 Login _login; strcpy(_login.UserName,&quot;河边小咸鱼&quot;); strcpy(_login.PassWord,&quot;123456&quot;); send(_mysocket,(const char*)&amp;_login,sizeof(_login),0); //这里就不用接收了 由select用来检测接收 &#125; else if(0 == strcmp(_msg,&quot;logout&quot;)) &#123; //发送 Logout _logout; strcpy(_logout.UserName,&quot;河边小咸鱼&quot;); send(_mysocket,(const char*)&amp;_logout,sizeof(_logout),0); //这里就不用接收了 由select用来检测接收 &#125; else &#123; printf(&quot;不存在的命令\\n&quot;); &#125; &#125;&#125;int main()&#123; //启动windows socket 2,x环境 windows特有 WORD ver = MAKEWORD(2,2);//WinSock库版本号 WSADATA dat;//网络结构体 储存WSAStartup函数调用后返回的Socket数据 if(0 != WSAStartup(ver,&amp;dat))//正确初始化后返回0 &#123; return 0; &#125; //建立一个socket SOCKET _mysocket = socket(AF_INET,SOCK_STREAM,0);//IPV4 数据流类型 类型可以不用写 if(INVALID_SOCKET == _mysocket)//建立失败 &#123; return 0; &#125; //连接服务器 sockaddr_in _sin = &#123;&#125;;//sockaddr结构体 _sin.sin_family = AF_INET;//IPV4 _sin.sin_port = htons(8888);//想要连接的端口号 _sin.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);//想要连接的IP if(SOCKET_ERROR == connect(_mysocket,(sockaddr*)&amp;_sin,sizeof(sockaddr_in))) &#123; cout&lt;&lt;&quot;连接失败&quot;&lt;&lt;endl; closesocket(_mysocket); &#125; else &#123; cout&lt;&lt;&quot;连接成功&quot;&lt;&lt;endl; &#125; //创建新线程 thread t1(_cmdThread,_mysocket); t1.detach();//线程分离 while(_run) &#123; fd_set _fdRead;//建立集合 FD_ZERO(&amp;_fdRead);//清空集合 FD_SET(_mysocket,&amp;_fdRead);//放入集合 timeval _t = &#123;1,0&#125;;//select最大响应时间 //新建seclect int _ret = select(_mysocket+1,&amp;_fdRead,NULL,NULL,&amp;_t); if(_ret&lt;0) &#123; printf(&quot;seclect任务结束\\n&quot;); break; &#125; if(FD_ISSET(_mysocket,&amp;_fdRead))//获取是否有可读socket &#123; FD_CLR(_mysocket,&amp;_fdRead);//清理计数器 if(-1 == _handle(_mysocket)) &#123; printf(&quot;seclect任务结束\\n&quot;); break; &#125; &#125; &#125; //关闭socket closesocket(_mysocket); //清除windows socket 环境 WSACleanup(); return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"网络编程","slug":"网络编程","permalink":"https://zgg2001.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"C++网络编程学习：网络数据报文的收发","slug":"20210122_C++网络编程学习：网络数据报文的收发","date":"2021-01-22T04:25:43.000Z","updated":"2021-01-22T04:25:43.000Z","comments":true,"path":"2021/01/22/20210122_C++网络编程学习：网络数据报文的收发/","permalink":"https://zgg2001.github.io/2021/01/22/20210122_C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%96%87%E7%9A%84%E6%94%B6%E5%8F%91/","excerpt":"使用的语言为C&#x2F;C++ 源码支持的平台为：Windows 一、网络数据报文的格式定义 报文有两个部分，包头和包体，是网络消息的基本单元。 包头： 描述本次消息包的大小，描述包体数据的作用。 包体： 其中包含了需要传输的数据。","text":"使用的语言为C&#x2F;C++ 源码支持的平台为：Windows 一、网络数据报文的格式定义 报文有两个部分，包头和包体，是网络消息的基本单元。 包头： 描述本次消息包的大小，描述包体数据的作用。 包体： 其中包含了需要传输的数据。 &emsp;&emsp;根据此数据结构，我们可以根据包头的内容，来灵活的对包体的数据进行处理。 二、将包头与包体数据分开收发1.概括&emsp;&emsp;通过上文对网络数据报文的定义，我们可以很轻易的想到： 发送端进行两次send操作，第一次send发送包头，第二次send发送包体，即可实现网络数据报文的发送。 接收端进行两次recv操作，第一次recv接收包头，第二次recv接收包体并根据包头的内容进行数据处理，即可实现网络数据报文的接收。 &emsp;&emsp;按以上操作，即可实现网络数据报文的收发。 2.代码及其详细注释2.1 服务端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166#define WIN32_LEAN_AND_MEAN#include&lt;winSock2.h&gt;#include&lt;windows.h&gt;#include&lt;bits/stdc++.h&gt;#pragma comment(lib,&quot;ws2_32.lib&quot;)//链接此动态链接库 windows特有 using namespace std; //枚举类型记录命令 enum cmd &#123; CMD_LOGIN,//登录 CMD_LOGOUT,//登出 CMD_ERROR//错误 &#125;;//定义数据包头 struct DateHeader &#123; short cmd;//命令 short date_length;//数据的长短 &#125;;//包体1 登录 传输账号与密码struct Login&#123; char UserName[32];//用户名 char PassWord[32];//密码 &#125;;//包体2 登录结果 传输结果struct LoginResult &#123; int Result;&#125;;//包体3 登出 传输用户名 struct Logout&#123; char UserName[32];//用户名 &#125;;//包体4 登出结果 传输结果struct LogoutResult &#123; int Result;&#125;; int main() &#123; //启动windows socket 2,x环境 windows特有 WORD ver = MAKEWORD(2,2);//WinSock库版本号 WSADATA dat;//网络结构体 储存WSAStartup函数调用后返回的Socket数据 if(0 != WSAStartup(ver,&amp;dat))//正确初始化后返回0 &#123; return 0; &#125; //建立一个socket SOCKET _mysocket = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);//IPV4 数据流类型 TCP类型 if(INVALID_SOCKET == _mysocket)//建立失败 &#123; return 0; &#125; //绑定网络端口和IP地址 sockaddr_in _myaddr = &#123;&#125;;//建立sockaddr结构体 sockaddr_in结构体方便填写 但是下面要进行类型转换 _myaddr.sin_family = AF_INET;//IPV4 _myaddr.sin_port = htons(8888);//端口 host to net unsigned short _myaddr.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);//网络地址 INADDR_ANY监听所有网卡的端口 if(SOCKET_ERROR == bind(_mysocket,(sockaddr*)&amp;_myaddr,sizeof(sockaddr_in)))//socket (强制转换)sockaddr结构体 结构体大小 &#123; cout&lt;&lt;&quot;绑定不成功&quot;&lt;&lt;endl; &#125; else &#123; //cout&lt;&lt;&quot;绑定成功&quot;&lt;&lt;endl; &#125; //监听网络端口 if(SOCKET_ERROR == listen(_mysocket,5))//套接字 最大多少人连接 &#123; cout&lt;&lt;&quot;监听失败&quot;&lt;&lt;endl; &#125; else &#123; //cout&lt;&lt;&quot;监听成功&quot;&lt;&lt;endl; &#125; //等待接收客户端连接 sockaddr_in _clientAddr = &#123;&#125;;//新建sockadd结构体接收客户端数据 int _addr_len = sizeof(sockaddr_in);//获取sockadd结构体长度 SOCKET _temp_socket = INVALID_SOCKET;//声明客户端套接字 _temp_socket = accept(_mysocket,(sockaddr*)&amp;_clientAddr,&amp;_addr_len);//自身套接字 客户端结构体 结构体大小 if(INVALID_SOCKET == _temp_socket)//接收失败 &#123; cout&lt;&lt;&quot;接收到无效客户端Socket&quot;&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;&quot;新客户端加入&quot;&lt;&lt;endl; printf(&quot;IP地址为：%s \\n&quot;, inet_ntoa(_clientAddr.sin_addr)); &#125; while(true) &#123; //接收客户端发送的数据 DateHeader _head = &#123;&#125;; int _buf_len = recv(_temp_socket,(char*)&amp;_head,sizeof(DateHeader),0); if(_buf_len&lt;=0) &#123; printf(&quot;客户端已退出\\n&quot;); break; &#125; printf(&quot;接收到包头，命令：%d，数据长度：%d\\n&quot;,_head.cmd,_head.date_length); switch(_head.cmd) &#123; case CMD_LOGIN://登录 接收登录包体 &#123; Login _login = &#123;&#125;; recv(_temp_socket,(char*)&amp;_login,sizeof(Login),0); /* 进行判断操作 */ printf(&quot;%s已登录\\n&quot;,_login.UserName); send(_temp_socket,(char*)&amp;_head,sizeof(DateHeader),0);//发包头 LoginResult _result = &#123;1&#125;; send(_temp_socket,(char*)&amp;_result,sizeof(LoginResult),0);//发包体 &#125; break; case CMD_LOGOUT://登出 接收登出包体 &#123; Logout _logout = &#123;&#125;; recv(_temp_socket,(char*)&amp;_logout,sizeof(Logout),0); /* 进行判断操作 */ printf(&quot;%s已登出\\n&quot;,_logout.UserName); send(_temp_socket,(char*)&amp;_head,sizeof(DateHeader),0);//发包头 LogoutResult _result = &#123;1&#125;; send(_temp_socket,(char*)&amp;_result,sizeof(LogoutResult),0);//发包体 &#125; break; default://错误 &#123; _head.cmd = CMD_ERROR; _head.date_length = 0; send(_temp_socket,(char*)&amp;_head,sizeof(DateHeader),0);//发包头 &#125; break; &#125; &#125; //关闭客户端socket closesocket(_temp_socket); //关闭socket closesocket(_mysocket); //清除windows socket 环境 WSACleanup(); printf(&quot;任务结束，程序已退出&quot;); getchar(); return 0;&#125; 2.2 客户端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#define WIN32_LEAN_AND_MEAN#include&lt;winSock2.h&gt;#include&lt;windows.h&gt;#include&lt;bits/stdc++.h&gt;#pragma comment(lib,&quot;ws2_32.lib&quot;)//链接此动态链接库 windows特有 using namespace std; //枚举类型记录命令 enum cmd &#123; CMD_LOGIN,//登录 CMD_LOGOUT,//登出 CMD_ERROR//错误 &#125;;//定义数据包头 struct DateHeader &#123; short cmd;//命令 short date_length;//数据的长短 &#125;;//包体1 登录 传输账号与密码struct Login&#123; char UserName[32];//用户名 char PassWord[32];//密码 &#125;;//包体2 登录结果 传输结果struct LoginResult &#123; int Result;&#125;;//包体3 登出 传输用户名 struct Logout&#123; char UserName[32];//用户名 &#125;;//包体4 登出结果 传输结果struct LogoutResult &#123; int Result;&#125;; int main()&#123; //启动windows socket 2,x环境 windows特有 WORD ver = MAKEWORD(2,2);//WinSock库版本号 WSADATA dat;//网络结构体 储存WSAStartup函数调用后返回的Socket数据 if(0 != WSAStartup(ver,&amp;dat))//正确初始化后返回0 &#123; return 0; &#125; //建立一个socket SOCKET _mysocket = socket(AF_INET,SOCK_STREAM,0);//IPV4 数据流类型 类型可以不用写 if(INVALID_SOCKET == _mysocket)//建立失败 &#123; return 0; &#125; //连接服务器 sockaddr_in _sin = &#123;&#125;;//sockaddr结构体 _sin.sin_family = AF_INET;//IPV4 _sin.sin_port = htons(8888);//想要连接的端口号 _sin.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);//想要连接的IP if(SOCKET_ERROR == connect(_mysocket,(sockaddr*)&amp;_sin,sizeof(sockaddr_in))) &#123; cout&lt;&lt;&quot;连接失败&quot;&lt;&lt;endl; closesocket(_mysocket); &#125; else &#123; cout&lt;&lt;&quot;连接成功&quot;&lt;&lt;endl; &#125; while(true) &#123; //输入请求 char _msg[256] = &#123;&#125;; scanf(&quot;%s&quot;,_msg); //处理请求 if(0 == strcmp(_msg,&quot;exit&quot;)) &#123; break; &#125; else if(0 == strcmp(_msg,&quot;login&quot;)) &#123; //发送 Login _login = &#123;&quot;河边小咸鱼&quot;,&quot;123456&quot;&#125;; DateHeader _head = &#123;CMD_LOGIN,sizeof(_login)&#125;; send(_mysocket,(const char*)&amp;_head,sizeof(_head),0); send(_mysocket,(const char*)&amp;_login,sizeof(_login),0); //接收 DateHeader _head2 = &#123;&#125;; LoginResult _result= &#123;&#125;; recv(_mysocket,(char*)&amp;_head2,sizeof(DateHeader),0); recv(_mysocket,(char*)&amp;_result,sizeof(LoginResult),0); printf(&quot;result:%d\\n&quot;,_result.Result); &#125; else if(0 == strcmp(_msg,&quot;logout&quot;)) &#123; //发送 Logout _logout = &#123;&quot;河边小咸鱼&quot;&#125;; DateHeader _head = &#123;CMD_LOGOUT,sizeof(_logout)&#125;; send(_mysocket,(const char*)&amp;_head,sizeof(_head),0); send(_mysocket,(const char*)&amp;_logout,sizeof(_logout),0); //接收 DateHeader _head2 = &#123;&#125;; LogoutResult _result= &#123;&#125;; recv(_mysocket,(char*)&amp;_head2,sizeof(DateHeader),0); recv(_mysocket,(char*)&amp;_result,sizeof(LogoutResult),0); printf(&quot;result:%d\\n&quot;,_result.Result); &#125; else &#123; printf(&quot;不存在的命令\\n&quot;); &#125; &#125; //关闭socket closesocket(_mysocket); //清除windows socket 环境 WSACleanup(); return 0;&#125; 三、将分开收发报文数据改为一次收发1.思路&emsp;&emsp;由上文，我们可以知道，可以通过两次send和两次recv进行报文的收发，但是其中操作较为麻烦，需要多次声明DateHeader包头结构体，不仅消耗时间资源，也容易出错。&emsp;&emsp;因此，我们可以尝试将分开收发改为一次收发。大致思路为完善报文的结构体，使包体继承包头结构体，或者使包体结构体中包含一个包头结构体。由此完善报文的结构体，只进行一次send操作，即可发送所有报文数据。&emsp;&emsp;在进行数据接收时，我们先接收包头大小的数据，随后根据包头的内容，来确定接下来接收数据的大小，即接收 总数据大小 减去 包头数据大小 的数据。而在接下来使用recv接收剩下数据时，要使用指针偏移，跳过结构体包头的接收(因为接收过了)，直接接收到包体数据位置上。 12345/*因为包头已经接收过了 所以进行指针偏移：&amp;_login+sizeof(DateHeader)接收数据长短为：sizeof(Login)-sizeof(DateHeader) 减去包头的大小*/recv(_temp_socket,(char*)&amp;_login+sizeof(DateHeader),sizeof(Login)-sizeof(DateHeader),0); 2.代码及其详细注释2.1 服务端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#define WIN32_LEAN_AND_MEAN#include&lt;winSock2.h&gt;#include&lt;windows.h&gt;#include&lt;bits/stdc++.h&gt;#pragma comment(lib,&quot;ws2_32.lib&quot;)//链接此动态链接库 windows特有 using namespace std; //枚举类型记录命令 enum cmd &#123; CMD_LOGIN,//登录 CMD_LOGINRESULT,//登录结果 CMD_LOGOUT,//登出 CMD_LOGOUTRESULT,//登出结果 CMD_ERROR//错误 &#125;;//定义数据包头 struct DateHeader &#123; short cmd;//命令 short date_length;//数据的长短 &#125;;//包1 登录 传输账号与密码struct Login : public DateHeader &#123; Login()//初始化包头 &#123; this-&gt;cmd = CMD_LOGIN; this-&gt;date_length = sizeof(Login); &#125; char UserName[32];//用户名 char PassWord[32];//密码 &#125;;//包2 登录结果 传输结果struct LoginResult : public DateHeader &#123; LoginResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGINRESULT; this-&gt;date_length = sizeof(LoginResult); &#125; int Result;&#125;;//包3 登出 传输用户名 struct Logout : public DateHeader &#123; Logout()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUT; this-&gt;date_length = sizeof(Logout); &#125; char UserName[32];//用户名 &#125;;//包4 登出结果 传输结果struct LogoutResult : public DateHeader &#123; LogoutResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUTRESULT; this-&gt;date_length = sizeof(LogoutResult); &#125; int Result;&#125;; int main() &#123; //启动windows socket 2,x环境 windows特有 WORD ver = MAKEWORD(2,2);//WinSock库版本号 WSADATA dat;//网络结构体 储存WSAStartup函数调用后返回的Socket数据 if(0 != WSAStartup(ver,&amp;dat))//正确初始化后返回0 &#123; return 0; &#125; //建立一个socket SOCKET _mysocket = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);//IPV4 数据流类型 TCP类型 if(INVALID_SOCKET == _mysocket)//建立失败 &#123; return 0; &#125; //绑定网络端口和IP地址 sockaddr_in _myaddr = &#123;&#125;;//建立sockaddr结构体 sockaddr_in结构体方便填写 但是下面要进行类型转换 _myaddr.sin_family = AF_INET;//IPV4 _myaddr.sin_port = htons(8888);//端口 host to net unsigned short _myaddr.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);//网络地址 INADDR_ANY监听所有网卡的端口 if(SOCKET_ERROR == bind(_mysocket,(sockaddr*)&amp;_myaddr,sizeof(sockaddr_in)))//socket (强制转换)sockaddr结构体 结构体大小 &#123; cout&lt;&lt;&quot;绑定不成功&quot;&lt;&lt;endl; &#125; else &#123; //cout&lt;&lt;&quot;绑定成功&quot;&lt;&lt;endl; &#125; //监听网络端口 if(SOCKET_ERROR == listen(_mysocket,5))//套接字 最大多少人连接 &#123; cout&lt;&lt;&quot;监听失败&quot;&lt;&lt;endl; &#125; else &#123; //cout&lt;&lt;&quot;监听成功&quot;&lt;&lt;endl; &#125; //等待接收客户端连接 sockaddr_in _clientAddr = &#123;&#125;;//新建sockadd结构体接收客户端数据 int _addr_len = sizeof(sockaddr_in);//获取sockadd结构体长度 SOCKET _temp_socket = INVALID_SOCKET;//声明客户端套接字 _temp_socket = accept(_mysocket,(sockaddr*)&amp;_clientAddr,&amp;_addr_len);//自身套接字 客户端结构体 结构体大小 if(INVALID_SOCKET == _temp_socket)//接收失败 &#123; cout&lt;&lt;&quot;接收到无效客户端Socket&quot;&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;&quot;新客户端加入&quot;&lt;&lt;endl; printf(&quot;IP地址为：%s \\n&quot;, inet_ntoa(_clientAddr.sin_addr)); &#125; while(true) &#123; //接收客户端发送的数据 DateHeader _head = &#123;&#125;; int _buf_len = recv(_temp_socket,(char*)&amp;_head,sizeof(DateHeader),0); if(_buf_len&lt;=0) &#123; printf(&quot;客户端已退出\\n&quot;); break; &#125; printf(&quot;接收到包头，命令：%d，数据长度：%d\\n&quot;,_head.cmd,_head.date_length); switch(_head.cmd) &#123; case CMD_LOGIN://登录 接收登录包体 &#123; Login _login; recv(_temp_socket,(char*)&amp;_login+sizeof(DateHeader),sizeof(Login)-sizeof(DateHeader),0); /* 进行判断操作 */ printf(&quot;%s已登录\\n密码：%s\\n&quot;,_login.UserName,_login.PassWord); LoginResult _result; _result.Result = 1; send(_temp_socket,(char*)&amp;_result,sizeof(LoginResult),0);//发包体 &#125; break; case CMD_LOGOUT://登出 接收登出包体 &#123; Logout _logout; recv(_temp_socket,(char*)&amp;_logout+sizeof(DateHeader),sizeof(Logout)-sizeof(DateHeader),0); /* 进行判断操作 */ printf(&quot;%s已登出\\n&quot;,_logout.UserName); LogoutResult _result; _result.Result = 1; send(_temp_socket,(char*)&amp;_result,sizeof(LogoutResult),0);//发包体 &#125; break; default://错误 &#123; _head.cmd = CMD_ERROR; _head.date_length = 0; send(_temp_socket,(char*)&amp;_head,sizeof(DateHeader),0);//发包头 &#125; break; &#125; &#125; //关闭客户端socket closesocket(_temp_socket); //关闭socket closesocket(_mysocket); //清除windows socket 环境 WSACleanup(); printf(&quot;任务结束，程序已退出&quot;); getchar(); return 0;&#125; 2.2 客户端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#define WIN32_LEAN_AND_MEAN#include&lt;winSock2.h&gt;#include&lt;windows.h&gt;#include&lt;bits/stdc++.h&gt;#pragma comment(lib,&quot;ws2_32.lib&quot;)//链接此动态链接库 windows特有 using namespace std; //枚举类型记录命令 enum cmd &#123; CMD_LOGIN,//登录 CMD_LOGINRESULT,//登录结果 CMD_LOGOUT,//登出 CMD_LOGOUTRESULT,//登出结果 CMD_ERROR//错误 &#125;;//定义数据包头 struct DateHeader &#123; short cmd;//命令 short date_length;//数据的长短 &#125;;//包1 登录 传输账号与密码struct Login : public DateHeader &#123; Login()//初始化包头 &#123; this-&gt;cmd = CMD_LOGIN; this-&gt;date_length = sizeof(Login); &#125; char UserName[32];//用户名 char PassWord[32];//密码 &#125;;//包2 登录结果 传输结果struct LoginResult : public DateHeader &#123; LoginResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGINRESULT; this-&gt;date_length = sizeof(LoginResult); &#125; int Result;&#125;;//包3 登出 传输用户名 struct Logout : public DateHeader &#123; Logout()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUT; this-&gt;date_length = sizeof(Logout); &#125; char UserName[32];//用户名 &#125;;//包4 登出结果 传输结果struct LogoutResult : public DateHeader &#123; LogoutResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUTRESULT; this-&gt;date_length = sizeof(LogoutResult); &#125; int Result;&#125;; int main()&#123; //启动windows socket 2,x环境 windows特有 WORD ver = MAKEWORD(2,2);//WinSock库版本号 WSADATA dat;//网络结构体 储存WSAStartup函数调用后返回的Socket数据 if(0 != WSAStartup(ver,&amp;dat))//正确初始化后返回0 &#123; return 0; &#125; //建立一个socket SOCKET _mysocket = socket(AF_INET,SOCK_STREAM,0);//IPV4 数据流类型 类型可以不用写 if(INVALID_SOCKET == _mysocket)//建立失败 &#123; return 0; &#125; //连接服务器 sockaddr_in _sin = &#123;&#125;;//sockaddr结构体 _sin.sin_family = AF_INET;//IPV4 _sin.sin_port = htons(8888);//想要连接的端口号 _sin.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);//想要连接的IP if(SOCKET_ERROR == connect(_mysocket,(sockaddr*)&amp;_sin,sizeof(sockaddr_in))) &#123; cout&lt;&lt;&quot;连接失败&quot;&lt;&lt;endl; closesocket(_mysocket); &#125; else &#123; cout&lt;&lt;&quot;连接成功&quot;&lt;&lt;endl; &#125; while(true) &#123; //输入请求 char _msg[256] = &#123;&#125;; scanf(&quot;%s&quot;,_msg); //处理请求 if(0 == strcmp(_msg,&quot;exit&quot;)) &#123; break; &#125; else if(0 == strcmp(_msg,&quot;login&quot;)) &#123; //发送 Login _login; strcpy(_login.UserName,&quot;河边小咸鱼&quot;); strcpy(_login.PassWord,&quot;123456&quot;); send(_mysocket,(const char*)&amp;_login,sizeof(_login),0); //接收 LoginResult _result; recv(_mysocket,(char*)&amp;_result,sizeof(LoginResult),0); printf(&quot;result:%d\\n&quot;,_result.Result); &#125; else if(0 == strcmp(_msg,&quot;logout&quot;)) &#123; //发送 Logout _logout; strcpy(_logout.UserName,&quot;河边小咸鱼&quot;); send(_mysocket,(const char*)&amp;_logout,sizeof(_logout),0); //接收 LogoutResult _result; recv(_mysocket,(char*)&amp;_result,sizeof(LogoutResult),0); printf(&quot;result:%d\\n&quot;,_result.Result); &#125; else &#123; printf(&quot;不存在的命令\\n&quot;); &#125; &#125; //关闭socket closesocket(_mysocket); //清除windows socket 环境 WSACleanup(); return 0;&#125; 网络编程学习记录 使用的语言为C&#x2F;C++ 源码支持的平台为：Windows 笔记一：建立基础TCP服务端&#x2F;客户端 &emsp;点我跳转笔记二：网络数据报文的收发 &emsp;点我跳转笔记三：升级为select网络模型 &emsp;点我跳转笔记四：跨平台支持Windows、Linux系统 &emsp;点我跳转笔记五：源码的封装 &emsp;点我跳转笔记六：缓冲区溢出与粘包分包 &emsp;点我跳转笔记七：服务端多线程分离业务处理高负载 &emsp;点我跳转笔记八：对socket select网络模型的优化 &emsp;点我跳转笔记九：消息接收与发送分离 &emsp;点我跳转笔记十：项目化 (加入内存池静态库 &#x2F; 报文动态库) &emsp;更多笔记请点我 @TOC 一、网络数据报文的格式定义 报文有两个部分，包头和包体，是网络消息的基本单元。 包头： 描述本次消息包的大小，描述包体数据的作用。 包体： 其中包含了需要传输的数据。 &emsp;&emsp;根据此数据结构，我们可以根据包头的内容，来灵活的对包体的数据进行处理。 二、将包头与包体数据分开收发1.概括&emsp;&emsp;通过上文对网络数据报文的定义，我们可以很轻易的想到： 发送端进行两次send操作，第一次send发送包头，第二次send发送包体，即可实现网络数据报文的发送。 接收端进行两次recv操作，第一次recv接收包头，第二次recv接收包体并根据包头的内容进行数据处理，即可实现网络数据报文的接收。 &emsp;&emsp;按以上操作，即可实现网络数据报文的收发。 2.代码及其详细注释2.1 服务端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166#define WIN32_LEAN_AND_MEAN#include&lt;winSock2.h&gt;#include&lt;windows.h&gt;#include&lt;bits/stdc++.h&gt;#pragma comment(lib,&quot;ws2_32.lib&quot;)//链接此动态链接库 windows特有 using namespace std; //枚举类型记录命令 enum cmd &#123; CMD_LOGIN,//登录 CMD_LOGOUT,//登出 CMD_ERROR//错误 &#125;;//定义数据包头 struct DateHeader &#123; short cmd;//命令 short date_length;//数据的长短 &#125;;//包体1 登录 传输账号与密码struct Login&#123; char UserName[32];//用户名 char PassWord[32];//密码 &#125;;//包体2 登录结果 传输结果struct LoginResult &#123; int Result;&#125;;//包体3 登出 传输用户名 struct Logout&#123; char UserName[32];//用户名 &#125;;//包体4 登出结果 传输结果struct LogoutResult &#123; int Result;&#125;; int main() &#123; //启动windows socket 2,x环境 windows特有 WORD ver = MAKEWORD(2,2);//WinSock库版本号 WSADATA dat;//网络结构体 储存WSAStartup函数调用后返回的Socket数据 if(0 != WSAStartup(ver,&amp;dat))//正确初始化后返回0 &#123; return 0; &#125; //建立一个socket SOCKET _mysocket = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);//IPV4 数据流类型 TCP类型 if(INVALID_SOCKET == _mysocket)//建立失败 &#123; return 0; &#125; //绑定网络端口和IP地址 sockaddr_in _myaddr = &#123;&#125;;//建立sockaddr结构体 sockaddr_in结构体方便填写 但是下面要进行类型转换 _myaddr.sin_family = AF_INET;//IPV4 _myaddr.sin_port = htons(8888);//端口 host to net unsigned short _myaddr.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);//网络地址 INADDR_ANY监听所有网卡的端口 if(SOCKET_ERROR == bind(_mysocket,(sockaddr*)&amp;_myaddr,sizeof(sockaddr_in)))//socket (强制转换)sockaddr结构体 结构体大小 &#123; cout&lt;&lt;&quot;绑定不成功&quot;&lt;&lt;endl; &#125; else &#123; //cout&lt;&lt;&quot;绑定成功&quot;&lt;&lt;endl; &#125; //监听网络端口 if(SOCKET_ERROR == listen(_mysocket,5))//套接字 最大多少人连接 &#123; cout&lt;&lt;&quot;监听失败&quot;&lt;&lt;endl; &#125; else &#123; //cout&lt;&lt;&quot;监听成功&quot;&lt;&lt;endl; &#125; //等待接收客户端连接 sockaddr_in _clientAddr = &#123;&#125;;//新建sockadd结构体接收客户端数据 int _addr_len = sizeof(sockaddr_in);//获取sockadd结构体长度 SOCKET _temp_socket = INVALID_SOCKET;//声明客户端套接字 _temp_socket = accept(_mysocket,(sockaddr*)&amp;_clientAddr,&amp;_addr_len);//自身套接字 客户端结构体 结构体大小 if(INVALID_SOCKET == _temp_socket)//接收失败 &#123; cout&lt;&lt;&quot;接收到无效客户端Socket&quot;&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;&quot;新客户端加入&quot;&lt;&lt;endl; printf(&quot;IP地址为：%s \\n&quot;, inet_ntoa(_clientAddr.sin_addr)); &#125; while(true) &#123; //接收客户端发送的数据 DateHeader _head = &#123;&#125;; int _buf_len = recv(_temp_socket,(char*)&amp;_head,sizeof(DateHeader),0); if(_buf_len&lt;=0) &#123; printf(&quot;客户端已退出\\n&quot;); break; &#125; printf(&quot;接收到包头，命令：%d，数据长度：%d\\n&quot;,_head.cmd,_head.date_length); switch(_head.cmd) &#123; case CMD_LOGIN://登录 接收登录包体 &#123; Login _login = &#123;&#125;; recv(_temp_socket,(char*)&amp;_login,sizeof(Login),0); /* 进行判断操作 */ printf(&quot;%s已登录\\n&quot;,_login.UserName); send(_temp_socket,(char*)&amp;_head,sizeof(DateHeader),0);//发包头 LoginResult _result = &#123;1&#125;; send(_temp_socket,(char*)&amp;_result,sizeof(LoginResult),0);//发包体 &#125; break; case CMD_LOGOUT://登出 接收登出包体 &#123; Logout _logout = &#123;&#125;; recv(_temp_socket,(char*)&amp;_logout,sizeof(Logout),0); /* 进行判断操作 */ printf(&quot;%s已登出\\n&quot;,_logout.UserName); send(_temp_socket,(char*)&amp;_head,sizeof(DateHeader),0);//发包头 LogoutResult _result = &#123;1&#125;; send(_temp_socket,(char*)&amp;_result,sizeof(LogoutResult),0);//发包体 &#125; break; default://错误 &#123; _head.cmd = CMD_ERROR; _head.date_length = 0; send(_temp_socket,(char*)&amp;_head,sizeof(DateHeader),0);//发包头 &#125; break; &#125; &#125; //关闭客户端socket closesocket(_temp_socket); //关闭socket closesocket(_mysocket); //清除windows socket 环境 WSACleanup(); printf(&quot;任务结束，程序已退出&quot;); getchar(); return 0;&#125; 2.2 客户端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#define WIN32_LEAN_AND_MEAN#include&lt;winSock2.h&gt;#include&lt;windows.h&gt;#include&lt;bits/stdc++.h&gt;#pragma comment(lib,&quot;ws2_32.lib&quot;)//链接此动态链接库 windows特有 using namespace std; //枚举类型记录命令 enum cmd &#123; CMD_LOGIN,//登录 CMD_LOGOUT,//登出 CMD_ERROR//错误 &#125;;//定义数据包头 struct DateHeader &#123; short cmd;//命令 short date_length;//数据的长短 &#125;;//包体1 登录 传输账号与密码struct Login&#123; char UserName[32];//用户名 char PassWord[32];//密码 &#125;;//包体2 登录结果 传输结果struct LoginResult &#123; int Result;&#125;;//包体3 登出 传输用户名 struct Logout&#123; char UserName[32];//用户名 &#125;;//包体4 登出结果 传输结果struct LogoutResult &#123; int Result;&#125;; int main()&#123; //启动windows socket 2,x环境 windows特有 WORD ver = MAKEWORD(2,2);//WinSock库版本号 WSADATA dat;//网络结构体 储存WSAStartup函数调用后返回的Socket数据 if(0 != WSAStartup(ver,&amp;dat))//正确初始化后返回0 &#123; return 0; &#125; //建立一个socket SOCKET _mysocket = socket(AF_INET,SOCK_STREAM,0);//IPV4 数据流类型 类型可以不用写 if(INVALID_SOCKET == _mysocket)//建立失败 &#123; return 0; &#125; //连接服务器 sockaddr_in _sin = &#123;&#125;;//sockaddr结构体 _sin.sin_family = AF_INET;//IPV4 _sin.sin_port = htons(8888);//想要连接的端口号 _sin.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);//想要连接的IP if(SOCKET_ERROR == connect(_mysocket,(sockaddr*)&amp;_sin,sizeof(sockaddr_in))) &#123; cout&lt;&lt;&quot;连接失败&quot;&lt;&lt;endl; closesocket(_mysocket); &#125; else &#123; cout&lt;&lt;&quot;连接成功&quot;&lt;&lt;endl; &#125; while(true) &#123; //输入请求 char _msg[256] = &#123;&#125;; scanf(&quot;%s&quot;,_msg); //处理请求 if(0 == strcmp(_msg,&quot;exit&quot;)) &#123; break; &#125; else if(0 == strcmp(_msg,&quot;login&quot;)) &#123; //发送 Login _login = &#123;&quot;河边小咸鱼&quot;,&quot;123456&quot;&#125;; DateHeader _head = &#123;CMD_LOGIN,sizeof(_login)&#125;; send(_mysocket,(const char*)&amp;_head,sizeof(_head),0); send(_mysocket,(const char*)&amp;_login,sizeof(_login),0); //接收 DateHeader _head2 = &#123;&#125;; LoginResult _result= &#123;&#125;; recv(_mysocket,(char*)&amp;_head2,sizeof(DateHeader),0); recv(_mysocket,(char*)&amp;_result,sizeof(LoginResult),0); printf(&quot;result:%d\\n&quot;,_result.Result); &#125; else if(0 == strcmp(_msg,&quot;logout&quot;)) &#123; //发送 Logout _logout = &#123;&quot;河边小咸鱼&quot;&#125;; DateHeader _head = &#123;CMD_LOGOUT,sizeof(_logout)&#125;; send(_mysocket,(const char*)&amp;_head,sizeof(_head),0); send(_mysocket,(const char*)&amp;_logout,sizeof(_logout),0); //接收 DateHeader _head2 = &#123;&#125;; LogoutResult _result= &#123;&#125;; recv(_mysocket,(char*)&amp;_head2,sizeof(DateHeader),0); recv(_mysocket,(char*)&amp;_result,sizeof(LogoutResult),0); printf(&quot;result:%d\\n&quot;,_result.Result); &#125; else &#123; printf(&quot;不存在的命令\\n&quot;); &#125; &#125; //关闭socket closesocket(_mysocket); //清除windows socket 环境 WSACleanup(); return 0;&#125; 三、将分开收发报文数据改为一次收发1.思路&emsp;&emsp;由上文，我们可以知道，可以通过两次send和两次recv进行报文的收发，但是其中操作较为麻烦，需要多次声明DateHeader包头结构体，不仅消耗时间资源，也容易出错。&emsp;&emsp;因此，我们可以尝试将分开收发改为一次收发。大致思路为完善报文的结构体，使包体继承包头结构体，或者使包体结构体中包含一个包头结构体。由此完善报文的结构体，只进行一次send操作，即可发送所有报文数据。&emsp;&emsp;在进行数据接收时，我们先接收包头大小的数据，随后根据包头的内容，来确定接下来接收数据的大小，即接收 总数据大小 减去 包头数据大小 的数据。而在接下来使用recv接收剩下数据时，要使用指针偏移，跳过结构体包头的接收(因为接收过了)，直接接收到包体数据位置上。 12345/*因为包头已经接收过了 所以进行指针偏移：&amp;_login+sizeof(DateHeader)接收数据长短为：sizeof(Login)-sizeof(DateHeader) 减去包头的大小*/recv(_temp_socket,(char*)&amp;_login+sizeof(DateHeader),sizeof(Login)-sizeof(DateHeader),0); 2.代码及其详细注释2.1 服务端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#define WIN32_LEAN_AND_MEAN#include&lt;winSock2.h&gt;#include&lt;windows.h&gt;#include&lt;bits/stdc++.h&gt;#pragma comment(lib,&quot;ws2_32.lib&quot;)//链接此动态链接库 windows特有 using namespace std; //枚举类型记录命令 enum cmd &#123; CMD_LOGIN,//登录 CMD_LOGINRESULT,//登录结果 CMD_LOGOUT,//登出 CMD_LOGOUTRESULT,//登出结果 CMD_ERROR//错误 &#125;;//定义数据包头 struct DateHeader &#123; short cmd;//命令 short date_length;//数据的长短 &#125;;//包1 登录 传输账号与密码struct Login : public DateHeader &#123; Login()//初始化包头 &#123; this-&gt;cmd = CMD_LOGIN; this-&gt;date_length = sizeof(Login); &#125; char UserName[32];//用户名 char PassWord[32];//密码 &#125;;//包2 登录结果 传输结果struct LoginResult : public DateHeader &#123; LoginResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGINRESULT; this-&gt;date_length = sizeof(LoginResult); &#125; int Result;&#125;;//包3 登出 传输用户名 struct Logout : public DateHeader &#123; Logout()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUT; this-&gt;date_length = sizeof(Logout); &#125; char UserName[32];//用户名 &#125;;//包4 登出结果 传输结果struct LogoutResult : public DateHeader &#123; LogoutResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUTRESULT; this-&gt;date_length = sizeof(LogoutResult); &#125; int Result;&#125;; int main() &#123; //启动windows socket 2,x环境 windows特有 WORD ver = MAKEWORD(2,2);//WinSock库版本号 WSADATA dat;//网络结构体 储存WSAStartup函数调用后返回的Socket数据 if(0 != WSAStartup(ver,&amp;dat))//正确初始化后返回0 &#123; return 0; &#125; //建立一个socket SOCKET _mysocket = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);//IPV4 数据流类型 TCP类型 if(INVALID_SOCKET == _mysocket)//建立失败 &#123; return 0; &#125; //绑定网络端口和IP地址 sockaddr_in _myaddr = &#123;&#125;;//建立sockaddr结构体 sockaddr_in结构体方便填写 但是下面要进行类型转换 _myaddr.sin_family = AF_INET;//IPV4 _myaddr.sin_port = htons(8888);//端口 host to net unsigned short _myaddr.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);//网络地址 INADDR_ANY监听所有网卡的端口 if(SOCKET_ERROR == bind(_mysocket,(sockaddr*)&amp;_myaddr,sizeof(sockaddr_in)))//socket (强制转换)sockaddr结构体 结构体大小 &#123; cout&lt;&lt;&quot;绑定不成功&quot;&lt;&lt;endl; &#125; else &#123; //cout&lt;&lt;&quot;绑定成功&quot;&lt;&lt;endl; &#125; //监听网络端口 if(SOCKET_ERROR == listen(_mysocket,5))//套接字 最大多少人连接 &#123; cout&lt;&lt;&quot;监听失败&quot;&lt;&lt;endl; &#125; else &#123; //cout&lt;&lt;&quot;监听成功&quot;&lt;&lt;endl; &#125; //等待接收客户端连接 sockaddr_in _clientAddr = &#123;&#125;;//新建sockadd结构体接收客户端数据 int _addr_len = sizeof(sockaddr_in);//获取sockadd结构体长度 SOCKET _temp_socket = INVALID_SOCKET;//声明客户端套接字 _temp_socket = accept(_mysocket,(sockaddr*)&amp;_clientAddr,&amp;_addr_len);//自身套接字 客户端结构体 结构体大小 if(INVALID_SOCKET == _temp_socket)//接收失败 &#123; cout&lt;&lt;&quot;接收到无效客户端Socket&quot;&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;&quot;新客户端加入&quot;&lt;&lt;endl; printf(&quot;IP地址为：%s \\n&quot;, inet_ntoa(_clientAddr.sin_addr)); &#125; while(true) &#123; //接收客户端发送的数据 DateHeader _head = &#123;&#125;; int _buf_len = recv(_temp_socket,(char*)&amp;_head,sizeof(DateHeader),0); if(_buf_len&lt;=0) &#123; printf(&quot;客户端已退出\\n&quot;); break; &#125; printf(&quot;接收到包头，命令：%d，数据长度：%d\\n&quot;,_head.cmd,_head.date_length); switch(_head.cmd) &#123; case CMD_LOGIN://登录 接收登录包体 &#123; Login _login; recv(_temp_socket,(char*)&amp;_login+sizeof(DateHeader),sizeof(Login)-sizeof(DateHeader),0); /* 进行判断操作 */ printf(&quot;%s已登录\\n密码：%s\\n&quot;,_login.UserName,_login.PassWord); LoginResult _result; _result.Result = 1; send(_temp_socket,(char*)&amp;_result,sizeof(LoginResult),0);//发包体 &#125; break; case CMD_LOGOUT://登出 接收登出包体 &#123; Logout _logout; recv(_temp_socket,(char*)&amp;_logout+sizeof(DateHeader),sizeof(Logout)-sizeof(DateHeader),0); /* 进行判断操作 */ printf(&quot;%s已登出\\n&quot;,_logout.UserName); LogoutResult _result; _result.Result = 1; send(_temp_socket,(char*)&amp;_result,sizeof(LogoutResult),0);//发包体 &#125; break; default://错误 &#123; _head.cmd = CMD_ERROR; _head.date_length = 0; send(_temp_socket,(char*)&amp;_head,sizeof(DateHeader),0);//发包头 &#125; break; &#125; &#125; //关闭客户端socket closesocket(_temp_socket); //关闭socket closesocket(_mysocket); //清除windows socket 环境 WSACleanup(); printf(&quot;任务结束，程序已退出&quot;); getchar(); return 0;&#125; 2.2 客户端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#define WIN32_LEAN_AND_MEAN#include&lt;winSock2.h&gt;#include&lt;windows.h&gt;#include&lt;bits/stdc++.h&gt;#pragma comment(lib,&quot;ws2_32.lib&quot;)//链接此动态链接库 windows特有 using namespace std; //枚举类型记录命令 enum cmd &#123; CMD_LOGIN,//登录 CMD_LOGINRESULT,//登录结果 CMD_LOGOUT,//登出 CMD_LOGOUTRESULT,//登出结果 CMD_ERROR//错误 &#125;;//定义数据包头 struct DateHeader &#123; short cmd;//命令 short date_length;//数据的长短 &#125;;//包1 登录 传输账号与密码struct Login : public DateHeader &#123; Login()//初始化包头 &#123; this-&gt;cmd = CMD_LOGIN; this-&gt;date_length = sizeof(Login); &#125; char UserName[32];//用户名 char PassWord[32];//密码 &#125;;//包2 登录结果 传输结果struct LoginResult : public DateHeader &#123; LoginResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGINRESULT; this-&gt;date_length = sizeof(LoginResult); &#125; int Result;&#125;;//包3 登出 传输用户名 struct Logout : public DateHeader &#123; Logout()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUT; this-&gt;date_length = sizeof(Logout); &#125; char UserName[32];//用户名 &#125;;//包4 登出结果 传输结果struct LogoutResult : public DateHeader &#123; LogoutResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUTRESULT; this-&gt;date_length = sizeof(LogoutResult); &#125; int Result;&#125;; int main()&#123; //启动windows socket 2,x环境 windows特有 WORD ver = MAKEWORD(2,2);//WinSock库版本号 WSADATA dat;//网络结构体 储存WSAStartup函数调用后返回的Socket数据 if(0 != WSAStartup(ver,&amp;dat))//正确初始化后返回0 &#123; return 0; &#125; //建立一个socket SOCKET _mysocket = socket(AF_INET,SOCK_STREAM,0);//IPV4 数据流类型 类型可以不用写 if(INVALID_SOCKET == _mysocket)//建立失败 &#123; return 0; &#125; //连接服务器 sockaddr_in _sin = &#123;&#125;;//sockaddr结构体 _sin.sin_family = AF_INET;//IPV4 _sin.sin_port = htons(8888);//想要连接的端口号 _sin.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);//想要连接的IP if(SOCKET_ERROR == connect(_mysocket,(sockaddr*)&amp;_sin,sizeof(sockaddr_in))) &#123; cout&lt;&lt;&quot;连接失败&quot;&lt;&lt;endl; closesocket(_mysocket); &#125; else &#123; cout&lt;&lt;&quot;连接成功&quot;&lt;&lt;endl; &#125; while(true) &#123; //输入请求 char _msg[256] = &#123;&#125;; scanf(&quot;%s&quot;,_msg); //处理请求 if(0 == strcmp(_msg,&quot;exit&quot;)) &#123; break; &#125; else if(0 == strcmp(_msg,&quot;login&quot;)) &#123; //发送 Login _login; strcpy(_login.UserName,&quot;河边小咸鱼&quot;); strcpy(_login.PassWord,&quot;123456&quot;); send(_mysocket,(const char*)&amp;_login,sizeof(_login),0); //接收 LoginResult _result; recv(_mysocket,(char*)&amp;_result,sizeof(LoginResult),0); printf(&quot;result:%d\\n&quot;,_result.Result); &#125; else if(0 == strcmp(_msg,&quot;logout&quot;)) &#123; //发送 Logout _logout; strcpy(_logout.UserName,&quot;河边小咸鱼&quot;); send(_mysocket,(const char*)&amp;_logout,sizeof(_logout),0); //接收 LogoutResult _result; recv(_mysocket,(char*)&amp;_result,sizeof(LogoutResult),0); printf(&quot;result:%d\\n&quot;,_result.Result); &#125; else &#123; printf(&quot;不存在的命令\\n&quot;); &#125; &#125; //关闭socket closesocket(_mysocket); //清除windows socket 环境 WSACleanup(); return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"网络编程","slug":"网络编程","permalink":"https://zgg2001.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"C++网络编程学习：建立基础TCP服务端/客户端","slug":"20210121_C++网络编程学习：建立基础TCP服务端-客户端","date":"2021-01-21T09:49:20.000Z","updated":"2021-01-21T09:49:20.000Z","comments":true,"path":"2021/01/21/20210121_C++网络编程学习：建立基础TCP服务端-客户端/","permalink":"https://zgg2001.github.io/2021/01/21/20210121_C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%BB%BA%E7%AB%8B%E5%9F%BA%E7%A1%80TCP%E6%9C%8D%E5%8A%A1%E7%AB%AF-%E5%AE%A2%E6%88%B7%E7%AB%AF/","excerpt":"使用的语言为C&#x2F;C++ 源码支持的平台为：Windows 一、建立简易TCP服务端1.建立服务端大致流程 建立一个套接字 （socket） 绑定客户端连接的端口 （bind） 监听网络端口 （listen） 等待接受客户端连接 （accept） 接收客户端发送的数据 （recv） 向客户端发送数据 （send） 关闭套接字 （closesocket）","text":"使用的语言为C&#x2F;C++ 源码支持的平台为：Windows 一、建立简易TCP服务端1.建立服务端大致流程 建立一个套接字 （socket） 绑定客户端连接的端口 （bind） 监听网络端口 （listen） 等待接受客户端连接 （accept） 接收客户端发送的数据 （recv） 向客户端发送数据 （send） 关闭套接字 （closesocket） 2.代码实现以及详细注释123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#define WIN32_LEAN_AND_MEAN//消除下面两个头文件存在的冲突#include&lt;winSock2.h&gt;//此头文件应在windows.h头文件的上面，否则会有冲突#include&lt;windows.h&gt;#include&lt;bits/stdc++.h&gt;#pragma comment(lib,&quot;ws2_32.lib&quot;)//链接此动态链接库 windows特有 using namespace std; int main() &#123; //启动windows socket 2,x环境 windows特有 WORD ver = MAKEWORD(2,2);//WinSock库版本号 WSADATA dat;//网络结构体 储存WSAStartup函数调用后返回的Socket数据 if(0 != WSAStartup(ver,&amp;dat))//正确初始化后返回0 &#123; return 0; &#125; //建立一个socket SOCKET _mysocket = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);//IPV4 数据流类型 TCP类型 if(INVALID_SOCKET == _mysocket)//建立失败 &#123; return 0; &#125; //绑定网络端口和IP地址 sockaddr_in _myaddr = &#123;&#125;;//建立sockaddr结构体 sockaddr_in结构体方便填写 但是下面要进行类型转换 _myaddr.sin_family = AF_INET;//IPV4 _myaddr.sin_port = htons(8888);//端口 host to net unsigned short _myaddr.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);//网络地址 INADDR_ANY监听所有网卡的端口 if(SOCKET_ERROR == bind(_mysocket,(sockaddr*)&amp;_myaddr,sizeof(sockaddr_in)))//socket (强制转换)sockaddr结构体 结构体大小 &#123; cout&lt;&lt;&quot;绑定不成功&quot;&lt;&lt;endl; &#125; else &#123; //cout&lt;&lt;&quot;绑定成功&quot;&lt;&lt;endl; &#125; //监听网络端口 if(SOCKET_ERROR == listen(_mysocket,5))//套接字 最大多少人连接 &#123; cout&lt;&lt;&quot;监听失败&quot;&lt;&lt;endl; &#125; else &#123; //cout&lt;&lt;&quot;监听成功&quot;&lt;&lt;endl; &#125; //等待接收客户端连接 sockaddr_in _clientAddr = &#123;&#125;;//新建sockadd结构体接收客户端数据 int _addr_len = sizeof(sockaddr_in);//获取sockadd结构体长度 SOCKET _temp_socket = INVALID_SOCKET;//声明客户端套接字 char _buf[256] = &#123;&#125;;//接收客户端发送的消息 while(true) &#123; _temp_socket = accept(_mysocket,(sockaddr*)&amp;_clientAddr,&amp;_addr_len);//自身套接字 客户端结构体 结构体大小 if(INVALID_SOCKET == _temp_socket)//接收失败 &#123; cout&lt;&lt;&quot;接收到无效客户端Socket&quot;&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;&quot;新客户端加入&quot;&lt;&lt;endl; printf(&quot;IP地址为：%s \\n&quot;, inet_ntoa(_clientAddr.sin_addr)); &#125; //接收客户端发送的数据 char _buf[256] = &#123;&#125;; int _buf_len = recv(_temp_socket,_buf,256,0); if(_buf_len&gt;0) &#123; printf(&quot;%s\\n&quot;,_buf); &#125; //向客户端发送数据 char _msg[] = &quot;HelloWorld&quot;; send(_temp_socket,_msg,strlen(_msg)+1,0);//客户端套接字 数据 数据长短 flag //关闭客户端socket closesocket(_temp_socket); &#125; //关闭socket closesocket(_mysocket); //清除windows socket 环境 WSACleanup(); return 0;&#125; 二、建立简易TCP客户端1.建立客户端大致流程 建立一个套接字 （socket） 连接服务器 （connect） 向客户端发送数据 （send） 接收客户端发送的数据 （recv） 关闭套接字 （closesocket） 2.代码实现以及详细注释1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#define WIN32_LEAN_AND_MEAN#include&lt;winSock2.h&gt;#include&lt;windows.h&gt;#include&lt;bits/stdc++.h&gt;#pragma comment(lib,&quot;ws2_32.lib&quot;)//链接此动态链接库 windows特有 using namespace std; int main()&#123; //启动windows socket 2,x环境 windows特有 WORD ver = MAKEWORD(2,2);//WinSock库版本号 WSADATA dat;//网络结构体 储存WSAStartup函数调用后返回的Socket数据 if(0 != WSAStartup(ver,&amp;dat))//正确初始化后返回0 &#123; return 0; &#125; //建立一个socket SOCKET _mysocket = socket(AF_INET,SOCK_STREAM,0);//IPV4 数据流类型 类型可以不用写 if(INVALID_SOCKET == _mysocket)//建立失败 &#123; return 0; &#125; //连接服务器 sockaddr_in _sin = &#123;&#125;;//sockaddr结构体 _sin.sin_family = AF_INET;//IPV4 _sin.sin_port = htons(8888);//想要连接的端口号 _sin.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);//想要连接的IP if(SOCKET_ERROR == connect(_mysocket,(sockaddr*)&amp;_sin,sizeof(sockaddr_in))) &#123; cout&lt;&lt;&quot;连接失败&quot;&lt;&lt;endl; closesocket(_mysocket); &#125; else &#123; cout&lt;&lt;&quot;连接成功&quot;&lt;&lt;endl; &#125; //向客户端发送数据 char _msg[] = &quot;HelloServer&quot;; send(_mysocket,_msg,strlen(_msg)+1,0);//客户端套接字 数据 数据长短 flag //接收服务器信息 char _buf[256] = &#123;&#125;; int _buf_len = recv(_mysocket,_buf,256,0); if(_buf_len&gt;0) &#123; printf(&quot;%s\\n&quot;,_buf); &#125; //关闭socket closesocket(_mysocket); //清除windows socket 环境 WSACleanup(); return 0;&#125; 三、建立可持续处理请求的网络程序1.思路&emsp;&emsp;在进行socket连接后，即服务端进行accept操作、客户端进行connect操作后，使用循环，在此循环中进行send&#x2F;recv操作传输数据，即可实现持续处理请求。 2.代码实现以及详细注释2.1 服务端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#define WIN32_LEAN_AND_MEAN#include&lt;winSock2.h&gt;#include&lt;windows.h&gt;#include&lt;bits/stdc++.h&gt;#pragma comment(lib,&quot;ws2_32.lib&quot;)//链接此动态链接库 windows特有 using namespace std; int main() &#123; //启动windows socket 2,x环境 windows特有 WORD ver = MAKEWORD(2,2);//WinSock库版本号 WSADATA dat;//网络结构体 储存WSAStartup函数调用后返回的Socket数据 if(0 != WSAStartup(ver,&amp;dat))//正确初始化后返回0 &#123; return 0; &#125; //建立一个socket SOCKET _mysocket = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);//IPV4 数据流类型 TCP类型 if(INVALID_SOCKET == _mysocket)//建立失败 &#123; return 0; &#125; //绑定网络端口和IP地址 sockaddr_in _myaddr = &#123;&#125;;//建立sockaddr结构体 sockaddr_in结构体方便填写 但是下面要进行类型转换 _myaddr.sin_family = AF_INET;//IPV4 _myaddr.sin_port = htons(8888);//端口 host to net unsigned short _myaddr.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);//网络地址 INADDR_ANY监听所有网卡的端口 if(SOCKET_ERROR == bind(_mysocket,(sockaddr*)&amp;_myaddr,sizeof(sockaddr_in)))//socket (强制转换)sockaddr结构体 结构体大小 &#123; cout&lt;&lt;&quot;绑定不成功&quot;&lt;&lt;endl; &#125; else &#123; //cout&lt;&lt;&quot;绑定成功&quot;&lt;&lt;endl; &#125; //监听网络端口 if(SOCKET_ERROR == listen(_mysocket,5))//套接字 最大多少人连接 &#123; cout&lt;&lt;&quot;监听失败&quot;&lt;&lt;endl; &#125; else &#123; //cout&lt;&lt;&quot;监听成功&quot;&lt;&lt;endl; &#125; //等待接收客户端连接 sockaddr_in _clientAddr = &#123;&#125;;//新建sockadd结构体接收客户端数据 int _addr_len = sizeof(sockaddr_in);//获取sockadd结构体长度 SOCKET _temp_socket = INVALID_SOCKET;//声明客户端套接字 char _buf[256] = &#123;&#125;;//接收客户端发送的消息 _temp_socket = accept(_mysocket,(sockaddr*)&amp;_clientAddr,&amp;_addr_len);//自身套接字 客户端结构体 结构体大小 if(INVALID_SOCKET == _temp_socket)//接收失败 &#123; cout&lt;&lt;&quot;接收到无效客户端Socket&quot;&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;&quot;新客户端加入&quot;&lt;&lt;endl; printf(&quot;IP地址为：%s \\n&quot;, inet_ntoa(_clientAddr.sin_addr)); &#125; while(true)//循环 &#123; //接收客户端发送的数据 int _buf_len = recv(_temp_socket,_buf,256,0); if(_buf_len&lt;=0) &#123; printf(&quot;客户端已退出\\n&quot;); break; &#125; if(0 == strcmp(_buf,&quot;getname&quot;)) &#123; //向客户端发送数据 char _msg[] = &quot;My name is Mr.Zhao&quot;; send(_temp_socket,_msg,strlen(_msg)+1,0);//客户端套接字 数据 数据长短 flag &#125; else if(0 == strcmp(_buf,&quot;getage&quot;)) &#123; //向客户端发送数据 char _msg[] = &quot;My age is 19&quot;; send(_temp_socket,_msg,strlen(_msg)+1,0);//客户端套接字 数据 数据长短 flag &#125; else &#123; //向客户端发送数据 char _msg[] = &quot;???&quot;; send(_temp_socket,_msg,strlen(_msg)+1,0);//客户端套接字 数据 数据长短 flag &#125; &#125; //关闭客户端socket closesocket(_temp_socket); //关闭socket closesocket(_mysocket); //清除windows socket 环境 WSACleanup(); printf(&quot;任务结束，程序已退出&quot;); getchar(); return 0;&#125; 2.2 客户端代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#define WIN32_LEAN_AND_MEAN#include&lt;winSock2.h&gt;#include&lt;windows.h&gt;#include&lt;bits/stdc++.h&gt;#pragma comment(lib,&quot;ws2_32.lib&quot;)//链接此动态链接库 windows特有 using namespace std; int main()&#123; //启动windows socket 2,x环境 windows特有 WORD ver = MAKEWORD(2,2);//WinSock库版本号 WSADATA dat;//网络结构体 储存WSAStartup函数调用后返回的Socket数据 if(0 != WSAStartup(ver,&amp;dat))//正确初始化后返回0 &#123; return 0; &#125; //建立一个socket SOCKET _mysocket = socket(AF_INET,SOCK_STREAM,0);//IPV4 数据流类型 类型可以不用写 if(INVALID_SOCKET == _mysocket)//建立失败 &#123; return 0; &#125; //连接服务器 sockaddr_in _sin = &#123;&#125;;//sockaddr结构体 _sin.sin_family = AF_INET;//IPV4 _sin.sin_port = htons(8888);//想要连接的端口号 _sin.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);//想要连接的IP if(SOCKET_ERROR == connect(_mysocket,(sockaddr*)&amp;_sin,sizeof(sockaddr_in))) &#123; cout&lt;&lt;&quot;连接失败&quot;&lt;&lt;endl; closesocket(_mysocket); &#125; else &#123; cout&lt;&lt;&quot;连接成功&quot;&lt;&lt;endl; &#125; while(true)//循环 &#123; //输入请求 char _msg[256] = &#123;&#125;; scanf(&quot;%s&quot;,_msg); //处理请求 if(0 == strcmp(_msg,&quot;exit&quot;))//退出 &#123; break; &#125; else &#123; //向客户端发送数据 send(_mysocket,_msg,strlen(_msg)+1,0);//客户端套接字 数据 数据长短 flag &#125; //接收服务器信息 char _buf[256] = &#123;&#125;; int _buf_len = recv(_mysocket,_buf,256,0); if(_buf_len&gt;0) &#123; printf(&quot;%s\\n&quot;,_buf); &#125; &#125; //关闭socket closesocket(_mysocket); //清除windows socket 环境 WSACleanup(); return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"网络编程","slug":"网络编程","permalink":"https://zgg2001.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"Java容器及其相关学习记录","slug":"20210119_Java容器及其相关学习记录","date":"2021-01-19T02:54:28.000Z","updated":"2021-01-19T02:54:28.000Z","comments":true,"path":"2021/01/19/20210119_Java容器及其相关学习记录/","permalink":"https://zgg2001.github.io/2021/01/19/20210119_Java%E5%AE%B9%E5%99%A8%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","excerpt":"本文主要记录Java容器相关的内容。更多详细Java学习记录，请看我的另一篇文章：链接点我","text":"本文主要记录Java容器相关的内容。更多详细Java学习记录，请看我的另一篇文章：链接点我 1.容器关系图如图所示： 2.Iterator迭代器主要用于遍历Collection中的元素。由于Java没有指针，所以迭代器的使用相比C++更复杂一点。 2.1 常用方法 import java.util.Iterator; public E next() ：返回迭代的下一个元素。 public boolean hasNext() ：如果仍有元素可以迭代，返回true。 public void remove()： 删除当前指针所指向的元素，一般和next方法一起用，这时候的作用就是删除next方法返回的元素。 2.2 使用实例12345678910111213141516171819202122232425262728import java.util.Collection;import java.util.ArrayList;import java.util.Iterator;public class test &#123; public static void main(String[] args) &#123; Collection&lt;Integer&gt; t1 = new ArrayList&lt;&gt;(); t1.add(1); t1.add(2); t1.add(3); t1.add(4); t1.add(5); //while循环遍历 Iterator&lt;Integer&gt; iter1 = t1.iterator(); while(iter1.hasNext()) &#123; int temp = iter1.next(); System.out.println(temp); &#125; //for循环遍历 for(Iterator&lt;Integer&gt; iter2 = t1.iterator();iter2.hasNext();) &#123; int temp = iter2.next(); System.out.println(temp); &#125; &#125;&#125; 2.3 增强for循环增强for循环，用来遍历集合和数组。是JDK1.5之后出现的新特性，底层使用的也是迭代器，但是简化了使用方法。(不用导Iterator包) 格式： 1234for(集合/数组的数据类型 变量名 : 集合名/数组名)&#123; System.out.println(变量名);&#125; 实例： 12345678910111213141516171819import java.util.Collection;import java.util.ArrayList;public class test &#123; public static void main(String[] args) &#123; Collection&lt;Integer&gt; t1 = new ArrayList&lt;&gt;(); t1.add(1); t1.add(2); t1.add(3); t1.add(4); t1.add(5); //增强for循环 for(int i : t1) &#123; System.out.println(i); &#125; &#125;&#125; 3.Collection（单列集合）Collection是所有单列集合的父接口，其中定义了单列集合(List和Set)通用的一些方法，这些方法可以用于操作所有的单列集合。 import java.util.Collection; public boolean add(E e) ：把给定的对象添加到当前集合中。 public void clear() ：清空集合中的所有元素。 public boolean remove(E e) ：把给定的对象在当前集合中删除。 public boolean contains(E e) ：判断当前集合中是否包含给定的对象。 public boolean isEmpty() ：判断当前集合是否为空。 public int size() ：返回集合中元素的个数。 public Object[] toarray() ：把集合中的元素，储存到数组中。 public Iterator iterator() ： 获取集合所依赖的迭代器对象。 3.1 List（列表）List接口为有序的集合，并且存在索引，**包含了一些带索引的方法(特有)**。List接口中允许存储重复的元素。 import java.util.List; public void add(int index, E element) ：将指定的元素，添加到该集合指定的位置上。 public E get(int index) ：返回集合中指定位置的元素。 public E remove(int index) ：移除列表中指定的元素，返回的为被移除的元素。 public E set(int index, E element) ：用指定的元素替换集合中指定位置的元素，返回值为更新前的元素。 3.1.1 ArrayListArrayList储存结构为数组结构，通过List接口实现大小可变的数组。元素增删慢，查找快。ArrayList的实现是多线程的，也就是实现不是同步的，效率高，但是存在线程安全问题。 import java.util.ArrayList; 3.1.2 LinkedListLinkedList储存结构为链表结构，通过List接口实现双向链表。元素增删快，查找慢。LinkedList提供了大量首尾操作的特有方法，跟C++的STL队列方法思路都差不多。 import java.util.LinkedList; public void addFirst(E e) ：将指定元素添加到列表的开头。 public void addLast(E e) ：将指定元素添加到列表的结尾。 public E getFirst() ：返回此列表的第一个元素。 public E getLast() ：返回此列表的最后一个元素。 public E removeFirst() ：移除并返回列表的第一个元素。 public E removeLast() ：移除并返回列表的最后一个元素。 public E pop() ：从此列表的堆栈处弹出一个元素。此处等效于removeFirst(); public void push(E e) ：将元素推入列表的堆栈。此处等效于addFirst(); public boolean isEmpty() ：如果列表不包含元素，返回true。 3.1.3 VectorVector储存结构为数组结构，通过List接口实现大小可变的数组。元素增删慢，查找快。Vector的实现是单线程的，即实现是同步的，所以效率比ArrayList要低，但是不存在线程安全问题。 import java.util.Vector; 3.2 Set（集合）Set接口与Collection接口中的方法基本一致，没有对Collection进行功能上的扩充，但是比Collection接口更加严格。Set接口中元素无序，且都会以某种规则保证存入的元素不出现重复。也不能通过普通的for循环进行遍历。 (参考C++中的set即可) import java.util.Set; 3.2.1 HashSet底层为一个哈希表(数组加红黑树)，查询的速度非常快。且为一个无序的集合，存储和取出元素的顺序不一定一样。在进行数据add存储时，首先使用hashCode()方法获取哈希值进行比较，如果无重复则直接填入。如果存在哈希冲突，则使用equals()方法进行判重，如果不存在重复则填入。 import java.util.HashSet; 在HashSet存储自定义类型元素时，需重写对象的hashCode方法和equals方法，建立自己的比较方式，从而保证集合中对象唯一。 3.2.2 LinkedHashSet底层为一个哈希表+链表，多的这条链表用来记录元素的存储顺序，保证元素有序，即存储和取出元素的顺序一样。 import java.util.LinkedHashSet; 4.Map（双列集合&#x2F;图）Map为双列集合，一个元素里有两个值(key和value)。key不可重复，value可重复。 import java.util.Map; public V put(K key, V value) ：把指定的键与指定的值添加到Map集合中。 public V remove(Object key) ：把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。 public V get(Object key) ：根据指定的键，在Map集合中获取对应的值。 boolean containsKey(Object key) ：判断集合中是否包含指定的键。 public Set&lt;K&gt; keySet() ：获取Map集合中所有的键，存储到Set集合中。 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() ：获取到Map集合中所有的 键值对 对象的集合(Set集合)。 实例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.Set;import java.util.Map;import java.util.HashMap;public class test &#123; public static void main(String[] args) &#123; Integer temp; Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); //put添加元素 如果key不重复返回值为null;如果key重复,替换value,返回值是老value temp = map.put(&quot;张三&quot;, 18);//temp = null temp = map.put(&quot;张三&quot;, 19);//temp = 18 System.out.println(temp); //remove删除元素 key存在,返回value值;key不存在,返回null map.put(&quot;李四&quot;, 20); temp = map.remove(&quot;李四&quot;);//temp = 20 temp = map.remove(&quot;王五&quot;);//temp = null System.out.println(temp); //get获取元素 key存在,返回value值;key不存在,返回null temp = map.get(&quot;张三&quot;);//temp = 19 temp = map.get(&quot;赵六&quot;);//temp = null System.out.println(temp); //containsKey通过key判断集合中是否包含指定元素 存在返回true boolean bool = map.containsKey(&quot;张三&quot;);//true bool = map.containsKey(&quot;赵六&quot;);//false System.out.println(bool); //keySet 获取一个set,其中储存了map的所有key值 Set&lt;String&gt; set = map.keySet(); for(String i : set)//随后就可以根据set使用增强for或者迭代器进行遍历 &#123; temp = map.get(i); System.out.println(i+&quot; &quot;+temp); &#125; //entrySet 返回一个set,其中储存了map中的所有Entry对象 Set&lt;Map.Entry&lt;String,Integer&gt;&gt; set1 = map.entrySet(); for(Map.Entry&lt;String,Integer&gt; i : set1)//遍历set集合,获取每一个Entry对象 &#123; //通过Entry对象中的方法获取key和value String key = i.getKey(); Integer value = i.getValue(); System.out.println(key+&quot; &quot;+value); &#125; &#125;&#125; 4.1 HashMap底层为哈希表(数组+链表&#x2F;红黑树)，查询速度很快。且为一个无序的集合，存储和取出元素的顺序不一定一样。 import java.util.HashMap; 在HashMap存储自定义类型元素时，需重写key元素的hashCode方法和equals方法，从而保证key唯一。 4.2 LinkedHashMap底层为哈希表+链表，多的这条链表用来记录元素的存储顺序，保证元素有序，即存储和取出元素的顺序一样。 import java.util.LinkedHashMap; 4.3 Hashtable底层为哈希表，与HashMap基本一致。其与HashMap的关系，类似Vector与ArrayList的关系。 区别： HashMap键值可以为null，但是Hashtable的键值都不能为空。 Hashtable为单线程，线程安全但是速度慢。 import java.util.Hashtable; 5.Collections集合工具类 import java.util.Collections; public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T…elements) ：往集合中添加一些元素。 public static void shuffle(List&lt;?&gt; list) ：打乱集合顺序。 public static &lt;T&gt; void sort(List&lt;T&gt; list) ：将集合中元素按照默认规则排序。(默认为升序) public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; ) ：将集合中元素按照指定规则排序。 实例： 12345678910111213141516171819202122232425262728293031import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;public class test &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; t1 = new ArrayList&lt;&gt;(); //addAll 添加1，2，3，4，5 Collections.addAll(t1,1,2,3,4,5); //shuffle 打乱顺序 每次执行顺序都不一样 Collections.shuffle(t1); //sort默认排序 默认为升序 Collections.sort(t1); //sort自定义排序 降序 Collections.sort(t1,new Comparator&lt;Integer&gt;() &#123; @Override//重写compare方法 public int compare(Integer o1,Integer o2)/ &#123; //后减前为降序 前减后为升序 return o2-o1; &#125; &#125;); //增强for循环 for(int i : t1) &#123; System.out.println(i);//5 4 3 2 1 &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zgg2001.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zgg2001.github.io/tags/Java/"}]},{"title":"Java学习记录：基于C++的快速学习","slug":"20210108_Java学习记录：基于C++的快速学习","date":"2021-01-08T15:17:16.000Z","updated":"2021-01-08T15:17:16.000Z","comments":true,"path":"2021/01/08/20210108_Java学习记录：基于C++的快速学习/","permalink":"https://zgg2001.github.io/2021/01/08/20210108_Java%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E5%9F%BA%E4%BA%8EC++%E7%9A%84%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0/","excerpt":"HB小咸鱼学习记录 初中的时候曾经学过一点java，算是程序的敲门砖，但是没想到上了大学最先深入学习的是C语言和C++。21年初这个寒假决定在家系统学习Java和网络编程，发个帖子记录过程，方便今后查看。","text":"HB小咸鱼学习记录 初中的时候曾经学过一点java，算是程序的敲门砖，但是没想到上了大学最先深入学习的是C语言和C++。21年初这个寒假决定在家系统学习Java和网络编程，发个帖子记录过程，方便今后查看。 【前期准备】 Java JDK版本选择的是： “1.8.0_181” 编译器我选择的是： Eclipse 具体环境搭建方法由网络上查询得知，不多说了。 学习地址：（B站永远滴神）[video(video-zPI8bhtB-1610116863147)(type-bilibili)(url-https://player.bilibili.com/player.html?aid=797299458)(image-https://ss.csdn.net/p?http://i2.hdslb.com/bfs/archive/73b9c56133cf2defc06255ca50a219156917272e.png)(title-黑马程序员Java语言入门到精通-【基础+高级】-附全套资料(IDEA版))] 【笔记一】 1- 基本语法 C++里的include头文件和Java里的import包机制相似。 C++和Java代码执行的起点都是main函数。 变量关键字与C++基本一致。值得一提的是，由于Java里没有指针，所以Java中的字符串由字符串变量String储存。使用方法与C++&#x2F;STL里的string大同小异，记得Java里的String首字母要大写。 Java中申请数组时，分为动态分配和静态分配。动态分配为new申请内存后不设置各初始值，静态分配为new申请内存后直接设置各初始值。 int[] array1 = new int[3];//动态分配 int[] array2 = new int[]&#123;1,2,3&#125;;//静态分配 Java中的数组和字符串都自带类似C++&#x2F;STL里的方法，例如length()就是获取长度。 变量类型强制转换和C++一致都可以使用(int)double这样的格式进行转换。 字符类型与C++一致也是用的ASCII码。 if&#x2F;else条件判定语句与C++一致。 switch关键字的使用方法与C++一致。 for循环、while循环、do…while循环的使用方法与C++一致。 break和continue的使用方法与C++一致。 Java中类的思路与C++中基本一致。注意Java类中的公&#x2F;私有标识符不用加 ‘:’ 。 Java中类和方法的声明&#x2F;使用方法与C++基本一致。 对于只使用一次的对象，可以使用匿名对象，直接new就行。 final关键字代表最终的，不可改变的。 外部类名称.内部类名称 对象名 &#x3D; new 外部类名称().new 内部类名称(); 直接声明内部类。 现在的编译器支持自动装箱和自动拆箱。 包装类除了int–Integer，char–Character，其余都是首字母大写。 泛型省去了类型转换的麻烦，更加安全，但是只能储存一种数据。 native关键字，代表该方法调用的是本地操作系统的方法。 当方法的参数类型已经确定，但是参数个数不确定时，可以使用可变参数。修饰符 返回值类型 方法名(数据类型…变量名){} 底层为一个数组。 【笔记二】 115-118P Scanner接收类 Java接收输入的方式为调用Scanner类。需要导包：import java.util.Scanner; 接收数据的方法为:字符串-Scanner.next()&#x2F;Scanner.nextLine();其余类型-Scanner.next类型(); 如：int-Scanner.nextInt(); double-Scanner.nextDouble(); 【笔记三】 121-124P Random随机数类 Java生成随机数的方式为调用Random类。需要导包：import java.util.Random; Random类生成随机数的方法和Scanner的方法类似，如Random.nextInt(100); 范围左闭右开，即[0,100)，0~99。 【笔记四】 133-142P String字符串类 不需要导包。 字符串比较方法：str1.equals(str2); 相同返回true。**.equalsIgnoreCase()** 忽略大小写。 字符串长度：str1.length(); 返回字符串长度。 拼接字符串：str3 &#x3D; str1.concat(str2); 返回值为新的字符串地址。 获取字符串指定位置字符：char ch &#x3D; str1.charAt(1); 返回值为一个char。 查找子串在主串中第一次出现的位置：int a &#x3D; str1.indexOf(“abc”); 返回值为第一次出现的索引位置。没有的话返回-1。 字符串截取方法：str2 &#x3D; str1.substring(5);&#x2F;&#x2F;从第5号截取到末尾str2 &#x3D; str1.substring(4,7);&#x2F;&#x2F;从4号截取到6号，左闭右开[4,7) 字符串转为char数组：char[] chars &#x3D; “hello”.toCharArray(); 字符串转为byte数组：byte[] bytes &#x3D; “hello”.getBytes(); 替换字符串内指定内容：String str1 &#x3D; “how do you do?”.replace(“o”,”*”);&#x2F;&#x2F;h*w d* y*u d*? 分割字符串：String[] array1 &#x3D; “aaa.bbb.ccc”.split(“\\\\.”);&#x2F;&#x2F;切成aaa,bbb,ccc三个字符串 【笔记五】 143-147P static静态关键字 当使用static进行修饰后，被修饰的方法&#x2F;变量不再属于对象，而是属于类。 由于不再属于对象，所以带static的方法&#x2F;变量可以直接被调用。静态方法：类名称.静态方法();静态变量：类名称.静态变量; 静态不能直接访问非静态，例如静态方法访问非静态变量。 静态方法里也不能用this。 对于静态变量初始化，我们可以使用静态代码块。静态代码块只在类第一次被声明时，执行一次。 静态内容总是优先于非静态。 【笔记六】 148-149P Arrays数组工具类 需要导包：import java.util.Arrays; 将数组变为字符串：Arrays.toString();int[] a1 &#x3D; {10,20,30};String s1 &#x3D; Arrays.toString(a1);&#x2F;&#x2F;[10, 20, 30] 数组排序：Arrays.sort();int[] a1 &#x3D; {20,10,30};Arrays.sort(a1);&#x2F;&#x2F;10,20,30 默认为升序 【笔记七】 150-151P Math数学工具类 不需要导包。 取绝对值：Math.abs(); 与C++一致，但是浮点数类型也是abs()，不是fabs()。 取平方根：Math.sqrt(); 与C++一致。 求n次方：Math.pow(a,b); 求a的b次方，与C++一致。 比大小：Math.max(a,b) &#x2F; Math.min(a,b); a和b比大小，与C++一致。 向上取整：Math.ceil(); 向下取整：Math.floor(); 四舍五入：Math.round(); Math包里还有常见的数学值，比如Math.PI是圆周率，Math.E是e值。 【笔记八】 171-184P 接口相关 接口没有静态代码块和构造方法。 一个类的父类只有一个，但是一个类可以同时实现多个接口。当父类的方法与接口的默认方法冲突，优先父类。当实现多个接口时存在默认方法冲突，需要对默认方法进行重写。当实现多个接口时存在抽象方法冲突，只需要覆盖重写一次即可。 使用接口首先要定义接口类。定义接口类的格式如：public interface 接口名称 { 接口内容 } 使用接口需要创建接口实现类对接口进行实现。接口实现类的格式如：public class 实现类名称 implements 接口名称 { … } 接口中定义的变量均为常量。常量格式如：public static final 数据类型 常量名称 &#x3D; 数值; 前方三个关键词可省略。 接口中均为抽象方法，且实现类必须覆盖重写接口所有的抽象方法，除非实现类也是抽象类。(必须覆盖)抽象方法格式如：public abstract 返回值类型 方法名称(参数列表); Java8后，接口中可以定义默认方法。(可覆盖可不覆盖)默认方法格式如：public default 返回值类型 方法名称(参数列表) { 方法体 } Java8后，接口中可以定义静态方法。静态方法格式如：public static 返回值类型 方法名称(参数列表) { 方法体 } Java9后，接口中可以定义私有方法。(我的Java版本是1.8.0也就是Java8，所以不支持)普通私有方法格式如：private 返回值类型 方法名称(参数列表) { 方法体 }静态私有方法格式如：private static 返回值类型 方法名称(参数列表) { 方法体 } 【笔记九】 185-194P 继承与多态相关 C++继承用冒号，Java继承用关键字extends。 @Override检测是否重写，总体来说，Java的类继承与C++的类继承很相似。 Java不支持多重继承，所以有super关键字，用来找父类。 abstract为抽象关键字。抽象类&#x2F;抽象方法。 访问成员变量的规则：通过对象名称访问：看声明对象时对象的类型(等号左边)，没有就向上找。通过成员方法访问：看方法属于谁，就优先用谁的成员变量，没有就向上找。 实现多态性：父类引用指向子类对象。多态格式：父类名称 对象名 &#x3D; new 子类名称();接口名称 对象名 &#x3D; new 实现类名称(); 根据第6条和第7条可知，多态中成员方法优先用子类的成员方法；通过对象名称访问成员变量，优先用父类的成员变量。 “编译看左，运行看右”，即编译前把对象看为父类类型(左边)，运行时成员变量看左边，成员方法看右边。 个人感觉，多态的存在使代码更加有逻辑性。 向上转型：右侧new一个子类对象，把它当父类来看待。 (无法调用子类特有方法) 向下转型：将父类对象，还原成为本来的子类对象。格式：子类名称 对象名 &#x3D; (子类名称)父类对象；（有点像强制类型转换） 对象 instanceof 类名称 ：如果对象属于该类，则返回true。使用这个即可根据对象类型，来进行向下转型，使用子类特有方法。 【笔记十】 215-218P Object&#x2F;Objects根类 不需要导包。 **Object.toString()**：转换为字符串，默认转换对象的地址值，需重写。 **Object.equals(对象)**：比较对象是否相等，默认比较对象的地址值，需重写。 **Objects.equals(对象1,对象2)**：第二条的equals方法存在空指针异常可能，Objects的equals方法更加完善。 【笔记十一】 219-225P 日期时间类 Date类 需要导包：import java.util.Date; Date类的空参构造函数为获取当前日期。 Date类的带参构造函数为传入一个long类型的毫秒值，根据毫秒值计算日期。0L为1970年1月1日0点。(中国是东八区加8个小时) **Date.getTime()**：将日期转换为毫秒值，返回值为long类型。 DateFormat类 需要导包：import java.text.DateFormat; DateFomat类是一个抽象类，无法直接创建对象，可以使用其子类SimpleDateFormat(String pattern) SimpleDateFormat类需要导包：import java.text.SimpleDateFormat; SimpleDateFormat s1 &#x3D; new SimpleDateFormat(“yyyy年MM月dd日 HH时mm分ss秒”); 构造函数传参按这个格式即可，字母不能变，其余可变。 String str1 &#x3D; s1.format(Date对象); 将一个Date对象转换为SimpleDateFormat对象中指定格式的字符串。 Date date &#x3D; s1.parse(“2020年01月04日 20时00分00秒”); 按照SimpleDateFormat对象的格式，转换为一个Date格式对象。 Calendar类 需要导包：import java.util.Calendar; Calendar类为抽象类，无法直接创建对象。 Calendar c1 &#x3D; Calendar.getInstance(); 使用多态方法，获取一个Calendar的子类。等号右边方法为获取Calendar的子类。 **Calendar.get(字段)**：返回日历指定字段的数值。例：c1.get(Calendar.YEAR); **Calendar.set(字段,值)**：设置日历指定字段的数值。例：c1.set(Calendar.YEAR, 2020); **Calendar.add(字段,值)**：使指定字段增加给定值，可以为负数。例：c1.add(Calendar.YEAR, -2); **Calendar.getTime()**：将Calendar类转为Date类。例：Date date &#x3D; c1.getTime(); 【笔记十二】 226-226P System系统类 不需要导包。 System.currentTimeMillis()： 返回以毫秒为单位的当前时间，可以用来计算程序的运行时间。 System.arraycopy(参数1,参数2,参数3,参数4,参数5)： 将数组中指定的数据copy到另一个数组。参数1 &#x2F; 参数3：源数组 &#x2F; 目标数组。参数2 &#x2F; 参数4：源数组中的起始位置 &#x2F; 目标数组中的起始位置。参数5：要复制的数组元素的数量。 【笔记十三】 227-229P StringBuilder字符串缓冲区类 不需要导包。 字符串缓冲区，可以提高字符串的操作效率。 String底层为final修饰的数组，而StringBuilder底层是没有被final修饰的数组，可以改变长度。 StringBuilder()： 无参构造函数，默认建议一个空字符串。 StringBuilder(String str)： 带参构造函数，建立一个内容为str的字符串。 append(参数)： 向对象里添加指定参数内容。返回值为”this”，故不用接收返回值。 toString()： 将一个StringBuilder对象转为String对象，返回一个String对象，需要接收。 【笔记十四】 234-281P 容器及其相关* &emsp;详情请看我的另一篇文章：链接点我 &emsp;其中介绍了Java容器及其相关内容。","categories":[{"name":"Java","slug":"Java","permalink":"https://zgg2001.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zgg2001.github.io/tags/Java/"}]},{"title":"使用g++创建动态库和静态库及其相关探索","slug":"20201207_使用g++创建动态库和静态库及其相关探索","date":"2020-12-07T15:39:51.000Z","updated":"2020-12-07T15:39:51.000Z","comments":true,"path":"2020/12/07/20201207_使用g++创建动态库和静态库及其相关探索/","permalink":"https://zgg2001.github.io/2020/12/07/20201207_%E4%BD%BF%E7%94%A8g++%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81%E5%BA%93%E5%92%8C%E9%9D%99%E6%80%81%E5%BA%93%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E6%8E%A2%E7%B4%A2/","excerpt":"使用g++创建动态库和静态库及其相关探索","text":"使用g++创建动态库和静态库及其相关探索 0.前期准备 首先我们建立头文件 “hello.h” 内容如图： 随后我们建立源文件 “hello.cpp” 内容如图： 最后我们建立源文件 “main.cpp” 内容如图： 我们使用 g++ -c 编译出.o文件。无论是动态库还是静态库，都得由.o文件创建，所以我们先编译出.o文件。 结果如图：可以看到有 hello.o 文件 1.静态库创建及链接 使用 ar crv 命令创立静态库。 结果如图：建立出了静态库文件 libmyhello.a ，静态库文件后缀为.a 。 使用 g++ 命令链接静态库 1g++ main.cpp libmyhello.a -o main 结果如图：生成了可执行文件main，且可以正常运行。 删除静态库libmyhello.a，程序仍能运行，说明链接成功。 结果如图： 2.动态库创建及链接 使用 -shared -fPCI 命令创立动态库。 结果如图：建立出了动态库文件 libtest.so ，动态库文件后缀为.so 。 使用 g++ 命令链接动态库 1234g++ main.cpp -L. -ltest -o main/*-L代表so库目录，“-L.” 是当前目录， -I代表引用文件目录。main即为可执行文件*/ 结果如图： 生成可执行文件main 运行程序 直接运行会报错：缺少文件。我们将动态库移动到&#x2F;usr&#x2F;lib 中即可 1mv libtest.so /usr/lib 随后即可正常运行（如果移动后仍不能运行，请看下文） 3.相关问题移动动态库后仍不能运行1.首先进入 &#x2F;etc&#x2F;ld.so.conf 文件 1vim /etc/ld.so.conf 2.修改内容为如下 1include /etc/ld.so.conf.d/*.conf 3.进入目录，创建任意*.conf文件 12cd /etc/ld.so.conf.dvim mylib.conf 4.在其中添加so的路径即可 1/usr/lib 5.执行命令使其生效 1sudo ldconfig 随后程序即可正常运行","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"}]},{"title":"2019 蓝桥杯 C/C++实现 B组国赛","slug":"20201112_2019蓝桥杯C-C++实现B组国赛","date":"2020-11-12T15:23:34.000Z","updated":"2020-11-12T15:23:34.000Z","comments":true,"path":"2020/11/12/20201112_2019蓝桥杯C-C++实现B组国赛/","permalink":"https://zgg2001.github.io/2020/11/12/20201112_2019%E8%93%9D%E6%A1%A5%E6%9D%AFC-C++%E5%AE%9E%E7%8E%B0B%E7%BB%84%E5%9B%BD%E8%B5%9B/","excerpt":"2019 蓝桥杯 C&#x2F;C++实现 B组国赛 题目 &amp; 题解","text":"2019 蓝桥杯 C&#x2F;C++实现 B组国赛 题目 &amp; 题解 A：平方序列请找到两个正整数X和Y满足下列条件：1、2019&lt;X&lt;Y2、2019^2^、X^2^、Y^2^构成等差数列满足条件的X和Y可能有多种情况，请给出X+Y的值，并且令X+Y尽可能的小。 思路： 两层暴力循环。 答案： 7020 代码： 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int t=2019*2019; for(int x=2020;x&lt;10000;x++) &#123; for(int y=x+1;y&lt;10000;y++) &#123; //cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl; if(y*y-x*x==x*x-t) &#123; cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl; cout&lt;&lt;x+y; return 0; &#125; &#125; &#125; return 0;&#125; B：质数拆分2019可以被分解成若干个两两不同的素数，请问不同的分解方案有多少种？注意：分解方案不考虑顺序，如2+2017&#x3D;2019和2017+2&#x3D;2019属于同一种方案。 思路： 动态规划。dp[a][b]表示数字a拆成若干份，最大值为b的方法数。可知，状态转移方程为 dp[a][b] &#x3D; (dp[a-b][2]+dp[a-b][3]+dp[a-b][5]+…+dp[a-b][b下的最大素数]); 用双层循环对a和b进行遍历，其中b均为素数，最后对dp[2019]进行统计即可。 答案： 55965365465060 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;const int M = 2020;vector&lt;int&gt;ps;long long dp[M][M];void shai()&#123; bool kg=true; for(int now=2;now&lt;M;now++) &#123; kg=true; for(int t=2;t&lt;=sqrt(now);t++) &#123; if(now%t==0) &#123; kg=false; break; &#125; &#125; if(kg==true) &#123; ps.push_back(now); &#125; &#125;&#125;int main()&#123; shai(); memset(dp,0,sizeof(dp)); for(int now=0;now&lt;ps.size();now++) &#123; dp[ps[now]][ps[now]] = 1; &#125; for(int now=2;now&lt;M;now++) &#123; for(int count=0;ps[count]&lt;now;count++) &#123; for(int t=0;t&lt;count&amp;&amp;ps[t]&lt;=now-ps[count];t++) &#123; dp[now][ps[count]] += dp[now-ps[count]][ps[t]]; &#125; &#125; &#125; long long ans=0; for(int now=0;now&lt;ps.size();now++) &#123; printf(&quot;%lld &quot;,dp[M-1][ps[now]]); ans+=dp[M-1][ps[now]]; &#125; printf(&quot;\\n最终答案：%lld&quot;,ans); return 0;&#125; C：拼接小明要把一根木头切成两段，然后拼接成一个直角。 如下图所示，他把中间部分分成了 n × n 的小正方形，他标记了每个小正方形属于左边还是右边。 然后沿两边的分界线将木头切断，将右边旋转向上后拼接在一起。要求每个小正方形都正好属于左边或右边，而且同一边的必须是连通的。在拼接时，拼接的部位必须保持在原来大正方形里面。请问，对于 7 × 7 的小正方形，有多少种合法的划分小正方形的方式。 D：求值有一个7X7的方格。方格左上角顶点坐标为(0,0)，右下角坐标为(7,7)。求满足下列条件的路径条数：1、起点和终点都是(0,0)2、路径不自交3、路径长度不大于124、对于每一个顶点，有上下左右四个方向可以走，但是不能越界。例如，图中路线，左上角顶点（0，0），路线长度为10思路： dfs暴力搜索，为了防止路径重复，即(0,0) &gt; (0,1) &gt; (0,0)，(0,0) &gt; (1,0) &gt; (0,0)，我把初始点(0,0)进行标记，在坐标即将改变时进行判定。 答案： 206 代码： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;bool m[8][8];int fx[4][2] = &#123;&#123;-1,0&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;0,1&#125;&#125;;int ans=0;void dfs(int x,int y,int nnn)&#123; if(nnn&gt;=12) &#123; return; &#125; for(int now=0;now&lt;4;now++) &#123; int tx = x + fx[now][0]; int ty = y + fx[now][1]; if(tx&lt;0||ty&lt;0||tx&gt;7||ty&gt;7) continue; if(tx==0&amp;&amp;ty==0&amp;&amp;nnn!=1) &#123; ans++; return; &#125; if(m[tx][ty]==true) continue; m[tx][ty]=true; dfs(tx,ty,nnn+1); m[tx][ty]=false; &#125;&#125;int main()&#123; memset(m,false,sizeof(m)); m[0][0]=true; dfs(0,0,0); cout&lt;&lt;ans; return 0;&#125; E：路径计数有1个约数的最小数为1（1），有两个约数的最小数为2（1，2）……有n个约数的最小数为SnS1&#x3D;1 （1）S2&#x3D;2 （1 2）S3&#x3D;4 （1 2 4）S4&#x3D;6 （1 2 3 6）求S100 思路： 两层暴力循环。 答案： 45360 代码： 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int ans; for(int now=100;;now++) &#123; ans=1; for(int t=2;t&lt;=now;t++) &#123; if(now%t==0) &#123; ans++; &#125; &#125; if(ans==100) &#123; cout&lt;&lt;now; return 0; &#125; &#125; return 0;&#125; F：最优包含我们称一个字符串 S 包含字符串 T 是指 T 是 S 的一个子序列，即可以从字符串 S 中抽出若干个字符，它们按原来的顺序组合成一个新的字符串与 T 完全一样。 给定两个字符串 S 和 T，请问最少修改 S 中的多少个字符，能使 S 包含 T？ 输入格式：输入两行，每行一个字符串。第一行的字符串为 S，第二行的字符串为 T。两个字符串均非空而且只包含大写英文字母。 输出格式：输出一个整数，表示答案。 数据范围：1≤|T|≤|S|≤1000 输入样例：ABCDEABCDXAABZ 输出样例：3 OJ链接 AC代码： 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt; using namespace std;int dp[1001][1001];int main(void)&#123; memset(dp,0,sizeof(dp)); string s1,s2; cin&gt;&gt;s1&gt;&gt;s2; for(int x=1;x&lt;=s2.size();x++) &#123; for(int y=x;y&lt;=s1.size();y++) &#123; if(s1[y-1]!=s2[x-1]) &#123; if(y&gt;x) dp[x][y] = min(dp[x-1][y-1]+1,dp[x][y-1]); else dp[x][y] = dp[x-1][y-1]+1; &#125; else &#123; dp[x][y] = dp[x-1][y-1]; &#125; &#125; &#125; cout&lt;&lt;dp[s2.size()][s1.size()]; return 0;&#125; G：排列数在一个排列中，一个折点是指排列中的一个元素，它同时小于两边的元素，或者同时大于两边的元素。对于一个 1 ∼ n 的排列，如果可以将这个排列中包含 t 个折点，则它称为一个 t + 1 单调序列。例如，排列 (1, 4, 2, 3) 是一个 3 单调序列，其中 4 和 2 都是折点。 给定 n 和 k，请问 1 ∼ n 的所有排列中有多少个 k 单调队列？ 输入格式：输入一行包含两个整数 n, k。 输出格式：输出一个整数，表示答案。答案可能很大，你可需要输出满足条件的排列数量除以 123456 的余数即可。 样例输入：4 2 样例输出：12 数据范围：对于 20% 的评测用例，1 ≤ k ≤ n ≤ 10；对于 40% 的评测用例，1 ≤ k ≤ n ≤ 20；对于 60% 的评测用例，1 ≤ k ≤ n ≤ 100；对于所有评测用例，1 ≤ k ≤ n ≤ 500。 H：解谜游戏 小明正在玩一款解谜游戏，谜题由 24 根塑料棒组成， 其中黄色塑料棒 4 根，红色 8 根，绿色 12 根 (后面用 Y 表示黄色、R 表示红色、G 表示绿色)。 初始时这些塑料棒排成三圈，如上图所示，外圈 12 根，中圈 8 根，内圈 4 根。 小明可以进行三种操作： 将三圈塑料棒都顺时针旋转一个单位。例如当前外圈从 0 点位置开始，顺时针依次是 YRYGRYGRGGGG，中圈是 RGRGGRRY，内圈是 GGGR。那么顺时针旋转一次之后，外圈、中圈、内圈依次变为：GYRYGRYGRGGG、YRGRGGRR 和 RGGG。将三圈塑料棒都逆时针旋转一个单位。例如当前外圈从 0 点位置开始，顺时针依次是 YRYGRYGRGGGG，中圈是 RGRGGRRY，内圈是 GGGR。那么逆时针旋转一次之后，外圈、中圈、内圈依次变为：RYGRYGRGGGGY、GRGGRRYR 和 GGRG将三圈 0 点位置的塑料棒做一个轮换。具体来说：外圈 0 点塑料棒移动到内圈 0 点，内圈 0 点移动到中圈 0 点，中圈 0 点移动到外圈 0 点。例如当前外圈从 0 点位置开始顺时针依次是 YRYGRYGRGGGG，中圈是RGRGGRRY，内圈是 GGGR。那么轮换一次之后，外圈、中圈、内圈依次变为：RRYGRYGRGGGG、GGRGGRRY 和 YGGR。小明的目标是把所有绿色移动到外圈、所有红色移动中圈、所有黄色移动到内圈。给定初始状态，请你判断小明是否可以达成目标？ 输入格式：第一行包含一个整数 T，代表询问的组数。(1 ≤ T ≤ 100)。每组询问包含 3 行：第一行包含 12 个大写字母，代表外圈从 0 点位置开始顺时针每个塑料棒的颜色。第二行包含 8 个大写字母，代表中圈从 0 点位置开始顺时针每个塑料棒的颜色。第三行包含 4 个大写字母，代表内圈从 0 点位置开始顺时针每个塑料棒的颜色。 输出格式：对于每组询问，输出一行 YES 或者 NO，代表小明是否可以达成目标。 样例输入：2GYGGGGGGGGGGRGRRRRRRYRYYYGGGRRRRGGGYYGGGRRRRYGGG 样例输出：YESNO I：第八大奇迹在一条 R 河流域，繁衍着一个古老的名族 Z，他们世代沿河而居，也在河边发展出了璀璨的文明。 Z 族在 R 河沿岸修建了很多建筑，最近，他们热衷攀比起来，他们总是在比谁的建筑建得最奇特。 幸好 Z 族人对奇特的理解都差不多，他们很快给每栋建筑都打了分，这样评选谁最奇特就轻而易举了。 于是，根据分值，大家很快评出了最奇特的建筑，称为大奇迹。 后来他们又陆续评选了第二奇特、第二奇特、……、第七奇特的建筑，依次称为第二大奇迹、第三大奇迹、……、第七大奇迹。 最近，他们开始评选第八奇特的建筑，准备命名为第八大奇迹，在评选中，他们遇到了一些问题。 首先，Z 族一直在发展，有的建筑被拆除又建了新的建筑，新建筑的奇特值和原建筑不一样，这使得评选不那么容易了。 其次，Z 族的每个人所生活的范围可能不一样，他们见过的建筑并不是所有的建筑，他们坚持他们自己所看到的第八奇特的建筑就是第八大奇迹。 Z 族首领最近很头疼这个问题，他害怕因为意见不一致导致 Z 族发生分歧。他找到你，他想先了解一下，民众自己认为的奇迹是怎样的。 现在告诉在 R 河周边的建筑的变化情况，以及在变化过程中一些人的生活范围，请编程求出每个人认为的第八大奇迹的奇特值是多少。 输入格式：输入的第一行包含两个整数 L, N，分别表示河流的长度和要你处理的信息的数量。开始时河流沿岸没有建筑，或者说所有的奇特值为 0。接下来 N 行，每行一条你要处理的信息。如果信息为 C p x，表示流域中第 p 个位置 (1 ≤ p ≤ L) 建立了一个建筑，其奇特值为 x。如果这个位置原来有建筑，原来的建筑会被拆除。如果信息为 Q a b，表示有个人生活的范围是河流的第 a 到 b 个位置（包含 a 和 b，a ≤ b），这时你要算出这个区间的第八大奇迹的奇特值，并输出。如果找不到第八大奇迹，输出 0。 输出格式：对于每个为 Q 的信息，你需要输出一个整数，表示区间中第八大奇迹的奇特值。 样例输入：10 15C 1 10C 2 20C 3 30C 4 40C 5 50C 6 60C 7 70C 8 80C 9 90C 10 100Q 1 2Q 1 10Q 1 8C 10 1Q 1 10 样例输出：0301020 数据范围：对于 20% 的评测用例，1 ≤ L ≤ 1000, 1 ≤ N ≤ 1000。对于 40% 的评测用例，1 ≤ L ≤ 10000, 1 ≤ N ≤ 10000。对于 100% 的评测用例，1 ≤ L ≤ 100000，1 ≤ N ≤ 100000。所有奇特值为不超过 10^9^ 的非负整数。 J：燃烧权杖小 C 最近迷上了一款游戏。现在，在游戏中，小 C 有一个英雄，生命值为 x；敌人也有一个英雄，生命值为 y。 除此以外，还有 k 个士兵，生命值分别为a1 、a2 、……、ak，现在小 C 打算使用一个叫做“燃烧权杖”的技能。 “燃烧权杖”会每次等概率随机选择一个活着的角色（英雄或士兵），扣减其 10 点生命值， 然后如果该角色的生命值小于或等于 0，则该角色死亡，不会再被“燃烧权杖”选中。 “燃烧权杖”会重复做上述操作，直至任意一名英雄死亡。 小 C 想知道使用“燃烧权杖”后敌方英雄死亡（即，小 C 的英雄存活）的概率。 为了避免精度误差，你只需要输出答案模一个质数 p 的结果，具体见输出格式。 输入格式：输入包含多组数据。输入第一行包含一个正整数 T，表示数据组数。接下来 T 组，每组数据第一行包含四个非负整数 x, y, p, k，分别表示小C的英雄的生命值、敌方英雄的生命值，模数和士兵个数。第二行包含 k 个正整数 a1 、a2 、……、ak ，分别表示每个士兵的生命值。 输出格式：对于每组数据，输出一行一个非负整数，表示答案模质数 p 的余数。可以证明，答案一定为有理数。设答案为 a &#x2F; b（a 和 b 为互质的正整数），你输出的数为 x，则你需要保证 a 与 bx 模 p 同余；也即，x &#x3D; (a·b−1 ) mod p，其中 b−1 表示 b 模 p 的逆元， mod 为取模运算。 样例输入：61 10 101 0100 1 101 050 30 4903 21 1987 654 233 13211000000000 999999999 233 31 2 31000000000 999999999 3 31 2 3 样例输出：513710351181172 样例说明：对于第一组数据，所求概率即为“燃烧权杖”第一次就扣减敌方英雄 10 点生命值的概率，即 1&#x2F;2。2 × 51 模 101 余 1。对于第二组数据，答案为 1023&#x2F;1024，1024 × 37 与 1023 模 101 同余。对于第三组数据，答案为 99&#x2F;128。 数据范围：对于 10% 的评测用例，x, y, a1 ,··· , ak ≤ 10。对于 20% 的评测用例，x, y, a1,··· , ak ≤ 100。对于 50% 的评测用例，x, y, a1 ,··· , ak ≤ 1000。另有 10% 的评测用例，p &#x3D; 3。另有 20% 的评测用例，p ≤ 100。对于全部评测用例，1 ≤ x, y, a1 ,··· , ak ≤ 10^9^ ，3 ≤ p ≤ 10000 且 p 为质数，0 ≤ k ≤ 10。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://zgg2001.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}]},{"title":"动态规划学习记录：题型/思路汇总","slug":"20201105_动态规划学习记录：题型思路汇总","date":"2020-11-05T11:58:59.000Z","updated":"2020-11-05T11:58:59.000Z","comments":true,"path":"2020/11/05/20201105_动态规划学习记录：题型思路汇总/","permalink":"https://zgg2001.github.io/2020/11/05/20201105_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E9%A2%98%E5%9E%8B%E6%80%9D%E8%B7%AF%E6%B1%87%E6%80%BB/","excerpt":"动态规划学习记录 记录了常见的一维与二维动态规划题目 &amp; 题解。","text":"动态规划学习记录 记录了常见的一维与二维动态规划题目 &amp; 题解。 一维数组动态规划 一般来说这类题数据都是一维的。例如只受价格影响，如果像01背包问题那样的受价格和大小两个数据影响，就是二维的动态规划。一维动态规划的状态转移方程一般都是平级移动，受之前状态的影响，相对较简单。 1.爬楼梯假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？注意：给定 n 是一个正整数。 示例 1：输入： 2输出： 2解释： 有两种方法可以爬到楼顶。 1 阶 + 1 阶 2 阶 示例 2：输入： 3输出： 3解释： 有三种方法可以爬到楼顶。 1 阶 + 1 阶 + 1 阶 1 阶 + 2 阶 2 阶 + 1 阶 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/climbing-stairs OJ链接著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路：思路很简单，因为一次只能跳一格或者两格，所以当前阶数可前往的方法数等于前两阶的方法数之和。 状态转移方程为：dp[now] &#x3D; dp[now-1] + dp[now-2]; AC代码： 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;class Solution &#123;public: int climbStairs(int n) &#123; int *dp = new int[n+10],t; dp[1]=1; dp[2]=2; for(int now=3;now&lt;=n;now++) &#123; dp[now] = dp[now-1]+dp[now-2]; &#125; t = dp[n]; delete[] dp; return t; &#125;&#125;;int main()&#123; int n; cin&gt;&gt;n; Solution s; cout&lt;&lt;s.climbStairs(n); return 0;&#125; 2.数硬币给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。你可以认为每种硬币的数量是无限的。 示例 1：输入：coins &#x3D; [1, 2, 5], amount &#x3D; 11输出：3解释：11 &#x3D; 5 + 5 + 1 示例 2：输入：coins &#x3D; [2], amount &#x3D; 3输出：-1 示例 3：输入：coins &#x3D; [1], amount &#x3D; 0输出：0 示例 4：输入：coins &#x3D; [1], amount &#x3D; 1输出：1 示例 5：输入：coins &#x3D; [1], amount &#x3D; 2输出：2 提示：1 &lt;&#x3D; coins.length &lt;&#x3D; 121 &lt;&#x3D; coins[i] &lt;&#x3D; 231 - 10 &lt;&#x3D; amount &lt;&#x3D; 104 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/coin-change OJ链接著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路： 当前金额的最小需要硬币数，等于当前金额分别减去硬币面额的所需最小硬币数的最小值加一。例如求2,5,7面额硬币凑27块钱所需的最少硬币，就得求20块钱、22块钱、25块钱的最少硬币(27-7 27-5 27-2)，找到其中的最小值加一就是27块钱所需的最小硬币数。而20块钱，22块钱，25块钱的最少硬币数就按这个倒推，最终可以求出所有金额所需的最小硬币数。 状态转移方程为：dp[x] &#x3D; x金额的所需最少硬币数;dp[now] &#x3D; min( (now-coin[0])+1, (now-coin[1])+1, …… (now-coin[end])+1 );最终结果为: dp[amount]; AC代码： 12345678910111213141516171819202122232425262728class Solution &#123;public: int func(int *z,vector&lt;int&gt;&amp; coins,int d) &#123; int temp=9999999; for(int now=0;now&lt;coins.size();now++) &#123; if(d-coins[now]&gt;=0) &#123; temp=min(temp,z[d-coins[now]]); &#125; &#125; return temp+1; &#125; int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123; int *count=new int[amount+1]; count[0]=0; for(int now=1;now&lt;amount+1;now++) &#123; count[now]=func(count,coins,now); //printf(&quot;%d\\n&quot;,count[now]); &#125; return count[amount]==10000000 ? -1 : count[amount]; &#125;&#125;; 3.最大子序和给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例:输入: [-2,1,-3,4,-1,2,1,-5,4]输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/maximum-subarray OJ链接著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路：加一个max变量，储存最大值，dp数组储存当前连续的最大值。 状态转移方程为：dp[now] &#x3D; max(nums[now],dp[now-1]+nums[now]; AC代码： 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int *dp = new int[nums.size()+1],max_=0; dp[0]=nums[0]; max_=dp[0]; for(int now=1;now&lt;nums.size();now++) &#123; dp[now]=max(nums[now],dp[now-1]+nums[now]); max_=max(max_,dp[now]); &#125; return max_; &#125;&#125;;int main()&#123; int a[] = &#123;-2,1,-3,4,-1,2,1,-5,4&#125;; vector&lt;int&gt;n(a,a+9); Solution s; cout&lt;&lt;s.maxSubArray(n); return 0;&#125; 4.区域和检索 - 数组不可变给定一个整数数组 nums，求出数组从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点。实现 NumArray 类：NumArray(int[] nums) 使用数组 nums 初始化对象int sumRange(int i, int j) 返回数组 nums 从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点（也就是 sum(nums[i], nums[i + 1], … , nums[j])） 示例： 输入：[“NumArray”, “sumRange”, “sumRange”, “sumRange”][[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]] 输出：[null, 1, -1, -3] 解释：NumArray numArray &#x3D; new NumArray([-2, 0, 3, -5, 2, -1]);numArray.sumRange(0, 2); &#x2F;&#x2F; return 1 ((-2) + 0 + 3)numArray.sumRange(2, 5); &#x2F;&#x2F; return -1 (3 + (-5) + 2 + (-1))numArray.sumRange(0, 5); &#x2F;&#x2F; return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1)) 提示：0 &lt;&#x3D; nums.length &lt;&#x3D; 104-105 &lt;&#x3D; nums[i] &lt;&#x3D; 1050 &lt;&#x3D; i &lt;&#x3D; j &lt; nums.length最多调用 104 次 sumRange 方法 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/range-sum-query-immutable OJ链接著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路：用dp数组记录前x个数的和，求i ~ j区间的值的和即为dp[j+1] - dp[i]; 状态转移方程：dp[now]代表前now个数字的和；dp[now] &#x3D; dp[now-1] + nums[now-1]; AC代码： 123456789101112131415161718class NumArray &#123;public: NumArray(vector&lt;int&gt;&amp; nums) &#123; dp.resize(nums.size()+10,0); for(int i=1;i&lt;=nums.size();i++) &#123; dp[i]=dp[i-1]+nums[i-1]; &#125; &#125; int sumRange(int i, int j) &#123; return dp[j+1]-dp[i]; &#125;private: vector&lt;int&gt; dp;&#125;; 5.整数拆分定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。 示例 1:输入: 2输出: 1解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1。 示例 2:输入: 10输出: 36解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36。说明: 你可以假设 n 不小于 2 且不大于 58。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/integer-break OJ地址著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路： 遍历所有可能的分割结果。 状态转移方程为：dp[x] &#x3D; 整数为x时的最大组合乘积;初始dp[1]&#x3D;1;即1的整数最大乘积是1;dp[x] &#x3D; max( max( dp[x-1] * 1, (x-1) * 1 ), max( dp[x-2] * 2, (x-2) * 2 ), max( dp[x-3] * 3, (x-3) * 3 ), …… max( dp[1] * (x-1), 1 * (x-1) );最终结果为: dp[n]; AC代码： 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;class Solution &#123;public: int integerBreak(int n) &#123; int *count = new int[n+1],temp=0; count[1]=1; for(int now=2;now&lt;n+1;now++) &#123; temp=0; for(int t1=1;t1&lt;now;t1++) &#123; temp=max(temp,count[now-t1]*t1); temp=max(temp,(now-t1)*t1); &#125; count[now]=temp; //cout&lt;&lt;count[now]&lt;&lt;endl; &#125; return count[n]; &#125;&#125;;int main()&#123; int n; cin&gt;&gt;n; Solution s; cout&lt;&lt;s.integerBreak(n); return 0;&#125; 6.打家劫舍你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 示例 1：输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。 偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。 示例 2：输入：[2,7,9,3,1]输出：12解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。 偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。 提示：0 &lt;&#x3D; nums.length &lt;&#x3D; 1000 &lt;&#x3D; nums[i] &lt;&#x3D; 400 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/house-robber OJ链接著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路： 可简单看出最大值是在不偷前一个屋子加上偷当前屋子和不偷当前屋子和偷前一个屋子之间做选择。 状态转移方程为：dp[x] &#x3D; 偷到x号房子时的最大可偷最大价值;初始dp[0]&#x3D;0,dp[1]&#x3D;nums[0];即不偷的时候价值为0，只偷一个屋子时价值最大为第一个屋子;dp[x] &#x3D; max( dp[x-2]+nums[x], dp[x-1] );最终结果为: dp[nums.size()]; AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; int *dp = new int[nums.size()+1]; if(nums.size()&gt;=1) &#123; dp[0]=0,dp[1]=nums[0]; for(int now=2;now&lt;=nums.size();now++) &#123; dp[now] = max(dp[now-2]+nums[now-1],dp[now-1]); //cout&lt;&lt;dp[now]&lt;&lt;endl; &#125; return dp[nums.size()]; &#125; else &#123; return 0; &#125; &#125;&#125;;int main()&#123; vector&lt;int&gt;n; int t; while(scanf(&quot;%d&quot;,&amp;t)!=EOF) &#123; n.push_back(t); &#125; Solution s; cout&lt;&lt;s.rob(n); return 0;&#125; 7.打家劫舍II你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下 ，能够偷窃到的最高金额。 示例 1：输入：nums &#x3D; [2,3,2]输出：3解释：你不能先偷窃 1 号房屋（金额 &#x3D; 2），然后偷窃 3 号房屋（金额 &#x3D; 2）, 因为他们是相邻的。 示例 2：输入：nums &#x3D; [1,2,3,1]输出：4解释：你可以先偷窃 1 号房屋（金额 &#x3D; 1），然后偷窃 3 号房屋（金额 &#x3D; 3）。偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。 示例 3：输入：nums &#x3D; [0]输出：0 提示：1 &lt;&#x3D; nums.length &lt;&#x3D; 1000 &lt;&#x3D; nums[i] &lt;&#x3D; 1000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/house-robber-ii OJ链接著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路： 在上一题的基础上，增加了环的概念。大致就是有首不能有尾，有尾不能有首。我们可以先求{1，n-1}这个区间的最大值，再求{2，n}这个区间的最大值，然后取这两个值中的最大值，即为本题答案。 AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; int *dp = new int[nums.size()+1]; int *dp2 = new int[nums.size()+1]; if(nums.size()&gt;=1) &#123; dp[0]=0,dp[1]=nums[0];// 0 ~ n-1 for(int now=2;now&lt;=nums.size()-1;now++) &#123; dp[now] = max(dp[now-2]+nums[now-1],dp[now-1]); //cout&lt;&lt;dp[now]&lt;&lt;endl; &#125; dp2[0]=0,dp2[1]=0;// 1 ~ n for(int now=2;now&lt;=nums.size();now++) &#123; dp2[now] = max(dp2[now-2]+nums[now-1],dp2[now-1]); //cout&lt;&lt;dp[now]&lt;&lt;endl; &#125; if(nums.size()&gt;1) dp[nums.size()]=max(dp[nums.size()-1],dp2[nums.size()]); return dp[nums.size()]; &#125; else &#123; return 0; &#125; &#125;&#125;;int main()&#123; vector&lt;int&gt;n; int t; while(scanf(&quot;%d&quot;,&amp;t)!=EOF) &#123; n.push_back(t); &#125; Solution s; cout&lt;&lt;s.rob(n); return 0;&#125; 8.解码方法一条包含字母 A-Z 的消息通过以下方式进行了编码：‘A’ -&gt; 1‘B’ -&gt; 2…‘Z’ -&gt; 26给定一个只包含数字的非空字符串，请计算解码方法的总数。题目数据保证答案肯定是一个 32 位的整数。 示例 1：输入：”12”输出：2解释：它可以解码为 “AB”（1 2）或者 “L”（12）。 示例 2：输入：”226”输出：3解释：它可以解码为 “BZ” (2 26), “VF” (22 6), 或者 “BBF” (2 2 6) 。 示例 3：输入：s &#x3D; “0”输出：0 示例 4：输入：s &#x3D; “1”输出：1 示例 5：输入：s &#x3D; “2”输出：1 提示：1 &lt;&#x3D; s.length &lt;&#x3D; 100s 只包含数字，并且可以包含前导零。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/decode-ways OJ链接著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码： 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: int numDecodings(string s) &#123; int *dp = new int[s.size()+1]; memset(dp,0,sizeof(dp)); dp[0]=1; s[0]==&#x27;0&#x27; ? dp[1]=0 : dp[1]=1; for(int now=2;now&lt;=s.size();now++) &#123; if(s[now-1]!=&#x27;0&#x27;) &#123; if(s[now-2]==&#x27;1&#x27;||(s[now-2]==&#x27;2&#x27;&amp;&amp;s[now-1]&lt;=&#x27;6&#x27;)) &#123; dp[now]=dp[now-1]+dp[now-2]; &#125; else &#123; dp[now]=dp[now-1]; &#125; &#125; else &#123; if(s[now-2]==&#x27;2&#x27;||s[now-2]==&#x27;1&#x27;) &#123; dp[now]=dp[now-2]; &#125; else &#123; return 0; &#125; &#125; &#125; return dp[s.size()]; &#125;&#125;; 9.乘积最大字数组给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。 示例 1:输入: [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。 示例 2:输入: [-2,0,-1]输出: 0解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/maximum-product-subarray OJ链接著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码： 12345678910111213141516171819202122class Solution &#123;public: int maxProduct(vector&lt;int&gt;&amp; nums) &#123; int dp_max[nums.size()+10],dp_min[nums.size()+10]; dp_max[1]=nums[0]; dp_min[1]=nums[0]; for(int now=2;now&lt;=nums.size();now++) &#123; dp_max[now] = max(dp_min[now-1]*nums[now-1], dp_max[now-1]*nums[now-1]); dp_max[now] = max(dp_max[now], nums[now-1]); dp_min[now] = min(dp_max[now-1]*nums[now-1], dp_min[now-1]*nums[now-1]); dp_min[now] = min(dp_min[now], nums[now-1]); &#125; int max_ = INT_MIN; for(int now=1;now&lt;=nums.size();now++) &#123; max_ = max(max_,dp_max[now]); &#125; return max_; &#125;&#125;; 10.完全平方数给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 示例 1:输入: n &#x3D; 12输出: 3解释: 12 &#x3D; 4 + 4 + 4. 示例 2:输入: n &#x3D; 13输出: 2解释: 13 &#x3D; 4 + 9. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/perfect-squares OJ链接著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码： 12345678910111213141516171819class Solution &#123;public: int numSquares(int n) &#123; int dp[n+1],t=1; memset(dp,9999,sizeof(dp)); dp[0] = 0; for(int now=1;now&lt;=n;now++) &#123; t=1; while(t*t&lt;=now) &#123; dp[now] = min(dp[now],dp[now-t*t]+1); t++; &#125; &#125; return dp[n]; &#125;&#125;; 二维数组动态规划 这类的dp题有两个影响结果的数值，例如01背包问题里的价值和大小、空间问题里的x,y坐标等等都是二维的数据。这种题建立dp数组的时候，就需要构建二维的dp数组，并且状态转移方程的变化情况也更加多样，相对较难一点。 1.不同路径一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。问总共有多少条不同的路径？ 例如，上图是一个7 x 3 的网格。有多少可能的路径？ 示例 1: 输入: m &#x3D; 3, n &#x3D; 2 输出: 3解释:从左上角开始，总共有 3 条路径可以到达右下角。 向右 -&gt; 向右 -&gt; 向下 向右 -&gt; 向下 -&gt; 向右 向下 -&gt; 向右 -&gt; 向右 示例 2: 输入: m &#x3D; 7, n &#x3D; 3 输出: 28 提示：1 &lt;&#x3D; m, n &lt;&#x3D; 100题目数据保证答案小于等于 2 * 10 ^ 9 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/unique-paths OJ链接著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路： dp构建表格，dp[x][y]代表在x,y坐标时的可前往路程数。由于方格只能向下或者向右走，所以前往某一格的方案数，就是前往上一格和左一格的方案数之和。 状态转移方程：dp[x][y] &#x3D; dp[x-1][y]+dp[x][y-1];最终结果为: dp[X][Y]; AC代码： OJ链接 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;class Solution &#123;public: int uniquePaths(int m, int n) &#123; int dp[101][101]; memset(dp,0,sizeof(dp)); dp[1][1]=1; for(int now=1;now&lt;=m;now++) &#123; for(int now1=1;now1&lt;=n;now1++) &#123; if(now-1&gt;=1) &#123; dp[now][now1]+=dp[now-1][now1]; &#125; if(now1-1&gt;=1) &#123; dp[now][now1]+=dp[now][now1-1]; &#125; &#125; &#125; return dp[m][n]; &#125;&#125;;int main()&#123; Solution s; cout&lt;&lt;s.uniquePaths(7,3); return 0;&#125; 2.不同路径II一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 网格中的障碍物和空位置分别用 1 和 0 来表示。 示例 1： 输入：obstacleGrid &#x3D; [[0,0,0],[0,1,0],[0,0,0]] 输出：2解释：3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径： 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右 示例 2： 输入：obstacleGrid &#x3D; [[0,1],[0,0]] 输出：1 提示：m &#x3D;&#x3D; obstacleGrid.length n &#x3D;&#x3D; obstacleGrid[i].length1 &lt;&#x3D; m, n &lt;&#x3D; 100obstacleGrid[i][j] 为 0 或 1 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/unique-paths-ii OJ链接著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路：在上一题的基础上，增加一个判断即可，当遍历到障碍格时，直接跳过不计数即可。令障碍格的可到达方法为0。 状态转移方程：dp[x][y] &#x3D; dp[x-1][y]+dp[x][y-1];最终结果为: dp[X][Y]; AC代码： 12345678910111213141516171819202122232425262728293031class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int dp[101][101]; memset(dp,0,sizeof(dp)); dp[1][1]=1; for(int now=1;now&lt;=obstacleGrid.size();now++) &#123; for(int now1=1;now1&lt;=obstacleGrid[0].size();now1++) &#123; if(obstacleGrid[now-1][now1-1]==0) &#123; if(now-1&gt;=1) &#123; dp[now][now1]+=dp[now-1][now1]; &#125; if(now1-1&gt;=1) &#123; dp[now][now1]+=dp[now][now1-1]; &#125; &#125; else &#123; dp[now][now1]=0; &#125; &#125; &#125; return dp[obstacleGrid.size()][obstacleGrid[0].size()]; &#125;&#125;; 3.最小路径和给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。说明：每次只能向下或者向右移动一步。 示例 1： 输入：grid &#x3D; [[1,3,1],[1,5,1],[4,2,1]] 输出：7解释： 因为路径 1→3→1→1→1 的总和最小。 示例 2： 输入：grid &#x3D; [[1,2,3],[4,5,6]] 输出：12 提示：m &#x3D;&#x3D; grid.lengthn &#x3D;&#x3D; grid[i].length1 &lt;&#x3D; m, n &lt;&#x3D; 2000 &lt;&#x3D; grid[i][j] &lt;&#x3D; 100 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/minimum-path-sum OJ链接著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路：由于只能向下或者向右移动，所以前往一个格子的最小路径，就是其上一个格子和左一个格子的较小路径和加上这个格子的权值。 状态转移方程：dp[x][y] &#x3D; min(dp[x-1][y], dp[x][y-1]) + grid[x][y]; AC代码： 12345678910111213141516171819202122232425262728class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int dp[201][201]; memset(dp,0,sizeof(dp)); dp[0][0]=grid[0][0]; for(int now=0;now&lt;grid.size();now++) &#123; for(int now1=0;now1&lt;grid[now].size();now1++) &#123; if(now!=0&amp;&amp;now1!=0) &#123; dp[now][now1] = min(dp[now-1][now1],dp[now][now1-1]) + grid[now][now1]; &#125; else if(now==0&amp;&amp;now1!=0) &#123; dp[now][now1] = dp[now][now1-1] + grid[now][now1]; &#125; else if(now!=0&amp;&amp;now1==0) &#123; dp[now][now1] = dp[now-1][now1] + grid[now][now1]; &#125; &#125; &#125; return dp[grid.size()-1][grid[0].size()-1]; &#125;&#125;; 4.三角形最小路径和给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。 例如，给定三角形： 123456[ [2], [3,4], [6,5,7], [4,1,8,3]] 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 &#x3D; 11）。 说明：如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/triangle OJ链接著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路：建立二维数组，储存到达每一个坐标的最小路径值。最后遍历最后一行的最小值，即为最终答案。 状态转移方程：对于行首元素：dp[x][0] &#x3D; dp[x-1][0] + triangle[x][0];对于行尾元素：dp[x][x] &#x3D; dp[x-1][x-1] + triangle[x][x];对于行中元素：dp[x][y] &#x3D; min(dp[x-1][y-1], dp[x-1][y]) + triangle[x][y]; AC代码： 123456789101112131415161718192021222324class Solution &#123;public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123; int dp[triangle.size()][triangle.size()]; memset(dp,0,sizeof(dp)); dp[0][0]=triangle[0][0]; for(int now=1;now&lt;triangle.size();now++) &#123; dp[now][0]=dp[now-1][0]+triangle[now][0]; dp[now][now]=dp[now-1][now-1]+triangle[now][now]; for(int t=1;t&lt;=now-1;t++) &#123; dp[now][t] = min(dp[now-1][t-1],dp[now-1][t]) + triangle[now][t]; &#125; &#125; int min_=INT_MAX; for(int now=0;now&lt;triangle.size();now++) &#123; min_=min(dp[triangle.size()-1][now],min_); &#125; return min_; &#125;&#125;; 5.最大正方形在一个由 ‘0’ 和 ‘1’ 组成的二维矩阵内，找到只包含 ‘1’ 的最大正方形，并返回其面积。 示例： 1234567输入：matrix = [[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;], [&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]输出：4 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/maximal-square OJ链接著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码： 1234567891011121314151617181920212223242526272829class Solution &#123;public: int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; if(matrix.size()==0) return 0; int dp[matrix.size()+1][matrix[0].size()+1]; int max_=0,temp; memset(dp,0,sizeof(dp)); for(int x=1;x&lt;=matrix.size();x++) &#123; for(int y=1;y&lt;=matrix[0].size();y++) &#123; if(matrix[x-1][y-1]==&#x27;1&#x27;) &#123; temp = min(dp[x-1][y-1],dp[x-1][y]); temp = min(temp,dp[x][y-1]); dp[x][y] = temp+1; max_ = max(max_,dp[x][y]); &#125; else &#123; dp[x][y] = 0; &#125; &#125; &#125; return max_*max_; &#125;&#125;;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"C语言实现大整数加减 数组实现","slug":"20201013_C语言实现大整数加减数组实现","date":"2020-10-13T15:25:06.000Z","updated":"2020-10-13T15:25:06.000Z","comments":true,"path":"2020/10/13/20201013_C语言实现大整数加减数组实现/","permalink":"https://zgg2001.github.io/2020/10/13/20201013_C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0/","excerpt":"C语言通过数组实现大整数加减法","text":"C语言通过数组实现大整数加减法 思路导图 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include&lt;bits/stdc++.h&gt;void add(int* count_1,int *count_2,int *ans,int max)&#123; for(int now=0;now&lt;max;now++) &#123; ans[now]+=count_1[now]+count_2[now];//这一位的值加上第一个数组的该位值 再加上第二个数组的该位值 if(ans[now]&gt;=10)//大于10就进位 &#123; ans[now+1]+=1;//进一位 ans[now]%=10;//留下个位 &#125; &#125; &#125;void sub(int* count_1,int *count_2,int *ans,int max)&#123; for(int now=0;now&lt;max;now++) &#123; ans[now]+=count_1[now]-count_2[now];//这一位的值等于第一个数组的该位值 减去第二个数组的该位值 if(ans[now]&lt;0)//如果该位数字小于0 &#123; ans[now]+=10;//借一位 加10 ans[now+1]--;//前一位-1; &#125; &#125; &#125; void print(int *ans,int max)&#123; bool kg=false; for(int now=max-1;now&gt;=0;now--) &#123; if(ans[now]!=0||kg==true) &#123; printf(&quot;%d&quot;,ans[now]); kg=true; &#125; &#125; &#125;int main()&#123; char string0[1000],*front,*after,sign;//输入的字符串 切割后的第一个字符串front 第二个字符串after 符号 scanf(&quot;%s&quot;,string0); for(int now=0;;now++) &#123; if(string0[now]==&#x27;+&#x27;)//找到加号 &#123; sign=&#x27;+&#x27;; front=strtok_r(string0,&quot;+&quot;,&amp;after);//切割 break; &#125; else if(string0[now]==&#x27;-&#x27;)//找到减号 &#123; sign=&#x27;-&#x27;; front=strtok_r(string0,&quot;-&quot;,&amp;after);//切割 break; &#125; &#125; int n=strlen(front),m=strlen(after);//两个数的位数 用于下一行的最大位数的选择 int max;//最大位数 不超过两个数最大位数+1 if(n&gt;m)//n比m大 &#123; max=n+1; &#125; else &#123; max=m+1; &#125; int count_1[max], count_2[max], ans[max];//第一个数的数组 第二个数的数组 答案 memset(count_1,0,sizeof(count_1)); memset(count_2,0,sizeof(count_2)); memset(ans,0,sizeof(ans));//每一位都初始化为0 for(int now=0;now&lt;n;now++) &#123; count_1[now]=front[n-now-1]-&#x27;0&#x27;; &#125; for(int now=0;now&lt;m;now++) &#123; count_2[now]=after[m-now-1]-&#x27;0&#x27;; &#125; printf(&quot; = &quot;); if(sign==&#x27;+&#x27;) &#123; add(count_1,count_2,ans,max); &#125; else &#123; if(n&gt;m)// 1 比 2 长 &#123; sub(count_1,count_2,ans,max); &#125; else if(n==m)//一样长 &#123; bool state=false; for(int a=max-1;a&gt;=0&amp;&amp;state==false;a--) &#123; if(count_1[a]&gt;count_2[a]) &#123; sub(count_1,count_2,ans,max); state=true; &#125; else if(count_1[a]&lt;count_2[a]) &#123; printf(&quot;-&quot;); sub(count_2,count_1,ans,max); state=true; &#125; &#125; if(state==false) &#123; printf(&quot;0&quot;); &#125; &#125; else//1 比 2 短 &#123; printf(&quot;-&quot;); sub(count_2,count_1,ans,max); &#125; &#125; print(ans,max); return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"C语言","slug":"C语言","permalink":"https://zgg2001.github.io/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"C语言读取csv文件数据并分组","slug":"20200911_C语言读取csv文件数据并分组","date":"2020-09-11T14:34:12.000Z","updated":"2020-09-11T14:34:12.000Z","comments":true,"path":"2020/09/11/20200911_C语言读取csv文件数据并分组/","permalink":"https://zgg2001.github.io/2020/09/11/20200911_C%E8%AF%AD%E8%A8%80%E8%AF%BB%E5%8F%96csv%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%88%86%E7%BB%84/","excerpt":"核心就是.csv文件各组数据之间用‘,’逗号来分割，我们使用C语言的strtok函数对.csv文件的每一行数据进行分割即可。","text":"核心就是.csv文件各组数据之间用‘,’逗号来分割，我们使用C语言的strtok函数对.csv文件的每一行数据进行分割即可。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;void cut(char *line,int num)//读入这一行的数据 / 数据的组数-1（逗号的个数） &#123; char *temp; temp=strtok(line,&quot;,&quot;); if(temp) &#123; printf(&quot;第1组数据：%6s\\t&quot;,temp);//第一组数据 &#125; for(int now=0;now&lt;num-1;now++) &#123; temp = strtok(NULL,&quot;,&quot;); printf(&quot;第%d组数据：%6s\\t&quot;,now+2,temp);//中间的数据 &#125; temp = strtok(NULL,&quot;,&quot;); temp[strlen(temp)-1]=&#x27;\\0&#x27;;//把fgets读取的回车去掉 printf(&quot;第%d组数据：%6s\\n&quot;,num+1, temp);//最后一组数据 &#125;int main(int argc, char *argv[])&#123; /*if(argc!=3) &#123; return 0; &#125;*/ FILE *file = fopen(&quot;minute.csv&quot;,&quot;r&quot;);//读文件 if(!file) &#123; printf(&quot;file error&quot;); return 0; &#125; char line[1024]; int num=0; fgets(line,1024,file); for(int now=0;line[now]!=&#x27;\\n&#x27;;now++)//通过统计分割的逗号 来统计数据的组数 &#123; if(line[now]==&#x27;,&#x27;) &#123; num++; &#125; &#125; printf(&quot;一共有%d组数据\\n&quot;,num+1);//有num个逗号 就是有num+1组数据 cut(line,num);//分割输出第一行 while(fgets(line,1024,file)!=NULL)//对之后行进行分割 &#123; cut(line,num); &#125; return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"https://zgg2001.github.io/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"2020 第十一届 蓝桥杯 整数拼接","slug":"20200907_2020第十一届蓝桥杯整数拼接","date":"2020-09-07T03:41:04.000Z","updated":"2020-09-07T03:41:04.000Z","comments":true,"path":"2020/09/07/20200907_2020第十一届蓝桥杯整数拼接/","permalink":"https://zgg2001.github.io/2020/09/07/20200907_2020%E7%AC%AC%E5%8D%81%E4%B8%80%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%95%B4%E6%95%B0%E6%8B%BC%E6%8E%A5/","excerpt":"此题为2020年第十一届蓝桥杯省赛第一场B组第九题","text":"此题为2020年第十一届蓝桥杯省赛第一场B组第九题 时间限制: 1.0s 内存限制: 256.0MB 本题总分：25 分问题：给定义个长度为 n 的数组 A1, A2, · · · , An。你可以从中选出两个数 Ai (i 不等于 j)，然后将 Ai 和 Aj 一前一后拼成一个新的整数。例如 12 和 以拼成 12345 或 34512。注意交换 Ai 和 Aj 的顺序总是被视为 2 种拼法，是 Ai &#x3D; Aj 时。请你计算有多少种拼法满足拼出的整数是 K 的倍数。 输入：第一行包含 2 个整数 n 和 K。第二行包含 n 个整数 A1, A2, · · · , An。 输出：一个整数代表答案。 样例输入：4 21 2 3 4 样例输出：6 评测用例规模与约定：对于 30% 的评测用例，1 ≤ n ≤ 1000, 1 ≤ K ≤ 20, 1 ≤ Ai ≤ 10的四次方。对于所有评测用例，1 ≤ n ≤ 10的五次方，1 ≤ K ≤ 10的五次方，1 ≤ Ai ≤ 10的九次方。 思路： 直接暴力肯定超时。我们可以先进行一次操作，对所有数字进行遍历。求出对于每个数，后数为多少时满足题目要求。因为所有数都小于等于十的九次方，即最多为10位数，所以我们只需要求每个数在后数为1位数到10位数时对后数的余数要求即可。然后再遍历一次判定满足要求的后数，总答案加上对该后数的需求即可。数据接收数组选择long long，防止运算中数据超限。答案也选择long long，防止储存不下。 具体思路如下： 整式为 （数一*10^数二的位数^+数二）%k &#x3D;&#x3D; 0 即数一数二满足要求 我们遍历整个数组，按 （k - 数一*10^1-10^%k）%k 求出数一在1-10次方的情况下对后数余数的要求。这次遍历统计的是数一对于数二的需求。 用一个二维数组 mymap[位数][余数需求] 来储存对于 特定数二 的需求数量。 再次遍历整个数组，对数组元素的位数与余数进行计算，如果位数与余数满足需求，总答案则加上上一步中统计的需求数量。这次遍历是为了寻找数二。 在遍历中，我们需要进行去重判定。如果一个数跟自己组合也满足条件，说明上面多加了一次，总答案减去1。 AC代码： OJ链接 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;long long myarray[100001];//存数 int mymap[11][100001];//存不同幂情况下对余数的需求 mymap[幂][需求]=数量 long long ans=0;//答案 void func1(int n,int k)//将各个位数可组合数的需求进行统计 &#123; for(int now=0;now&lt;n;now++) &#123; for(int temp=1;temp&lt;=10;temp++) &#123; int times=(long long)pow(10,temp)%k; mymap[temp][(k-myarray[now]*times%k)%k]++;//在temp次幂的情况下 对后数余数为 k-array[now]*times%k 的需求加一 //即后数为temp位数 并且余数为 k-array[now]*times%k 即可成功组合 //因为 array[now]*times%k 可能等于0 所以k减它可能等于k 所以需要总体%k一下 &#125; &#125;&#125;void func2(int n,int k)//遍历所有数 答案加上需求数 顺便去重 &#123; for(int now=0;now&lt;n;now++) &#123; int times=(int)log10(myarray[now])+1;//当前数位数 ans+=mymap[times][myarray[now]%k];//加上所有可以组合的 if((myarray[now]*(int)pow(10,times)%k+myarray[now]%k)%k==0)//去重 &#123; ans--;//如果一个数跟自己组合也满足条件 说明上面多加了一次 减去它 &#125; &#125;&#125; int main() &#123; int n,k; memset(mymap,0,sizeof(mymap)); scanf(&quot;%d %d&quot;,&amp;n,&amp;k); for(int now=0;now&lt;n;now++) &#123; scanf(&quot;%lld&quot;,&amp;myarray[now]); &#125; func1(n,k); func2(n,k); printf(&quot;%lld&quot;,ans); return 0;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://zgg2001.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}]},{"title":"2020 蓝桥杯 C/C++实现 7月B组省赛","slug":"20200906_2020蓝桥杯C-C++实现7月B组省赛","date":"2020-09-06T09:52:31.000Z","updated":"2020-09-06T09:52:31.000Z","comments":true,"path":"2020/09/06/20200906_2020蓝桥杯C-C++实现7月B组省赛/","permalink":"https://zgg2001.github.io/2020/09/06/20200906_2020%E8%93%9D%E6%A1%A5%E6%9D%AFC-C++%E5%AE%9E%E7%8E%B07%E6%9C%88B%E7%BB%84%E7%9C%81%E8%B5%9B/","excerpt":"2020蓝桥杯 C&#x2F;C++ 7月B组省赛原题 &amp; 题解","text":"2020蓝桥杯 C&#x2F;C++ 7月B组省赛原题 &amp; 题解 @TOC 试题 A: 跑步训练本题总分：5 分问题：小明要做一个跑步训练。初始时，小明充满体力，体力值计为 10000。如果小明跑步，每分钟损耗600 的体力。如果小明休息，每分钟增加 300 的体力。体力的损耗和增加都是均匀变化的。小明打算跑一分钟、休息一分钟、再跑一分钟、再休息一分钟……如此循环。如果某个时刻小明的体力到达 0，他就停止锻炼。请问小明在多久后停止锻炼。为了使答案为整数，请以秒为单位输出答案。答案中只填写数，不填写单位。 思路： 简单循环即可。 答案： 3880 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int first=10000,ans=0; while(first) &#123; if(first&gt;=600) &#123; first-=600; ans+=60; first+=300; ans+=60; &#125; else &#123; ans+=first/10; first=0; &#125; &#125; cout&lt;&lt;ans; return 0;&#125; 试题 B: 纪念日本题总分：5 分问题：2020 年 7 月 1 日是中国某党成立 99 周年纪念日。中国某党成立于 1921 年 7 月 23 日。请问从 1921 年 7 月 23 日中午 12 时到 2020 年 7 月 1 日中午 12 时一共含多少分钟？ 思路： 先算多少天，再算多少时，再算多少分钟。 答案： 52038720 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int ans=0; for(int now=1922;now&lt;2020;now++)//1922到2019年共有多少天 &#123; if(now%100!=0&amp;&amp;now%4==0||now%400==0) &#123; ans+=366; &#125; else &#123; ans+=365; &#125; &#125; ans=ans+31+29+31+30+31+30;//2020年1到6月有多少天 ans=ans+31+30+31+30+31;//1921年8月到12月有多少天 ans+=9;//加上多余那几天 ans*=24;//换算成时 ans*=60;//换算成分 cout&lt;&lt;ans; return 0;&#125; 试题 C: 合并检测本题总分：10 分问题：新冠疫情由新冠病毒引起，最近在 A 国蔓延，为了尽快控制疫情，A 国准 备给大量民众进病毒核酸检测。然而，用于检测的试剂盒紧缺。 为了解决这一困难，科学家想了一个办法：合并检测。即将从多个人（k 个）采集的标本放到同一个试剂盒中进行检测。如果结果为阴性，则说明这 k 个人都是阴性，用一个试剂盒完成了 k 个人的检测。如果结果为阳性，则说明 至少有一个人为阳性，需要将这 k 个人的样本全部重新独立检测（从理论上看， 如果检测前 k−1 个人都是阴性可以推断出第 k 个人是阳性，但是在实际操作中 不会利用此推断，而是将 k 个人独立检测），加上最开始的合并检测，一共使用 了 k + 1 个试剂盒完成了 k 个人的检测。 A 国估计被测的民众的感染率大概是 **1%**，呈均匀分布。请问 k 取多少能 最节省试剂盒？ 思路： 假设有一共检测m个人，则第一批检测需要m&#x2F;k个试剂盒（向上取整）。由于感染率为1%，且均匀分布，则有0.01 * m个试剂盒会有阳性反应。这时进行第二批挨个检测，检测盒数量即为0.01 * m * k个。则总需求盒子数即为m&#x2F;k+0.01 * m * k个（m&#x2F;k向上取整）。 答案： 10 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int min_=999,min_k=0; int m=100;//假设初始人有100 for(int k=1;k&lt;=100;k++) &#123; int need=m/k+0.01*m*k; if(m%k!=0) need++; if(need&lt;min_) &#123; min_=need; min_k=k; &#125; &#125; cout&lt;&lt;min_k; return 0;&#125; 试题 D: REPEAT 程序本题总分：15 分问题：附件 prog.txt 中是一个用某种语言写的程序。prog.txt 附件下载地址其中 REPEAT k 表示一个次数为 k 的循环。循环控制的范围由缩进表达，从次行开始连续的缩进比该行多的（前面的空白更长的）为循环包含的内容。例如如下片段： A &#x3D; A + 4 所在的行到 A &#x3D; A + 8 所在的行都在第一行的循环两次中。REPEAT 6: 所在的行到 A &#x3D; A + 7 所在的行都在 REPEAT 5: 循环中。A &#x3D; A + 5 实际总共的循环次数是 2 × 5 × 6 &#x3D; 60 次。请问该程序执行完毕之后，A 的值是多少？ 思路： 可以建立一个栈来存放循环的信息，一个变量times存放当前行数被执行的次数。通过对文本的观察我们发现，可以通过每一行前面的空格数量来判断当前行数的“等级”，4个空格代表一个等级。如果当前行等级比上一层循环的等级低则说明退出了上一层循环，对栈和times进行改变即可。随后我们发现整个文本里面，所有数字都为单位数，所以我们直接用循环找到一个数字即可提取出该行的有效数字。 答案： 241830 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string string_; stack&lt;int&gt;stack_; freopen(&quot;prog.txt&quot;, &quot;rb&quot;, stdin); getline(cin, string_);//读第一行 A=0 int A=0,times=1,old_counts=0;//A=0,当前倍数，老的层数 while(getline(cin, string_)) &#123; int counts=0;//当前的层数， for(counts=0;counts&lt;string_.size();counts++) &#123; //记录空格数 4个空格是一层 if(string_[counts]!=&#x27; &#x27;) break; &#125; counts/=4;//这句话的层数 while(counts&lt;old_counts)//新层数低 则退出一层循环 pop &#123; times/=stack_.top(); stack_.pop(); old_counts--; &#125; if(string_[counts*4]==&#x27;R&#x27;)//R开头就是新增循环 &#123; for(int now=counts*4;now&lt;string_.size();now++)//找到数字 &#123; if(string_[now]&gt;=&#x27;0&#x27;&amp;&amp;string_[now]&lt;=&#x27;9&#x27;)//如果是数字 &#123; stack_.push(string_[now]-&#x27;0&#x27;); times*=string_[now]-&#x27;0&#x27;; old_counts++; break; &#125; &#125; &#125; else//否则就是执行计算操作 &#123; for(int now=counts*4;now&lt;string_.size();now++)//找到数字 &#123; if(string_[now]&gt;=&#x27;0&#x27;&amp;&amp;string_[now]&lt;=&#x27;9&#x27;)//如果是数字 &#123; A+=(string_[now]-&#x27;0&#x27;)*times; break; &#125; &#125; &#125; &#125; cout&lt;&lt;A; return 0;&#125; 试题 E: 矩阵本题总分：15 分问题：把 1 ∼ 2020 放在 2 × 1010 的矩阵里。要求同一行中右边的比左边大，列中下边的比上边的大。一共有多少种方案？答案很大，你只需要给出方案数除以 2020 的余数即可。 思路： 动态规划。 答案： 1340 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;int f[1020][1020];int main()&#123; f[0][0] = 1; // 两行一个数字都不放，也是一种方案 for (int i = 0; i &lt;= 1010; i ++) for (int j = 0; j &lt;= 1010; j ++) &#123; if(i - 1 &gt;= j) // 转移前的状态也要合法，即第一行的数量不小于第二行的数量 f[i][j] += f[i - 1][j] % 2020; if(j) f[i][j] += f[i][j - 1] % 2020; &#125; cout &lt;&lt; f[1010][1010] &lt;&lt; endl; return 0;&#125; 以下五题均能通过AcWing的数据测试 试题 F: 整除序列时间限制: 1.0s 内存限制: 256.0MB 本题总分：15问题：有一个序列，序列的第一个数是 n，后面的每个数是前一个数整除 2，出这个序列中值为正数的项。 输入:输入一行包含一个整数 n。 输出：输出一行，包含多个整数，相邻的整数之间用一个空格分隔，表示答案。 样例输入：20 样例输出：20 10 5 2 1 评测用例规模与约定：对于 80% 的评测用例，1 ≤ n ≤ 10的9次方。对于所有评测用例，1 ≤ n ≤ 10的18次方。 思路： 直接循环除就好。 AC代码： OJ链接 1234567891011121314#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; long long n=0; scanf(&quot;%lld&quot;,&amp;n); while(n) &#123; printf(&quot;%lld &quot;,n); n&gt;&gt;=1; &#125; return 0;&#125; 试题 G: 解码时间限制: 1.0s 内存限制: 256.0MB 本题总分：20 分问题：小明有一串很长的英文字母，可能包含大写和小写。在这串字母中，有很多连续的是重复的。小明想了一个办法将这串字达得更短：将连续的几个相同字母写成字母 + 出现次数的形式。例如，连续的 5 个 a，即 aaaaa，小明可以简写成 a5（也可能简写aa3a 等）。对于这个例子：HHHellllloo，小明可以简写成 H3el5o2。为了方便表达，小明不会将连续的超过 9 个相同的字符写成简写的形式。现在给出简写后的字符串，请帮助小明还原成原来的串。 输入：输入一行包含一个字符串。 输出：输出一个字符串，表示还原后的串。 样例输入：H3el5o2 样例输出：HHHellllloo 评测用例规模与约定：对于所有评测用例，字符串由大小写英文字母和数字组成，长度不100。请注意原来的串长度可能超过 100。 思路： 对字符串进行循环判断即可。 AC代码： OJ链接 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string string_; char old_letter;//老字母 getline(cin,string_); old_letter=string_[0];//指向第一个字母 for(int now=1;now&lt;string_.size();now++) &#123; if(string_[now]&gt;=&#x27;1&#x27;&amp;&amp;string_[now]&lt;=&#x27;9&#x27;)//数字就循环输出 &#123; for(int temp=0;temp&lt;string_[now]-&#x27;0&#x27;-1;temp++) &#123; printf(&quot;%c&quot;,old_letter); &#125; &#125; else//否则输出一次 换新字 &#123; printf(&quot;%c&quot;,old_letter); old_letter=string_[now]; &#125; &#125; printf(&quot;%c&quot;,old_letter); return 0;&#125; 试题 H: 走方格时间限制: 1.0s 内存限制: 256.0MB 本题总分：20 分问题：在平面上有一些二维的点阵。这些点的编号就像二维数组的编号一样，从上到下依次为第 1 至第 n 行，从左到右依次为第 1 至第 m 列，每一个点可以用行号和列号来表示。现在有个人站在第 1 行第 1 列，要走到第 n 行第 m 列。只能向右或者向下走。注意，如果行号和列数都是偶数，不能走入这一格中。问有多少种方案。 输入：输入一行包含两个整数 n, m。 输出：输出一个整数，表示答案。 样例输入1：3 4 样例输出1：2 样例输入2：6 6 样例输出2：0 评测用例规模与约定：对于所有评测用例，1 ≤ n ≤ 30, 1 ≤ m ≤ 30。 思路： dfs暴力搜索的话，当n&#x3D;29，m&#x3D;30的时候会超时。我们可以用dp把结果都记录下来然后直接输出。记得行号列号都是偶数的时候跳过，因为不能走入这种方格。 AC代码： OJ链接 1.dfs写法（超时）12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;int fx[2][2]=&#123;&#123;0,1&#125;,&#123;1,0&#125;&#125;,ans=0;//右/下 答案 int n,m,a1,b1;//n,m void dfs(int a,int b)&#123; if(a==n&amp;&amp;b==m) &#123; ans++; return; &#125; for(int now=0;now&lt;2;now++) &#123; a1=a+fx[now][0]; b1=b+fx[now][1]; if(a1&gt;n||b1&gt;m) continue; if(!(a1&amp;1)&amp;&amp;!(b1&amp;1)) continue; dfs(a1,b1); &#125;&#125; int main()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); if(!(n&amp;1)&amp;&amp;!(m&amp;1)) &#123; cout&lt;&lt;0; return 0; &#125; dfs(1,1); cout&lt;&lt;ans; return 0;&#125; 2.dp写法（可AC） 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int dp[31][31];//dp int n,m;//n,m scanf(&quot;%d %d&quot;,&amp;n,&amp;m); memset(dp,0,sizeof(dp)); dp[1][1]=1; for(int now=1;now&lt;=30;now++) &#123; for(int now1=1;now1&lt;=30;now1++) &#123; if(!(now&amp;1)&amp;&amp;!(now1&amp;1))//都是偶数就跳过 continue; if(now-1&gt;=1) &#123; dp[now][now1]+=dp[now-1][now1]; &#125; if(now1-1&gt;=1) &#123; dp[now][now1]+=dp[now][now1-1]; &#125; &#125; &#125; /*for(int now=1;now&lt;=30;now++) &#123; for(int now1=1;now1&lt;=30;now1++) &#123; printf(&quot;%d &quot;,dp[now][now1]); &#125; printf(&quot;\\n&quot;); &#125;*/ cout&lt;&lt;dp[n][m]; return 0;&#125; 试题 I: 整数拼接时间限制: 1.0s 内存限制: 256.0MB 本题总分：25 分问题：给定义个长度为 n 的数组 A1, A2, · · · , An。你可以从中选出两个数 Ai (i 不等于 j)，然后将 Ai 和 Aj 一前一后拼成一个新的整数。例如 12 和 以拼成 12345 或 34512。注意交换 Ai 和 Aj 的顺序总是被视为 2 种拼法，是 Ai &#x3D; Aj 时。请你计算有多少种拼法满足拼出的整数是 K 的倍数。 输入：第一行包含 2 个整数 n 和 K。第二行包含 n 个整数 A1, A2, · · · , An。 输出：一个整数代表答案。 样例输入：4 21 2 3 4 样例输出：6 评测用例规模与约定：对于 30% 的评测用例，1 ≤ n ≤ 1000, 1 ≤ K ≤ 20, 1 ≤ Ai ≤ 10的四次方。对于所有评测用例，1 ≤ n ≤ 10的五次方，1 ≤ K ≤ 10的五次方，1 ≤ Ai ≤ 10的九次方。 思路： 直接暴力肯定超时。我们可以先进行一次操作，对所有数字进行遍历。求出对于每个数，后数为多少时满足题目要求。因为所有数都小于等于十的九次方，即最多为10位数，所以我们只需要求每个数在后数为1位数到10位数时对后数的余数要求即可。然后再遍历一次判定满足要求的后数，总答案加上对该后数的需求即可。数据接收数组选择long long，防止运算中数据超限。答案也选择long long，防止储存不下。 具体思路如下： 整式为 （数一*10^数二的位数^+数二）%k &#x3D;&#x3D; 0 即数一数二满足要求 我们遍历整个数组，按 （k - 数一*10^1-10^%k）%k 求出数一在1-10次方的情况下对后数余数的要求。这次遍历统计的是数一对于数二的需求。 用一个二维数组 mymap[位数][余数需求] 来储存对于 特定数二 的需求数量。 再次遍历整个数组，对数组元素的位数与余数进行计算，如果位数与余数满足需求，总答案则加上上一步中统计的需求数量。这次遍历是为了寻找数二。 在遍历中，我们需要进行去重判定。如果一个数跟自己组合也满足条件，说明上面多加了一次，总答案减去1。 AC代码： OJ链接 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;long long myarray[100001];//存数 int mymap[11][100001];//存不同幂情况下对余数的需求 mymap[幂][需求]=数量 long long ans=0;//答案 void func1(int n,int k)//将各个位数可组合数的需求进行统计 &#123; for(int now=0;now&lt;n;now++) &#123; for(int temp=1;temp&lt;=10;temp++) &#123; int times=(long long)pow(10,temp)%k; mymap[temp][(k-myarray[now]*times%k)%k]++;//在temp次幂的情况下 对后数余数为 k-array[now]*times%k 的需求加一 //即后数为temp位数 并且余数为 k-array[now]*times%k 即可成功组合 //因为 array[now]*times%k 可能等于0 所以k减它可能等于k 所以需要总体%k一下 &#125; &#125;&#125;void func2(int n,int k)//遍历所有数 答案加上需求数 顺便去重 &#123; for(int now=0;now&lt;n;now++) &#123; int times=(int)log10(myarray[now])+1;//当前数位数 ans+=mymap[times][myarray[now]%k];//加上所有可以组合的 if((myarray[now]*(int)pow(10,times)%k+myarray[now]%k)%k==0)//去重 &#123; ans--;//如果一个数跟自己组合也满足条件 说明上面多加了一次 减去它 &#125; &#125;&#125; int main() &#123; int n,k; memset(mymap,0,sizeof(mymap)); scanf(&quot;%d %d&quot;,&amp;n,&amp;k); for(int now=0;now&lt;n;now++) &#123; scanf(&quot;%lld&quot;,&amp;myarray[now]); &#125; func1(n,k); func2(n,k); printf(&quot;%lld&quot;,ans); return 0;&#125; 试题 J: 网络分析时间限制: 1.0s 内存限制: 256.0MB 本题总分：25 分问题：小明正在做一个网络实验。他设置了 n 台电脑，称为节点，用于收发和存储数据。初始时，所有节点都是独立的，不存在任何连接。小明可以通过网线将两个节点连接起来，连接后两个节点就可以互相了。两个节点如果存在网线连接，称为相邻。小明有时会测试当时的网络，他会在某个节点发送一条信息，信息会到每个相邻的节点，之后这些节点又会转发到自己相邻的节点，直到所有或间接相邻的节点都收到了信息。所有发送和接收的节点都会将信息存储一条信息只存储一次。给出小明连接和测试的过程，请计算出每个节点存储信息的大小。 输入：输入的第一行包含两个整数 n, m，分别表示节点数量和操作数量。节1 至 n 编号。接下来 m 行，每行三个整数，表示一个操作。如果操作为 1 a b，表示将节点 a 和节点 b 通过网线连接起来。当 时，表示连接了一个自环，对网络没有实质影响。如果操作为 2 p t，表示在节点 p 上发送一条大小为 t 的信息。 输出：输出一行，包含 n 个整数，相邻整数之间用一个空格分割，依次表示完上述操作后节点 1 至节点 n 上存储信息的大小。 样例输入：4 81 1 22 1 102 3 51 4 12 2 21 1 21 2 42 2 1 样例输出：13 13 5 3 评测用例规模与约定：对于 30% 的评测用例，1 ≤ n ≤ 20，1 ≤ m ≤ 100。对于 50% 的评测用例，1 ≤ n ≤ 100，1 ≤ m ≤ 1000。对于 70% 的评测用例，1 ≤ n ≤ 1000，1 ≤ m ≤ 10000。对于所有评测用例，1 ≤ n ≤ 10000，1 ≤ m ≤ 100000，1 ≤ t ≤ 100。 思路： 核心思路是并查集。一个数组用来存旧值，一个数组用来存根结点权值，一个数组是并查集的father数组。执行2操作时，查集寻找到操作值的根结点并加权。执行1操作时，若两数在一个集内则不操作；若两数不在一个集内，则对所有节点进行遍历，使他们的旧值数组加上其根节点的权值，随后进行并集操作。记得对权值数组进行清零，防止后面重复计算。 AC代码： OJ链接 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;int old_[10001],new_[10001],father[10001],n,m;//存老值 存根节点新值 父节点数组 int find(int a)&#123; return father[a]==a ? a : father[a]=find(father[a]);//路径压缩&#125;void union_(int a,int b)&#123; int temp_a=find(a),temp_b=find(b); if(temp_a!=temp_b) &#123; for(register int now=1;now&lt;=n;now++) &#123; old_[now]+=new_[find(now)];//旧值数组遍历加上权值 &#125; memset(new_,0,sizeof(new_));//重置权值数组，防止重复计算 father[temp_a]=temp_b; &#125;&#125;int main()&#123; int a,b,c; memset(new_,0,sizeof(new_)); for(register int now=1;now&lt;=10000;now++) &#123; father[now]=now;//father数组初始化 &#125; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); while(m--) &#123; scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c); if(a==1) &#123; union_(b,c); &#125; else &#123; new_[find(b)]+=c; &#125; &#125; for(register int now=1;now&lt;=n;now++) &#123; printf(&quot;%d &quot;,old_[now]+new_[find(now)]); &#125; return 0;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://zgg2001.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}]},{"title":"2020 蓝桥杯 C/C++实现 7月C组省赛","slug":"20200903_2020蓝桥杯C-C++实现7月C组省赛","date":"2020-09-03T14:54:29.000Z","updated":"2020-09-03T14:54:29.000Z","comments":true,"path":"2020/09/03/20200903_2020蓝桥杯C-C++实现7月C组省赛/","permalink":"https://zgg2001.github.io/2020/09/03/20200903_2020%E8%93%9D%E6%A1%A5%E6%9D%AFC-C++%E5%AE%9E%E7%8E%B07%E6%9C%88C%E7%BB%84%E7%9C%81%E8%B5%9B/","excerpt":"2020蓝桥杯 C&#x2F;C++ 7月C组省赛原题 &amp; 题解","text":"2020蓝桥杯 C&#x2F;C++ 7月C组省赛原题 &amp; 题解 试题 A: 指数计算本题总分：5 分问题：请计算：7 ^ 2020 mod 1921，其中 A mod B 表示 A 除以 B 的余数。 思路： 快速幂。 答案： 480 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;long long ksm(int a,int b,int c)&#123; if(b==0) &#123; return 1; &#125; if(b==1) &#123; return a; &#125; if(b&amp;1) &#123; return a*ksm(a,b-1,c)%c; &#125; else &#123; long long ans=ksm(a,b/2,c)%c; return ans*ans%c; &#125;&#125;int main()&#123; printf(&quot;%lld&quot;,ksm(7,2020,1921)); return 0;&#125; 试题 B: 解密本题总分：5 分问题:小明设计了一种文章加密的方法：对于每个字母 c，将它变成某个另外的字符 Tc。下表给出了字符变换的规则：例如，将字符串 YeRi 加密可得字符串 EaFn。小明有一个随机的字符串，加密后为EaFnjISplhFviDhwFbEjRjfIBBkRyY(由 30 个大小写英文字母组成，不包含换行符），请问原字符串是多少？（如果你把以上字符串和表格复制到文本文件中，请务必检查复制的内容是否与文档中的一致。在试题目录下有一个文件 str.txt，第一行为上面的字符串，后面 52 行依次为表格中的内容。） 思路： 因为我没有文本形式的这个对照表。。。所以用的最笨的方法。 答案： YeRikGSunlRzgDlvRwYkXkrGWWhXaA 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string a=&quot;EaFnjISplhFviDhwFbEjRjfIBBkRyY&quot;; //cin&gt;&gt;a; //EaFnjISplhFviDhwFbEjRjfIBBkRyY for(int now=0;now&lt;a.size();now++) &#123; switch(a[now]) &#123; case &#x27;a&#x27;:cout&lt;&lt;&#x27;e&#x27;;break; case &#x27;b&#x27;:cout&lt;&lt;&#x27;w&#x27;;break; case &#x27;c&#x27;:cout&lt;&lt;&#x27;f&#x27;;break; case &#x27;d&#x27;:cout&lt;&lt;&#x27;d&#x27;;break; case &#x27;e&#x27;:cout&lt;&lt;&#x27;y&#x27;;break; case &#x27;f&#x27;:cout&lt;&lt;&#x27;r&#x27;;break; case &#x27;g&#x27;:cout&lt;&lt;&#x27;o&#x27;;break; case &#x27;h&#x27;:cout&lt;&lt;&#x27;l&#x27;;break; case &#x27;i&#x27;:cout&lt;&lt;&#x27;g&#x27;;break; case &#x27;j&#x27;:cout&lt;&lt;&#x27;k&#x27;;break; case &#x27;k&#x27;:cout&lt;&lt;&#x27;h&#x27;;break; case &#x27;l&#x27;:cout&lt;&lt;&#x27;n&#x27;;break; case &#x27;m&#x27;:cout&lt;&lt;&#x27;c&#x27;;break; case &#x27;n&#x27;:cout&lt;&lt;&#x27;i&#x27;;break; case &#x27;o&#x27;:cout&lt;&lt;&#x27;p&#x27;;break; case &#x27;p&#x27;:cout&lt;&lt;&#x27;u&#x27;;break; case &#x27;q&#x27;:cout&lt;&lt;&#x27;m&#x27;;break; case &#x27;r&#x27;:cout&lt;&lt;&#x27;x&#x27;;break; case &#x27;s&#x27;:cout&lt;&lt;&#x27;s&#x27;;break; case &#x27;t&#x27;:cout&lt;&lt;&#x27;j&#x27;;break; case &#x27;u&#x27;:cout&lt;&lt;&#x27;q&#x27;;break; case &#x27;v&#x27;:cout&lt;&lt;&#x27;z&#x27;;break; case &#x27;w&#x27;:cout&lt;&lt;&#x27;v&#x27;;break; case &#x27;x&#x27;:cout&lt;&lt;&#x27;b&#x27;;break; case &#x27;y&#x27;:cout&lt;&lt;&#x27;a&#x27;;break; case &#x27;z&#x27;:cout&lt;&lt;&#x27;t&#x27;;break; case &#x27;A&#x27;:cout&lt;&lt;&#x27;E&#x27;;break; case &#x27;B&#x27;:cout&lt;&lt;&#x27;W&#x27;;break; case &#x27;C&#x27;:cout&lt;&lt;&#x27;F&#x27;;break; case &#x27;D&#x27;:cout&lt;&lt;&#x27;D&#x27;;break; case &#x27;E&#x27;:cout&lt;&lt;&#x27;Y&#x27;;break; case &#x27;F&#x27;:cout&lt;&lt;&#x27;R&#x27;;break; case &#x27;G&#x27;:cout&lt;&lt;&#x27;O&#x27;;break; case &#x27;H&#x27;:cout&lt;&lt;&#x27;L&#x27;;break; case &#x27;I&#x27;:cout&lt;&lt;&#x27;G&#x27;;break; case &#x27;J&#x27;:cout&lt;&lt;&#x27;K&#x27;;break; case &#x27;K&#x27;:cout&lt;&lt;&#x27;H&#x27;;break; case &#x27;L&#x27;:cout&lt;&lt;&#x27;N&#x27;;break; case &#x27;M&#x27;:cout&lt;&lt;&#x27;C&#x27;;break; case &#x27;N&#x27;:cout&lt;&lt;&#x27;I&#x27;;break; case &#x27;O&#x27;:cout&lt;&lt;&#x27;P&#x27;;break; case &#x27;P&#x27;:cout&lt;&lt;&#x27;U&#x27;;break; case &#x27;Q&#x27;:cout&lt;&lt;&#x27;M&#x27;;break; case &#x27;R&#x27;:cout&lt;&lt;&#x27;X&#x27;;break; case &#x27;S&#x27;:cout&lt;&lt;&#x27;S&#x27;;break; case &#x27;T&#x27;:cout&lt;&lt;&#x27;J&#x27;;break; case &#x27;U&#x27;:cout&lt;&lt;&#x27;Q&#x27;;break; case &#x27;V&#x27;:cout&lt;&lt;&#x27;Z&#x27;;break; case &#x27;W&#x27;:cout&lt;&lt;&#x27;V&#x27;;break; case &#x27;X&#x27;:cout&lt;&lt;&#x27;B&#x27;;break; case &#x27;Y&#x27;:cout&lt;&lt;&#x27;A&#x27;;break; case &#x27;Z&#x27;:cout&lt;&lt;&#x27;T&#x27;;break; &#125; &#125; return 0;&#125; 试题 C: 跑步训练本题总分：10 分问题：小明要做一个跑步训练。初始时，小明充满体力，体力值计为 10000。如果小明跑步，每分钟损耗600 的体力。如果小明休息，每分钟增加 300 的体力。体力的损耗和增加都是均匀变化的。小明打算跑一分钟、休息一分钟、再跑一分钟、再休息一分钟……如此循环。如果某个时刻小明的体力到达 0，他就停止锻炼。请问小明在多久后停止锻炼。为了使答案为整数，请以秒为单位输出答案。答案中只填写数，不填写单位。 思路： 简单循环即可。 答案： 3880 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int first=10000,ans=0; while(first) &#123; if(first&gt;=600) &#123; first-=600; ans+=60; first+=300; ans+=60; &#125; else &#123; ans+=first/10; first=0; &#125; &#125; cout&lt;&lt;ans; return 0;&#125; 试题 D: 合并检测本题总分：10 分问题：新冠疫情由新冠病毒引起，最近在 A 国蔓延，为了尽快控制疫情，A 国准 备给大量民众进病毒核酸检测。然而，用于检测的试剂盒紧缺。 为了解决这一困难，科学家想了一个办法：合并检测。即将从多个人（k 个）采集的标本放到同一个试剂盒中进行检测。如果结果为阴性，则说明这 k 个人都是阴性，用一个试剂盒完成了 k 个人的检测。如果结果为阳性，则说明 至少有一个人为阳性，需要将这 k 个人的样本全部重新独立检测（从理论上看， 如果检测前 k−1 个人都是阴性可以推断出第 k 个人是阳性，但是在实际操作中 不会利用此推断，而是将 k 个人独立检测），加上最开始的合并检测，一共使用 了 k + 1 个试剂盒完成了 k 个人的检测。 A 国估计被测的民众的感染率大概是 **1%**，呈均匀分布。请问 k 取多少能 最节省试剂盒？ 思路： 假设有一共检测m个人，则第一批检测需要m&#x2F;k个试剂盒（向上取整）。由于感染率为1%，且均匀分布，则有0.01 * m个试剂盒会有阳性反应。这时进行第二批挨个检测，检测盒数量即为0.01 * m * k个。则总需求盒子数即为m&#x2F;k+0.01 * m * k个（m&#x2F;k向上取整）。 答案： 10 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int min_=999,min_k=0; int m=100;//假设初始人有100 for(int k=1;k&lt;=100;k++) &#123; int need=m/k+0.01*m*k; if(m%k!=0) need++; if(need&lt;min_) &#123; min_=need; min_k=k; &#125; &#125; cout&lt;&lt;min_k; return 0;&#125; 试题 E: REPEAT 程序本题总分：15 分问题：附件 prog.txt 中是一个用某种语言写的程序。prog.txt 附件下载地址其中 REPEAT k 表示一个次数为 k 的循环。循环控制的范围由缩进表达，从次行开始连续的缩进比该行多的（前面的空白更长的）为循环包含的内容。例如如下片段： A &#x3D; A + 4 所在的行到 A &#x3D; A + 8 所在的行都在第一行的循环两次中。REPEAT 6: 所在的行到 A &#x3D; A + 7 所在的行都在 REPEAT 5: 循环中。A &#x3D; A + 5 实际总共的循环次数是 2 × 5 × 6 &#x3D; 60 次。请问该程序执行完毕之后，A 的值是多少？ 思路： 可以建立一个栈来存放循环的信息，一个变量times存放当前行数被执行的次数。通过对文本的观察我们发现，可以通过每一行前面的空格数量来判断当前行数的“等级”，4个空格代表一个等级。如果当前行等级比上一层循环的等级低则说明退出了上一层循环，对栈和times进行改变即可。随后我们发现整个文本里面，所有数字都为单位数，所以我们直接用循环找到一个数字即可提取出该行的有效数字。 答案： 241830 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string string_; stack&lt;int&gt;stack_; freopen(&quot;prog.txt&quot;, &quot;rb&quot;, stdin); getline(cin, string_);//读第一行 A=0 int A=0,times=1,old_counts=0;//A=0,当前倍数，老的层数 while(getline(cin, string_)) &#123; int counts=0;//当前的层数， for(counts=0;counts&lt;string_.size();counts++) &#123; //记录空格数 4个空格是一层 if(string_[counts]!=&#x27; &#x27;) break; &#125; counts/=4;//这句话的层数 while(counts&lt;old_counts)//新层数低 则退出一层循环 pop &#123; times/=stack_.top(); stack_.pop(); old_counts--; &#125; if(string_[counts*4]==&#x27;R&#x27;)//R开头就是新增循环 &#123; for(int now=counts*4;now&lt;string_.size();now++)//找到数字 &#123; if(string_[now]&gt;=&#x27;0&#x27;&amp;&amp;string_[now]&lt;=&#x27;9&#x27;)//如果是数字 &#123; stack_.push(string_[now]-&#x27;0&#x27;); times*=string_[now]-&#x27;0&#x27;; old_counts++; break; &#125; &#125; &#125; else//否则就是执行计算操作 &#123; for(int now=counts*4;now&lt;string_.size();now++)//找到数字 &#123; if(string_[now]&gt;=&#x27;0&#x27;&amp;&amp;string_[now]&lt;=&#x27;9&#x27;)//如果是数字 &#123; A+=(string_[now]-&#x27;0&#x27;)*times; break; &#125; &#125; &#125; &#125; cout&lt;&lt;A; return 0;&#125; 试题 F: 分类计数时间限制: 1.0s 内存限制: 512.0MB 本题总分：15 分问题：输入一个字符串，请输出这个字符串包含多少个大写字母，多少个小写字母，多少个数字。 输入：输入一行包含一个字符串。 输出：输出三行，每行一个整数，分别表示大写字母、小写字母和数字的个数。 样例输入：1+a&#x3D;Aab 样例输出：131 思路： 简单循环。 代码： 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string string_; getline(cin,string_); int ans_1=0,ans_2=0,ans_3=0;//大写，小写，数字 for (int now=0;now&lt;string_.size();now++) &#123; if(string_[now]&lt;=&#x27;Z&#x27;&amp;&amp;string_[now]&gt;=&#x27;A&#x27;) &#123; ans_1++; &#125; else if(string_[now]&lt;=&#x27;z&#x27;&amp;&amp;string_[now]&gt;=&#x27;a&#x27;) &#123; ans_2++; &#125; else if(string_[now]&lt;=&#x27;9&#x27;&amp;&amp;string_[now]&gt;=&#x27;0&#x27;) &#123; ans_3++; &#125; &#125; printf(&quot;%d\\n%d\\n%d\\n&quot;,ans_1,ans_2,ans_3); return 0;&#125; 试题 G: 整除序列时间限制: 1.0s 内存限制: 512.0MB 本题总分：20 分问题：有一个序列，序列的第一个数是 n，后面的每个数是前一个数整除 2，请输出这个序列中值为正数的项。 输入：输入一行包含一个整数 n。 输出：输出一行，包含多个整数，相邻的整数之间用一个空格分隔，表示答案。 样例输入：20 样例输出：20 10 5 2 1 评测用例规模与约定：对于 80% 的评测用例，1 ≤ n ≤ 10的9次方。对于所有评测用例，1 ≤ n ≤ 10的18次方。 思路： 简单循环即可。 代码： 1234567891011121314#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; long long n; scanf(&quot;%lld&quot;,&amp;n); while(n) &#123; printf(&quot;%lld &quot;,n); n&gt;&gt;=1; &#125; return 0;&#125; 试题 H: 走方格时间限制: 1.0s 内存限制: 512.0MB 本题总分：20 分问题：在平面上有一些二维的点阵。这些点的编号就像二维数组的编号一样，从上到下依次为第 1 至第 n 行，从左到右依次为第 1 至第 m 列，每一个点可以用行号和列号来表示。现在有个人站在第 1 行第 1 列，要走到第 n 行第 m 列。只能向右或者向下走。注意，如果行号和列数都是偶数，不能走入这一格中。问有多少种方案。 输入：输入一行包含两个整数 n, m。 输出：输出一个整数，表示答案。 样例输入1：3 4 样例输出1：2 样例输入2：6 6 样例输出2：0 评测用例规模与约定：对于所有评测用例，1 ≤ n ≤ 30, 1 ≤ m ≤ 30。 思路： dfs暴力搜索的话，当n&#x3D;29，m&#x3D;30的时候应该会超时。我们可以用dp把结果都记录下来然后直接输出。记得行号列号都是偶数的时候跳过，因为不能走入这种方格。 代码： dfs写法12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;int fx[2][2]=&#123;&#123;0,1&#125;,&#123;1,0&#125;&#125;,ans=0;//右/下 答案 int n,m,a1,b1;//n,m void dfs(int a,int b)&#123; if(a==n&amp;&amp;b==m) &#123; ans++; return; &#125; for(int now=0;now&lt;2;now++) &#123; a1=a+fx[now][0]; b1=b+fx[now][1]; if(a1&gt;n||b1&gt;m) continue; if(!(a1&amp;1)&amp;&amp;!(b1&amp;1)) continue; dfs(a1,b1); &#125;&#125; int main()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); if(!(n&amp;1)&amp;&amp;!(m&amp;1)) &#123; cout&lt;&lt;0; return 0; &#125; dfs(1,1); cout&lt;&lt;ans; return 0;&#125; dp写法 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int dp[31][31];//dp int n,m;//n,m scanf(&quot;%d %d&quot;,&amp;n,&amp;m); memset(dp,0,sizeof(dp)); dp[1][1]=1; for(int now=1;now&lt;=30;now++) &#123; for(int now1=1;now1&lt;=30;now1++) &#123; if(!(now&amp;1)&amp;&amp;!(now1&amp;1))//都是偶数就跳过 continue; if(now-1&gt;=1) &#123; dp[now][now1]+=dp[now-1][now1]; &#125; if(now1-1&gt;=1) &#123; dp[now][now1]+=dp[now][now1-1]; &#125; &#125; &#125; /*for(int now=1;now&lt;=30;now++) &#123; for(int now1=1;now1&lt;=30;now1++) &#123; printf(&quot;%d &quot;,dp[now][now1]); &#125; printf(&quot;\\n&quot;); &#125;*/ cout&lt;&lt;dp[n][m]; return 0;&#125; 试题 I: 字符串编码时间限制: 1.0s 内存限制: 512.0MB 本题总分：25 分问题：小明发明了一种给由全大写字母组成的字符串编码的方法。对于每一个大写字母，小明将它转换成它在 26 个英文字母中序号，即 A → 1, B → 2, … Z →26。这样一个字符串就能被转化成一个数字序列：比如 ABCXYZ → 123242526。现在给定一个转换后的数字序列，小明想还原出原本的字符串。当然这样的还原有可能存在多个符合条件的字符串。小明希望找出其中字典序最大的字符串。 输入：一个数字序列。 输出：一个只包含大写字母的字符串，代表答案 样例输入：123242526 样例输出：LCXYZ 评测用例规模与约定对于 20% 的评测用例，输入的长度不超过 20。对于所有评测用例，输入的长度不超过 200000。 思路： 多条件判定，连着两个数和大于26的单个输出，后数第两个值为0的单个输出……大概要点好像就这么多，欢迎补充。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string string_; getline(cin,string_); for(int now=0;now&lt;string_.size();) &#123; if(string_[now]==&#x27;1&#x27;)//开头为1 &#123; if(now+2&lt;string_.size())//后两位有数 &#123; if(string_[now+2]!=&#x27;0&#x27;)//后第两位不是0 &#123; printf(&quot;%c&quot;,(string_[now]-&#x27;0&#x27;)*10+string_[now+1]-&#x27;0&#x27;+&#x27;A&#x27;-1); now+=2;//后移两位 &#125; else &#123; printf(&quot;%c&quot;,string_[now]-&#x27;0&#x27;+&#x27;A&#x27;-1); now++;//后移一位 &#125; &#125; else if(now+1&lt;string_.size())//后一位有数 &#123; printf(&quot;%c&quot;,(string_[now]-&#x27;0&#x27;)*10+string_[now+1]-&#x27;0&#x27;+&#x27;A&#x27;-1); now+=2;//后移两位 &#125; else//最后一位直接输出 &#123; printf(&quot;%c&quot;,string_[now]-&#x27;0&#x27;+&#x27;A&#x27;-1); now++;//后移一位 &#125; &#125; else if(string_[now]==&#x27;2&#x27;)//开头为2 &#123; if(now+2&lt;string_.size())//后两位有数 &#123; if(string_[now+2]!=&#x27;0&#x27;)//后第两位不是0 &#123; if(string_[now+1]&lt;=&#x27;6&#x27;)//小于26 &#123; printf(&quot;%c&quot;,(string_[now]-&#x27;0&#x27;)*10+string_[now+1]-&#x27;0&#x27;+&#x27;A&#x27;-1); now+=2;//后移两位 &#125; else &#123; printf(&quot;%c&quot;,string_[now]-&#x27;0&#x27;+&#x27;A&#x27;-1); now++;//后移一位 &#125; &#125; else &#123; printf(&quot;%c&quot;,string_[now]-&#x27;0&#x27;+&#x27;A&#x27;-1); now++;//后移一位 &#125; &#125; else if(now+1&lt;string_.size())//后一位有数 &#123; if(string_[now+1]&lt;=&#x27;6&#x27;)//小于26 &#123; printf(&quot;%c&quot;,(string_[now]-&#x27;0&#x27;)*10+string_[now+1]-&#x27;0&#x27;+&#x27;A&#x27;-1); now+=2;//后移两位 &#125; else &#123; printf(&quot;%c&quot;,string_[now]-&#x27;0&#x27;+&#x27;A&#x27;-1); now++;//后移一位 &#125; &#125; else//最后一位直接输出 &#123; printf(&quot;%c&quot;,string_[now]-&#x27;0&#x27;+&#x27;A&#x27;-1); now++;//后移一位 &#125; &#125; else//其余直接输出 &#123; printf(&quot;%c&quot;,string_[now]-&#x27;0&#x27;+&#x27;A&#x27;-1); now++;//后移一位 &#125; &#125; return 0;&#125; 试题 J: 整数小拼接时间限制: 1.0s 内存限制: 512.0MB 本题总分：25 分问题：给定义个长度为 n 的数组 A1, A2, · · · , An。你可以从中选出两个数 Ai 和 Aj (i不等于 j)，然后将 Ai 和 Aj 一前一后拼成一个新的整数。例如 12 和 345 可以拼成 12345 或 34512 。注意交换 Ai 和 Aj 的顺序总是被视为 2 种拼法，即便是 Ai &#x3D; Aj 时。请你计算有多少种拼法满足拼出的整数小于等于 K。 输入：第一行包含 2 个整数 n 和 K。第二行包含 n 个整数 A1, A2, · · · , An。 输出：一个整数代表答案。 样例输入：4 331 2 3 4 样例输出：8 评测用例规模与约定：对于 30% 的评测用例，1 ≤ N ≤ 1000, 1 ≤ K ≤ 10的8次方, 1 ≤ Ai ≤ 10的四次方。对于所有评测用例，1 ≤ N ≤ 100000，1 ≤ K ≤ 10的十次方，1 ≤ Ai ≤ 10的九次方。 思路： 暴力求解应该只能过30%样例。我的思路是在第一次接收数组的时候，直接再次按位数存到二维数组里。在接下来的判断中，两个数的位数相加小于K的位数的话，就是合法值。两个数的位数相加等于K的时候再相加准确计算，由于数据最大为十的十次方，所以用long long存。这样的思路应该能比直接暴力快不少，评测点应该能多过几个，但是能不能AC我也不清楚，毕竟现在也没样例数据。如果大佬们有好的思路，麻烦指导下谢谢。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;long long array[100001];//存数据 vector&lt;long long&gt;mymap[10];//存上面数组的每个数的位数 int main()&#123; long long n,k,ans=0; scanf(&quot;%lld %lld&quot;,&amp;n,&amp;k); for(int now=0;now&lt;n;now++) &#123; scanf(&quot;%lld&quot;,&amp;array[now]); mymap[(int)log10(array[now])+1].push_back(array[now]);//按位数存进mymap里 &#125; int k_count=(int)log10(k)+1,temp,temp1;//k的位数 中间值（后面用） for(int now=1;now&lt;k_count-1;now++)//两个数位数相加小于k的位数 说明肯定小于k 直接交叉相乘 &#123; for(int now1=1;now1+now&lt;k_count;now1++) &#123; ans+=mymap[now].size()*mymap[now1].size(); if(now==now1)//如果位数相同 则有重复计算 &#123; ans-=mymap[now].size();//减去一部分 &#125; &#125; &#125; sort(array,array+n);//先排个序 一会循环到位数大于等于k的位数的时候 直接break; for(int now=0;now&lt;n;now++)//两个数位数相加等于k的情况 挨个判断 &#123; temp=(int)log10(array[now])+1; if(temp&gt;=k_count) break; temp1=mymap[k_count-temp].size(); for(int now1=0;now1&lt;temp1;now1++) &#123; //cout&lt;&lt;array[now]*pow(10,k_count-temp)+mymap[k_count-temp][now1]&lt;&lt;&quot; &quot;&lt;&lt;k&lt;&lt;endl; if(array[now]*pow(10,k_count-temp)+mymap[k_count-temp][now1]&lt;=k)//两数相加小于等于k &#123; ans++; &#125; &#125; if(temp==k_count-temp&amp;&amp;array[now]*pow(10,k_count-temp)+array[now]&lt;=k)//重复计数 减一个 &#123; ans--; &#125; &#125; printf(&quot;%d&quot;,ans); return 0;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://zgg2001.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}]},{"title":"c/c++算法 基础题 练手汇总","slug":"20200902_c++算法基础题练手汇总","date":"2020-09-02T10:40:16.000Z","updated":"2020-09-02T10:40:16.000Z","comments":true,"path":"2020/09/02/20200902_c++算法基础题练手汇总/","permalink":"https://zgg2001.github.io/2020/09/02/20200902_c++%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E9%A2%98%E7%BB%83%E6%89%8B%E6%B1%87%E6%80%BB/","excerpt":"因为是基础题所以都不算难，个人把碰见过的感觉比较好的练手基础题在这里做个汇总，方便查阅。","text":"因为是基础题所以都不算难，个人把碰见过的感觉比较好的练手基础题在这里做个汇总，方便查阅。 枚举 一般都是数据量比较小的简单题，难点在于对数据的判断处理。用循环直接对数据区间枚举随后进行判断即可。如果数据量较大，就优化判断条件或者找共性减少运算时间。 1.安全区题目描述在一个nn的网格图上有m个探测器，第i个探测器位于(xi,yi)位置，探测半径为ri。求出nn个点中有多少个是安全的点，即未被探测的点。 输入第一行为两个整数n,m(1&lt;&#x3D;n&lt;&#x3D;100,1&lt;&#x3D;m&lt;&#x3D;n*n)接下来m行每行3个整数表示xi,yi,ri（1&lt;&#x3D;xi,yi,ri&lt;&#x3D;n） 输出输出一个整数表示答案 样例输入5 23 3 14 2 1 样例输出17 OJ链接 思路： 重点是半径判断，我是用sqrt((x-x1) * (x-x1) + (y-y1) * (y-y1)) &gt; r 来判断是否在检测半径内，同时用二维数组来储存是否能被探测到。 AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;bool mymap[101][101];void func(int x,int y,int r,int n)//中心点 x y 探测半径 r 地图总长 n&#123; for(int a=x-r;a&lt;=x+r;a++) &#123; if(a&lt;1||a&gt;n)//x超界 continue; for(int b=y-r;b&lt;=y+r;b++) &#123; if(b&lt;1||b&gt;n)//y超界 continue; if(sqrt((x-a)*(x-a)+(y-b)*(y-b))&gt;r)//不在半径内 continue; //printf(&quot;%lf %d\\n&quot;,sqrt((x-a)*(x-a)+(y-b)*(y-b)),r); if(!mymap[a][b]) mymap[a][b]=true; &#125; &#125;&#125;int main()&#123; memset(mymap,false,sizeof(mymap)); int n,m,xi,yi,ri,ans=0; cin&gt;&gt;n&gt;&gt;m; /*for(int a=1;a&lt;=n;a++) &#123; for(int b=1;b&lt;=n;b++) &#123; printf(&quot;%d &quot;,mymap[a][b]); &#125; printf(&quot;\\n&quot;); &#125;*/ for(int temp=0;temp&lt;m;temp++) &#123; cin&gt;&gt;xi&gt;&gt;yi&gt;&gt;ri; func(xi,yi,ri,n); &#125; for(int a=1;a&lt;=n;a++) &#123; for(int b=1;b&lt;=n;b++) &#123; //printf(&quot;%d &quot;,mymap[a][b]); if(mymap[a][b]==false) ans++; &#125; //printf(&quot;\\n&quot;); &#125; cout&lt;&lt;ans; return 0;&#125; 2.统计方形题目描述有一个n*m方格的棋盘，求其方格包含多少正方形、长方形（此处长方形不包含正方形） 输入输入存在多组测试数据。每组测试数据输入两个整数n,m，数字不超过5000 输出对于每组数据输出一行包含两个整数，分别表示正方形数目和长方形数目 样例输入2 3 样例输出8 10 思路： 就是两层循环，代表当前图形的长和宽，长宽一样就是正方形，不一样就是长方形。然后求出这一行能有多少个这种图形(1+(m-b))，再求这一列有多少种这种图形(1+(n-a))，两者相乘就是这个图里有多少种这种图形。然后加到总数里，等循环跑完就是答案。 代码： 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n,m; long long ans1=0,ans2=0;//ans1=正方形 ans2=长方形 cin&gt;&gt;n&gt;&gt;m; for(int a=1;a&lt;=n;a++) &#123; for(int b=1;b&lt;=m;b++) &#123; if(a==b) &#123; ans1+=(1+(n-a))*(1+(m-a)); &#125; else &#123; ans2+=(1+(n-a))*(1+(m-b)); &#125; &#125; &#125; cout&lt;&lt;ans1&lt;&lt;&quot; &quot;&lt;&lt;ans2; return 0;&#125; 但是这样复杂度会比较高，可能会超时，所以有第二种求法。先求出总的矩形个数，再用一层循环求出正方形个数，总的减去正方形的就是长方形的。 AC代码： 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std; int main ()&#123; /*对于一个n*m的棋盘，共有矩形 (m+m-1+m-2+...+1)*(n+n-1+n-2+...+1) 即[m*(m+1)/2]*[n*(n+1)/2]个，这一步可知用前一个式子循环道加，也可版用后一个式子直接算； 共有正方形（假设m&gt;n) m*n+(m-1)*(n-1)+...+(m-n+1)*1 个，这步用循环做就行； 长方形就用 矩形权数 减去 正方形数 就行了。*/ int n,m; while(scanf(&quot;%d %d&quot;,&amp;n,&amp;m)!=EOF) &#123; long long sum1=0; for(int i=1;i&lt;=min(n,m);i++) &#123; sum1+=(n-i+1)*(m-i+1); &#125; printf(&quot;%lld &quot;,sum1); long long sum2=1LL*n*(n+1)/2*1LL*m*(m+1)/2;//1 printf(&quot;%lld\\n&quot;,sum2-sum1); &#125; return 0;&#125; 3.连续自然数和（尺取法）题目对于给定自然数N，求出存在多少个连续自然数段，长度至少为2，使得这些连续的自然数段之和为N。 输入输入有若干行，每行一个正整数n。(1&lt;&#x3D;n&lt;&#x3D;2000000) 输出对于每组测试数据输出第一个数字表示答案 样例输入910000 样例输出24 思路： 可以用for循环暴力循环出来，但是我下面是用的尺取法，来减少复杂度。 AC代码： 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n; while(scanf(&quot;%d&quot;,&amp;n)!=EOF) &#123; int ans=0,temp=0,f=1,e=1;//答案个数 中间值 头 尾 while(n!=0)//尺取 &#123; while(temp&lt;n&amp;&amp;e&lt;n) &#123; temp+=e; e++; &#125; if(temp&lt;n) &#123; break; &#125; if(temp==n&amp;&amp;e-f&gt;=1) &#123; ans++; &#125; temp-=f; f++; &#125; printf(&quot;%d\\n&quot;,ans); &#125; return 0;&#125; 4.蓝桥杯 数字分组问题描述 输入任意10个浮点数，根据它们的聚集程度划分为3组，输出每一组的平均值。 提供老师上课讲的一种思路：将10个数字进行在数轴上排序，然后计算每两个点间的距离，在所有的距离中选取两个最大距离处断开，这样就把10个数字分为了3组。 本题难度较大，如果深入讨论会比较复杂，大家可以只考虑如下面样例所示的分组情况非常简单的情况，只要简单情况能够成功计算，本题就能得分。 另外，本题内容有些超前，推荐大家自学一下数组那一章中第一节一维数组，然后使用一维数组来做。排序算法可以参考trustie平台上传的冒泡排序法参考资料。 输入格式 十个待输入的浮点数，使用空格隔开 输出格式 三组数的平均数，每输出一个需要换行 样例输入一个满足题目要求的输入范例。例1：50.4 51.3 52.3 9.5 10.4 11.6 19.1 20.8 21.9 49.6例2：8.6 7.4 3.5 17.9 19.1 18.5 37.6 40.4 38.5 40.0 样例输出与上面的样例输入对应的输出。例1：10.520.650.9例2:6.518.539.125 思路： 直接循环枚举检测间隔即可。 AC代码： OJ链接 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;double shuzu[10];int main()&#123; double max1=0,max2=0,m1,m2; for(int a=0;a&lt;10;a++) &#123; scanf(&quot;%lf&quot;,&amp;shuzu[a]); &#125; sort(shuzu,shuzu+10); for(int a=0;a&lt;9;a++) &#123; double temp=shuzu[a+1]-shuzu[a]; if(temp&gt;max1) &#123; max2=max1; m2=m1; max1=temp; m1=a; &#125; else if(temp&gt;max2) &#123; max2=temp; m2=a; &#125; &#125; double temp=0; for(int a=0;a&lt;=min(m1,m2);a++) &#123; temp+=shuzu[a]; &#125; printf(&quot;%g\\n&quot;,temp/(min(m1,m2)+1)); temp=0; for(int a=min(m1,m2)+1;a&lt;=max(m1,m2);a++) &#123; temp+=shuzu[a]; &#125; printf(&quot;%g\\n&quot;,temp/(max(m1,m2)-min(m1,m2))); temp=0; for(int a=max(m1,m2)+1;a&lt;=9;a++) &#123; temp+=shuzu[a]; &#125; printf(&quot;%g\\n&quot;,temp/(9-max(m1,m2))); return 0; &#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"2016 蓝桥杯 剪邮票 dfs","slug":"20200831_2016蓝桥杯剪邮票dfs","date":"2020-08-31T13:23:21.000Z","updated":"2020-08-31T13:23:21.000Z","comments":true,"path":"2020/08/31/20200831_2016蓝桥杯剪邮票dfs/","permalink":"https://zgg2001.github.io/2020/08/31/20200831_2016%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%89%AA%E9%82%AE%E7%A5%A8dfs/","excerpt":"这是2016年蓝桥杯C语言省赛B组的第七题","text":"这是2016年蓝桥杯C语言省赛B组的第七题 题目：如下图, 有12张连在一起的12生肖的邮票。现在你要从中剪下5张来，要求必须是连着的。（仅仅连接一个角不算相连） 比如，下面两张图中，粉红色所示部分就是合格的剪取。 请你计算，一共有多少种不同的剪取方法。 输出：请填写表示方案数目的整数。 OJ链接 思路： 首先，我们将数组储存为1 2 3 46 7 8 911 12 13 14这样如果两数相减绝对值是5则是上下相邻关系，绝对值是1则是左右相邻关系。 通过对上图的观察我们可以发现，如果满足题意，则各邮票的相连邮票数量之和一定大于等于8，且每个邮票都有相连邮票。（上面两个图的相连数量之和都为8，如果剪12567的话相连数量就是9）按照这个规律我们就可以用双重循环来搜索答案了。 前面用5层循环来组合出所有可能，防止重复。 AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt; using namespace std;int temp[]=&#123;1,2,3,4,6,7,8,9,11,12,13,14&#125;;int shuzu[5]; int ans=0;/*1 2 3 46 7 8 911 12 13 14*/bool judge()&#123; int count=0; for(int now=0;now&lt;5;now++)//取前五个 看是否都相连 &#123; int flag=0;//先假设不相连 for(int now1=0;now1&lt;5;now1++)//挨个判断 &#123; if(now==now1) continue; if(abs(shuzu[now1]-shuzu[now])==5||abs(shuzu[now1]-shuzu[now])==1)//上下相连 绝对值为5 或者 左右相连 绝对值为1 &#123; flag+=1;//相连点位+1 &#125; &#125; if(flag==0)//如果是孤立点 没有相连点位 就直接返回false &#123; return false; &#125; count+=flag;//加上连接数 &#125; if(count&lt;8)//如果连接数小于8 则说明5个点位没有相互相邻 &#123; return false; &#125; //printf(&quot;%d %d %d %d %d\\n&quot;,shuzu[0],shuzu[1],shuzu[2],shuzu[3],shuzu[4]); return true;&#125;int main()&#123; for(int a=0;a&lt;12;a++) &#123; for(int b=a+1;b&lt;12;b++) &#123; for(int c=b+1;c&lt;12;c++) &#123; for(int d=c+1;d&lt;12;d++) &#123; for(int e=d+1;e&lt;12;e++) &#123; shuzu[0]=temp[a],shuzu[1]=temp[b],shuzu[2]=temp[c],shuzu[3]=temp[d],shuzu[4]=temp[e]; if(judge()) &#123; ans++; &#125; &#125; &#125; &#125; &#125; &#125; cout&lt;&lt;ans; return 0;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://zgg2001.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}]},{"title":"2017 蓝桥杯 日期问题","slug":"20200828_2017蓝桥杯日期问题","date":"2020-08-28T15:17:42.000Z","updated":"2020-08-28T15:17:42.000Z","comments":true,"path":"2020/08/28/20200828_2017蓝桥杯日期问题/","permalink":"https://zgg2001.github.io/2020/08/28/20200828_2017%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%97%A5%E6%9C%9F%E9%97%AE%E9%A2%98/","excerpt":"这是2017年蓝桥杯C语言省赛B组的第七题","text":"这是2017年蓝桥杯C语言省赛B组的第七题 题目描述小明正在整理一批历史文献。这些历史文献中出现了很多日期。小明知道这些日期都在1960年1月1日至2059年12月31日。令小明头疼的是，这些日期采用的格式非常不统一，有采用年&#x2F;月&#x2F;日的，有采用月&#x2F;日&#x2F;年的，还有采用日&#x2F;月&#x2F;年的。更加麻烦的是，年份也都省略了前两位，使得文献上的一个日期，存在很多可能的日期与其对应。比如02&#x2F;03&#x2F;04，可能是2002年03月04日、2004年02月03日或2004年03月02日。给出一个文献上的日期，你能帮助小明判断有哪些可能的日期对其对应吗？ 输入一个日期，格式是”AA&#x2F;BB&#x2F;CC”。 (0 &lt;&#x3D; A, B, C &lt;&#x3D; 9) 输出输出若干个不相同的日期，每个日期一行，格式是”yyyy-MM-dd”。多个日期按从早到晚排列。 样例输入02&#x2F;03&#x2F;04 样例输出2002-03-042004-02-032004-03-02 OJ链接 思路： 本来刚看见这道题，我还觉得很简单。。。但是一写发现情况很复杂，需要判定的东西很多，果然好歹也是偏后面的题，不会太简单。 我的思路就是主函数进行接收数据，然后在主函数里数据排序后，利用一个judge函数进行判定日期是否合法，如果合法就输出。 judge函数判定主要为：月是否合理、根据月份判断日是否合理（首先要判断是不是30&#x2F;31天的月，如果是2月则要判定是不是闰年，随后看日期是否超限）。 随后需要注意的是，相同日期只用输出一次，所以在主函数里我们需要判定judge函数的传参是否相同，如果相同就说明是相同日期，输出一次即可。 AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;using namespace std;void judge(int a,int b,int c)//判断是否合理 合理即输出 &#123; if(b&lt;1||b&gt;12)//月超标 pass return; if(c&lt;1||c&gt;31)//日超标 pass return; if((b==1||b==3||b==5||b==7||b==8||b==10||b==12)&amp;&amp;c&gt;31)//如果是 1 3 5 7 8 10 12月 并且日期大于31 pass return; if((b==4||b==6||b==9||b==11)&amp;&amp;c&gt;30)//如果是 4 6 9 11 月 并且日期大于30 pass return; if(b==2)//如果是2月就判断是不是闰年 &#123; if(a%400==0||(a%4==0&amp;&amp;a%100!=0))//是闰年 &#123; if(c&gt;29)//大于29天 pass return; &#125; else &#123; if(c&gt;28)//大于28天 pass return; &#125; &#125; printf(&quot;%d-%02d-%02d\\n&quot;,a,b,c);//成功输出 &#125;int main()&#123; int a,b,c,a1,c1; scanf(&quot;%d/%d/%d&quot;,&amp;a,&amp;b,&amp;c); a1=a; c1=c; if(a&lt;=59)//加100方便比较 a1+=100; if(c&lt;=59) c1+=100; /* 三种情况 a b c 年 月 日 （1） 月 日 年 （2) 日 月 年 (3) */ if(a1&lt;c1)//a小于c的话 先输出（1） 再（2）（3） &#123; judge(1900+a1,b,c);//判断是否合理 合理即输出 int max_temp = max(a,b);//取b,c最大值和最小值 int min_temp = min(a,b); judge(1900+c1,min_temp,max_temp);//按从小到大 输出（2）（3） if(max_temp!=min_temp)//防止重复输出 judge(1900+c1,max_temp,min_temp); &#125; else if(a1==c1)//只有一个年份 &#123; if(a==b)//三数相等就只输出一次 judge(1900+a1,b,c); else//否则按顺序输出 &#123; int max_temp = max(a,b);//取b,c最大值和最小值 int min_temp = min(a,b); judge(1900+a1,min_temp,max_temp); judge(1900+c1,max_temp,min_temp); &#125; &#125; else//先输出（2）（3）再（1） &#123; int max_temp = max(a,b);//取b,c最大值和最小值 int min_temp = min(a,b); judge(1900+c1,min_temp,max_temp);//按从小到大 输出（2）（3） if(max_temp!=min_temp)//防止重复输出 judge(1900+c1,max_temp,min_temp); judge(1900+a1,b,c);//判断是否合理 合理即输出 （1） &#125; return 0;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://zgg2001.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}]},{"title":"2018 蓝桥杯 日志统计 尺取法","slug":"20200827_2018蓝桥杯日志统计尺取法","date":"2020-08-27T03:09:37.000Z","updated":"2020-08-27T03:09:37.000Z","comments":true,"path":"2020/08/27/20200827_2018蓝桥杯日志统计尺取法/","permalink":"https://zgg2001.github.io/2020/08/27/20200827_2018%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%97%A5%E5%BF%97%E7%BB%9F%E8%AE%A1%E5%B0%BA%E5%8F%96%E6%B3%95/","excerpt":"这是2018年蓝桥杯C语言省赛B组的第八题","text":"这是2018年蓝桥杯C语言省赛B组的第八题 题目描述小明维护着一个程序员论坛。现在他收集了一份”点赞”日志，日志共有N行。其中每一行的格式是：ts id。表示在ts时刻编号id的帖子收到一个”赞”。现在小明想统计有哪些帖子曾经是”热帖”。如果一个帖子曾在任意一个长度为D的时间段内收到不少于K个赞，小明就认为这个帖子曾是”热帖”。具体来说，如果存在某个时刻T满足该帖在[T, T+D)这段时间内(注意是左闭右开区间)收到不少于K个赞，该帖就曾是”热帖”。给定日志，请你帮助小明统计出所有曾是”热帖”的帖子编号。 输入第一行包含三个整数N、D和K。以下N行每行一条日志，包含两个整数ts和id。1 &lt;&#x3D; K &lt;&#x3D; N &lt;&#x3D; 100000 0 &lt;&#x3D; ts &lt;&#x3D; 100000 0 &lt;&#x3D; id &lt;&#x3D; 100000 输出按从小到大的顺序输出热帖id。每个id一行。 样例输入7 10 20 10 1010 1010 19 1100 3100 3 样例输出13 OJ链接 思路：我的思路是一个二维数组储存每个id的点赞时间，即maps[id][]&#x3D;ts。然后根据maps数组对每个id运用尺取法进行条件判定，如果符合要求就是答案。为了减少对数组的搜索，我引入了一个set用来储存出现过的id号，然后对出现过的id号关联的数组进行查询即可。 尺取法： 我认为就是在一个连续的集合里，设定一个子集的首位位置和末尾位置，然后不断的推进首尾位置，寻找符合条件的子集。因为这题要计算相差的时间，所以数据必须是有序的，所以下面的代码中我使用了sort对maps数组进行排序。 AC代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt;maps[100001]; //二维数组储存每个节点的被点赞的时间 maps[x][0]就是x号帖子第一次被点赞的时间 set&lt;int&gt;alls; //储存出现的帖子编号 与maps配合 避免不必要的查询 直接maps[alls][]就行 int main()&#123; int n,d,k,ts,id; scanf(&quot;%d %d %d&quot;,&amp;n,&amp;d,&amp;k); while(n--) &#123; scanf(&quot;%d %d&quot;,&amp;ts,&amp;id); alls.insert(id); //储存出现的id号 maps[id].push_back(ts); //将点赞时间储存至maps[id][] &#125; for(set&lt;int&gt;::iterator iter=alls.begin();iter!=alls.end();iter++) //对整个maps[alls][]数组进行排序 方便后面的时间统计 &#123; sort(maps[*iter].begin(),maps[*iter].end()); //对有数据的数组进行排序 即 maps[alls][] &#125; for(set&lt;int&gt;::iterator iter=alls.begin();iter!=alls.end();iter++) //对有数据的maps数组进行查找 &#123; int all=0,first=0,end=0; //点赞数量 第一个赞的位置 最后一个赞的位置 while(1) //尺取法 &#123; while(all&lt;k&amp;&amp;end&lt;maps[*iter].size()) //点赞数小于要求 &amp;&amp; 数组里的数据还没有统计完 &#123; all++; end++; &#125; if(all&lt;k) //统计完了 赞也不够 break; if(maps[*iter][end-1]-maps[*iter][first]&lt;d) //赞够 并且 第一个赞和末尾赞的时间相隔符合要求 &#123; printf(&quot;%d\\n&quot;,*iter); //由于set有序 所以直接输出即可 break; &#125; all--; first++; &#125; &#125; return 0;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://zgg2001.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}]},{"title":"2018 蓝桥杯 全球变暖(dfs) 深度优先遍历写法","slug":"20200826_2018蓝桥杯全球变暖(dfs)深度优先遍历写法","date":"2020-08-26T02:44:25.000Z","updated":"2020-08-26T02:44:25.000Z","comments":true,"path":"2020/08/26/20200826_2018蓝桥杯全球变暖(dfs)深度优先遍历写法/","permalink":"https://zgg2001.github.io/2020/08/26/20200826_2018%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%85%A8%E7%90%83%E5%8F%98%E6%9A%96(dfs)%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E5%86%99%E6%B3%95/","excerpt":"这是2018年蓝桥杯C语言省赛B组的第九题","text":"这是2018年蓝桥杯C语言省赛B组的第九题 题目你有一张某海域NxN像素的照片，”.”表示海洋、”#”表示陆地，如下所示： 其中”上下左右”四个方向上连在一起的一片陆地组成一座岛屿。例如上图就有2座岛屿。由于全球变暖导致了海面上升，科学家预测未来几十年，岛屿边缘一个像素的范围会被海水淹没。具体来说如果一块陆地像素与海洋相邻(上下左右四个相邻像素中有海洋)，它就会被淹没。例如上图中的海域未来会变成如下样子： 请你计算：依照科学家的预测，照片中有多少岛屿会被完全淹没。 输入第一行包含一个整数N。 (1 &lt;&#x3D; N &lt;&#x3D; 1000)以下N行N列代表一张海域照片。照片保证第1行、第1列、第N行、第N列的像素都是海洋。 输出一个整数表示答案。 样例输入样例输出1 OJ链接 思路：在接收初始图之后，首先搜索查找初始岛屿数，在找到一个岛屿后，对整个岛屿进行标记，防止重复计数。随后再次进行搜索，如果有四周均为陆地的坐标，则标记此坐标未被淹没。最后查找所有未被淹没的坐标，并将坐标所处的整个岛标记，防止重复计数。初始岛屿数量减去未被淹没岛的数量，即为被淹没的岛的数量。 AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;bits/stdc++.h&gt;using namespace std;char maps[1001][1001];void dfs1(int x,int y)&#123; if(maps[x][y]!=&#x27;#&#x27;) return; maps[x][y]=&#x27;1&#x27;;//将#标记为1 dfs1(x+1,y);//把整个岛都进行标记 防止重复计算 dfs1(x-1,y); dfs1(x,y+1); dfs1(x,y-1);&#125; void dfs2(int x,int y)&#123; if(maps[x][y]==&#x27;.&#x27;) return; if(maps[x+1][y]==&#x27;1&#x27;&amp;&amp;maps[x-1][y]==&#x27;1&#x27;&amp;&amp;maps[x][y+1]==&#x27;1&#x27;&amp;&amp;maps[x][y-1]==&#x27;1&#x27;)//四周都是陆地 则标记为2 &#123; maps[x][y]=&#x27;2&#x27;; &#125; dfs1(x+1,y);//找4个方向 dfs1(x-1,y); dfs1(x,y+1); dfs1(x,y-1);&#125; void dfs3(int x,int y)&#123; if(maps[x][y]==&#x27;.&#x27;) return; maps[x][y]=&#x27;.&#x27;;//将#标记为 . dfs3(x+1,y);//把整个岛都进行沉没操作 防止重复计算 dfs3(x-1,y); dfs3(x,y+1); dfs3(x,y-1);&#125; int main()&#123; int n,first_num=0,end_num=0;//层数 初始岛屿数量 末尾岛屿数量 scanf(&quot;%d&quot;,&amp;n); for(int a=1;a&lt;=n;a++) &#123; for(int b=1;b&lt;=n;b++) &#123; while(1) &#123; scanf(&quot;%c&quot;,&amp;maps[a][b]); if(maps[a][b]==&#x27;.&#x27;||maps[a][b]==&#x27;#&#x27;) break; &#125; &#125; &#125; //先查找有多少个岛屿 for(int a=1;a&lt;=n;a++) &#123; for(int b=1;b&lt;=n;b++) &#123; if(maps[a][b]==&#x27;#&#x27;) &#123; dfs1(a,b); first_num++;//初始岛屿+1 &#125; &#125; &#125; //再对整个岛屿进行变化 for(int a=1;a&lt;=n;a++) &#123; for(int b=1;b&lt;=n;b++) &#123; if(maps[a][b]==&#x27;1&#x27;) &#123; dfs2(a,b); &#125; &#125; &#125; //最后查找剩余多少个岛屿 for(int a=1;a&lt;=n;a++) &#123; for(int b=1;b&lt;=n;b++) &#123; if(maps[a][b]==&#x27;2&#x27;) &#123; dfs3(a,b); end_num++;//最终岛屿+1 &#125; &#125; &#125; cout&lt;&lt;first_num-end_num; return 0;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://zgg2001.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}]},{"title":"2018 蓝桥杯 递增三元组 sort排序","slug":"20200825_2018蓝桥杯递增三元组sort排序","date":"2020-08-25T01:52:19.000Z","updated":"2020-08-25T01:52:19.000Z","comments":true,"path":"2020/08/25/20200825_2018蓝桥杯递增三元组sort排序/","permalink":"https://zgg2001.github.io/2020/08/25/20200825_2018%E8%93%9D%E6%A1%A5%E6%9D%AF%E9%80%92%E5%A2%9E%E4%B8%89%E5%85%83%E7%BB%84sort%E6%8E%92%E5%BA%8F/","excerpt":"这是2018年蓝桥杯C语言省赛B组的第六题","text":"这是2018年蓝桥杯C语言省赛B组的第六题 题目：给定三个整数数组A &#x3D; [A1, A2, … AN],B &#x3D; [B1, B2, … BN],C &#x3D; [C1, C2, … CN]，请你统计有多少个三元组(i, j, k) 满足： 1 &lt;&#x3D; i, j, k &lt;&#x3D; N Ai &lt; Bj &lt; Ck 输入第一行包含一个整数N。第二行包含N个整数A1, A2, … AN。第三行包含N个整数B1, B2, … BN。第四行包含N个整数C1, C2, … CN。1 &lt;&#x3D; N &lt;&#x3D; 100000 0 &lt;&#x3D; Ai, Bi, Ci &lt;&#x3D; 100000 输出一个整数表示答案 样例输入31 1 12 2 23 3 3 样例输出27 OJ链接 思路：先用sort对三个数组进行排序。随后对B数组进行遍历，用lower_bound函数求出A数组中小于B数组当前元素的数量，用upper_bound函数求出C数组中大于B数组当前元素的数量，两者相乘算出B数组当前元素下可行解的数量，把B数组遍历一遍即可求出总解。PS：记得用long long，用int的话会爆。 AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;int a[100001],b[100001],c[100001];int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); for(int now=0;now&lt;n;now++) &#123; scanf(&quot;%d&quot;,&amp;a[now]); &#125; for(int now=0;now&lt;n;now++) &#123; scanf(&quot;%d&quot;,&amp;b[now]); &#125; for(int now=0;now&lt;n;now++) &#123; scanf(&quot;%d&quot;,&amp;c[now]); &#125; sort(a,a+n);//排序 sort(b,b+n); sort(c,c+n); long long ans=0;//记得用long long for(int now=0;now&lt;n;now++)//b为中间值 遍历 &#123; long long s1=lower_bound(a,a+n,b[now])-a;//获取a中小于b【now】的个数 long long s2=n-(upper_bound(c,c+n,b[now])-c);//获取c中大于b【now】的个数 ans+=s1*s2; &#125; cout&lt;&lt;ans; return 0; &#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://zgg2001.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}]},{"title":"并查集学习记录：模板/思路汇总","slug":"20200819_并查集学习记录：模板思路汇总","date":"2020-08-19T05:35:53.000Z","updated":"2020-08-19T05:35:53.000Z","comments":true,"path":"2020/08/19/20200819_并查集学习记录：模板思路汇总/","permalink":"https://zgg2001.github.io/2020/08/19/20200819_%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%80%9D%E8%B7%AF%E6%B1%87%E6%80%BB/","excerpt":"HB小咸鱼学习记录 自我对于“并查集”的理解有时候一些题，是让你判断图中一些数据是否在一个集合中。例如1和3联通，2和3联通，问你1和2是否联通。这其实问的就是1和2是否在一个联通集合里，如果用搜索进行遍历的话，就需要挨个对路径进行尝试，如果数据量大的话，消耗时间就会过多，这时候就可以用并查集来解决问题。","text":"HB小咸鱼学习记录 自我对于“并查集”的理解有时候一些题，是让你判断图中一些数据是否在一个集合中。例如1和3联通，2和3联通，问你1和2是否联通。这其实问的就是1和2是否在一个联通集合里，如果用搜索进行遍历的话，就需要挨个对路径进行尝试，如果数据量大的话，消耗时间就会过多，这时候就可以用并查集来解决问题。 并查集的大致思路并查集的核心操作就是“并”与“查”。“并”指的是将两个数据放到一个集合里，“查”就是查询一个数据在哪个集合里。首先，我们声明一个father数组，数组的值是指向当前下标元素的父节点。其次，我们对这个数组进行初始化，使得当前下标的值是他本身。代表他是自己的父节点，即他是根节点，这个情况下可以看作每个元素都是一个单独的集合。 12345int father[MAX];for(int now=1;now&lt;MAX;now++)//初始化 &#123; father[now]=now;&#125; 接着，我们建立“查”操作，查询某一数据属于哪个集合，就是查询他的根节点。因为我们设定了father数组，所以我们不断查找该数据的父节点，即可知道该数据的根节点。我们如果要查询两个数据是否属于一个集合，即可通过“查”操作获取两个数据的根节点，如果两个数据的根节点相同，则说明两个数属于同一个集合。 12345678910111213141516//第一种写法（递归）//第一种写法可以用三目运算符缩写为 return father[a]==a ? a : find(father[a]);int find(int a)&#123; if(father[a]==a) return a; return find(father[a]);&#125;//第二种写法int find(int a)&#123; int temp = father[a]; while(father[temp]!=temp) temp = father[temp]; return temp;&#125; 最后，我们建立“并”操作，可以将两个集合合并。我们首先获取想要合并的数据A和数据B的根节点。如果根节点相同，则说明两个数据本来就属于一个集合，所以不用进行合并处理；如果根节点不同，则说明两个数据不属于同一个集合，此时我们需要进行合并操作。合并操作很简单，让一个数据的根节点指向另一个数据的根节点即可。 123456789int union_(int a,int b)&#123; int temp_a=find(a); int temp_b=find(b); if(temp_a!=temp_b) &#123; father[temp_a]=temp_b; &#125; &#125; 一些优化 秩优化我们在进行“并”操作时，如果和上面一样，规定无论如何都是数据A往数据B并，那么很有可能大树并小树，导致整个集合的深度增加，最极端的例子是形成了一条链，此时如果find链尾，则会将整个链遍历一遍，时间消耗会大大增加。所以我们在进行“并”操作时，可以获取两个数据所处集合的深度，让深度低的成为深度高的子集。而当深度一样时，则可以看你的喜好进行合并。 12345678910111213141516171819202122int deep[MAX] = &#123;0&#125;;//深度数组，初始深度都为0，储存各个集合的深度 int union_(int a,int b)&#123; int temp_a=find(a); int temp_b=find(b); if(temp_a!=temp_b)//两个数据不在同一个集合 &#123; if(deep[temp_a]&gt;deep[temp_b])//a比b深度高 &#123; father[temp_b]=temp_a;//b成为a的子集 &#125; else if(deep[temp_a]&lt;deep[temp_b])//a比b深度低 &#123; father[temp_a]=temp_b;//a成为b的子集 &#125; else//深度一样 &#123; father[temp_b]=temp_a;//b成为a的子集 deep[temp_a]++;//a的根节点的深度加一 &#125; &#125; &#125; 路径压缩 在我们进行find查询时，如果我们只在乎某数据的根节点，而不在意他的各个父节点时，我们可以进行路径压缩。让这个数据的父节点直接指向根节点，这样被称作“路径压缩”。在进行路径压缩后，所有的节点都指向根节点，这样集合的深度只有1，在之后进行数据的根节点查询时的复杂度只有O(1),大大提升查询速度。 1234567891011121314151617181920212223//第一种写法（递归）//第一种写法可以用三目运算符缩写为 return father[a]==a ? a : father[a] = find(father[a]);int find(int a)&#123; if(father[a]==a) return a; return father[a] = find(father[a]);&#125;//第二种写法int find(int a) &#123; int temp = father[a]; while(father[temp]!=temp) temp = father[temp]; int i=a,j; while(i!=temp) //路径压缩 &#123; j=father[i]; // 在改变上级之前用临时变量j记录下他的值 father[i]=temp; //把上级改为根节点 i=j; &#125; return temp ;&#125; 并查集的大致模板这是秩优化+路径压缩的模板，其余版本看上面的思路模块即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445int father[MAX];//父节点数组int deep[MAX] = &#123;0&#125;;//深度数组，初始深度都为0，储存各个集合的深度 void init()//初始化 &#123; for(int now=1;now&lt;MAX;now++) &#123; father[now]=now; &#125;&#125;int find(int a)//查询&#123; if(father[a]==a) return a; return father[a] = find(father[a]);&#125;int union_(int a,int b)//合并&#123; int temp_a=find(a); int temp_b=find(b); if(temp_a!=temp_b)//两个数据不在同一个集合 &#123; if(deep[temp_a]&gt;deep[temp_b])//a比b深度高 &#123; father[temp_b]=temp_a;//b成为a的子集 &#125; else if(deep[temp_a]&lt;deep[temp_b])//a比b深度低 &#123; father[temp_a]=temp_b;//a成为b的子集 &#125; else//深度一样 &#123; father[temp_b]=temp_a;//b成为a的子集 deep[temp_a]++;//a的根节点的深度加一 &#125; &#125; &#125;int main()&#123; ........ return 0;&#125; 并查集例题1.畅通工程某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？ Input测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( &lt; 1000 )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。注意:两个城市之间可以有多条道路相通,也就是说3 31 21 22 1这种输入也是合法的当N为0时，输入结束，该用例不被处理。 Output对每个测试用例，在1行里输出最少还需要建设的道路数目。 Sample Input4 21 34 33 31 21 32 35 21 23 5999 00 Sample Output102998 题目地址 思路：这题在把所有的数据接收后，运用并查集进行集合合并，最后根节点的个数就是集合的个数。而联通n个节点最少需要n-1条边，故根节点的个数减去1就是建设道路的最少值。由于题中只在乎最后根节点的个数，所有使用了路径压缩，提高代码的运算速度。 AC代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;int father[1001];int find(int a)&#123; return father[a]==a ? a : father[a] = find(father[a]);&#125; int compose(int a,int b)&#123; int temp_a=find(a); int temp_b=find(b); if(temp_a!=temp_b) &#123; father[temp_a]=temp_b; &#125; &#125;int main()&#123; int a,b,c,d; while(scanf(&quot;%d&quot;,&amp;a)&amp;&amp;a) &#123; scanf(&quot;%d&quot;,&amp;b); for(int now=1;now&lt;=a;now++)//初始化 &#123; father[now]=now; &#125; while(b--) &#123; scanf(&quot;%d %d&quot;,&amp;c,&amp;d); compose(c,d); &#125; int ans=0; for(int now=1;now&lt;=a;now++) &#123; if(father[now]==now) ans++; &#125; cout&lt;&lt;ans-1&lt;&lt;endl; &#125; return 0;&#125; 2.修改数组给定一个长度为N 的数组A &#x3D; [A1, A2,…,AN]，数组中有可能有重复出现的整数。现在小明要按以下方法将其修改为没有重复整数的数组。小明会依次修改A2,A3,…, AN。当修改Ai 时，小明会检查Ai 是否在A1~ Ai-1 中出现过。如果出现过，则小明会给Ai 加上1 ；如果新的Ai 仍在之前出现过，小明会持续给Ai 加1 ，直到Ai 没有在A1~Ai-1中出现过。当AN 也经过上述修改之后，显然A数组中就没有重复的整数了。现在给定初始的A 数组，请你计算出最终的A 数组。 输入第一行包含一个整数N(1&lt;&#x3D;N&lt;&#x3D;100000)第二行包含N个整数A1,A2,…,AN(1&lt;&#x3D;Ai&lt;&#x3D;1000000) 输出输出N个整数，依次是最终的A1,A2,…,AN 样例输入 Copy52 1 1 3 4 样例输出 Copy2 1 3 4 5 题目地址 思路：我们可以把用过的数字放到一个集合里，而让他的父节点指向下一个可以用的数字，具体操作就是**father[a]&#x3D;find(father[a]+1)**。这样我们就会一直对使用过的数字的父节点进行加一操作，直到找到一个没有被使用过的数字。由于这题只需要知道该数字是否被使用过，即是否在“被使用过”这个集合里，所以我们可以使用路径压缩，提高运算效率。 AC代码： 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;int father[1000001];int find(int a)&#123; if(father[a]==-1) &#123; father[a]=a; return a; &#125; return father[a]=find(father[a]+1);&#125;int main()&#123; int input,aa; cin&gt;&gt;input; memset(father,-1,sizeof(father)); for(int now=1;now&lt;=input;now++) &#123; cin&gt;&gt;aa; aa=find(aa); cout&lt;&lt;aa&lt;&lt;&quot; &quot;; &#125; return 0;&#125; 3.敌人俗话说得好，敌人的敌人就是朋友。现在有n个人，编号1至n，初始互不相识。接下来有m个操作，操作分为两种： （1）检查x号和y号是否是朋友，若不是，则变成敌人（2）询问x号的朋友有多少个请你针对每个操作中的询问给出回答。 输入第一行两个正整数n、m，表示人的数量和操作的数量。接下来m行，依次描述输入。每行的第一个整数为1或2表示操作种类。对于操作（1），随后有两个正整数x，y。对于操作（2），随后一个正整数x。 输出输出包含m行，对于操作（1），输入’N’或”Y”，’N’表示x和y之前不是朋友，’Y’表示是朋友。对于操作（2），输出x的朋友数量。 输入示例5 81 1 21 1 31 2 32 31 4 52 31 1 42 3 输出示例NNY1N1N2 思路：这道题相比之前的题，一个不同的特点就是我们无法直接将两个数据放进同一个集合，因为输入的数据要变为“敌人”关系，即不在同一个集合内。那么我们如何能将两个数据放进同一个集合呢？我们可以扩大father数组，使它是原来的两倍大。假如一共有N个数，则1到N代表本身，N+1到2N则代表1到N的敌人。当我们设定两个数是敌人的时候，只需要把第一个数据和第二个数据的敌人放在一个集合，第二个数据和第一个数据的敌人防在一个集合，即可完成合并的操作。因为当和一个数的敌人是朋友时，那和这个数就是敌人。当查询一个数的朋友时，遍历查询与其根节点相同的点的个数，再减去一（它本身），即为朋友的个数。本题由于也是只看根节点，所以可以使用路径压缩。 AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;int father[600001];//最大300000个数 数的敌人也有300000个 故一共600000int find(int a)//查询&#123; return father[a]==a ? a : father[a] = find(father[a]);&#125;int compose(int a,int b)//合并&#123; int temp_a=find(a); int temp_b=find(b); if(temp_a!=temp_b) &#123; father[temp_a]=temp_b; &#125;&#125;int main()&#123; int input1,input2,a,b,c; cin&gt;&gt;input1&gt;&gt;input2; for(int now=1;now&lt;=input1*2;now++)//初始化 &#123; father[now]=now; &#125; for(int now=0;now&lt;input2;now++)//接收初始值 &#123; cin&gt;&gt;a; if(a==1)//1操作 &#123; cin&gt;&gt;b&gt;&gt;c; if(find(b)==find(c))//是朋友 &#123; cout&lt;&lt;&quot;Y&quot;&lt;&lt;endl; &#125; else &#123; compose(b,c+input1);//将输入的第一个数据和第二个数据的敌人放在一个集合里 compose(c,b+input1);//将输入的第二个数据和第一个数据的敌人放在一个集合里 cout&lt;&lt;&quot;N&quot;&lt;&lt;endl; &#125; &#125; else if(a==2)//2操作 &#123; cin&gt;&gt;b; int ans=0; /*for(int now=1;now&lt;=input1*2;now++) &#123; cout&lt;&lt;father[now]&lt;&lt;&quot; &quot;; &#125;*/ for(int now=1;now&lt;=input1;now++)//如果根节点相同则说明在同一集合，是朋友 &#123; if(find(b)==find(now)) ans++; &#125; cout&lt;&lt;ans-1&lt;&lt;endl; &#125; &#125; return 0;&#125; 4.食物链有N只动物分别编号为1，2，……，N。所有动物都属于A，B，C中的一类。已知A能吃掉B，B能吃掉C，C能吃掉A。按顺序给出下面的两种信息共K条： 第一种：x和y属于同一类； 第二种：x吃y。然而这些信息可能会出错，有可能有的信息和之前给出的信息矛盾，也有的信息可能给出的x和y不在1到N的范围内。求在K条信息中有多少条是不正确的。计算过程中，我们将忽视诸如此类的错误信息。 输入第一行两个自然数，两数间用一个空格分隔，分别表示N和K，接下来的K行，每行有三个数，第一个数为0或1，分别对应第一种或第二种，接着的两个数，分别为该条信息的x和y，三个数两两之间用一个空格分隔。 输出一个自然数，表示错误信息的条数。 输入示例100 70 101 11 1 21 2 31 3 30 1 31 3 10 5 5 输出示例3 思路：与上一题“敌人”相似，这一题也可以通过扩展数组建立多重关系来做。这一题存在同类、吃、被吃这三个关系。所以我们把数组扩到到原来的三倍，1到N代表本身，N+1到2N代表被“本身”吃的，2N+1到3N代表吃“本身”的。当我们建立0操作的“A和B同类”关系时，只需要把三个区域同等合并即可，即A本身和B本身合并为一类，A吃的和B吃的合并为一类，吃A的和吃B的合并为一类，即可说明A和B地位相同。当我们建立1操作的“A吃B”关系时，将B和A吃的划为一类，B吃的和吃A的划为一类，A和吃B的划为一类，即可实现A吃B关系网的建立。而当输入超限、在0操作时判断出A和B是吃或被吃关系、在1操作时判断出A和B是同类或被吃关系时，即为语句错误，答案数量加一。由此结束时输出即可。 AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;using namespace std;int father[150001];int find(int a)&#123; return father[a]==a ? a : father[a] = find(father[a]);&#125;int compose(int a,int b)&#123; int temp_a=find(a); int temp_b=find(b); if(temp_a!=temp_b) &#123; father[temp_a]=temp_b; &#125;&#125;int main()&#123; int input1,input2,a,b,c,ans=0; cin&gt;&gt;input1&gt;&gt;input2; for(int now=1;now&lt;=input1*3;now++)//初始化 &#123; father[now]=now; &#125; for(int now=0;now&lt;input2;now++)//接收初始值 &#123; cin&gt;&gt;a; if(a==0)//输入0 x与y同类 &#123; cin&gt;&gt;b&gt;&gt;c; if(b&gt;input1||b&lt;1||c&gt;input1||c&lt;1)//输入不合法 &#123; ans++; continue; &#125; else &#123; if(find(b)==find(c+input1)||find(b)==find(c+2*input1))//如果属于吃或者被吃关系 &#123; ans++; continue; &#125; else//指向平级，代表同类 &#123; compose(b,c); compose(b+input1,c+input1); compose(b+input1*2,c+input1*2); &#125; &#125; &#125; else if(a==1)//输入1 x吃y &#123; cin&gt;&gt;b&gt;&gt;c; if(b&gt;input1||b&lt;1||c&gt;input1||c&lt;1)//输入不合法 &#123; ans++; continue; &#125; else &#123; if(find(b)==find(c)||find(b)==find(c+input1))//属于同一类或者被吃关系 &#123; ans++; continue; &#125; else &#123; compose(b+input1,c);//b吃的 和 c一类 即 b吃c compose(b+input1*2,c+input1);//吃b的 和 c吃的一类 compose(b,c+input1*2);//b 和 吃c的一类 &#125; &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl;//结果 return 0;&#125; 5. 网络分析时间限制: 1.0s 内存限制: 256.0MB 本题总分：25 分问题：小明正在做一个网络实验。他设置了 n 台电脑，称为节点，用于收发和存储数据。初始时，所有节点都是独立的，不存在任何连接。小明可以通过网线将两个节点连接起来，连接后两个节点就可以互相了。两个节点如果存在网线连接，称为相邻。小明有时会测试当时的网络，他会在某个节点发送一条信息，信息会到每个相邻的节点，之后这些节点又会转发到自己相邻的节点，直到所有或间接相邻的节点都收到了信息。所有发送和接收的节点都会将信息存储一条信息只存储一次。给出小明连接和测试的过程，请计算出每个节点存储信息的大小。 输入：输入的第一行包含两个整数 n, m，分别表示节点数量和操作数量。节1 至 n 编号。接下来 m 行，每行三个整数，表示一个操作。如果操作为 1 a b，表示将节点 a 和节点 b 通过网线连接起来。当 时，表示连接了一个自环，对网络没有实质影响。如果操作为 2 p t，表示在节点 p 上发送一条大小为 t 的信息。 输出：输出一行，包含 n 个整数，相邻整数之间用一个空格分割，依次表示完上述操作后节点 1 至节点 n 上存储信息的大小。 样例输入：4 81 1 22 1 102 3 51 4 12 2 21 1 21 2 42 2 1 样例输出：13 13 5 3 评测用例规模与约定：对于 30% 的评测用例，1 ≤ n ≤ 20，1 ≤ m ≤ 100。对于 50% 的评测用例，1 ≤ n ≤ 100，1 ≤ m ≤ 1000。对于 70% 的评测用例，1 ≤ n ≤ 1000，1 ≤ m ≤ 10000。对于所有评测用例，1 ≤ n ≤ 10000，1 ≤ m ≤ 100000，1 ≤ t ≤ 100。 思路： 核心思路是并查集。一个数组用来存旧值，一个数组用来存根结点权值，一个数组是并查集的father数组。执行2操作时，查集寻找到操作值的根结点并加权。执行1操作时，若两数在一个集内则不操作；若两数不在一个集内，则对所有节点进行遍历，使他们的旧值数组加上其根节点的权值，随后进行并集操作。记得对权值数组进行清零，防止后面重复计算。 AC代码： OJ链接 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;int old_[10001],new_[10001],father[10001],n,m;//存老值 存根节点新值 父节点数组 int find(int a)&#123; return father[a]==a ? a : father[a]=find(father[a]);//路径压缩&#125;void union_(int a,int b)&#123; int temp_a=find(a),temp_b=find(b); if(temp_a!=temp_b) &#123; for(register int now=1;now&lt;=n;now++) &#123; old_[now]+=new_[find(now)];//旧值数组遍历加上权值 &#125; memset(new_,0,sizeof(new_));//重置权值数组，防止重复计算 father[temp_a]=temp_b; &#125;&#125;int main()&#123; int a,b,c; memset(new_,0,sizeof(new_)); for(register int now=1;now&lt;=10000;now++) &#123; father[now]=now;//father数组初始化 &#125; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); while(m--) &#123; scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c); if(a==1) &#123; union_(b,c); &#125; else &#123; new_[find(b)]+=c; &#125; &#125; for(register int now=1;now&lt;=n;now++) &#123; printf(&quot;%d &quot;,old_[now]+new_[find(now)]); &#125; return 0;&#125; 小结在使用并查集中，要根据题目数据选择合适的优化。一般都得用路径压缩提高效率，但是秩优化用的比较少（我感觉），因为在进行路径压缩后秩优化后的结构就不复存在的，我感觉二者是有点矛盾的。但是两者一起使用相较于只使用路径压缩也会在第一次接收数据时提高一点效率，但是为了敲代码的效率，我还是喜欢只敲路径压缩。使用并查集时，要选择合适的数据结构例如秩优化时的储存深度的数组、例题第三题“敌人”的长数组、以及涉及带权并查集的结构。总之，还是得多刷题，多积累经验。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"bfs学习记录：模板/思路汇总","slug":"20200814_bfs学习记录：模板思路汇总","date":"2020-08-14T14:19:12.000Z","updated":"2020-08-14T14:19:12.000Z","comments":true,"path":"2020/08/14/20200814_bfs学习记录：模板思路汇总/","permalink":"https://zgg2001.github.io/2020/08/14/20200814_bfs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%80%9D%E8%B7%AF%E6%B1%87%E6%80%BB/","excerpt":"HB小咸鱼学习记录 一点看法蓝桥杯刷了不少的搜索题，但是bfs的题很少，大部分都是dfs的题。但是去年蓝桥杯就考了bfs，所以还是得好好刷题。bfs由于是一个循环进行搜索，所以没法回溯，因而每个点位只能被走一次。这样加快了搜索速度，但是由于每个点只能走一次导致无法列举出所有的可走路径。而这样的好处是避免了绕远路，搜索到结果时一定是最短路。所以大部分的求最短路的题都用bfs.","text":"HB小咸鱼学习记录 一点看法蓝桥杯刷了不少的搜索题，但是bfs的题很少，大部分都是dfs的题。但是去年蓝桥杯就考了bfs，所以还是得好好刷题。bfs由于是一个循环进行搜索，所以没法回溯，因而每个点位只能被走一次。这样加快了搜索速度，但是由于每个点只能走一次导致无法列举出所有的可走路径。而这样的好处是避免了绕远路，搜索到结果时一定是最短路。所以大部分的求最短路的题都用bfs. 自我对于“广度优先搜索”的理解bfs,字面来看就是以广度为优先的搜索方式。搜索时以原点向四周扩散。如果说dfs是“搜完一个屋子再搜另一个屋子”，那bfs就是“把每个屋子的柜子搜了再搜每个屋子的桌子……”这样层层深入的搜索。这样可以优先搜索物品可能在的地方，从而减少搜索的时间。就像我们规定以“前左右”的顺序走迷宫，而在寻找迷宫的出口时就可以看成进行了一次搜索。我们首先记录下来第一个路口能前往哪几个路口，随后再按照规定的顺序（前左右）查看这几个路口的又能前往哪几个路口。途中前往过的路口要进行标记，防止重复的查看。直到查看一个路口，它可以前往到终点或者它就是终点，此时搜索结束。我们查看的轮数就是前往该终点的最小步数。而在搜索过程中，我们可以使用适当的数据结构来储存前往终点所经过的路口，这就是最短路径。这样进行搜索的范围大，查找到终点的路径始终是最短路径。但缺点是我们没办法迭代出所有的可前往终点的路径。 bfs的大致思路首先，如上个片段所说，我们首先需要一个二维数组，来对迷宫进行标记，标记出可以走的点和障碍（不可以走的点）。其次，我们建立一个队列，把起点加入到队列中。接着，我们建立一个while循环，设定在队列不为空的时候执行循环。循环中，我们首先获取队列的头结点坐标，随后我们需要对移动的规则进行规定。例如上文的例子规定的“上左右”，我们可以用一个二维数组来储存移动后坐标的变化： 1int direction[4][2] = &#123;&#123;0,-1&#125;,&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,1&#125;&#125;; 这个数组里面的四组数据就分别代表“上左右下”，在对坐标变换时进行 12int x1=x+direction[a][0];int y1=y+direction[a][1]; 即可实现对坐标的变化。我们按照这个顺序，对头结点的周围进行判断，如果可以前往的话，就将变换后的数据点加入队列。然后将新点（x1,y1）的状态进行更改，代表你已经来过这里了。防止重复的搜索。最后，我们需要设定上一步循环的中止条件，从而在找到出口时停止或者返回一些信息。我们常常在循环中获取头结点后进行判定，如果头结点数据是我们想要搜索到的信息，我们就中止循环。 bfs的大致模板1234567891011121314151617181920void BFS(传入的数据)&#123; queue&lt;int&gt;q; //建立一个队列 q.push(初始坐标); //把头结点（初始点）加入队列 while(队列不为空) &#123; top = q.front(); //取出队首元素top if(队首元素top就是你要搜索的目标) &#123; 执行一些操作 return; &#125; top.pop(); //将队首元素出队； for(按顺序寻找top的所有子节点) &#123; 把可以前往的子节点入队 标记入队的子节点，防止下次重复入队 &#125; &#125;&#125; bfs例题蓝桥杯 学霸的迷宫样例输入Input Sample 1:3 3001100110样例输出Output Sample 1:4RDRD 题目链接 这一题算是bfs的经典例题，题目不止让求了最短的步数，还让输出了最短的路径。所以我们在队列结点的数据结构中添加了一个string字符串，用来储存到达某个点的最短路径。在找到终点时，输出最短步数和最短路径即可。ac代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt; using namespace std;struct data //队列里的数据结构 &#123; int x; //坐标x int y; //坐标y int times; //步数 string road; //走过的路径 data(int a,int b,int d,string c) //构造函数 &#123; x=a; y=b; times=d; road = c; &#125; &#125;;queue&lt;data&gt;datas; //队列用来存放点位数据 bool maps[501][501]; //存放迷宫地图的点位 false代表可前往 true代表不可前往 char fx[] = &#123;&#x27;D&#x27;,&#x27;L&#x27;,&#x27;R&#x27;,&#x27;U&#x27;&#125;; //方向ascii码从小到大排列 int site[4][2] = &#123;&#123;0,1&#125;,&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;&#125;; //下 左 右 上的坐标变化 void bfs(int n,int m) //传参为迷宫的大小 n为宽 m为长 &#123; datas.push(data(1,1,0,&quot;&quot;)); //把起始点压入队列 maps[1][1]=true; //标记初始点已走过 while(!datas.empty()) //如果队列不为空 &#123; data now = datas.front(); //声明一个结构体变量 让now变量指向队列的头结点 datas.pop(); //弹出头结点 //cout&lt;&lt;now.x&lt;&lt;&quot; &quot;&lt;&lt;now.y&lt;&lt;endl; if(now.x==n&amp;&amp;now.y==m) //如果头结点就是要找的点 就搜索结束 &#123; cout&lt;&lt;now.times&lt;&lt;endl&lt;&lt;now.road&lt;&lt;endl; //输出走过的路径 和步数 return; &#125; for(int temp=0;temp&lt;4;temp++) //开始查找该点的四周点位 （因为只有上下左右4个走法 所以循4次 &#123; int x1=now.x+site[temp][0]; //变换过的x坐标 int y1=now.y+site[temp][1]; //变换过的y坐标 if(maps[y1][x1]) //如果该点已经走过或者有障碍 跳过 continue; if(x1&lt;1||y1&lt;1||x1&gt;n||y1&gt;m) //如果坐标超出范围 就跳过此循环 continue; datas.push(data(x1,y1,now.times+1,now.road+fx[temp])); //把新点位压入队列 路径加上新选择的fx[temp] maps[y1][x1] = true; //标记已走过 &#125; &#125; &#125;int main()&#123; memset(maps,false,sizeof(maps)); //初始化 int x,y; //接收迷宫大小 char input; cin&gt;&gt;y&gt;&gt;x; getchar(); for(int y1=1;y1&lt;=y;y1++) //迷宫长 &#123; for(int x1=1;x1&lt;=x;x1++) //迷宫宽 &#123; cin&gt;&gt;input; if(input==&#x27;1&#x27;) maps[y1][x1]=true; //如果输入是1就标记不可走 &#125; getchar(); &#125; bfs(x,y); //bfs 迷宫长宽 与 xy坐标是相反的 所以传反着的坐标 return 0;&#125; 小结在使用bfs中，要根据题目数据选择合适的数据类型。bfs的题中往往不会只让你输出最短路径的长度，一般还会带点别的东西，所以要建立合适的结构来储存数据。bfs的常用环境一般是用来寻找不带权值的图的最短路。问题关键词常为“能否到达”、“最短路径”。目前来看蓝桥杯中对bfs的考察度往往低于dfs，但是蓝桥杯最近几年对bfs的考察也在变多，所以还得好好练。总之，还是得多刷题，多积累经验。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"dfs学习记录：模板/思路汇总","slug":"20200813_dfs学习记录：模板思路汇总","date":"2020-08-13T10:37:50.000Z","updated":"2020-08-13T10:37:50.000Z","comments":true,"path":"2020/08/13/20200813_dfs学习记录：模板思路汇总/","permalink":"https://zgg2001.github.io/2020/08/13/20200813_dfs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%80%9D%E8%B7%AF%E6%B1%87%E6%80%BB/","excerpt":"HB小咸鱼学习记录 因为疫情，大一在校半年便草草结束了，大二转眼将至。疫情期间在家没事便抽空预习了预习大二要学的数据结构。思来想去还是决定把学习的过程记录下来，方便自己以后查阅或者总结。","text":"HB小咸鱼学习记录 因为疫情，大一在校半年便草草结束了，大二转眼将至。疫情期间在家没事便抽空预习了预习大二要学的数据结构。思来想去还是决定把学习的过程记录下来，方便自己以后查阅或者总结。 一点看法在我看来，计算机的一大优势便是计算速度快。由此，人们在对某些问题的计算方面上，就不用像高斯找到1加到100的特殊技巧那样费力寻找技巧，直接依靠着计算机的计算力从1直接加到100就好。这种不需要技巧的运算方式就是暴力运算。而当你需要对图进行搜索的时候，最基础的就是暴力搜索。就我目前的接触而言，常见的暴力搜索方式便是深度优先遍历与广度优先遍历了。 自我对于“深度优先搜索”的理解dfs,字面来看就是以深度为优先的搜索方式。用通俗点来讲就是一条道走到黑。就像我们规定以“前左右”的顺序走迷宫，而在寻找迷宫的出口时就可以看成进行了一次搜索。这样首先便是一直向前走下去。直到前面没有路了，我们就按照“前左右”再向左走，要是左边还走不通就再向右走直到走到死胡同里。当走到死胡同里的时候说明我们走完了一条迷宫的支线，此时我们可以认为自己单刀直入了这条支线的最深处。此时我们还需要找迷宫的出口，于是我们后退到上一个交叉路口的位置，按照“前左右”的顺序寻找一个没有进入过的支线。如果这个路口的支线已经全部走过，则再次后退到上一个交叉路口进行搜索 ……直到找到出口。由此看来，如果运气好，我们第一次走便可能直接走到出口；但是运气差的话，可能把整个迷宫走完才能找到出口。 dfs的大致思路首先，如上个片段所说，我们首先需要一个二维数组，来储存迷宫的大致情况，包括可以走的路、障碍物、入口、出口……其次，我们对于已经走过的分叉路口要进行标记，防止进入已经进入过的路口，就像在走迷宫时你会主动避开走过的路线一样。这个通常用一个与上面地图大小相同的二维数组来储存坐标的状态。例如false代表没走过，true代表走过。接着，我们需要对移动的规则进行规定。例如上文的例子规定的“上左右”，我们可以用一个二维数组来储存移动后坐标的变化： 1int direction[4][2] = &#123;&#123;0,-1&#125;,&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,1&#125;&#125;; 这个数组里面的四组数据就分别代表“上左右下”，在对坐标变换时进行 12int x1=x+direction[a][0];int y1=y+direction[a][1]; 即可实现对坐标的变化。且在变化后将x1,y1的点的状态进行更改，代表你已经来过这里了。而当你到达死路进行后退且前往别的点的时候，记得把刚来过的点的状态进行更改，使下一次也能前往。最后，我们需要进行判定，从而在找到出口时停止或者返回一些信息。 dfs的大致模板123456789101112131415161718192021void dfs(当前点位的信息)&#123; if(到达中止条件) &#123; 执行一些东西; return; &#125; if(当前点位越界或者不符合规定)//即进行剪枝 return; for(按照搜索的方向进行循环) &#123; 根据当前点位进行修改得到新点位; if(新点位可以前往) &#123; 执行一些东西; 把新点位标记; dfs(新点位的信息); 取消新点位的标记; &#125; &#125; &#125; 按照上面的思路大致可写以下代码： 123456789101112131415161718192021222324int map[100][100]; //地图 其中值为0则代表可走 bool b_map[100][100]; //点状态集 值为false代表没被走过 true代表被走过 int direction[4][2] = &#123;&#123;0,-1&#125;,&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,1&#125;&#125;; //搜索方向坐标变化集 int X,Y; //终点坐标 void dfs(int x,int y,int times) //传入当前点的x,y坐标以及走的次数 &#123; if(x==X&amp;&amp;y==Y) //当走到出口时 &#123; std::cout&lt;&lt;times&lt;&lt;&quot;\\n&quot;; //输出走的步数 return; &#125; for(int a=0;a&lt;4;a++) //对搜索方向进行遍历 &#123; int x1=x+direction[a][0]; //x加上当前搜索方向的变化 int y1=y+direction[a][1]; //y加上当前搜索方向的变化 if(!map[x1][y1]&amp;&amp;!b_map[x1][y1]) //判定x1,y1点是否可走 &#123; b_map[x1][y1] = true; //可走的话就标记以走过 dfs(x1,y1,time+1); //递归 传入新点位的坐标 以及走的次数加一 进行下一个坐标点的判定 b_map[x1][y1] = false; //取消标记 表示该线路以及搜索完毕 &#125; &#125; &#125; dfs的相关例题dfs虽然搜索细致，但是在搜索过程中会进行大量的无意义运算，浪费时间，于是在运算中就要进行“剪枝”，即根据所求信息增加判定要求，从而最大限度的减少递归的调用次数，加快运算时间。 1.蓝桥杯 迷宫OJ链接 思路： 在这道蓝桥杯的题目里，由于是求最短路径，所以用bfs来写比较简单。用dfs来写的话由于数据过大，不剪枝或者剪的不够的话稳稳的超时。但是我们可以引入一个与图一样大小的二维数组，该数组用来储存到达该点的最小步数。则如果在递归中，当前步数大于当前点的最小步数，说明到达当前点多走歪路了，则中止递归。在该条件的约束下，该dfs的运算效率得到了极大的提升。 AC代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;using namespace std;#define X 30#define Y 50 int a_map[31][51],ans=100000000,zhj=100000000;bool b_map[31][51];char fx[10000];char t_fx[10000];int z_4[4][2] = &#123;&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125;,&#123;-1,0&#125;&#125;; char z[4] = &#123;&#x27;D&#x27;,&#x27;L&#x27;,&#x27;R&#x27;,&#x27;U&#x27;&#125;;int dp[31][51];void dfs(int x,int y,int time,int he)//当前点的x,y坐标 走的步数 当前的路程权值&#123; if(x==X&amp;&amp;y==Y) &#123; if(time&lt;zhj&amp;&amp;he&lt;ans) &#123; for(int now=0;now&lt;time;now++) fx[now]=t_fx[now]; zhj=time-1; &#125; return; &#125; for(int a=0;a&lt;4;a++) &#123; if(he+z[a]&gt;ans)//条件判定 continue; int x1=x+z_4[a][0]; int y1=y+z_4[a][1]; if(x1&lt;1 || y1&lt;1 || x1&gt;X || y1&gt;Y)//条件判定 continue; if(b_map[x1][y1])//条件判定 continue; if(time+1&gt;dp[x1][y1])//条件判定 continue; dp[x1][y1]=time+1;//当前点的最小步数更新 b_map[x1][y1]=true; t_fx[time] = z[a]; dfs(x1,y1,time+1,he+z[a]); b_map[x1][y1]=false; &#125;&#125;int main()&#123; memset(fx,0,sizeof(fx)); memset(a_map,0,sizeof(a_map)); memset(b_map,false,sizeof(b_map)); memset(dp,999999,sizeof(dp)); for(int a=1;a&lt;=X;a++) &#123; for(int b=1;b&lt;=Y;b++) &#123; a_map[a][b] = getchar()-&#x27;0&#x27;; if(a_map[a][b]==1) b_map[a][b]=true; &#125; getchar(); &#125; b_map[1][1] = true; dfs(1,1,0,0); for(int now=0;now&lt;=zhj;now++) &#123; printf(&quot;%c&quot;,fx[now]); &#125; return 0;&#125; 该思路原地址 2.蓝桥杯 全球变暖题目你有一张某海域NxN像素的照片，”.”表示海洋、”#”表示陆地，如下所示： 其中”上下左右”四个方向上连在一起的一片陆地组成一座岛屿。例如上图就有2座岛屿。由于全球变暖导致了海面上升，科学家预测未来几十年，岛屿边缘一个像素的范围会被海水淹没。具体来说如果一块陆地像素与海洋相邻(上下左右四个相邻像素中有海洋)，它就会被淹没。例如上图中的海域未来会变成如下样子： 请你计算：依照科学家的预测，照片中有多少岛屿会被完全淹没。 输入第一行包含一个整数N。 (1 &lt;&#x3D; N &lt;&#x3D; 1000)以下N行N列代表一张海域照片。照片保证第1行、第1列、第N行、第N列的像素都是海洋。 输出一个整数表示答案。 样例输入样例输出1 OJ链接 思路：在接收初始图之后，首先搜索查找初始岛屿数，在找到一个岛屿后，对整个岛屿进行标记，防止重复计数。随后再次进行搜索，如果有四周均为陆地的坐标，则标记此坐标未被淹没。最后查找所有未被淹没的坐标，并将坐标所处的整个岛标记，防止重复计数。初始岛屿数量减去未被淹没岛的数量，即为被淹没的岛的数量。 AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;bits/stdc++.h&gt;using namespace std;char maps[1001][1001];void dfs1(int x,int y)&#123; if(maps[x][y]!=&#x27;#&#x27;) return; maps[x][y]=&#x27;1&#x27;;//将#标记为1 dfs1(x+1,y);//把整个岛都进行标记 防止重复计算 dfs1(x-1,y); dfs1(x,y+1); dfs1(x,y-1);&#125; void dfs2(int x,int y)&#123; if(maps[x][y]==&#x27;.&#x27;) return; if(maps[x+1][y]==&#x27;1&#x27;&amp;&amp;maps[x-1][y]==&#x27;1&#x27;&amp;&amp;maps[x][y+1]==&#x27;1&#x27;&amp;&amp;maps[x][y-1]==&#x27;1&#x27;)//四周都是陆地 则标记为2 &#123; maps[x][y]=&#x27;2&#x27;; &#125; dfs1(x+1,y);//找4个方向 dfs1(x-1,y); dfs1(x,y+1); dfs1(x,y-1);&#125; void dfs3(int x,int y)&#123; if(maps[x][y]==&#x27;.&#x27;) return; maps[x][y]=&#x27;.&#x27;;//将#标记为 . dfs3(x+1,y);//把整个岛都进行沉没操作 防止重复计算 dfs3(x-1,y); dfs3(x,y+1); dfs3(x,y-1);&#125; int main()&#123; int n,first_num=0,end_num=0;//层数 初始岛屿数量 末尾岛屿数量 scanf(&quot;%d&quot;,&amp;n); for(int a=1;a&lt;=n;a++) &#123; for(int b=1;b&lt;=n;b++) &#123; while(1) &#123; scanf(&quot;%c&quot;,&amp;maps[a][b]); if(maps[a][b]==&#x27;.&#x27;||maps[a][b]==&#x27;#&#x27;) break; &#125; &#125; &#125; //先查找有多少个岛屿 for(int a=1;a&lt;=n;a++) &#123; for(int b=1;b&lt;=n;b++) &#123; if(maps[a][b]==&#x27;#&#x27;) &#123; dfs1(a,b); first_num++;//初始岛屿+1 &#125; &#125; &#125; //再对整个岛屿进行变化 for(int a=1;a&lt;=n;a++) &#123; for(int b=1;b&lt;=n;b++) &#123; if(maps[a][b]==&#x27;1&#x27;) &#123; dfs2(a,b); &#125; &#125; &#125; //最后查找剩余多少个岛屿 for(int a=1;a&lt;=n;a++) &#123; for(int b=1;b&lt;=n;b++) &#123; if(maps[a][b]==&#x27;2&#x27;) &#123; dfs3(a,b); end_num++;//最终岛屿+1 &#125; &#125; &#125; cout&lt;&lt;first_num-end_num; return 0;&#125; 3.leetcode 路径总和给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。说明: 叶子节点是指没有子节点的节点。 示例:给定如下二叉树，以及目标和 sum &#x3D; 22， 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\ 7 2 1 返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum OJ链接著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码： 12345678910111213141516171819202122232425262728class Solution &#123;public: bool hasPathSum(TreeNode* root, int sum) &#123; kg=false; if(root!=NULL) dfs(root,root-&gt;val,sum); return kg; &#125; void dfs(TreeNode* root,int now,int end) &#123; if(now==end&amp;&amp;root-&gt;left==NULL&amp;&amp;root-&gt;right==NULL) &#123; kg = true; return; &#125; if(root-&gt;left==NULL&amp;&amp;root-&gt;right==NULL) &#123; return; &#125; if(root-&gt;left!=NULL) dfs(root-&gt;left,now+root-&gt;left-&gt;val,end); if(root-&gt;right!=NULL) dfs(root-&gt;right,now+root-&gt;right-&gt;val,end); &#125;private: bool kg;&#125;; 4.leetcode 路径总和II给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。说明: 叶子节点是指没有子节点的节点。 示例:给定如下二叉树，以及目标和 sum &#x3D; 22， 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\ 7 2 5 1 返回: [ [5,4,11,2], [5,8,4,5]] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum-ii OJ链接著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123; if(root) &#123; temp.push_back(root-&gt;val); dfs(root,sum-root-&gt;val); &#125; return ps; &#125;private: vector&lt;vector&lt;int&gt;&gt;ps; vector&lt;int&gt;temp; void dfs(TreeNode* root,int end) &#123; if(end==0&amp;&amp;!root-&gt;left&amp;&amp;!root-&gt;right) &#123; vector&lt;int&gt;t=temp; ps.push_back(t); return; &#125; if(!root-&gt;left&amp;&amp;!root-&gt;right) &#123; return; &#125; if(root-&gt;left) &#123; temp.push_back(root-&gt;left-&gt;val); dfs(root-&gt;left,end-root-&gt;left-&gt;val); temp.pop_back(); &#125; if(root-&gt;right) &#123; temp.push_back(root-&gt;right-&gt;val); dfs(root-&gt;right,end-root-&gt;right-&gt;val); temp.pop_back(); &#125; &#125;&#125;; 小结在使用dfs中，要根据题目数据选择合适的数据类型。比如在题目数据过大时，申请较大的二维数组很容易失败。即使申请成功也会造成极大的内存浪费，循环时也很不方便。这时就可以使用stl里的vector来储存数据，可以很好的提高的数据获取效率。要尽量多的进行筛选，增加效率好多题不止考的是dfs，甚至会考一点dp，所以要多想多做，寻找搜索中的共同点并对症下药。dfs的常用环境找最长路，特殊路等等等等。一般对带权图的搜索都用dfs。在刷蓝桥杯的题的途中发现好多题都可以用dfs进行暴力，但是往往会超时。要想ac还得换题目想让你用的方法。但是往往能过几个检测点，所以不会的题都可以dfs一下混点分哈哈哈哈哈。总之，还是得多刷题，多积累经验。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]}],"categories":[{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Java","slug":"Java","permalink":"https://zgg2001.github.io/categories/Java/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"C++标准库学习","slug":"C-标准库学习","permalink":"https://zgg2001.github.io/tags/C-%E6%A0%87%E5%87%86%E5%BA%93%E5%AD%A6%E4%B9%A0/"},{"name":"源码阅读","slug":"源码阅读","permalink":"https://zgg2001.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://zgg2001.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"},{"name":"网络编程","slug":"网络编程","permalink":"https://zgg2001.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"QT","slug":"QT","permalink":"https://zgg2001.github.io/tags/QT/"},{"name":"Java","slug":"Java","permalink":"https://zgg2001.github.io/tags/Java/"},{"name":"C语言","slug":"C语言","permalink":"https://zgg2001.github.io/tags/C%E8%AF%AD%E8%A8%80/"}]}