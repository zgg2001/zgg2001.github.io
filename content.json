{"meta":{"title":"小咸鱼的自留地","subtitle":"","description":"河边小咸鱼","author":"Zgg2001","url":"https://zgg2001.github.io","root":"/"},"pages":[{"title":"分类","date":"2024-09-08T00:08:37.000Z","updated":"2024-09-08T00:09:36.789Z","comments":true,"path":"categories/index.html","permalink":"https://zgg2001.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2024-09-08T00:05:02.000Z","updated":"2024-09-08T00:07:40.799Z","comments":true,"path":"tags/index.html","permalink":"https://zgg2001.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"redis学习记录：字典(dict)源码分析","slug":"20220603_redis学习记录：字典(dict)源码分析","date":"2022-06-03T14:03:23.000Z","updated":"2022-06-03T14:03:23.000Z","comments":true,"path":"2022/06/03/20220603_redis学习记录：字典(dict)源码分析/","permalink":"https://zgg2001.github.io/2022/06/03/20220603_redis%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E5%AD%97%E5%85%B8(dict)%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"最近在看《redis设计与实现》这本书，对于其中一些部分内容我还是很感兴趣的，由此抽空会切进去学习一下实现源码，并且在CSDN上记录一下吧。 个人的《redis设计与实现》读书笔记记录：https://github.com/zgg2001/redis_learning","text":"最近在看《redis设计与实现》这本书，对于其中一些部分内容我还是很感兴趣的，由此抽空会切进去学习一下实现源码，并且在CSDN上记录一下吧。 个人的《redis设计与实现》读书笔记记录：https://github.com/zgg2001/redis_learning 一、前言&emsp;&emsp;字典是目前使用率蛮高的一种KV存储数据结构，简单说就是一个key对应一个value，并且可以确保通过key可以快速的获取value。&emsp;&emsp;字典的具体实现还是有很大的差异的。在C++中一般字典结构被称为map，目前stl常用的字典结构有std::map和std::unordered_map，前者的底层实现是红黑树，后者的底层实现为哈希表，两者都可以实现高效率的查询&#x2F;插入操作。&emsp;&emsp;回归到redis上，redis中字典的出场率很高，毕竟redis本来就是一个KV内存数据库。可以说其底层就是使用字典来实现的，而常规的增删查改也是基于字典来进行的。但是C语言中是没有内置字典数据结构的，所以redis自己构建了字典实现。 &emsp; 二、redis字典的实现思路&emsp;&emsp;redis的字典底层实现采用哈希表，总体思路和C++里的std::unordered_map思路差不多，简单来说都是哈希表+开链法。但是由于C语言里也没有自己的std::vector，所以redis的字典存储空间也是需要自己通过malloc/free管理。&emsp;&emsp;从具体实现上来看，redis字典主要由三部分组成：字典部分、哈希表部分、哈希表节点部分。从关系上来看，字典部分含有两张哈希表，而哈希表中含有若干哈希表节点。&emsp;&emsp;redis的字典思路其实还算是简单，但是其中很多策略和细节的实现我都蛮感兴趣的，所以还是会细看一下。其中个人比较感兴趣的部分有开链法的代码部分以及渐进式rehash的实现部分。 &emsp; 三、实现源码分析1. 哈希表节点数据结构12345678910111213141516typedef struct dictEntry &#123; // 键 void *key; // 值 union &#123; void *val; uint64_t u64; int64_t s64; &#125; v; // 指向下个哈希表节点，形成链表 struct dictEntry *next;&#125; dictEntry; &emsp;&emsp;如上为哈希表节点的数据结构，可以说是字典结构里的最底层数据结构。简而言之一个哈希表节点由常规的key、value以及一个next指针组成，还是比较清晰的。&emsp;&emsp;key的类型为void指针，来实现存各式各样的内容。redis字典的键部分一般都是字符串对象，所以就没有像值部分那样使用联合体来特化内容。&emsp;&emsp;value部分使用一个联合体，其中有void*类型和有&#x2F;无符号64位int类型，另外新版本的redis中好像也添加了高精度浮点数double类型。这里使用联合体主要还是为了节省内存，避免存数值内容时的内存浪费。&emsp;&emsp;next指针部分算是开链法的具体实现，即通过这个指针来把哈希冲突的节点给连接起来，来解决哈希冲突问题。 2. 哈希表数据结构12345678910111213141516typedef struct dictht &#123; // 哈希表数组 dictEntry **table; // 哈希表大小 unsigned long size; // 哈希表大小掩码，用于计算索引值 // 总是等于 size - 1 unsigned long sizemask; // 该哈希表已有节点的数量 unsigned long used;&#125; dictht; &emsp;&emsp;如上为哈希表的数据结构，dictht通过一个dictEntry指针数组来建表。除了基础的表结构，此数据结构中也存放了已使用大小、总大小和大小掩码。&emsp;&emsp;首先是二级指针table，用于指向一个哈希表节点数组，来保存哈希表节点。所以这部分内存实际上是由字典直接进行管理的，不像是STL里使用std::vector当底层。&emsp;&emsp;然后说一下sizemask这个属性，其值总是等于size - 1，其实也就是指针数组的下标范围(0 ~ size - 1)，相关公式为index = hash &amp; sizemask，来避免索引值超出数组范围。redis字典的扩容策略要求哈希表大小全部为2的n次方，所以这里进行减一操作就可以获取范围掩码了，还是挺巧妙的。&emsp;&emsp;剩下的两个属性size和used就比较常规了，没什么好说的。 3. 字典数据结构12345678910111213141516171819typedef struct dict &#123; // 类型特定函数 dictType *type; // 私有数据 void *privdata; // 哈希表 dictht ht[2]; // rehash 索引 // 当 rehash 不在进行时，值为 -1 int rehashidx; /* rehashing not in progress if rehashidx == -1 */ // 目前正在运行的安全迭代器的数量 int iterators; /* number of iterators currently running */&#125; dict; &emsp;&emsp;如上为字典的数据结构。首先看最重要的，属性ht用于存放哈希表，而且可以看到是用大小为2的数组存的，主要就是为了方便进行渐进式rehash操作，而下面的rehashidx属性用来配合记录rehash进度，rehash部分下面会进行具体分析。&emsp;&emsp;其次privdata属性是一个void*指针，指向一些特定参数，这些参数用于配合dictType里的回调函数。&emsp;&emsp;接下来来看type属性，其类型为dictType指针。具体来看内容，dictType结构体里存了一组回调函数，其结构体内容如下： 123456789101112131415161718192021typedef struct dictType &#123; // 计算哈希值的函数 unsigned int (*hashFunction)(const void *key); // 复制键的函数 void *(*keyDup)(void *privdata, const void *key); // 复制值的函数 void *(*valDup)(void *privdata, const void *obj); // 对比键的函数 int (*keyCompare)(void *privdata, const void *key1, const void *key2); // 销毁键的函数 void (*keyDestructor)(void *privdata, void *key); // 销毁值的函数 void (*valDestructor)(void *privdata, void *obj);&#125; dictType; &emsp;&emsp;可以看到是一组用于操作指定类型键值对的函数，不同的字典配备函数也可能不同，算是为了方便进行泛型编程吧。 4. 渐进式rehash部分&emsp;&emsp;首先讲一下redis字典的rehash策略，redis中为了防止在进行扩展&#x2F;收缩的rehash时，由于数据过多造成服务器停止服务，采用了渐进式rehash思路。即rehash不一次性进行完毕，而是分多次、渐进式的对键值对进行rehash操作。&emsp;&emsp;首先实现渐进式rehash的基础就是得有可记录的、独立的两张新表，对此redis数据结构dict以dictht数组的形式存放哈希表，数组大小为2。日常使用时使用[0]表，在扩展&#x2F;收缩时，为[1]分配新表，并渐进式将[0]表上的键值对rehash分配到[1]表上。当rehash完成时，[1]表拥有所有键值对而[0]表为空，此时释放[0]表，并将[1]表设置[0]表，再将[1]表置空，此时渐进式rehash流程完全完成。&emsp;&emsp;还有一个值得一提的重点就是渐进式rehash的具体过程：redis字典数据结构dict中有一个rehash索引rehashidx，每当对rehash过程中的字典进行增删查改操作时，程序除了进行指定操作外，还会将[0]表在rehashidx索引上的所有键值对rehash到[1]表上，随后索引rehashidx值自增一。当渐进式rehash过程结束后，索引rehashidx置为-1，意为未在rehash过程中。&emsp;&emsp;此外，还需要注意的一个细节是渐进式rehash过程中增删查改的操作。在这个过程中，字典是同时使用[0]和[1]两张表的，所以删、查、改操作会同时在两张表上进行，来保证不会漏数据。例如查找一个键时，会先在[0]表上找，如果没有则会去[1]表上找，找不到再返回。而增操作则会直接将新键值对放在[1]表上，[0]表不进行任何添加操作，这主要是为了保证[0]表数据只减不增，并随着rehash操作最终变成空表。&emsp;&emsp;然后来看一下具体的实现源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768int dictRehash(dict *d, int n) &#123; // 只可以在 rehash 进行中时执行 if (!dictIsRehashing(d)) return 0; // 进行 N 步迁移 // T = O(N) while(n--) &#123; dictEntry *de, *nextde; /* Check if we already rehashed the whole table... */ // 如果 0 号哈希表为空，那么表示 rehash 执行完毕 // T = O(1) if (d-&gt;ht[0].used == 0) &#123; // 释放 0 号哈希表 zfree(d-&gt;ht[0].table); // 将原来的 1 号哈希表设置为新的 0 号哈希表 d-&gt;ht[0] = d-&gt;ht[1]; // 重置旧的 1 号哈希表 _dictReset(&amp;d-&gt;ht[1]); // 关闭 rehash 标识 d-&gt;rehashidx = -1; // 返回 0 ，向调用者表示 rehash 已经完成 return 0; &#125; /* Note that rehashidx can&#x27;t overflow as we are sure there are more * elements because ht[0].used != 0 */ // 确保 rehashidx 没有越界 assert(d-&gt;ht[0].size &gt; (unsigned)d-&gt;rehashidx); // 略过数组中为空的索引，找到下一个非空索引 while(d-&gt;ht[0].table[d-&gt;rehashidx] == NULL) d-&gt;rehashidx++; // 指向该索引的链表表头节点 de = d-&gt;ht[0].table[d-&gt;rehashidx]; /* Move all the keys in this bucket from the old to the new hash HT */ // 将链表中的所有节点迁移到新哈希表 // T = O(1) while(de) &#123; unsigned int h; // 保存下个节点的指针 nextde = de-&gt;next; /* Get the index in the new hash table */ // 计算新哈希表的哈希值，以及节点插入的索引位置 h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[1].sizemask; // 插入节点到新哈希表 de-&gt;next = d-&gt;ht[1].table[h]; d-&gt;ht[1].table[h] = de; // 更新计数器 d-&gt;ht[0].used--; d-&gt;ht[1].used++; // 继续处理下个节点 de = nextde; &#125; // 将刚迁移完的哈希表索引的指针设为空 d-&gt;ht[0].table[d-&gt;rehashidx] = NULL; // 更新 rehash 索引 d-&gt;rehashidx++; &#125; return 1;&#125; &emsp;&emsp;可以看到在渐进式rehash的过程里，碰到空索引会跳过并且会自动找下一个非空索引，直至完成指定步数或者[0]表为空。当[0]表为空时，进行释放、交换、重置三连，并标记渐进式rehash结束。&emsp;&emsp;渐进式rehash的每一步都会把一个索引处内的一条链表rehash至[1]表上，其中涉及到索引更新、计数器更新和置空等操作。 最后看一下各种情况下进行rehash的源码部分： 123static void _dictRehashStep(dict *d) &#123; if (d-&gt;iterators == 0) dictRehash(d,1);&#125; &emsp;&emsp;首先是封装好的进行单次rehash操作的函数。 1234567dictEntry *dictAddRaw(dict *d, void *key)&#123; ... // 如果条件允许的话，进行单步 rehash // T = O(1) if (dictIsRehashing(d)) _dictRehashStep(d); ... &emsp;&emsp;尝试插入键会触发单步rehash。 123456static int dictGenericDelete(dict *d, const void *key, int nofree)&#123; ... // 进行单步 rehash ，T = O(1) if (dictIsRehashing(d)) _dictRehashStep(d); ... &emsp;&emsp;查找删除节点会触发单步rehash。 123456dictEntry *dictFind(dict *d, const void *key)&#123; ... // 如果条件允许的话，进行单步 rehash if (dictIsRehashing(d)) _dictRehashStep(d); ... &emsp;&emsp;只进行节点查找也会触发单步rehash。 123456dictEntry *dictGetRandomKey(dict *d)&#123; ... // 进行单步 rehash if (dictIsRehashing(d)) _dictRehashStep(d); ... &emsp;&emsp;随机返回任一节点也会触发单步rehash。 5. 扩容部分&emsp;&emsp;首先来讲一下redis字典的空间分配策略，总结哈希表空间变化规律如下： 当执行扩展操作时：新的大小为第一个大于等于当前已使用大小二倍的2的n次方。例如当前已使用大小为4，执行扩容操作，扩容后哈希表总大小为8(8 &gt;&#x3D; 4 * 2)。 当执行收缩操作时：新的大小为第一个大于等于当前已使用大小的2的n次方。例如当前已使用大小为3，执行收缩操作，收缩后哈希表总大小为4(4 &gt;&#x3D; 3)。 &emsp;&emsp;哈希表扩展和收缩的情况如下：(负载因子：已使用&#x2F;总量) 当负载因子小于0.1时，进行收缩操作。 当未执行BGSAVE&#x2F;BGREWRITEAOF命令时，负载因子大于等于1时，进行扩展操作。 当在执行BGSAVE&#x2F;BGREWRITEAOF命令时，负载因子大于等于5时，进行扩展操作。 &emsp;&emsp;当执行BGSAVE&#x2F;BGREWRITEAOF时提高扩展所需负载因子，主要是因为执行这两个命令时都需要redis创建子进程，而此时进行rehash操作可能会触发子进程的”写时复制”机制。所以此时减少rehash操作即可避免不必要的内存写入操作，最大限度的节约内存。&emsp;&emsp;然后来看一下具体的实现源码： 12345678910111213141516171819202122int dictExpand(dict *d, unsigned long size): // 新哈希表 dictht n; // 根据 size 参数，计算哈希表的大小 unsigned long realsize = _dictNextPower(size); /* the size is invalid if it is smaller than the number of * elements already inside the hash table */ // 不能在字典正在 rehash 时进行 // size 的值也不能小于 0 号哈希表的当前已使用节点 if (dictIsRehashing(d) || d-&gt;ht[0].used &gt; size) return DICT_ERR; /* Allocate the new hash table and initialize all pointers to NULL */ // 为哈希表分配空间，并将所有指针指向 NULL n.size = realsize; n.sizemask = realsize-1; // T = O(N) n.table = zcalloc(realsize*sizeof(dictEntry*)); n.used = 0; &emsp;&emsp;可以看到这部分在获取下一个大小后进行了内存申请，申请了realsize个dictEntry指针大小的内存。 12345678910111213// 如果 0 号哈希表为空，那么这是一次初始化：// 程序将新哈希表赋给 0 号哈希表的指针，然后字典就可以开始处理键值对了。if (d-&gt;ht[0].table == NULL) &#123; d-&gt;ht[0] = n; return DICT_OK;&#125;// 如果 0 号哈希表非空，那么这是一次 rehash ：// 程序将新哈希表设置为 1 号哈希表，// 并将字典的 rehash 标识打开，让程序可以开始对字典进行 rehashd-&gt;ht[1] = n;d-&gt;rehashidx = 0;return DICT_OK; &emsp;&emsp;这部分主要是为了进入rehash状态，当然如果是初始化就不用进rehash状态。 6. 开链法解决哈希冲突部分&emsp;&emsp;最后我决定看一下开链法的具体实现，毕竟这么有名的思路，看一下redis源码里是怎么写的。首先看一下新增节点的源码部分： 1234567891011121314151617181920212223242526272829303132333435363738dictEntry *dictAddRaw(dict *d, void *key)&#123; int index; dictEntry *entry; dictht *ht; // 如果条件允许的话，进行单步 rehash // T = O(1) if (dictIsRehashing(d)) _dictRehashStep(d); /* Get the index of the new element, or -1 if * the element already exists. */ // 计算键在哈希表中的索引值 // 如果值为 -1 ，那么表示键已经存在 // T = O(N) if ((index = _dictKeyIndex(d, key)) == -1) return NULL; // T = O(1) /* Allocate the memory and store the new entry */ // 如果字典正在 rehash ，那么将新键添加到 1 号哈希表 // 否则，将新键添加到 0 号哈希表 ht = dictIsRehashing(d) ? &amp;d-&gt;ht[1] : &amp;d-&gt;ht[0]; // 为新节点分配空间 entry = zmalloc(sizeof(*entry)); // 将新节点插入到链表表头 entry-&gt;next = ht-&gt;table[index]; ht-&gt;table[index] = entry; // 更新哈希表已使用节点数量 ht-&gt;used++; /* Set the hash entry fields. */ // 设置新节点的键 // T = O(1) dictSetKey(d, entry, key); return entry;&#125; &emsp;&emsp;太长不看，截取出关键部分： 123456//hash取下标index = _dictKeyIndex(d, key);// 将新节点插入到链表表头entry = zmalloc(sizeof(*entry));//申请新结点内存entry-&gt;next = ht-&gt;table[index];//执行头插操作ht-&gt;table[index] = entry; &emsp;&emsp;所以实际上redis的开链法实现就是配合着数据结构里的next指针，简单的把每个新节点头插在对应下标的链表上，非常的简单，也就几行代码，完全没有进行任何哈希冲突方面的判定。 &emsp; 四、总结&emsp;&emsp;redis的字典设计的还是非常巧妙的，尤其是其中的渐进式rehash实现。通过这次看具体代码我也是学到了很多新思路，尤其是看源码前完全没想到开链法实现竟然这么简单。&emsp;&emsp;就个人的感觉来看，redis的代码写的还是蛮清晰简便的，不像C++标准库套来套去非常的恶心。我感觉可能主要是因为C语言比较灵活，没有搞C++强类型那一套，所以通过void*就可以非常简便的实现泛型编程。其次可能就是redis的代码风格比较精简，确实读起来蛮舒服的（当然也是huangz大佬的书写的好）。","categories":[{"name":"Redis","slug":"Redis","permalink":"https://zgg2001.github.io/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://zgg2001.github.io/tags/Redis/"},{"name":"源码阅读","slug":"源码阅读","permalink":"https://zgg2001.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"}]},{"title":"C++学习记录：一个协程库的源码分析","slug":"20220319_C++学习记录：一个协程库的源码分析","date":"2022-03-19T12:28:51.000Z","updated":"2022-03-19T12:28:51.000Z","comments":true,"path":"2022/03/19/20220319_C++学习记录：一个协程库的源码分析/","permalink":"https://zgg2001.github.io/2022/03/19/20220319_C++%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%8D%8F%E7%A8%8B%E5%BA%93%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"抽空学习一些感兴趣的源码，这次学习云风大佬的一个协程库源码。 项目地址：https://github.com/cloudwu/coroutine 个人fork注释后的项目地址：https://github.com/zgg2001/coroutine","text":"抽空学习一些感兴趣的源码，这次学习云风大佬的一个协程库源码。 项目地址：https://github.com/cloudwu/coroutine 个人fork注释后的项目地址：https://github.com/zgg2001/coroutine 一、前言&emsp;&emsp;本来是想学习一下鹅厂的 libco 协程库来着，无奈之前没怎么接触过协程的实现，且 libco 源码太厚实了，啃起来太慢，所以打算先学习一个精简点的协程库，由浅入深再去啃 libco。 &emsp;&emsp;本次笔记记录的是云风大佬在2012年实现的一个短小精悍的协程库，代码总共只有200行左右，但却实现了协程的核心功能。个人感觉很适合用来学习协程的实现方法和执行流程，所以 fork 了一下，过了一遍并加了注释。&emsp;&emsp; 二、实现分析1. 数据结构&emsp;&emsp;首先是协程结构体，每个结构体实例对应着一条协程。可以看到其中定义了协程对应的回调函数与其传参，还有核心内存协程上下文ctx，以及每个协程对应的栈区内容等。 12345678910struct coroutine &#123; coroutine_func func;//协程回调函数 void *ud;//传参 ucontext_t ctx;//上下文 struct schedule * sch;//所属管理者 ptrdiff_t cap;//已经分配的内存大小 ptrdiff_t size;//协程运行时栈的保存后大小 int status;//状态 char *stack;//栈&#125;; &emsp;&emsp;其次是协程调度器结构体，其中储存了若干协程指针以及当前运行协程id等内容，用于进行协程调度等操作。其中最重要的我觉得是共享栈区stack。 12345678struct schedule &#123; char stack[STACK_SIZE];//栈 ucontext_t main;//主线程上下文 int nco;//当前协程数量 int cap;//协程最大数量 int running;//当前执行中的协程id struct coroutine **co;//协程组&#125;; 2. 整体思路&emsp;&emsp;了解了核心数据结构，那么协程的切换是如何实现的呢？我过了一遍源码，大致了解了云风大佬这个协程库的实现原理： &emsp;&emsp;简单来讲，调度器结构体 schedule 中有一块栈上的内存，声明为 char stack[STACK_SIZE];，当协程在执行时，会将这块内存当作自己的进程栈来使用。 &emsp;&emsp;当协程执行挂起操作时，会通过 memcpy 把执行栈上的内容 copy 至协程自己的缓冲区，进行栈区内容的保存；而当协程进行唤醒操作时，只需要把协程缓冲区中的栈内容 copy 至执行栈上，即可实现栈区内容的恢复。因为所有的协程在执行中都需要使用这块栈内存，所以这种协程实现方法被称为共享栈。 &emsp;&emsp;除了栈区内容的切换外，也需要进行硬件上下文的切换，对此，Linux存在系统调用来进行上下文的切换与保存，其均定义在头文件 ucontext.h 中。此协程库中主要使用的内容有： ucontext_t：上下文结构体，其中储存了上下文的内容。主要需要关注的有uc_link: 下一个要执行的上下文、uc_stack：此上下文所使用的栈信息，其余还有信号掩码、硬件上下文等内容。 getcontext：传入一个 ucontext_t，初始化它并获取当前上下文环境存入其中。 makecontext：传入一个 ucontext_t 和一个函数指针及其参数，作用是指定该上下文的入口函数。即在此上下文被激活后，执行这个被绑定的函数。 swapcontext：传入两个 ucontext_t，作用为切换上下文环境。具体操作是保存当前上下文环境至第一个 ucontext_t，并激活第二个 ucontext_t 的上下文环境。 &emsp;&emsp;所以可以说这个协程库主要就是通过系统调用切换&#x2F;保存上下文，以及保存每个协程的运行栈来实现的。&emsp;&emsp; 3. 唤醒 resume&emsp;&emsp;协程的核心操作唤醒的实现如下，其中已经加上了我的注释。 12345678910111213141516171819202122232425262728293031void coroutine_resume(struct schedule * S, int id) &#123; assert(S-&gt;running == -1); assert(id &gt;=0 &amp;&amp; id &lt; S-&gt;cap); struct coroutine *C = S-&gt;co[id];//确定唤醒的协程 if (C == NULL) return; int status = C-&gt;status; switch(status) &#123; case COROUTINE_READY://全新的协程 getcontext(&amp;C-&gt;ctx);//初始化并获取当前上下文环境：信号掩码/具体硬件上下文 C-&gt;ctx.uc_stack.ss_sp = S-&gt;stack;//共享栈 C-&gt;ctx.uc_stack.ss_size = STACK_SIZE;//共享栈大小 C-&gt;ctx.uc_link = &amp;S-&gt;main;//当前context执行结束之后要执行的下一个context S-&gt;running = id;//当前执行协程id C-&gt;status = COROUTINE_RUNNING; uintptr_t ptr = (uintptr_t)S; //makecontext修改上下文结构体，设定栈空间为C-&gt;ctx-&gt;uc_stack，激活后执行mainfunc makecontext(&amp;C-&gt;ctx, (void (*)(void)) mainfunc, 2, (uint32_t)ptr, (uint32_t)(ptr&gt;&gt;32)); swapcontext(&amp;S-&gt;main, &amp;C-&gt;ctx);//保存当前上下文至S-&gt;main，并激活C-&gt;ctx上下文 break; case COROUTINE_SUSPEND://之前已挂起 memcpy(S-&gt;stack + STACK_SIZE - C-&gt;size, C-&gt;stack, C-&gt;size);//把协程栈的内存copy至调度器中 S-&gt;running = id; C-&gt;status = COROUTINE_RUNNING; swapcontext(&amp;S-&gt;main, &amp;C-&gt;ctx);//保存当前上下文至S-&gt;main，并激活C-&gt;ctx上下文 break; default: assert(0); &#125;&#125; &emsp;&emsp;在新建一条协程后，其状态为 COROUTINE_READY。在上面的源码中，可以看到对于刚创建的协程和被挂起后的协程操作是不一致的。主要原因是因为刚创建的协程并没有初始化上下文，而且也没有指定运行栈为调度器中的共享栈，所以新的协程需要指定上下文相关的内容并绑定入口函数。 &emsp;&emsp;此外，makecontext 中的入口函数传参被拆成两部分来传入，我感觉是因为传参类型为 uint 而在64位环境下指针大小为8B，为了避免这部分的差异，所以把指针分为前32位和后32位来进行传入。而在随后入口函数的定义中对指针进行拼合操作，来获取正确的指针。 &emsp;&emsp;另外值得一提的是在对已挂起协程的恢复时，需要恢复执行栈，所以使用 memcpy 进行内存拷贝。由于栈地址是由高向低发展，所以这里是从后倒着找栈顶 S-&gt;stack + STACK_SIZE - C-&gt;size。 &emsp;&emsp;入口函数 mainfunc 定义如下，主要就是传入协程调度器，从而获取正在执行的协程，从而执行对应的回调函数。并在回调函数执行完毕后删除协程，从而宣布此协程执行完毕。 12345678910111213static voidmainfunc(uint32_t low32, uint32_t hi32) &#123; //上32位和下32位组成一个指针，这里我觉得是为了避免64位与32位系统下long类型大小差异造成的影响 uintptr_t ptr = (uintptr_t)low32 | ((uintptr_t)hi32 &lt;&lt; 32); struct schedule *S = (struct schedule *)ptr; int id = S-&gt;running; struct coroutine *C = S-&gt;co[id]; C-&gt;func(S,C-&gt;ud);//执行协程的回调函数 _co_delete(C);//执行完毕删除协程 S-&gt;co[id] = NULL; --S-&gt;nco; S-&gt;running = -1;&#125; &emsp;&emsp; 4. 挂起 yield&emsp;&emsp;协程的核心操作挂起的实现如下，其中已经加上了我的注释。 12345678910111213141516171819202122232425voidcoroutine_yield(struct schedule * S) &#123; int id = S-&gt;running; assert(id &gt;= 0); struct coroutine * C = S-&gt;co[id]; assert((char *)&amp;C &gt; S-&gt;stack); _save_stack(C,S-&gt;stack + STACK_SIZE);//保存协程栈 C-&gt;status = COROUTINE_SUSPEND; S-&gt;running = -1; swapcontext(&amp;C-&gt;ctx , &amp;S-&gt;main);//保存当前上下文至C-&gt;ctx，并激活S-&gt;main上下文&#125;static void_save_stack(struct coroutine *C, char *top) &#123; char dummy = 0;//获取当前的栈顶地址 assert(top - &amp;dummy &lt;= STACK_SIZE); //此时栈大小就是 top - &amp;dummy if (C-&gt;cap &lt; top - &amp;dummy) &#123;//协程栈大小不足时，需要重新分配内存，用于保存当前协程栈 free(C-&gt;stack); C-&gt;cap = top-&amp;dummy; C-&gt;stack = malloc(C-&gt;cap); &#125; C-&gt;size = top - &amp;dummy; memcpy(C-&gt;stack, &amp;dummy, C-&gt;size);//将栈顶至栈底的内存拷贝至C-&gt;stack保存&#125; &emsp;&emsp;挂起操作相对就比较简单了，主要就是保存执行栈 + 切换上下文。其中主要的篇幅是在保存执行栈这一环节上，主要的逻辑是协程栈内存不足时释放并申请足够的内存，随后 copy 执行栈。&emsp;&emsp; 5. 新建与扩容&emsp;&emsp;值得一提的是协程调度结构体中是通过一个协程指针数组来储存所管理的协程的，所以涉及到扩容问题。此协程库中采用了经典的二倍扩容法，通过 realloc 进行扩容，具体实现如下： 123456789101112131415161718192021222324252627282930int coroutine_new(struct schedule *S, coroutine_func func, void *ud) &#123; struct coroutine *co = _co_new(S, func , ud); /* * 此处主要是判定管理者管理数量是否达到最大 * 当达到最大时，会使用realloc对协程组空间进行扩容，扩容后大小为两倍当前大小（经典的两倍扩容），随后插入在最后端 * 没达到最大时，则遍历协程组找到空闲位置插入 */ if (S-&gt;nco &gt;= S-&gt;cap) &#123;//扩容后，将新的协程插入到扩容后的第一个空闲处 int id = S-&gt;cap; S-&gt;co = realloc(S-&gt;co, S-&gt;cap * 2 * sizeof(struct coroutine *)); memset(S-&gt;co + S-&gt;cap , 0 , sizeof(struct coroutine *) * S-&gt;cap); S-&gt;co[S-&gt;cap] = co; S-&gt;cap *= 2; ++S-&gt;nco; return id; &#125; else &#123;//遍历整个协程组找到位置插入新协程 int i; for (i=0;i&lt;S-&gt;cap;i++) &#123; int id = (i+S-&gt;nco) % S-&gt;cap; if (S-&gt;co[id] == NULL) &#123; S-&gt;co[id] = co; ++S-&gt;nco; return id; &#125; &#125; &#125; assert(0); return -1;&#125; &emsp;&emsp; 三、小结&emsp;&emsp;这个协程库的实现比较简单明了，但是仍有很多学习的地方。通过这个协程库，我也初步了解了协程的实现原理。但是不得不说，虽然源码仅仅200行，但是其中很多思路可能是一时半会想不出来的。这种思路包括数据结构的定义&#x2F;函数的实现，我觉得都需要大量的积累，只能说我还有很多需要学习和接触的。 &emsp;&emsp;在之后对鹅厂 libco 的源码学习中，我应该会着重去了解相比此协程库其多出内容的作用和意义，希望可以让我接触到更多新的东西。","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"}],"tags":[{"name":"源码阅读","slug":"源码阅读","permalink":"https://zgg2001.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"},{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/tags/C-C/"}]},{"title":"C++学习记录：一个小线程池的源码分析","slug":"20220314_C++学习记录：一个小线程池的源码分析","date":"2022-03-14T12:28:26.000Z","updated":"2022-03-14T12:28:26.000Z","comments":true,"path":"2022/03/14/20220314_C++学习记录：一个小线程池的源码分析/","permalink":"https://zgg2001.github.io/2022/03/14/20220314_C++%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%B0%8F%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"抽空学习一些感兴趣的源码，这次学习一个小而美的C++11线程池源码。 项目地址：https://github.com/progschj/ThreadPool/","text":"抽空学习一些感兴趣的源码，这次学习一个小而美的C++11线程池源码。 项目地址：https://github.com/progschj/ThreadPool/ 一、源码一览&emsp;&emsp;核心代码很简单，就是下面这不到一百行。但是其中使用了很多新C++11的新东西，写的非常优雅，有很多可以学习的地方。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#ifndef THREAD_POOL_H#define THREAD_POOL_H#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;memory&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;#include &lt;future&gt;#include &lt;functional&gt;#include &lt;stdexcept&gt;class ThreadPool &#123;public: ThreadPool(size_t); template&lt;class F, class... Args&gt; auto enqueue(F&amp;&amp; f, Args&amp;&amp;... args) -&gt; std::future&lt;typename std::result_of&lt;F(Args...)&gt;::type&gt;; ~ThreadPool();private: // need to keep track of threads so we can join them std::vector&lt; std::thread &gt; workers; // the task queue std::queue&lt; std::function&lt;void()&gt; &gt; tasks; // synchronization std::mutex queue_mutex; std::condition_variable condition; bool stop; &#125;; // the constructor just launches some amount of workersinline ThreadPool::ThreadPool(size_t threads) : stop(false)&#123; for(size_t i = 0;i&lt;threads;++i) workers.emplace_back( [this] &#123; for(;;) &#123; std::function&lt;void()&gt; task; &#123; std::unique_lock&lt;std::mutex&gt; lock(this-&gt;queue_mutex); this-&gt;condition.wait(lock, [this]&#123; return this-&gt;stop || !this-&gt;tasks.empty(); &#125;); if(this-&gt;stop &amp;&amp; this-&gt;tasks.empty()) return; task = std::move(this-&gt;tasks.front()); this-&gt;tasks.pop(); &#125; task(); &#125; &#125; );&#125;// add new work item to the pooltemplate&lt;class F, class... Args&gt;auto ThreadPool::enqueue(F&amp;&amp; f, Args&amp;&amp;... args) -&gt; std::future&lt;typename std::result_of&lt;F(Args...)&gt;::type&gt;&#123; using return_type = typename std::result_of&lt;F(Args...)&gt;::type; auto task = std::make_shared&lt; std::packaged_task&lt;return_type()&gt; &gt;( std::bind(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...) ); std::future&lt;return_type&gt; res = task-&gt;get_future(); &#123; std::unique_lock&lt;std::mutex&gt; lock(queue_mutex); // don&#x27;t allow enqueueing after stopping the pool if(stop) throw std::runtime_error(&quot;enqueue on stopped ThreadPool&quot;); tasks.emplace([task]()&#123; (*task)(); &#125;); &#125; condition.notify_one(); return res;&#125;// the destructor joins all threadsinline ThreadPool::~ThreadPool()&#123; &#123; std::unique_lock&lt;std::mutex&gt; lock(queue_mutex); stop = true; &#125; condition.notify_all(); for(std::thread &amp;worker: workers) worker.join();&#125;#endif &emsp;&emsp; 二、源码分析1. 构造部分123456789101112131415161718192021222324252627// the constructor just launches some amount of workersinline ThreadPool::ThreadPool(size_t threads) : stop(false)&#123; for(size_t i = 0;i&lt;threads;++i) workers.emplace_back( [this] &#123; for(;;) &#123; std::function&lt;void()&gt; task; &#123; std::unique_lock&lt;std::mutex&gt; lock(this-&gt;queue_mutex); this-&gt;condition.wait(lock, [this]&#123; return this-&gt;stop || !this-&gt;tasks.empty(); &#125;); if(this-&gt;stop &amp;&amp; this-&gt;tasks.empty()) return; task = std::move(this-&gt;tasks.front()); this-&gt;tasks.pop(); &#125; task(); &#125; &#125; );&#125; &emsp;&emsp;如上为线程池的构造函数部分。其中主要是根据构造传参创建对应数量的线程，线程储存在 vector&lt; std::thread &gt; 中，线程通过 emplace_back 加 lambda 函数直接构造进vector里。 &emsp;&emsp;线程的流程总体也比较简单，就是一个死循环加条件变量阻塞，当被唤醒时进行判定，如果要求线程退出则 return 出去，否则去任务队列 queue&lt; std::function&lt;void()&gt; &gt; 里取任务执行。这块内容的线程安全是通过一个 std::unique_lock 来保证的。 &emsp;&emsp;值得一提的是这里的条件变量的 wait() 操作中添加了判定条件，从而避免虚假唤醒情况；并且获取 task 也是通过右值引用来进行的。&emsp;&emsp; 2. 析构部分1234567891011// the destructor joins all threadsinline ThreadPool::~ThreadPool()&#123; &#123; std::unique_lock&lt;std::mutex&gt; lock(queue_mutex); stop = true; &#125; condition.notify_all(); for(std::thread &amp;worker: workers) worker.join();&#125; &emsp;&emsp;析构部分总体也比较简单，即通过 notify_all() 唤醒所有条件变量，随后使用 join() 等待所有线程执行完毕，完成线程池的同步退出。 &emsp;&emsp;另外在这个线程池实现中，是通过一个变量 stop 来标记线程池是否退出的，线程安全也是通过一个 std::unique_lock 来保证的。这个锁逻辑意义上是任务队列锁，确保关于任务队列相关内容操作的线程安全。&emsp;&emsp; 3. 任务入队部分123456789101112131415161718192021222324// add new work item to the pooltemplate&lt;class F, class... Args&gt;auto ThreadPool::enqueue(F&amp;&amp; f, Args&amp;&amp;... args) -&gt; std::future&lt;typename std::result_of&lt;F(Args...)&gt;::type&gt;&#123; using return_type = typename std::result_of&lt;F(Args...)&gt;::type; auto task = std::make_shared&lt; std::packaged_task&lt;return_type()&gt; &gt;( std::bind(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...) ); std::future&lt;return_type&gt; res = task-&gt;get_future(); &#123; std::unique_lock&lt;std::mutex&gt; lock(queue_mutex); // don&#x27;t allow enqueueing after stopping the pool if(stop) throw std::runtime_error(&quot;enqueue on stopped ThreadPool&quot;); tasks.emplace([task]()&#123; (*task)(); &#125;); &#125; condition.notify_one(); return res;&#125; &emsp;&emsp;这是我感觉整个线程池中，写的最优雅的部分，其中运用了大量C++11的新东西。首先这个部分完成实现了任务入队操作，并且可以通过 std::future 系列操作来实现异步获取执行结果。 &emsp;&emsp;其中的实现是通过 std::packaged_task + std::bind 封装了可以异步执行的任务函数，函数返回一个 std::future 对象。通过这个对象即可异步获取线程的执行结果。另外这部分也中也使用了智能指针 std::shared_ptr，来保证task对象部分的智能释放。 &emsp;&emsp;此外，其中的任务队列通过 std::unique_lock 来保证线程安全，并且也通过大括号来限定临界区域。在任务加入任务队列中，会通过条件变量来唤醒一个已阻塞的线程，从而继续任务处理流程。 &emsp;&emsp; 三、小结&emsp;&emsp;所以这个线程池的任务处理流程就是：开辟线程 -&gt; 阻塞线程 -&gt; 任务入队 -&gt; 唤醒线程 -&gt; 执行线程 -&gt; 阻塞线程.&emsp;&emsp;总体来说思路很简单，关于执行结果的接收直接通过C++11的新库 std::future 来实现了，并且通过 std::unique_lock 和 std::condition_variable 来保证线程安全和线程等待的的最小化消耗。其中很多功能都是直接使用了C++11封装好的库，所以看起来很清晰明了并且写的也很优雅。但是毕竟代码量很少，所以相比很多完善的线程池还有很多优化的空间，不过当一个轻量化的线程池来使用我感觉也是够用了，而且从其中我也学习到了不少C++11的新库用法。","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"}],"tags":[{"name":"源码阅读","slug":"源码阅读","permalink":"https://zgg2001.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"},{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/tags/C-C/"}]},{"title":"C/C++学习记录：智能指针 std::unique_ptr 源码分析","slug":"20220225_C-C++学习记录：智能指针std::unique_ptr源码分析","date":"2022-02-25T05:13:56.000Z","updated":"2022-02-25T05:13:56.000Z","comments":true,"path":"2022/02/25/20220225_C-C++学习记录：智能指针std::unique_ptr源码分析/","permalink":"https://zgg2001.github.io/2022/02/25/20220225_C-C++%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88std::unique_ptr%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"抽空扣一点感兴趣的标准库源码，这里总结一下 std::unique_ptr 相关的分析 本文中 gcc version: 8.4.1 20200928 (Red Hat 8.4.1-1) (GCC) libstdc++:libstdc++-8.4.1-1.el8.x86_64 其中c++库安装路径为 /usr/include/c++/8","text":"抽空扣一点感兴趣的标准库源码，这里总结一下 std::unique_ptr 相关的分析 本文中 gcc version: 8.4.1 20200928 (Red Hat 8.4.1-1) (GCC) libstdc++:libstdc++-8.4.1-1.el8.x86_64 其中c++库安装路径为 /usr/include/c++/8 一、前言&emsp;&emsp;在对本篇文章内容的探索之前，我已经是对 std::unique_ptr 有所了解并且尝试实现过，所以本篇分析主要是为了查看标准库里的具体实现和写法，学习一下细节和思路。 &emsp;&emsp;众所周知啊 ，std::unique_ptr 的主要思路就是利用局部变量声明在栈上，会自动释放的特性，在构造函数里绑定指针，在析构函数里释放此指针的内容，从而达到智能指针的效果(自动释放)。这种机制被称为RAII机制，相关类被称为RAII类。 &emsp;&emsp;本篇笔记中会记录我在学习标准库代码时的思路和想法，此次我看的重点是自动释放的流程和相关数据结构的实现。&emsp; 二、源码分析1. 从 class unique_ptr 入手 class unique_ptr 的定义位于 /usr/include/c++/8/bits/unique_ptr.h 中。 &emsp;&emsp;首先可以看到，在这个文件中，存在两个 unique_ptr 类的定义，如下两图： 定义一： 定义二： &emsp;&emsp;根据注释以及部分来看代码，一百多行开始的定义一部分是针对 single objects 的，而四百多行开始的定义二部分是针对 array objects 的。简单来讲就是定义一是针对单个指针对象的，而特化版本定义二是针对存有多个指针的数组对象的。 &emsp;&emsp;另外，可以看到模板中有两个参数，_Tp 和 _Dp。根据之前对 std::unique_ptr的使用来看，第一个参数是指针所指向的类型；然后我简单看了一下源码和注释，第二个参数是删除器，即规定指针释放时的操作。 &emsp;&emsp;在定义一中，删除器被默认指定为 default_delete&lt;_Tp&gt;，在下文中会对其进行分析。而定义二中需要传入两个模板参数，指定类型和删除器，我认为原因是指针对象数组与单个指针对象析构时存在差异，所以需要单独定义删除的方法。 &emsp;&emsp;接着就是在智能指针中，肯定是存在一个成员变量来储存指针的，所以我决定先看一下这部分内容标准库里是怎么实现的。如下图，是 std::unique_ptr 的一个构造函数，其中传入 pointer 类型的 __p 并将其赋值到成员变量 _M_t 中。&emsp;&emsp;首先查看 pointer 的定义，为 using pointer = typename __uniq_ptr_impl&lt;_Tp, _Dp&gt;::pointer;。可以看到一个新的类型 __uniq_ptr_impl 出现了。了解了 pointer 的定义后再看一下成员变量 _M_t，定义如下：&emsp;&emsp;可以看到其类型也为 __uniq_ptr_impl，且模板传参为指针类型与其删除器。由此可以大概了解流程，即 std::unique_ptr 中存在一个 __uniq_ptr_impl 类型的成员变量，其中储存着传入的指针以及其删除器。在传参指针传入后，会将其赋值至成员变量 _M_t 中，并根据传参内容来决定删除器的内容，也储存至 _M_t 中。而接下来，我对这个储存指针的类型 __uniq_ptr_impl 进行了分析和探索。&emsp; 2. 储存类 class __uniq_ptr_impl class __uniq_ptr_impl 的定义位于 /usr/include/c++/8/bits/unique_ptr.h 中。 &emsp;&emsp;由上文可以得知，在 __uniq_ptr_impl 类中，储存着指针和其删除器。在下文中的分析中，我的重点在于储存这两个东西的实现，以及类中有哪些方法来完善其功能。下图为相关定义的位置：&emsp;&emsp;首先在类 __uniq_ptr_impl 中的最前定义了两个结构体，简单来说其作用就是传入类型 a，使用其内部的 type 即可析取出类型 a 的指针a*。其中用到了 remove_reference 结构体，这个在之前的 std::move 源码分析中有讲解，它起到去引用的功能，而在这里使用它即可保证 type 能正确取到不带引用的指针类型。具体实现如下：&emsp;&emsp;然后接下来是对构造函数的声明以及几个定义。首先是删除器的判定类型，可以实现对删除器的正确性的判定。接下来是一个 pointer 类型，就是对上文的 _Ptr 结构体中的 type 类型的使用，来取指针类型。然后是三个构造函数，一个是默认的空参构造，用了 C++11 中的default关键字；一个是仅传指针的构造函数，调用 _M_ptr 进行赋值；最后一个是传入指针和删除器的构造函数，赋值至成员变量 _M_t 中，这里用了 std::forward 来实现完美转发，也就是说这里的删除器可以是个右值。&emsp;&emsp;然后是几个取成员变量内容的方法和一个swap函数。一共是4个取成员变量内容的方法，指针和删除器各两个。两个方法中上面一个是取引用，即可以改变内容的；下面一个是const修饰的，是不可改内容的，应该是只用于查看内容。下面那个swap函数里，即为使用 std::swap 交换 __uniq_ptr_impl 类中的内容，此函数作用于 std::unique_ptr 中的指针所有权转让的情景。&emsp;&emsp;最后就是 __uniq_ptr_impl 类中的成员变量 _M_t，其使用了 C++11 中新增的数据结构 std::tuple 来储存指针和其删除器。所以上文中取其内容是通过 std::get 来取的。 3. 默认删除器 struct default_delete struct default_delete 的定义位于 /usr/include/c++/8/bits/unique_ptr.h 中。 &emsp;&emsp;上文中看了储存类的定义，下面来看一下出现率也很高的删除器。标准库中提供了两个最基础的删除器，来当默认删除器。提供的两个删除器分别为普通对象删除器和特化版的数组对象删除器。当传入参数为一个数组时，就会走下面那个定义。 定义一： 定义二：&emsp;&emsp;下面两个即为这两个删除器定义不同的最关键的地方。可以看到其中都存在 C++11 中的新特性静态断言，来进行合法性判定。而关键语句一个为 delete __ptr(85行)，另一个为 delete[] __ptr(122行)。这即为默认删除器的核心语句，即单个对象通过delete释放，数组对象通过delete[]来释放。这里的实现是通过重载操作符 () 来实现的，算是一种仿函数的写法。 4. 回归 class unique_ptr&emsp;&emsp;通过上面对储存类和删除器的实现分析，已经大概了解了 std::unique 中的大部分封装好的内容。接下来就看一下在 class unique_ptr 中都有些什么东西。(此处仅记录重点内容) &emsp;&emsp;首先是若干种构造函数： 空参构造 带参构造一，参数仅有指针 带参构造二，参数为指针和其删除器 带参构造三，传参为指针和删除器，但是都是右值 带参构造四，传参为一个空指针 带参构造五，传参为一个 std::unique 对象，这里涉及到引用折叠和完美转发，来实现所有权转移的操作 带参构造六，传参为一个 std::unique 对象，相比上文那个更加严谨 &emsp;&emsp;接下来是析构函数，如下图只有一种实现(单对象和数组对象都是这个)。可以看到逻辑很简单就是在析构的时候调用仿函数删除器来进行delete操作。这里的 pointer 是获取空指针用的。&emsp;&emsp;剩下的内容中，大部分都是对操作符 =、*、-&gt;等的重载来方便设定智能指针的内容，以及方便使用其内容。另外还封装了几个函数如下，来获取成员变量 _M_t 中的指针和删除器，上面提到的若干重载也是基于下面这几个函数来实现的。另外还有一些基础的函数，例如清空智能指针用的 release() 或者 reset()，还有交换内容的 swap 函数，这几个就不多说了，因为实现都比较简单。&emsp;&emsp;在定义的最后还有两个被禁止的操作，即对 std::unique_ptr 进行左值赋值操作，从而来保证逻辑的正确执行。&emsp; 三、总结&emsp;&emsp;总而言之，std::unique 的主要思路还是比较简单的。但是在标准库源码中会有很多很细节的操作，所以还是有很大的收获。在源码的最后还有若干对 hash 相关的重载操作，在此文中就不进行记录了。&emsp;&emsp;标准库的代码还是像套娃一样有很多层，前面看着会跳来跳去，但是了解底层以后，上面也就很清晰了。在接下来我应该会去看一下 std::shared_ptr 的实现，相对 std::unique_ptr 其肯定会复杂很多，但是这次搞完以后应该看起来也会轻松一点吧，毕竟思路还是有些相同点的，我的重点应该会放在其内部计数器的实现。","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"C++标准库学习","slug":"C-标准库学习","permalink":"https://zgg2001.github.io/tags/C-%E6%A0%87%E5%87%86%E5%BA%93%E5%AD%A6%E4%B9%A0/"},{"name":"源码阅读","slug":"源码阅读","permalink":"https://zgg2001.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"}]},{"title":"C++20学习记录：modules 和 ＜=＞","slug":"20220124_C++20学习记录：modules和<=>","date":"2022-01-24T12:28:33.000Z","updated":"2022-01-24T12:28:33.000Z","comments":true,"path":"2022/01/24/20220124_C++20学习记录：modules和<=>/","permalink":"https://zgg2001.github.io/2022/01/24/20220124_C++20%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9Amodules%E5%92%8C%3C=%3E/","excerpt":"本篇笔记记录了对于 C++20 新特性中模块和三路比较运算符的一些尝试。 主要参考地址：cppreference","text":"本篇笔记记录了对于 C++20 新特性中模块和三路比较运算符的一些尝试。 主要参考地址：cppreference 一、前言&emsp;&emsp;这次抽空对 C++20 的新特性进行一点尝试，首先目标定为我比较感兴趣的模块部分和一个新的运算符 &lt;=&gt;。 &emsp;&emsp;我的环境上的 gcc 版本为 8.4.1，我查了一下编译器支持，发现这个版本对于 C++20 的好多新特性无法完全支持，所以首先是手动编译安装了一下 11.2.0 的 gcc (真的慢…编了一个多小时)，所以本文使用的测试编译器为 gcc 11.2.0。&emsp;&emsp; 二、模块1. 概念&emsp;&emsp;模块是 C++20 中我个人比较感兴趣的一部分，它的功能为支持代码的模块化，其作用根据设计思路而言主要是显著地提高与宏地隔离并大大优化编译时间，而且它也可以使得代码更加”卫生”。 对于C++传统的头文件系统，主要的问题如下： 不够卫生：一个头文件中的代码可能会影响同一翻译单元中包含的另一个 #include 中的代码的含义，因此 #include 并非顺序无关。宏是这里的一个主要问题，尽管不是唯一的问题。 分离编译的不一致性：两个翻译单元中同一实体的声明可能不一致，但并非所有此类错误都被编译器或链接器捕获。 编译次数过多：从源代码文本编译接口比较慢。从源代码文本反复地编译同一份接口非常慢。 &emsp;&emsp;由此，标准委员会推出了模块这一新特性。这一特性说实话并不算新，现在很火的py和java都是很早就使用上了模块。但是对于C++而言我觉得这一新特性挑战还是很大，因为和以往的风格有很大不同。 对于模块，其关键思想如下： export 指令使实体可以被 import 到另一个模块中。 import 指令使从另一个模块 export 出来的的实体能够被使用。 import 的实体不会被隐式地再 export 出去。 import 不会将实体添加到上下文中，它只会使实体能被使用（因此，未使用的 import 基本上是无开销的）。 2. 代码测试&emsp;&emsp;由此开始记录我的测试过程。首先创建模块文件 test.cpp 和主文件 main.cpp 如下： 123456789101112131415//test.cpp 模块文件export module helloworld;export auto hello()&#123; return &quot;Hello C++ 20!&quot;;&#125;//main.cpp 主文件#include &lt;iostream&gt;import helloworld;int main()&#123; std::cout &lt;&lt; hello() &lt;&lt; std::endl;&#125; &emsp;&emsp;可以看到在 test.cpp 中导出了 helloworld 模块和其中的函数 hello()，并在 main.cpp 中导入了 helloworld 模块。随后尝试进行编译，编译和执行过程如下： 1234567891011121314g++ -std=c++20 -fmodules-ts -c test.cpp #编译模块g++ -std=c++20 -fmodules-ts -c main.cpp #编译主文件g++ -std=c++20 test.o main.o -o App #编译可执行文件需要注意的是:模块必须优先被编译，否则会报错。g++ -std=c++20 -fmodules-ts test.cpp main.cpp -o App #正确g++ -std=c++20 -fmodules-ts main.cpp test.cpp -o App #错误执行:./App输出:Hello C++ 20! &emsp;&emsp;编译完以后，可以看到目录下相比平常的编译，多了一个名叫 gcm.cache 的目录，如下图：&emsp;&emsp;进入其中，发现有一个以模块名命名的 .gcm 格式文件，这个就是编译好的模块文件。&emsp;&emsp;我看 cppreference 上说 C++20 按理是支持导入以往的标准库的，例如 import &lt;iostream&gt;;，但是经过我的测试，gcc 无法实现，查了一下发现 gcc 确实是没有完全支持。 3. 小结&emsp;&emsp;目前来看可能这个新特性并没有被完全的支持，而且其相较以往的头文件格式改变比较大，受限于老代码和稳定性、支持性之类的考量，可能不会被太快的接受。但是它在编译速度上的优势我觉得还是很有前途的，现阶段主要的问题应该是老代码的模块化重构，比如说当前无法导入标准库的主要原因就是标准库还没有重构完成，也许在 C++23 会重构完成吧，到时候可能模块化就会用的更加方便、更容易被人接受。&emsp;&emsp; 三、三路比较运算符1. 概念&emsp;&emsp;简单说就是一个新的运算符，功能是比较左右操作数的大小，格式为 左操作数 &lt;=&gt; 右操作数 。 其逻辑如下： 若 左操作数 &lt; 右操作数 则 (a &lt;=&gt; b) &lt; 0 若 左操作数 &gt; 右操作数 则 (a &lt;=&gt; b) &gt; 0 若 左操作数 和 右操作数 相等&#x2F;等价则 (a &lt;=&gt; b) == 0 &emsp;&emsp;总体而言使用还是挺简单的，一个运算符就可以进行大小的比较。下面是截的一点描述，简单来讲就是这个运算符的返回值是一个被封装了很多层的类型的右值。&emsp;&emsp;简单看一下源码，相关定义位于 /usr/local/include/c++/11.2.0/compare，最底层的枚举值为 小于：-1、等于：0、大于：1。&emsp;&emsp;然后就是各种封装内联对象，可以看到下图的定义和初始化。联系上图可以得知最底层储存类型为 signed char，所以十六进制下的值就是如下图一注释一样，less=0xff...。 2. 代码测试&emsp;&emsp;测试代码如下，使用起来也非常简单，没有什么好说的，但是需要注意比较结果是无法直接 cout 的，原因应该是作用域枚举没有重载 &lt;&lt;。 1234567891011121314151617181920212223242526#include &lt;compare&gt;#include &lt;iostream&gt; int main() &#123; double foo = -0.0; double bar = 0.0; auto res = foo &lt;=&gt; bar; if (res &lt; 0) std::cout &lt;&lt; &quot;-0 小于 0&quot;; else if (res &gt; 0) std::cout &lt;&lt; &quot;-0 大于 0&quot;; else // (res == 0) std::cout &lt;&lt; &quot;-0 与 0 相等&quot;;&#125;编译:g++ -std=c++20 main.cpp -o App执行:./App输出:-0 与 0 相等 3. 小结&emsp;&emsp;这算是一个小更新，但是说实话让 C++ 有了更多的看起来很秀的操作。在实际判断中这个运算符可以省去一些变量名的重复编写，我觉得可以避免一些低级的失误，比如说写错变量名之类的。总之还是挺有意思的一个小更新。","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"}],"tags":[{"name":"C++标准库学习","slug":"C-标准库学习","permalink":"https://zgg2001.github.io/tags/C-%E6%A0%87%E5%87%86%E5%BA%93%E5%AD%A6%E4%B9%A0/"},{"name":"源码阅读","slug":"源码阅读","permalink":"https://zgg2001.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"},{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/tags/C-C/"}]},{"title":"C++17学习记录：新语言功能特性","slug":"20220121_C++17学习记录：新语言功能特性","date":"2022-01-21T12:08:52.000Z","updated":"2022-01-21T12:08:52.000Z","comments":true,"path":"2022/01/21/20220121_C++17学习记录：新语言功能特性/","permalink":"https://zgg2001.github.io/2022/01/21/20220121_C++17%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E6%96%B0%E8%AF%AD%E8%A8%80%E5%8A%9F%E8%83%BD%E7%89%B9%E6%80%A7/","excerpt":"本篇笔记汇总了C++17中的主要新语言功能特性，根据个人理解与查阅的资料进行记录。 主要参考地址：cppreference C++17为继C++11后的第一个大版本更新，东西相较于C++14多了不少，但是基本上都是以往特性的优化与补充，这里简单进行一些主要新特性的记录。","text":"本篇笔记汇总了C++17中的主要新语言功能特性，根据个人理解与查阅的资料进行记录。 主要参考地址：cppreference C++17为继C++11后的第一个大版本更新，东西相较于C++14多了不少，但是基本上都是以往特性的优化与补充，这里简单进行一些主要新特性的记录。 · 折叠表达式&emsp;&emsp;在 C++11 中，其引入了可变参数模板，但是可变参数模板需要挨个递归处理可变参数。这就导致就算以同一种方式处理可变参数，也需要重复的函数递归，写起来很笨重。 &emsp;&emsp;比如下面这个例子，仅仅只需要累加求和，但是却需要写两个模板函数使得递归可行，从而遍历每一个参数，写起来相对麻烦且臃肿。 12345678910111213141516171819template&lt;typename T&gt;T add(T&amp;&amp; num)//基础函数&#123; return num;&#125;template&lt;typename T, typename ... Args&gt;T add(T&amp;&amp; num, Args&amp;&amp;... a)//递归变参函数&#123; return num + add(forward&lt;Args&gt;(a)...);//递归调用&#125;int main()&#123; cout &lt;&lt; add(1, 2, 3, 4, 5) &lt;&lt; endl;&#125;输出:15 &emsp;&emsp;折叠表达式是 C++17 新引进的语法特性。使用折叠表达式可以简化对 C++11 中引入的参数包的处理，从而在某些情况下避免使用递归。 &emsp;&emsp; 折叠表达式共有四种语法形式。分别为一元的左折叠和右折叠，以及二元的左折叠和右折叠。其支持所有二元运算符的简写，这里仅做简单记录，比如说上文中的例子就可以简化为如下写法(二元左折叠)： 1234567891011121314template&lt;typename T, typename ... Args&gt;T add(T&amp;&amp; num, Args&amp;&amp;... args)&#123; return (num + ... + args);&#125;int main()&#123; cout &lt;&lt; add(1, 2, 3, 4, 5) &lt;&lt; endl;&#125;/* g++ test.cpp -o test -std=c++17 */输出:15 &emsp;&emsp;总体而言，折叠表达式为变参模板写法提供了更多的可能性，可以在不影响原功能和代码可读性的前提下实现简化。 &emsp;&emsp; · 类模板实参推导&emsp;&emsp;简单来说，就是在实例化类模板时，可以自动推出模板参数而不需指定。具体限制为：如果构造函数能够推导出所有模板参数，则可以跳过显式定义模板参数。 &emsp;&emsp;下面是几个简单但方便的例子： 123456789101112int main()&#123; std::pair&lt;int, double&gt; p1(2, 4.5); //ok std::pair p2(2, 4.5); //-std=c++17 ok std::vector&lt;int&gt; v1 = &#123;1&#125;; //ok std::vector v2 = &#123;1&#125;; //-std=c++17 ok std::mutex mx; std::lock_guard&lt;std::mutex&gt; lock1(mx); //ok std::lock_guard lock2(mx); //-std=c++17 ok&#125; &emsp;&emsp;这东西怎么说，我感觉虽然方便但是并不是所有都适合这么搞。因为很容易分不清类型让代码可读性降低，所以我感觉像 pair、tuple、lock_guard这种临时变量用一下还好(因为其中的模板参数往往已经规定，省略一下可读性影响也不大)，如果有作用域比较广的变量最好就不要用了，因为很可能需要费神来思考它的模板参数。 &emsp;&emsp; · auto 占位的非类型模板形参&emsp;&emsp;从 C++17 开始，可以使用 auto 来声明一个非类型模板参数。 1234567template&lt;auto N&gt; class S &#123;...&#125;;S&lt;42&gt; s1; // OK: type of N in S is intS&lt;&#x27;a&#x27;&gt; s2; // OK: type of N in S is char &emsp;&emsp;如果非类型模板形参的类型包含占位符类型 auto，被推导类型的占位符 (C++20 起)，或 decltype(auto)，那么它可以被推导。推导会如同在虚设的声明 T x = 模板实参; 中推导变量 x 的类型一样进行，其中 T 是模板形参的声明类型。如果被推导的类型不能用于非类型模板形参，那么程序非良构。 123456template&lt;auto n&gt;struct B &#123; /* ... */ &#125;; B&lt;5&gt; b1; // OK：非类型模板形参的类型是 intB&lt;&#x27;a&#x27;&gt; b2; // OK：非类型模板形参的类型是 charB&lt;2.5&gt; b3; // 错误（C++20 前）：非类型模板形参的类型不能是 double &emsp;&emsp;对于类型中使用了占位符类型的非类型模板形参包，每个模板实参的类型会独立进行推导，而且不需要互相匹配： 1234template&lt;auto...&gt;struct C &#123;&#125;; C&lt;&#x27;C&#x27;, 0, 2L, nullptr&gt; x; // OK &emsp;&emsp; · 编译期的 constexpr if 语句&emsp;&emsp;constexpr if 是 C++17 中新特性，可以实现在编译期的条件判断。&emsp;&emsp;这个东西主要是为了实现泛型编译期处理中的条件判定，可以实现根据 constexpr if 来编译合适的代码段，从而可以在编译期干一部分模板类型判断相关的事情，提高代码的执行效率。 123456789101112131415161718192021222324252627template &lt;typename T&gt;void bar(T t) &#123; if constexpr (has_foo_v&lt;T&gt;) &#123; t.foo(); std::puts(&quot;yes&quot;); &#125; else &#123; std::puts(&quot;no&quot;); &#125;&#125;等价于:template &lt;typename T, typename=std::enable_if_t&lt;has_foo_v&lt;T&gt;&gt;&gt;void bar(T t) &#123; t.foo(); std::puts(&quot;yes&quot;);&#125;void bar(...) &#123; std::puts(&quot;no&quot;);&#125; &emsp;&emsp; · inline 变量&emsp;&emsp;在 C++17 后，可以给变量加上 inline 标签从而使其成为内联变量。其核心目的就是为了可以在头文件中定义一个全局可用的对象。 1234567class MyClass&#123; static inline std::string name = &quot;&quot;; // OK since C++17 ...&#125;; inline MyClass myGlobalObj; // OK even if included/defined by multiple CPP files &emsp;&emsp;另外声明为 constexpr 的静态成员变量(但不是命名空间作用域变量)是隐式的内联变量，即以下二者等价。 123456789struct D&#123; static constexpr int n = 5; // C++11/C++14: //声明但未定义 // since C++17: 定义&#125;;struct D&#123; inline static constexpr int n = 5;&#125;; 想深入了解可以看一下这位大佬的文章: 点我跳转 &emsp;&emsp; · 结构化绑定&emsp;&emsp;在我的理解中，这个新特性就是可以对含有多个元素的对象进行一个映射，即绑定指定名称到初始化器的子对象或元素。可能有点类似引用，但不同于引用的是，结构化绑定的类型不必为引用类型。 &emsp;&emsp;第一个用法，绑定数组： 1234int a[2] = &#123;1,2&#125;; auto [x,y] = a; // 创建 e[2]，复制 a 到 e，然后 x 指代 e[0]，y 指代 e[1]auto&amp; [xr, yr] = a; // xr 指代 a[0]，yr 指代 a[1] &emsp;&emsp;第二个用法，绑定元组式类型： 123456789float x&#123;&#125;;char y&#123;&#125;;int z&#123;&#125;; std::tuple&lt;float&amp;,char&amp;&amp;,int&gt; tpl(x,std::move(y),z);const auto&amp; [a,b,c] = tpl;// a 指名指代 x 的结构化绑定；decltype(a) 为 float&amp;// b 指名指代 y 的结构化绑定；decltype(b) 为 char&amp;&amp;// c 指名指代 tpl 的第 3 元素的结构化绑定；decltype(c) 为 const int &emsp;&emsp;第三个用法，绑定到数据成员： 12345678struct S &#123; mutable int x1 : 2; volatile double y1;&#125;;S f(); const auto [x, y] = f(); // x 是标识 2 位位域的 int 左值 // y 是 const volatile double 左值 &emsp;&emsp;我感觉，这个新特性的绑定元组部分还是挺有用的，包括接收返回值和范围for的取值等场景用起来都很方便和优雅。比如说下面这个例子，就可以省去取值的部分。 12345678int main()&#123; vector&lt;pair&lt;int, int&gt;&gt; a&#123;&#123;1, 2&#125;, &#123;3, 4&#125;&#125;; for(auto&amp; [x, y] : a) &#123; cout &lt;&lt; x &lt;&lt; y &lt;&lt; endl; &#125;&#125; &emsp;&emsp; · if 和 switch 语句中的初始化器&emsp;&emsp;简单来说就是在 if 和 switch 语句中也可以初始化变量了，类似于在 for 循环里声明新的变量。但是我感觉在 if/switch 中初始化变量的需求应该是不会太大，产生需求的主要场景应该是为了控制变量的作用域。 1234567891011121314151617181920212223242526272829303132333435int main()&#123; int s = 1; if(int a = 0; a == s) //A部分 &#123; cout &lt;&lt; a &lt;&lt; endl; &#125; else if(int b = 1; b == s) //B部分 &#123; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; &#125; else //C部分 &#123; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; 222 &lt;&lt; endl; &#125; switch(int c = 2; c) &#123; case 1: case 2: cout &lt;&lt; c &lt;&lt; endl; break; default: cout &lt;&lt; 333 &lt;&lt; endl; break; &#125;&#125;输出:012 &emsp;&emsp;如上为在 if/switch 语句中初始化变量。其中在 if 语句部分中，变量 a 的作用域为 A&#x2F;B&#x2F;C，变量 b 的作用域为 B&#x2F;C。而在 switch 语句部分中，变量 c 的作用域为整个 switch。 &emsp;&emsp;总体而言这个新特性通过在代码块中添加大括号也可以等价实现，但是看上去可能没那么优雅，所以还是有其独特的优点的。 &emsp;&emsp; · u8-char&emsp;&emsp;就是一个新的字符字面量，UTF-8字符字面量(每个字符大小为1字节)，格式如下，个人感觉没什么好说的。 12345u8&#x27;c字符&#x27;例:char c = u8&#x27;a&#x27;; //sizeof(c) = 1constexpr char str[] = u8&quot;123456&quot; &emsp;&emsp; · 命名空间相关&emsp;&emsp;简化嵌套命名空间定义： namespace A::B::C &#123; ... &#125; 等价于 namespace A &#123; namespace B &#123; namespace C &#123; ... &#125; &#125; &#125;。&emsp;&emsp;using 声明多个名称： 拥有多于一个 using 声明符的 using 声明，等价于对应的单个 using 声明符的 using 声明的序列，人话讲就是可以用逗号连接多个 using 声明。cppreference上的例子如下： 12345678910111213141516void f();namespace A &#123; void g();&#125; namespace X &#123; using ::f; // 全局 f 现在作为 ::X::f 可见 using A::g; // A::g 现在作为 ::X::g 可见 using A::g, ::f; // (C++17) OK：命名空间作用域允许双重声明&#125; void h()&#123; X::f(); // 调用 ::f X::g(); // 调用 A::g&#125; &emsp;&emsp;但是经过我自己的测试，C++17 我只发现新增了 using 双重定义相关的内容，其余的使用 C++11 标准也可以编译通过。 &emsp;&emsp; · 将 noexcept 作为类型系统的一部分&emsp;&emsp;在c++ 17异常处理规范成为函数类型的一部分。也就是说，下面两个函数现在有两种不同的类型: 12void f1();void f2() noexcept; // different type &emsp;&emsp;在c++ 17之前，这两个函数都具有相同的类型。&emsp;&emsp;因此，编译器现在将检测如果你使用一个函数抛出异常，而一个函数不抛出任何异常的情况: 123void (*fp)() noexcept; // pointer to function that doesn’t throwfp = f2; // OKfp = f1; // ERROR since C++17 &emsp;&emsp;当然，在允许抛出函数的地方使用不抛出的函数仍然是有效的: 123void (*fp2)(); // pointer to function that might throwfp2 = f2; // OKfp2 = f1; // OK &emsp;&emsp;因此，这个新特性不会破坏那些还没有使用noexcept函数指针的程序，但是现在可以确保您不再违反函数指针中的noexcept规范。想深入了解可以看一下这位大佬的文章: 点我跳转 &emsp;&emsp; · 新的求值顺序规则&emsp;&emsp;具体目的和影响可以看一下 StackOverflow 上的这个问题：点我跳转 具体新增的顺序规则如下：(摘自cppreference) 函数调用表达式中，指名函数的表达式按顺序早于每个参数表达式和每个默认实参。 函数调用表达式中，每个形参的初始化的值计算和副作用相对于任何其他形参的初始化的值计算和副作用是顺序不确定的。 用运算符写法进行调用时，每个重载的运算符均遵循其所重载的内建运算符的定序规则。 下标表达式 E1[E2] 中，E1 的每个值计算和副作用均按顺序早于 E2 的每个值计算和副作用。 成员指针表达式 E1.*E2 或 E1-&gt;*E2 中，E1 的每个值计算和副作用都按顺序早于 E2 的每个值计算和副作用（除非 E1 的动态类型不含 E2 所指的成员）。 移位运算符表达式 E1&lt;&lt;E2 和 E1&gt;&gt;E2 中，E1 的每个值计算和副作用都按顺序早于 E2 的每个值计算和副作用。 每个简单赋值表达式 E1&#x3D;E2 和每个复合赋值表达式 E1@&#x3D;E2 中，E2 的每个值计算和副作用均按顺序早于 E1 的每个值计算和副作用。 带括号的初始化器中的逗号分隔的表达式列表中的每个表达式，如同函数调用一般求值（顺序不确定）。 &emsp;&emsp; · 强制的复制消除&emsp;&emsp;简单来讲就是在对象的初始化中，当初始化器表达式是一个与变量类型相同的类类型的纯右值（忽略 cv 限定）时，T x = T(T(f())); //仅调用一次 T 的默认构造函数以初始化 x。比如下面这个例子，关掉g++默认的省略优化后，使用不同的标准编译，可以看出以C++17标准编译的话会进行一次复制消除（返回值优化），优化的位置是 main 函数里的无名临时量。 在对象的初始化中，当源对象是无名临时量且与目标对象具有相同类型（忽略 cv 限定）时。当无名临时量为 return 语句的操作数时，称这种复制消除的变体为 RVO，”返回值优化 (return value optimization)”。1234567891011121314151617181920212223242526272829303132333435363738394041424344class test&#123;public: test() &#123; cout &lt;&lt; &quot;constructor&quot; &lt;&lt; endl; &#125; ~test() &#123; cout &lt;&lt; &quot;destructor&quot; &lt;&lt; endl; &#125; test(const test&amp; other) &#123; cout &lt;&lt; &quot;copy constructor&quot; &lt;&lt; endl; &#125;&#125;;test Foo()&#123; test obj; return obj;&#125;int main()&#123; test obj = Foo();&#125;编译:g++ -g -fno-elide-constructors -Wall t.cpp -o t -std=c++11输出:constructorcopy constructordestructorcopy constructordestructordestructor编译:g++ -g -fno-elide-constructors -Wall t.cpp -o t -std=c++17输出:constructorcopy constructordestructordestructor &emsp;&emsp;想深入了解可以看一下这位大佬的文章: 点我跳转 &emsp;&emsp; · lambda 表达式捕获 *this&emsp;&emsp;lambda中可以捕获 *this 辣，可以通过捕获 *this 来将整个当前对象复制一遍。而之前只能捕获 this，即以引用捕获当前对象。我感觉新增这种捕获方式的一个应用场景就是可以避免悬垂引用问题。&emsp;&emsp; · constexpr 的 lambda 表达式&emsp;&emsp;lambda表达式的格式为：[ 捕获 ] ( 形参 ) lambda说明符 约束(可选) &#123; 函数体 &#125;，而在 C++17 中其说明符部分新增了一位成员 constexpr。 constexpr：显式指定函数调用运算符或运算符模板的任意特化为 constexpr 函数。如果没有此说明符但函数调用运算符或任意给定的运算符模板特化恰好满足针对 constexpr 函数的所有要求，那么它也会是 constexpr 的。 &emsp;&emsp; · 属性命名空间不必重复&emsp;&emsp;简单来说就是简化下面这种情况: 12345678910111213简化前:void f() &#123; [[rpr::kernel, rpr::target(cpu,gpu)]] // 重复 doTask();&#125;简化后:void f() &#123; [[using rpr: kernel, target(cpu,gpu)]] doTask();&#125; &emsp;&emsp; · 新属性 [[fallthrough]] [[nodiscard]] 和 [[maybe_unused]] [[fallthrough]](C++17)：指示从前一 case 标号直落是有意的，而在发生直落时给出警告的编译器不应该为此诊断。 [[nodiscard]](C++17)：鼓励编译器在返回值被舍弃时发布警告。**(印象里这个比较常用)** [[maybe_unused]](C++17)：压制编译器在未使用实体上的警告，若存在。 &emsp;&emsp; · __has_include&emsp;&emsp;即一种新的源文件包含语法，其作用为检查一个头或源文件是否可以被包含。cppreference上的例子如下，我感觉适配不同版本头文件时可能有用吧。 1234567891011121314151617181920#if __has_include(&lt;optional&gt;)# include &lt;optional&gt;# define has_optional 1 template&lt;class T&gt; using optional_t = std::optional&lt;T&gt;;#elif __has_include(&lt;experimental/optional&gt;)# include &lt;experimental/optional&gt;# define has_optional -1 template&lt;class T&gt; using optional_t = std::experimental::optional&lt;T&gt;;#else# define has_optional 0# include &lt;utility&gt;template&lt;class V&gt; class optional_t &#123; V v_&#123;&#125;; bool has_&#123;false&#125;; public: optional_t() = default; optional_t(V&amp;&amp; v) : v_(v), has_&#123;true&#125; &#123;&#125; V value_or(V&amp;&amp; alt) const&amp; &#123; return has_ ? v_ : alt; &#125; /*...*/&#125;;#endif &emsp;&emsp;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"}],"tags":[{"name":"C++标准库学习","slug":"C-标准库学习","permalink":"https://zgg2001.github.io/tags/C-%E6%A0%87%E5%87%86%E5%BA%93%E5%AD%A6%E4%B9%A0/"},{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/tags/C-C/"}]},{"title":"C++14学习记录：新语言功能特性","slug":"20211208_C++14学习记录：新语言功能特性","date":"2021-12-08T15:44:20.000Z","updated":"2021-12-08T15:44:20.000Z","comments":true,"path":"2021/12/08/20211208_C++14学习记录：新语言功能特性/","permalink":"https://zgg2001.github.io/2021/12/08/20211208_C++14%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E6%96%B0%E8%AF%AD%E8%A8%80%E5%8A%9F%E8%83%BD%E7%89%B9%E6%80%A7/","excerpt":"本篇笔记汇总了C++14中的主要新语言功能特性，根据个人理解与查阅的资料进行记录。 主要参考地址：cppreference C++14主要是在C++11标准之上的一些补充，所以相对的内容较少一些。","text":"本篇笔记汇总了C++14中的主要新语言功能特性，根据个人理解与查阅的资料进行记录。 主要参考地址：cppreference C++14主要是在C++11标准之上的一些补充，所以相对的内容较少一些。 · 变量模板&emsp;&emsp;在之前的版本中，模板均为函数模板或者类模板，而从C++14起，变量也可以使用模板了。变量模板的语法为 template &lt; 形参列表 &gt; 变量声明，通常模板的规则都适用于变量模板，比如说特化什么的。下面是几个例子： 1234567891011121314151617181920template&lt;class T&gt;constexpr T pi = T(3.1415926535897932385L);// 变量模板 template&lt;class T&gt;T circular_area(T r)//函数模板&#123; return pi&lt;T&gt; * r * r; //pi&lt;T&gt; 是变量模板实例化&#125;int main()&#123; double a = 3; cout &lt;&lt; circular_area(a) &lt;&lt; endl; cout &lt;&lt; circular_area&lt;double&gt;(2) &lt;&lt; endl; return 0;&#125;输出:28.274312.5664 &emsp;&emsp;与其他静态成员一样，静态数据成员模板的需要一个定义。这种定义可以在类定义外提供。处于命名空间作用域的静态数据成员的模板声明也可以是类模板的非模板数据成员的定义： 123456789101112131415struct limits &#123; template&lt;typename T&gt; static const T min;//静态数据成员模板的声明&#125;;template&lt;typename T&gt;const T limits::min = &#123; &#125;;//静态数据成员模板的定义 template&lt;class T&gt;class X &#123; static T s;//类模板的非模板静态数据成员的声明&#125;;template&lt;class T&gt;T X&lt;T&gt;::s = 0;//类模板的非模板静态数据成员的定义 &emsp;&emsp;在C++14引入变量模板前，参数化变量通常实现为类模板的静态数据成员，或返回所需值的 constexpr 函数模板，这点在STL源码里可以经常看见。但是说实话可能变量模板这个新特性比较新或者说非他不可的场景比较少，暂时我还没有用到过或者说在源码里见到过这个东西。 &emsp; · 泛型 lambda&emsp;&emsp;在C++11中，lambda 表达式的形参需要被声明为具体的类型。而在C++14中其放宽了这一要求，这就使得 lambda 表达式的形参声明中可以使用类型说明符 auto，从而达成泛型lambda的目的。 12345678910111213141516int main()&#123; auto lambda = [](auto x, auto y) &#123; return x + y; &#125;; cout &lt;&lt; lambda(1.1, 2) &lt;&lt; endl; cout &lt;&lt; lambda(1, 2) &lt;&lt; endl; cout &lt;&lt; lambda(&#x27;a&#x27;, &#x27;b&#x27;) &lt;&lt; endl; return 0;&#125;输出:3.13195 &emsp;&emsp;泛型 lambda 表达式遵循模板参数推导的规则。上面这段代码中的泛型 lambda 表达式的作用与下面的代码相同: 123456789struct unnamed_lambda&#123; template&lt;typename T, typename U&gt; auto operator()(T x, U y) const &#123; return x + y; &#125;&#125;;auto lambda = unnamed_lambda(); &emsp;&emsp;这东西我感觉使用起来还是挺方便的，毕竟某些场景泛型 lambda 会节省很多功夫。不过就我而言需求也没那么强，因为我个人用到 lambda 的场景一般对于 lambda 的传参都已经有明确的定义了，这时就没什么泛型编程的需求。 &emsp; · lambda 初始化捕获&emsp;&emsp;C++11的 lambda 表达式通过值拷贝和引用来捕获在外层作用域声明的变量。这就意味着 lambda 的值成员不可以是 move-only 类型，比如说智能指针 std::unique_ptr，它就是个仅移动的类型。而在C++14中，lambda 表达式放开限制，允许对被捕获的成员用任意的表达式初始化。 &emsp;&emsp;这样放开限制的第一个好处就是可以通过 std::move 来初始化捕获一个 move-only 类型的变量，如下例： 1234567891011121314151617181920int main()&#123; unique_ptr&lt;int&gt;p1 = make_unique&lt;int&gt;(10); cout &lt;&lt; &quot;1. main() p1:&quot; &lt;&lt; *p1 &lt;&lt; endl; auto lambda = [p1 = move(p1)]()//此处的第一个p1声明了新的变量，而第二个p1则表示在lambda之外声明的变量 &#123; cout &lt;&lt; &quot;2. lambda() p1:&quot; &lt;&lt; *p1 &lt;&lt; endl; &#125;; lambda(); if(!p1) &#123; cout &lt;&lt; &quot;3. main() p1 is empty&quot; &lt;&lt; endl; &#125; return 0;&#125;输出:1. main() p1:102. lambda() p1:103. main() p1 is empty &emsp;&emsp;而第二个好处就是可以任意声明 lambda 的值成员，而不需要外层作用域有一个具有相应名字的变量，如下例： 123456789101112int main()&#123; auto lambda = [a = 12345]() &#123; cout &lt;&lt; &quot;lambda() a:&quot; &lt;&lt; a &lt;&lt; endl; &#125;; lambda(); return 0;&#125;输出:lambda() a:12345 &emsp;&emsp;这个新特性我觉得挺有用的，让 lambda 更加的灵活和方便，虽然我还没用过。但是有一点需要注意，声明 lambda 的时候会直接执行里面的捕获语句，所以被捕获的 move-only 类型变量会直接失效…比如下面这个，即使不执行 lambda 函数也会失效。 12345678910111213141516171819int main()&#123; unique_ptr&lt;int&gt;p1 = make_unique&lt;int&gt;(10); cout &lt;&lt; &quot;1. main() p1:&quot; &lt;&lt; *p1 &lt;&lt; endl; auto lambda = [p1 = move(p1)]()//此处的第一个p1声明了新的变量，而第二个p1则表示在lambda之外声明的变量 &#123; ┊ cout &lt;&lt; &quot;2. lambda() p1:&quot; &lt;&lt; *p1 &lt;&lt; endl; &#125;; //lambda(); if(!p1) &#123; ┊ cout &lt;&lt; &quot;3. main() p1 is empty&quot; &lt;&lt; endl; &#125; return 0;&#125;输出:1. main() p1:103. main() p1 is empty &emsp; · new&#x2F;delete 消除&emsp;&emsp;贴一个stackoverflow上的相关回答(渣翻)： 点我跳转 问：&emsp;&emsp;鉴于 make_unique 和 make_shared 的可用性，以及 unique_ptr 和 shared_ptr 的自动析构函数，在C++14中使用 new 和 delete 的情况是什么(除了支持遗留代码)？ 答：&emsp;&emsp;虽然在许多情况下智能指针比原始指针更可取，但 new/delete 在 C++14 中仍然有很多用例。&emsp;&emsp;如果您需要编写任何需要就地构建的内容，例如:&emsp;&emsp;&emsp;1.一个内存池&emsp;&emsp;&emsp;2.一个分配器&emsp;&emsp;&emsp;3.标记变体&emsp;&emsp;&emsp;4.到缓冲区的二进制消息&emsp;&emsp;您将需要使用 new 和 delete。&emsp;&emsp;以及对于一些需要编写的容器，您可能希望使用原始指针进行存储。&emsp;&emsp;即使对于标准的智能指针，如果您想使用自定义删除器，您仍然需要 new，因为 make_unique 和 make_shared 不允许这样做。&emsp; · constexpr 函数上放松的限制&emsp;&emsp;C++11引入了声明为 constexpr 的函数的概念。声明为 constexpr 函数的意义是：如果其参数均为合适的编译期常量，则对这个 constexpr 函数的调用就可用于期望常量表达式的场合(如模板的非类型参数，或枚举常量的值)。如果参数的值在运行期才能确定，或者虽然参数的值是编译期常量，但不符合这个函数的要求，则对这个函数调用的求值只能在运行期进行。然而C++11要求 constexpr 函数只含有一个将被返回的表达式(也可以还含有 static_assert 声明等其它语句，但允许的语句类型很少)。 &emsp;&emsp;在C++14中将放松这些限制，但 goto 仍然不允许在 constexpr 函数中出现，其中可以含有以下内容： 任何声明，除了：1.static 或 thread_local 变量。2.没有初始化的变量声明。 条件分支语句 if 和 switch。 所有的循环语句，包括基于范围的for循环。 表达式可以改变一个对象的值，只需该对象的生命期在声明为 constexpr 的函数内部开始。包括对有 constexpr 声明的任何非 const 非静态成员函数的调用。 &emsp;&emsp;此外，C++11指出，所有被声明为 constexpr 的非静态成员函数也隐含声明为 const(即函数不能修改*this的值)。这点已经被删除，非静态成员函数可以为非 const。 &emsp;&emsp;怎么说呢，这东西在标准库里挺常见的，因为标准库要进行泛型编程，用模板和 constexpr 关键字的频率很高。但是在我个人的编程中，感觉用 constexpr 修饰的函数比较少吧…所以还没咋用过这种复杂点的 constexpr 函数。 &emsp; · 二进制字面量&emsp;&emsp;C++14的数字可以使用二进制形式指定，其格式使用前缀 0b 或 0B，类似之前的十六进制前缀 0x。没啥好说的。 1234567891011int main()&#123; int x = 0x666; int y = 0b101; cout &lt;&lt; x &lt;&lt; endl &lt;&lt; y &lt;&lt; endl; return 0;&#125;输出:16385 &emsp; · 数位分隔符&emsp;&emsp;C++14引入单引号 &#39; 作为数字分位符号，使得数值型的字面量可以具有更好的可读性。 &emsp;&emsp;Ada、D语言、Java、Perl、Ruby等程序设计语言使用下划线 _ 作为数字分位符号，C++之所以不和它们保持一致，是因为下划线已被用在用户自定义字面量的语法中。 12345678910111213141516int main()&#123; auto integer_literal = 100&#x27;0000; auto floating_point_literal = 1.797&#x27;693&#x27;134&#x27;862&#x27;315&#x27;7E+308; auto binary_literal = 0b0100&#x27;1100&#x27;0110; auto silly_example = 1&#x27;0&#x27;0&#x27;000&#x27;00; cout &lt;&lt; integer_literal &lt;&lt; endl &lt;&lt; floating_point_literal &lt;&lt; endl; cout &lt;&lt; binary_literal &lt;&lt; endl &lt;&lt; silly_example &lt;&lt; endl; return 0;&#125;输出:10000001.79769e+308122210000000 &emsp;&emsp;这东西我觉得挺有用的，由上面的例子可以看出来这个 &#39; 是随意加的，编译器会忽略它，所以可以按自己的喜好或者约定来添加分隔符。 &emsp; · 函数的返回类型推导&emsp;&emsp;C++11允许 lambda 表达式根据 return 语句的表达式类型推断返回类型。C++14为一般的函数也提供了这个能力，此外C++14还拓展了原有的规则，使得函数体并不是 &#123;return expression;&#125; 形式的函数也可以使用返回类型推导。 &emsp;&emsp;为了启用返回类型推导，函数声明必须将 auto 作为返回类型，但没有C++11的后置返回类型说明符： 1auto DeduceReturnType(); //返回类型由编译器推断 &emsp;&emsp;如果函数实现中含有多个 return 语句，这些表达式必须可以推断为相同的类型。使用返回类型推导的函数可以前向声明，但在定义之前不可以使用。它们的定义在使用它们的翻译单元(translation unit)之中必须是可用的。这样的函数中可以存在递归，但递归调用必须在函数定义中的至少一个 return 语句之后： 123456789101112131415auto Correct(int i) &#123; if (i == 1) return i;//返回类型被推断为int else return Correct(i-1)+i;//正确，可以调用&#125;auto Wrong(int i)&#123; if(i != 1) return Wrong(i-1)+i;//不能调用，之前没有return语句 else return i;//返回类型被推断为int&#125; &emsp;&emsp;这是我个人认为此次更新最有用的一个内容了，auto 返回值可以节省很多功夫。不过坏处就是不太明了，类型比较复杂的时候可读性比较差，但是我觉得一般的小场景用用还是很舒服的。 &emsp; · 带默认成员初始化器的聚合类。&emsp;&emsp;C++11新增 member initializer，这是一个表达式，被应用到类作用域的成员上，如果构造函数没有初始化这个成员。聚合体的定义被改为明确排除任何含有 member initializer 的类，因此，他们不允许使用聚合初始化。 &emsp;&emsp;C++14将放松这一限制，这种类型也允许聚合初始化。如果花括号初始化列表不提供该参数的值，member initializer 会初始化它。&emsp;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"}],"tags":[{"name":"C++标准库学习","slug":"C-标准库学习","permalink":"https://zgg2001.github.io/tags/C-%E6%A0%87%E5%87%86%E5%BA%93%E5%AD%A6%E4%B9%A0/"},{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/tags/C-C/"}]},{"title":"C++11学习记录：核心语言功能特性","slug":"20211202_C++11学习记录：核心语言功能特性","date":"2021-12-01T16:00:02.000Z","updated":"2021-12-01T16:00:02.000Z","comments":true,"path":"2021/12/02/20211202_C++11学习记录：核心语言功能特性/","permalink":"https://zgg2001.github.io/2021/12/02/20211202_C++11%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E6%A0%B8%E5%BF%83%E8%AF%AD%E8%A8%80%E5%8A%9F%E8%83%BD%E7%89%B9%E6%80%A7/","excerpt":"本篇笔记汇总了C++11中的主要新语言功能，根据个人理解与查阅的资料进行记录。 主要参考地址：cppreference","text":"本篇笔记汇总了C++11中的主要新语言功能，根据个人理解与查阅的资料进行记录。 主要参考地址：cppreference · 模板优化1. 对右尖括号的优化&emsp;&emsp; 简单来讲，就是在C++11以前，当在模板使用中出现双右尖括号的时候，编译器会解析为右移符号 &gt;&gt;。这就导致模板嵌套写起来不太方便，右括号之间需要用空格来空开。 1234//此句在C++11前是错误的，因为 &gt;&gt; 会解释为右移符号vector&lt;vector&lt;int&gt;&gt; test;//在C++11前，一般都加个空格给空开vector&lt; vector&lt;int&gt; &gt; test; &emsp;&emsp;在C++11中其改进了编译器的解析规则，尽可能多的将多个右尖括号 &gt; 解析成模板参数结束符，从而方便代码编写。 2. 默认模板参数&emsp;&emsp;在C++11中，模板参数支持设定默认值。当未设定模板类型时，编译器首先会根据传参进行类型推导，当推导失败时，就会使用模板参数的默认值（默认值没有的话就会报错）。 1234567891011121314151617template &lt;typename T = long, typename U = int&gt;void test(T t = &#x27;a&#x27;, U u = &#x27;b&#x27;)&#123; cout &lt;&lt; t &lt;&lt; &quot; - &quot; &lt;&lt; u &lt;&lt; endl;&#125;//test&lt;char, char&gt;test(&#x27;a&#x27;, &#x27;b&#x27;); //a - b//test&lt;int, char&gt;test&lt;int&gt;(&#x27;a&#x27;, &#x27;b&#x27;); //97 - b//test&lt;char, char&gt;test&lt;char&gt;(&#x27;a&#x27;, &#x27;b&#x27;); //a - b//test&lt;int, char&gt;test&lt;int, char&gt;(&#x27;a&#x27;, &#x27;b&#x27;); //97 - b//test&lt;char, int&gt;test&lt;char, int&gt;(&#x27;a&#x27;, &#x27;b&#x27;); //a - 98//test&lt;long, int&gt; 无法推导test(); //97 - 98 &emsp; · auto 与 decltype1. auto&emsp;&emsp;C++11中，出现了一个非常有用的关键字 auto，即占位类型说明符，它可以自动推导出占位处的类型。在C++11中，其只能服务于变量；在C++14中，其可以服务于函数返回值；在C++17中，它可以服务于非模板形参 template&lt;auto I&gt; struct A;；在C++20中，其也可以服务于函数形参 void f(auto);。下面单就C++11中的 auto 用法(变量)进行一定的总结。 &emsp;&emsp;首先，其基本用法为 auto x = expr;，此时编译器会从初始化器推导类型，具体规则参考模板实参推导的规则。所以在使用 auto 的时候，必须要指定初始化内容，这样才可以正确的推导出类型进行初始化。 1234auto a = 3.14; //doubleauto b = 520; //intauto c = &#x27;a&#x27;; //charauto d; //error未初始化 &emsp;&emsp;由于推导规则与模板实参推导规则一致，所以cv关键字的保留情况相同： 当变量不是指针或者引用类型时，推导的结果中不会保留 const、 volatile 关键字。 当变量是指针或者引用类型时，推导的结果中会保留 const、 volatile 关键字。 1234567891011int temp = 222;auto* a = &amp;temp; //auto = int -&gt; a : int*auto b = &amp;temp; //auto = int* -&gt; b : int*auto&amp; c = temp; //auto = int -&gt; c : int&amp;auto d = temp; //auto = int -&gt; d : intconst auto e = temp; //auto = int -&gt; e : const intauto f = e; //auto = int -&gt; f : int (忽略const)const auto&amp; g = temp; //auto = int -&gt; g : const int&amp;auto&amp; h = g; //auto = const int -&gt; h : const int&amp;auto* i = &amp;e; //auto = const int -&gt; i : const int* &emsp;&emsp;另外在C++11中，auto 不允许使用的场景主要有四个： 不能作为函数参数，因为函数调用时才会传实参，auto 使用要求必须要给修饰的变量赋值，二者矛盾。 不能用于类的非静态成员变量初始化。原因和上一条一样，因为类的非静态成员变量在没创建对象的时候也是未定义的。 不能使用 auto 关键字定义数组。int array[] = &#123;...&#125; 后，auto a = array 是被允许的，a 被推导为 int* 类型；而 auto b[] = array 是非法的，因为 auto 无法定义数组。 无法使用 auto 推导函数模板。Test&lt;double&gt; t; 后，Test&lt;auto&gt; t1 = t 是不被允许的，因为 auto 不算是一个类型，是没办法传进去的。 2. decltype&emsp;&emsp;即 declare type 的缩写。其作用也是推导类型，其推导和 auto 一样都是在编译期完成的。语法为 decltype(表达式)，其仅用于表达式类型的推导，不会理会表达式的值。但是有一点，auto 只能推导已初始化的变量类型，而 decltype 的可以推导比较复杂的表达式。 123int a = 10;decltype(a) b = 20; //b : int decltype(a * 2 + 3.14) c = 13.14; //c : double &emsp;&emsp;decltype 的主要规则如下，简单来说就是当表达式为纯右值时推导出来会剔除cv修饰(因为纯右值不能被cv修饰)，其余都会都会保存cv修饰。 如果 表达式 的值类别是亡值，将会 decltype 产生 T&amp;&amp;。 如果 表达式 的值类别是左值，或者被括号 () 包围，将会 decltype 产生 T&amp;。 如果 表达式 的值类别是纯右值，将会 decltype 产生 T。 &emsp; · 预置与弃置的函数1. 预置&emsp;&emsp;语法为 函数 = default;。通过将函数体定义为 default 来显式预置函数定义。 &emsp;&emsp;在声明类或者结构体的时候，如果未创建构造参数，则编译器会自动帮你创建一个空参空函数体的默认构造函数。例子如下： 123456789101112131415class Test&#123; int x; int y;&#125;;Test t();//可以编译编译器生成默认构造函数的Test类:class Test&#123; Test() &#123;&#125; int x; int y;&#125;;所以上面才可以调用空参构造 &emsp;&emsp;但是，一旦添加了其他有参数的构造函数，编译器就不再生成缺省的构造函数了。而在C++11中，其允许我们使用 = default 来要求编译器生成一个默认构造函数：Test() = default，这样就可以在使用其余带参构造函数时也能使用默认构造函数了。 2. 弃置&emsp;&emsp;语法为 函数 = delete;。通过将函数体定义为 delete 来显式弃置函数定义。其可以删除特殊成员函数以及普通成员函数和非成员函数，以阻止定义或调用它们。函数的弃置定义必须是翻译单元中的首条声明，已经声明过的函数不能声明为弃置的。 &emsp;&emsp;在 std::unique_ptr 里删除了传参为 unique_ptr 左值的构造参数，以及相关的 = 操作。这样就可以保证此智能指针的唯一性。我个人感觉还是挺有用的，这样直接删除就不用重载了。&emsp; · final 与 override1. final&emsp;&emsp;其作用为指定某个虚函数不能在派生类中被覆盖，或者某个类不能被派生。也就是说，其可以作用于函数或者类，但是作用于函数时只能是虚函数。此关键字写于虚函数或类的后面。 作用于虚函数：使用 final 修饰虚函数，阻止子类重写父类的此函数。12345678910...class Child : public Base&#123;public: void test() final &#123; ... &#125;&#125;;... 作用于类：使用 final 修饰类，此类无法被继承。 12345678910...class Child final : public Base&#123;public: void test() &#123; ... &#125;&#125;;... 2. override&emsp;&emsp;其作用为指定一个虚函数覆盖另一个虚函数。在成员函数的声明或定义中，override 说明符确保该函数为虚函数并覆盖某个基类中的虚函数。如果不是这样，那么程序会生成编译错误。 override 是在成员函数声明符之后使用时拥有特殊含义的标识符，其他情况下它不是保留的关键词。 12345678910...class Child : public Base&#123;public: void test() override &#123; ... &#125;&#125;;... &emsp; · 尾随返回类型&emsp;&emsp;尾随返回类型语法为auto 函数名(传参) -&gt; decltype(表达式) &#123; 函数体 &#125;，返回值类型为 decltype 推导出的类型。 &emsp;&emsp;这个东西我感觉主要是为模板服务，使用场景主要是： 返回值随模板类型变化1234567891011template &lt;typename T, typename U&gt;auto add(T x, U y) -&gt; decltype(x + y)//这里说一嘴，此处的decltype不能填函数体内新声明的变量，比如z&#123; auto z = x + y; return z;&#125;int a = 1;double b = 3.14;auto ret = add(a, b);cout &lt;&lt; ret &lt;&lt; endl; //4.14 返回值类型比较复杂1auto fpif(int) -&gt; int(*)(int) &emsp; · 右值引用&emsp;&emsp;C++11中增加了一个新的很好用的类型，右值引用 &amp;&amp;，就是对右值的引用。首先看一下左右值的区别，其实主要就是看能不能取地址： 左值为 locator value，即 lvalue；右值为 read value，即 rvalue。 左值：储存在内存中、有明确存储地址的数据(可取地址) 右值：可以提供数据值的数据(不可取地址) &emsp;&emsp;那么右值引用有什么作用？主要的作用就是延长右值的生命周期，以提高效率。 那么是如何提高效率的呢？比如说如下这个场景： 123vector&lt;vector&lt;int&gt;&gt;vt;vector&lt;int&gt;temp&#123;1, 2, 3, 4, 5&#125;;vt.push_back(temp); &emsp;&emsp;此段代码中，先声明了二维数组 vt，随后声明一个一维数组 temp 来塞入容器 vt。自此一维数组 temp 使命完成，其储存的右值也没有作用了。在 push_back() 操作中，其首先会将 temp 以左值引用传进去，随后再使用 construct 来创建一个 vector&lt;int&gt; 拷贝储存传进来的值，最后再放入容器(如下图)。这就导致在函数中，此组数据被完整拷贝了一次，降低了效率。&emsp;&emsp;那么，既然 temp 只在此处有用，可否直接把 temp 放入 vt 中来减少那次拷贝呢？右值引用就是为了这个场景而出现的。例如上面这个问题的本质为：temp 的右值生命周期到此为止，想要将其生命周期延长给另一个变量 vt，来避免对 temp 右值的复制。这时就可以传入右值来提高 vector::push_back() 的效率。 std::move源码分析 123vector&lt;vector&lt;int&gt;&gt;vt;vector&lt;int&gt;temp&#123;1, 2, 3, 4, 5&#125;;vt.push_back(move(temp));//这里的std::move的作用是将左值转为右值 &emsp;&emsp;C++11中，STL中已经重载了很多函数的传右值引用版本，比如下图中 vector::push_back() 的右值引用版本，其只调用了 emplace_back 函数来延长生命周期，从而避免使用 construct 重新拷贝创建。&emsp;&emsp;所以呢，在C++11以前，右值引用没出现时，实际面临的问题是分辨传入的是右值还是左值。 当右值引用出现后，函数就可以判断传入的是右值还是左值，从而做出更优的选择。例如 vector::push_back() 在接收到右值的时候，它就知道可以直接给这个右值改变”所有者”，从而提高效率。 &emsp; · 移动构造函数与移动赋值运算符1. 移动构造函数&emsp;&emsp;移动构造函数其实就是传参为本类右值的构造参数，来实现将传入右值拥有的内存资源”移为已用”，这部分内容的实现被叫做移动语义。上面右值引用中举得 vector::push_back(value_type&amp;&amp;) 例子中，其实就是移动语义的一种实现，它延长了传入右值的存活时间。 &emsp;&emsp;移动构造函数在检测到传入内容为右值时，会将右值内容赋予新建的对象，并且删除右值原属主的内容，来实现移动语义。此类将内容”移为已用”的构造参数即可被称为移动构造参数。下面就是一个移动构造参数的例子： 1234567891011121314151617181920212223class Test&#123;public: Test(int n) : num(new int(n)) &#123; cout&lt;&lt;&quot;copy construct&quot;&lt;&lt;endl; &#125; //移动构造函数 Test(Test&amp;&amp; t) : num(t.num) &#123; t.num = nullptr; cout&lt;&lt;&quot;move construct&quot;&lt;&lt;endl; &#125;private: int* num;&#125;;Test t(2);Test t1(move(t));输出:copy constructmove construct 2. 移动赋值运算符&emsp;&emsp;移动赋值函数和上面的移动构造函数相似，只不过移动构造函数是在构造函数里接收右值操作，而移动赋值运算符是重载了 operator = 操作，使其接收一个右值，从而类可以进行 类名 = 类右值 这样的移动语义操作。下面是一个例子，其中移动构造函数和移动赋值运算符都有定义： 12345678910111213141516171819202122232425262728struct A&#123; std::string s; A() : s(&quot;测试&quot;) &#123; &#125; A(const A&amp; o) : s(o.s) &#123; std::cout &lt;&lt; &quot;移动失败！\\n&quot;; &#125; A(A&amp;&amp; o) : s(std::move(o.s)) &#123; &#125; A&amp; operator=(const A&amp; other) &#123; s = other.s; std::cout &lt;&lt; &quot;复制赋值\\n&quot;; return *this; &#125; A&amp; operator=(A&amp;&amp; other) &#123; s = std::move(other.s); std::cout &lt;&lt; &quot;移动赋值\\n&quot;; return *this; &#125;&#125;;int main()&#123; A a1, a2; std::cout &lt;&lt; &quot;尝试从右值临时量移动赋值 A\\n&quot;; a1 = f(A()); // 从右值临时量移动赋值 std::cout &lt;&lt; &quot;尝试从亡值移动赋值 A\\n&quot;; a2 = std::move(a1); // 从亡值移动赋值&#125; &emsp; · 有作用域枚举&emsp;&emsp;在C++11之前，枚举类型可能会出现一个问题：枚举值的重复。比如说下面这种情况： 123456789101112131415//三原色enum LightColor&#123; red,//note: previous declaration ‘LightColor red’ green, blue//note: previous declaration ‘LightColor blue’&#125;;//三基色enum PaintColor&#123; red,//‘red’ conflicts with a previous declaration yellow, blue//‘blue’ conflicts with a previous declaration&#125;;//如上这样定义就会出现枚举值重复情况 无法正常编译 &emsp;&emsp;在C++11之前为了解决这种情况都是将其放入另一个作用域(类或命名空间)中，比如下面就是放入别的命名空间： 1234567891011121314151617181920212223//三原色namespace Light&#123; enum Color &#123; red, green, blue &#125;;&#125;//三基色namespace Paint&#123; enum Color &#123; red, yellow, blue &#125;;&#125;//定义Light::Color c1 = Light::red;Paint::Color c2 = Paint::red; &emsp;&emsp;但是使用命名空间或类这个解法明显有点繁琐以及浪费，于是在C++11中推出了有作用域枚举。如下： 1234567891011121314151617//三原色enum class LightColor&#123; red, green, blue&#125;;//三基色enum class PaintColor&#123; red, yellow, blue&#125;;//定义LightColor c1 = LightColor::red;PaintColor c2 = PaintColor::red; &emsp;&emsp;这样，既解决了常规枚举值重复的问题，也让整体定义和使用变得没那么繁琐。 &emsp; · constexpr 与字面类型1. constexpr&emsp;&emsp;在C语言中，const 关键字只有”只读”这一语义，但在C++中其引入了”常量”语义。在C++中，所谓”只读”和”常量”的区别大致在编译期间能不能直接确定初始值，若不能则被作为”只读变量”处理，若可以确定则被作为”常量”处理。 在 constexpr 出现之前，const 一直同时承担两种语义，故 constexpr 出现的意义便是承担”常量”这一语义。 &emsp;&emsp;所以，constexpr 表示在编译期就可以确定的内容，而 const 只保证运行时不直接被修改。我记得官方是建议凡是”常量”语义的场景都使用 constexpr，只对”只读”语义使用 const。另外在C++11中，constexpr 函数必须把一切放在单条 return 语句中，而在C++14后就无此要求了。 &emsp;&emsp;constexpr 可以修饰变量和函数。可以看到，C++标准库里的模板元编程内容都加上了 constexpr 修饰，因为这部分内容都是在编译期里可以被推出的。通过关键字 constexpr 的修饰，可以让编译器更好的优化、替换相关的常量，从而提高执行效率。当然，给一段不是常量返回值的函数加上关键字 constexpr 是无效的，编译器会在判定后忽略关键字。 &emsp;&emsp;另外存在 noexcept 运算符始终对常量表达式返回 true，所以它可以用于检查具体特定的 constexpr 函数返回是否采用常量表达式。 1234constexpr int f(); constexpr bool b1 = noexcept(f()); // false，constexpr 函数未定义constexpr int f() &#123; return 0; &#125;constexpr bool b2 = noexcept(f()); // true，f() 是常量表达式 2. 字面类型&emsp;&emsp;指明一个类型为字面类型。字面类型是 constexpr 变量所拥有的类型，且能通过 constexpr 函数构造、操作及返回它们。简单来说就是一个为了配合 constexpr 的理论概念。&emsp;&emsp;注意：标准中并没有定义具有这个名字的具名要求。这是核心语言所定义的一种类型类别。将它作为具名要求包含于此只是为了保持一致性。 &emsp; · 列表初始化&emsp;&emsp;在C++11之前，变量、数组、对象等都有不同的初始化方法。而在C++11中出现了一种新的初始化方式，其统一了初始化方式并且让初始化行为具有确定的效果，即列表初始化。 &emsp;&emsp;列表初始化的语法就是在要初始化的内容后加上一个大括号（括号前可以加等号），其中写上初始化的内容即可。 1234567891011121314Test t(520); //普通构造Test t = 520; //隐式转换Test t = &#123;520&#125;; //列表初始化Test t &#123;520&#125;; //列表初始化//以下均为列表初始化int i = &#123;1314&#125;; int i &#123;1314&#125;; int ii[] = &#123;1, 2, 3&#125;;int ii[] &#123;1, 2, 3&#125;; int* p = new int &#123;5201314&#125;;double b = double &#123;13.14&#125;;int* array = new int[3] &#123;1, 2, 3&#125;; &emsp;&emsp;注意：类中的私有成员或者静态成员无法进行列表初始化。这个官方一点的总结应该是只有聚合类型才可以无条件使用列表初始化。 如果一个非聚合类也想使用列表初始化，那它必须得拥有相对应的构造函数。cppreference解释链接 123456789struct test&#123; int x; int y;protected: static int z;&#125;t&#123;123, 321&#125;;//accept//静态成员初始化int test::z = 222; &emsp; · 委托与继承的构造函数1. 委托构造函数&emsp;&emsp;委托构造函数允许使用同一个类中的一个构造函数调用其他的构造函数，从而简化相关变量的初始化。我感觉这部分内容没什么好讲的，简单说就是可以通过 : 来调用其他的构造函数来简化操作。 1234567891011121314151617181920class Test&#123;public: Test(int max) &#123; max = max &gt; 0 ? max : 100; &#125; Test(int max, int min) : Test(max) &#123; min = min &gt; 0 &amp;&amp; min &lt; max ? min : 1; &#125; Test(int max, int min, int mid) : Test(max, min) &#123; mid = mid &lt; max &amp;&amp; mid &gt; min ? mid : 50; &#125;private: int _max; int _min; int _middle;&#125;; 2. 继承构造函数&emsp;&emsp;继承构造函数可以让派生类直接使用基类的构造函数，而无需自己再写构造函数，尤其是在基类有很多构造函数的情况下，可以极大的简化派生类构造函数的编写。 &emsp;&emsp;比如下面这个例子，如果想要使用基类的构造函数，挨个重写 Child(int i) : Base(i) &#123;&#125; 明显很麻烦，但是直接使用 using Base::Base; 就可以直接继承基类的构造函数，方便很多。 123456789101112131415161718class Base&#123;public: Base(int i) : m_i(i) &#123;&#125; Base(int i, double j) : m_i(i), m_j(j) &#123;&#125; Base(int i, double j, string k) : m_i(i), m_j(j), m_k(k) &#123;&#125; int m_i; double m_j; string m_k;&#125;;class Child : public Base&#123;public: using Base::Base; //甚至可以 using Base::func 这样来继承父类的成员函数func()&#125;; &emsp; · 花括号或等号初始化器&emsp;&emsp;如下，直接摘自cppreference。&emsp; · nullptr&emsp;&emsp;在C语言中，空指针普遍使用 NULL 来表示，其实际定义为 (void *)0。但在C++中，NULL 的实际定义为 0，这是因为C++中不能将void *类型的指针隐式转换成其他指针类型。C++是一门强类型的语言，这样将0当成空指针很明显不符合语言的特性，因为 NULL 往往会被推导成 long int 类型而不是指针类型，于是在C++11中推出了 nullptr 来定义各个类型的空指针。 1234567//C++与C中NULL的定义#undef NULL#if defined(__cplusplus)#define NULL 0#else#define NULL ((void *)0)#endif &emsp;&emsp;nullptr 实际是 std::nullptr_t 类型的纯右值，它可以转换成任意指针类型。这样就可以解决C++中不能将(void *)类型的指针隐式转换成其他指针类型的问题，从而避免 NULL 歧义出现。 12345678910111213141516171819202122232425262728293031323334#include &lt;cstddef&gt;#include &lt;iostream&gt; void f(int*)&#123; std::cout &lt;&lt; &quot;Pointer to integer overload\\n&quot;;&#125; void f(double*)&#123; std::cout &lt;&lt; &quot;Pointer to double overload\\n&quot;;&#125; void f(std::nullptr_t)&#123; std::cout &lt;&lt; &quot;null pointer overload\\n&quot;;&#125; int main()&#123; int* pi &#123;&#125;; double* pd &#123;&#125;; f(pi); f(pd); f(nullptr); // 无 void f(nullptr_t) 可能有歧义 // f(0); // 歧义调用：三个函数全部为候选 // f(NULL); // 若 NULL 是整数空指针常量则为歧义 // （如在大部分实现中的情况）&#125;结果：Pointer to integer overloadPointer to double overloadnull pointer overload &emsp; · long long&emsp;&emsp;就是C++11里新增的一组基础整数类型，简单来说其核心就是保证至少 64 位的宽度（8个字节），我觉得没什么好说的。&emsp; · char16_t 与 char32_t&emsp;&emsp;这两个是C++11里新增的字符类型，主要是为了服务UTF编码的。其与普通 char 的差别就是位宽不一样。具体定义如下： char16_t: UTF-16 字符表示的类型，要求大到足以表示任何 UTF-16 编码单元（ 16 位）。它与 std::uint_least16_t 具有相同的大小、符号性和对齐，但它是独立的类型。使用u来表示utf-16字符: char16_t c&#123; u&#39;a&#39; &#125;; char32_t: UTF-32 字符表示的类型，要求大到足以表示任何 UTF-32 编码单元（ 32 位）。它与 std::uint_least32_t 具有相同的大小、符号性和对齐，但它是独立的类型。使用U来表示utf-32字符:char32_t c&#123; U&#39;a&#39; &#125;; &emsp; · 类型别名&emsp;&emsp;C++11中，给关键字 using 添加了一个新的功能：定义类型的别名。就我的使用经验来看，其和 typedef 是一样的效果，没有区别。虽然 using 看起来更简洁一点，但是我感觉已经用 typedef 用习惯了… 使用场景一，和基础类型和函数指针搭配12345678910//语法using 新类型 = 旧类型;//下两者相同using func = void (*) (int, int); typedef void (*func)(int, int);//使用void test(int, int) &#123;&#125;func f = test; 使用场景二，和模板搭配，在STL源码里经常见12345678910template &lt;typename T&gt;struct MyMap&#123; typedef map&lt;int, T&gt; mapType;&#125;;MyMap&lt;int&gt;::mapType m;template &lt;typename T&gt;using MyMap = map&lt;int, T&gt;;MyMap&lt;int&gt; m; &emsp; · 变参数模板 形参包：模板形参包是接受零或更多模板实参（非类型、类型或模板）的模板形参。函数形参包是接受零或更多函数实参的函数形参，至少有一个形参包的模板被称作变参模板。 &emsp;&emsp;在C++11中，新出现了变参数模板，即可将任意数量的模板实参实例化。语法为：template&lt;class|typename ... Types&gt;。其弥补了C++模板不能灵活定义参数数量的不足。 123456789101112131415161718192021222324252627282930313233343536373839404142431. --------------------------------------------------------------------void test()//基础函数&#123; cout &lt;&lt; endl;&#125;template&lt;typename T, typename ... Args&gt;void test(const T&amp; t, const Args&amp;... a)//递归变参函数&#123; cout &lt;&lt; t &lt;&lt; endl; test(a...);//递归调用&#125;int main()&#123; test(string(&quot;hello&quot;), &quot;world1&quot;, 1, 3); return 0;&#125;2. --------------------------------------------------------------------void tprintf(const char* format)//基础函数&#123; std::cout &lt;&lt; format;&#125; template&lt;typename T, typename... Targs&gt;void tprintf(const char* format, T value, Targs... Fargs)//递归变参函数&#123; for ( ; *format != &#x27;\\0&#x27;; format++ ) &#123; if ( *format == &#x27;%&#x27; ) &#123; std::cout &lt;&lt; value; tprintf(format+1, Fargs...);//递归调用 return; &#125; std::cout &lt;&lt; *format; &#125;&#125; int main()&#123; tprintf(&quot;% world% %\\n&quot;,&quot;Hello&quot;,&#x27;!&#x27;,123); return 0;&#125; &emsp;&emsp;如上两个例子所示，变参数模板一般都是拥有一个基础函数，以及一个变参模板函数。在变参模板函数里处理定量的传参后递归调用，直至参数处理完毕。总体而言我感觉它的思路和一般的递归函数是相似的，其基础函数即为边界。 &emsp; · 推广的（非平凡）联合体&emsp;&emsp;&emsp; · 推广的 POD （平凡类型与标准布局类型）&emsp;&emsp;&emsp; · Unicode 字符串字面量&emsp;&emsp;在C++11之前，C++中只有通常字符串字面量：&quot;内容&quot; 以及宽字符串字面量：L&quot;内容&quot;。其中前者是最常用的一种，每个字符占一个字节；而后者则是代表每个字符占用两个字节。 &emsp;&emsp;上文中提到，C++11中提供了两个新字符类型 char16_t 与 char32_t，于是C++也更新了相对应的字符串字面量 u&quot;内容&quot; 和 U&quot;内容&quot;。此外还提供了另外新的两种字符串字面量 u8&quot;内容&quot; 和 R&quot;xxx(内容)xxx&quot;，这四种新的字面量的具体解释如下： u8&quot;内容&quot;：UTF-8 字符串字面量。 字符串字面量的类型是 const char[N](C++20 前) const char8_t[N](C++20 起)，其中 N 是以 UTF-8 编码单元计的字符串的大小，包含空终止符。 u&quot;内容&quot;：UTF-16 字符串字面量。 字符串字面量的类型是 const char16_t[N]，其中 N 是以 UTF-16 编码单元计的字符串的大小，包含空终止符。 U&quot;内容&quot;：UTF-32 字符串字面量。 字符串字面量的类型是 const char32_t[N]，其中 N 是以 UTF-32 编码单元计的字符串的大小，包含空终止符。 R&quot;xxx(内容)xxx&quot;：原始字符串字面量。 用于避免转义任何字符。这个我感觉还是挺有用的，在这里记录一下用法：12345678910111213141516171819202122232425262728293031323334353637 在原始字符串字面量的定义内容中，将不存在任何转义。 比如常见的路径字符串 &quot;C:\\\\demo\\\\test.txt&quot;，其中使用&quot;\\\\&quot;的原因是避免&quot;\\&quot;进行转义。 而当使用原始字符串字面量定义时，就可以直接 R&quot;(C:\\demo\\test.txt)&quot;，因为字符串中不会进行任何转义，所以就不需要使用&quot;\\\\&quot;了。eg: 样例输入： cout &lt;&lt; R&quot;(hello world \\n)&quot;; 样例输出： hello world \\n 另外有些时候，字符串太长或者说需要分段，常规来讲是通过&quot;\\n&quot;和&quot;\\&quot;来实现的，比如说下面这个例子，通过连接符和回车来实现分段。eg: 样例输入： cout &lt;&lt; &quot;1\\n\\ 2\\n\\ 3&quot; &lt;&lt; endl; 样例输出： 1 2 3 而当使用原始字符串字面量定义时，直接按位置输入即可，字符串中会根据位置自动换行。eg: 样例输入： cout &lt;&lt; R&quot;(1 2 3)&quot; &lt;&lt; endl; 样例输出： 1 2 3 另外，原始字符串字面量的那个&quot;xxx&quot;部分我个人认为与注释相似，没有实际影响，而且得注意前后必须一致。eg: 样例输入： cout &lt;&lt; R&quot;hello(hello world \\n)hello&quot; &lt;&lt; endl; 样例输出： hello world \\n &emsp; · 用户定义字面量&emsp;&emsp;C++11新标准中引入了用户自定义字面量，也叫自定义后缀操作符，即通过实现一个后缀操作符，将申明了该后缀标识的字面量转化为需要的类型。比如如下代码： 1234567891011121314151617long double operator&quot;&quot; _mm(long double x) &#123; return x / 1000; &#125;long double operator&quot;&quot; _m(long double x) &#123; return x; &#125;long double operator&quot;&quot; _km(long double x) &#123; return x * 1000; &#125;int main()&#123; cout &lt;&lt; 1.0_mm &lt;&lt; endl; //0.001 cout &lt;&lt; 1.0_m &lt;&lt; endl; //1 cout &lt;&lt; 1.0_km &lt;&lt; endl; //1000 return 0;&#125;输出结果:0.00111000 &emsp;&emsp;我个人而言这块内容是没有使用过，然后去网上找了一下相关的资料，感觉这东西是为了用户自定义类型的字面量解析输出…比如说下面这个例子： 123456789101112131415161718192021222324252627282930313233343536373839404142//一个自定义的rgb类型struct RGBA&#123; uint8_t r, g, b, a; RGBA(uint8_t r, uint8_t g, uint8_t b, uint8_t a):r(r),g(g),b(b),a(a)&#123;&#125;&#125;;//自定义字面量后缀RGBA operator&quot;&quot; _RGBA(const char* str, size_t size)&#123; const char* r = nullptr, *g = nullptr, *b = nullptr, *a = nullptr; for (const char* p = str; p != str + size; ++p) &#123; if (*p == &#x27;r&#x27;) r = p + 1; if (*p == &#x27;g&#x27;) g = p + 1; if (*p == &#x27;b&#x27;) b = p + 1; if (*p == &#x27;a&#x27;) a = p + 1; &#125; if (r == nullptr || g == nullptr || b == nullptr) throw; if (a == nullptr) &#123; return RGBA(atoi(r),atoi(g),atoi(b),0); &#125; else &#123; return RGBA(atoi(r), atoi(g), atoi(b),atoi(a)); &#125;&#125;//输出运算符重载ostream&amp; operator&lt;&lt;(ostream&amp; os,const RGBA&amp; color)&#123; return os&lt;&lt;&quot;r=&quot;&lt;&lt; (int)color.r&lt;&lt;&quot; g=&quot;&lt;&lt; (int)color.g&lt;&lt;&quot; b=&quot;&lt;&lt; (int)color.b&lt;&lt;&quot; a=&quot;&lt;&lt; (int)color.a&lt;&lt;endl;&#125;//mainint main()&#123; //自定义字面量来表示RGBA对象 cout &lt;&lt; &quot;r255 g255 b255 a40&quot;_RGBA &lt;&lt; endl; return 0;&#125;输出结果:r=255 g=255 b=255 a=40 &emsp;&emsp;值得注意的是，用户定义字面量中，只有下面的7种参数列表才是合法的，而且后面四种会自动计算出字符串的长度，挺好用的。具体可以看下面： 12345678910111213141516171819char const *unsigned long longlong doublechar const *, size_twchar_t const *, size_tchar16_t const *, size_tchar32_t const *, size_t//例子size_t operator&quot;&quot; _len(char const * str, size_t size)&#123; return size;&#125;int main()&#123; cout &lt;&lt; &quot;hello&quot;_len &lt;&lt;endl; //结果为5 return 0;&#125; &emsp; · 属性&emsp;&emsp;C++11中新增了一个概念：属性(attributes)，其功能为为类型、对象、代码等引入由实现定义的属性。在C++11中，其语法仅为[[ 属性列表 ]]，标准属性也只有下图的前两个： 12345[[gnu::always_inline]] [[gnu::hot]] [[gnu::const]] [[nodiscard]]inline int f(); // 声明 f 带四个属性 [[gnu::always_inline, gnu::const, gnu::hot, nodiscard]]int f(); // 同上，但使用含有四个属性的单个属性说明符 &emsp; · lambda 表达式&emsp;&emsp;即匿名函数表达式，其主要语法为：[捕获列表] (参数列表) 函数选项 -&gt; 返回值类型 &#123; 函数体 &#125;;，就是中、小、大三种括号来一遍。 捕获列表可以指定需要”捕获”哪些变量，以及按什么方式”捕获”。简单来说，就是lambda表达式的函数体是独立的区域，如果想使用外部的变量，就必须先给它”捕获”进来。具体方式如下： 12345678910111213141516171819202122232425262728293031323334353637[] 不捕获任何变量[&amp;] 捕获外部作用域中的所有变量，并作为引用在函数体内使用（按引用捕获）[=] 捕获外部作用域中的所有变量，并作为副本在函数体内使用（按值捕获）[=, &amp;foo] 按值捕获外部作用域中所有变量，并按照引用捕获外部变量foo[bar] 按值捕获bar变量，同时不捕获其他变量[&amp;bar] 按引用捕获bar变量，同时不捕获其他变量[this] 捕获当前类中的this指针 - 让lambda表达式拥有和当前类成员函数同样的访问权限 - 如果以及使用了&amp;或=，则默认添加此选项struct S2 &#123; void f(int i); &#125;;void S2::f(int i)&#123; [&amp;]&#123;&#125;; // OK：默认以引用捕获 [&amp;, i]&#123;&#125;; // OK：以引用捕获，但 i 以值捕获 [&amp;, &amp;i] &#123;&#125;; // 错误：以引用捕获为默认时后续不能以引用捕获 [&amp;, this] &#123;&#125;; // OK：等价于 [&amp;] [&amp;, this, i]&#123;&#125;; // OK：等价于 [&amp;, i]&#125;struct S2 &#123; void f(int i); &#125;;void S2::f(int i)&#123; [=]&#123;&#125;; // OK：默认以复制捕获 [=, &amp;i]&#123;&#125;; // OK：以复制捕获，但 i 以引用捕获 [=, *this]&#123;&#125;; // C++17 前：错误：无效语法 // C++17 起：OK：以复制捕获外围的 S2 [=, this] &#123;&#125;; // C++20 前：错误：= 为默认时的 this // C++20 起：OK：同 [=]&#125;struct S2 &#123; void f(int i); &#125;;void S2::f(int i)&#123; [i, i] &#123;&#125;; // 错误：i 重复 [this, *this] &#123;&#125;; // 错误：&quot;this&quot; 重复 (C++17)&#125; 参数列表和普通函数的相似，就是小括号里写上接收什么类型的参数之类的。当没有传参的时候，可以直接写空括号 ()，或者干脆省略括号 auto f = []&#123;return 1;&#125;;，但是不推荐不写因为我感觉会影响可读性。 函数选项主要有两个，mutable 和 exception：前者 mutable 含义为可以修改按值传递进来的拷贝(修改拷贝，不是值本身)；后者 exception 含义为指定函数抛出的异常，如抛出整数类型的异常，可以使用 throw();。这部分内容不需要可以直接省略不写，说实话我也没用过… 返回值类型是典型的”尾随返回类型”，但是一般是不写它的，因为会自动推导返回值类型。不过有一些情况下编译器无法推导返回类型，比如说返回一个初始化列表 return &#123;1, 2&#125;;，此时就必须指定返回值类型了。 &emsp;&emsp;lambda的本质其实是一个仿函数，当以值捕获变量时，其默认是 const 的，所以无法更改，而选项 mutable 的功能就是去掉 const 修饰。而当一个lambda表达式未捕获任何变量时，其还可以转换成一个普通的函数指针。 &emsp; · noexcept 说明符与 noexcept 运算符1. noexcept 说明符&emsp;&emsp;指定函数是否抛出异常。在函数后添加 noexcept 即可，也可以指定 false，默认即为 noexcept(false)。 1234void f() noexcept;void f(); // 错误：不同的异常说明void g() noexcept(false);void g(); // OK： g 的两个声明均为潜在抛出 2. noexcept 运算符&emsp;&emsp;noexcept 运算符进行编译时检查，若表达式声明为不抛出任何异常则返回 true。它可用于函数模板的 noexcept 说明符中，以声明函数将对某些类型抛出异常，但不对其他类型抛出。其语法为 noexcept(表达式)。 &emsp;&emsp;noexcept 运算符不对表达式求值。若表达式的潜在异常集合为空，则结果为 true，否则结果为 false。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;utility&gt;#include &lt;vector&gt; void may_throw();void no_throw() noexcept;auto lmay_throw = []&#123;&#125;;auto lno_throw = []() noexcept &#123;&#125;;class T&#123;public: ~T()&#123;&#125; // 析构函数妨碍了移动构造函数 // 复制构造函数为 noexcept&#125;;class U&#123;public: ~U()&#123;&#125; // 析构函数妨碍了移动构造函数 // 复制构造函数为 noexcept(false) std::vector&lt;int&gt; v;&#125;;class V&#123;public: std::vector&lt;int&gt; v;&#125;; int main()&#123; T t; U u; V v; std::cout &lt;&lt; std::boolalpha &lt;&lt; &quot;Is may_throw() noexcept? &quot; &lt;&lt; noexcept(may_throw()) &lt;&lt; &#x27;\\n&#x27; &lt;&lt; &quot;Is no_throw() noexcept? &quot; &lt;&lt; noexcept(no_throw()) &lt;&lt; &#x27;\\n&#x27; &lt;&lt; &quot;Is lmay_throw() noexcept? &quot; &lt;&lt; noexcept(lmay_throw()) &lt;&lt; &#x27;\\n&#x27; &lt;&lt; &quot;Is lno_throw() noexcept? &quot; &lt;&lt; noexcept(lno_throw()) &lt;&lt; &#x27;\\n&#x27; &lt;&lt; &quot;Is ~T() noexcept? &quot; &lt;&lt; noexcept(std::declval&lt;T&gt;().~T()) &lt;&lt; &#x27;\\n&#x27; // 注：以下各项测试也要求 ~T() 为 noexcept // 因为 noexccept 中的表达式构造并销毁了临时量 &lt;&lt; &quot;Is T(rvalue T) noexcept? &quot; &lt;&lt; noexcept(T(std::declval&lt;T&gt;())) &lt;&lt; &#x27;\\n&#x27; &lt;&lt; &quot;Is T(lvalue T) noexcept? &quot; &lt;&lt; noexcept(T(t)) &lt;&lt; &#x27;\\n&#x27; &lt;&lt; &quot;Is U(rvalue U) noexcept? &quot; &lt;&lt; noexcept(U(std::declval&lt;U&gt;())) &lt;&lt; &#x27;\\n&#x27; &lt;&lt; &quot;Is U(lvalue U) noexcept? &quot; &lt;&lt; noexcept(U(u)) &lt;&lt; &#x27;\\n&#x27; &lt;&lt; &quot;Is V(rvalue V) noexcept? &quot; &lt;&lt; noexcept(V(std::declval&lt;V&gt;())) &lt;&lt; &#x27;\\n&#x27; &lt;&lt; &quot;Is V(lvalue V) noexcept? &quot; &lt;&lt; noexcept(V(v)) &lt;&lt; &#x27;\\n&#x27;; &#125;输出:Is may_throw() noexcept? falseIs no_throw() noexcept? trueIs lmay_throw() noexcept? falseIs lno_throw() noexcept? trueIs ~T() noexcept? trueIs T(rvalue T) noexcept? trueIs T(lvalue T) noexcept? trueIs U(rvalue U) noexcept? falseIs U(lvalue U) noexcept? falseIs V(rvalue V) noexcept? trueIs V(lvalue V) noexcept? false &emsp; · alignof 与 alignas1. alignof&emsp;&emsp;查询类型的对齐要求。其语法为 alignof(类型标识) ，返回 std::size_t 类型的值。 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;struct Foo &#123; int i; float f; char c;&#125;;// 注：下面的 `alignas(alignof(long double))` 如果需要可以简化为 // `alignas(long double)`struct alignas(alignof(long double)) Foo2 &#123; // Foo2 成员的定义...&#125;;struct Empty &#123;&#125;;struct alignas(64) Empty64 &#123;&#125;;int main()&#123; std::cout &lt;&lt; &quot;对齐字节数&quot; &quot;\\n&quot; &quot;- char ：&quot; &lt;&lt; alignof(char) &lt;&lt; &quot;\\n&quot; &quot;- 指针 ：&quot; &lt;&lt; alignof(int*) &lt;&lt; &quot;\\n&quot; &quot;- Foo 类 ：&quot; &lt;&lt; alignof(Foo) &lt;&lt; &quot;\\n&quot; &quot;- Foo2 类 ：&quot; &lt;&lt; alignof(Foo2) &lt;&lt; &quot;\\n&quot; &quot;- 空类 ：&quot; &lt;&lt; alignof(Empty) &lt;&lt; &quot;\\n&quot; &quot;- alignas(64) Empty：&quot; &lt;&lt; alignof(Empty64) &lt;&lt; &quot;\\n&quot;;&#125;可能的输出:对齐字节数- char ：1- 指针 ：8- Foo 类 ：4- Foo2 类 ：16- 空类 ：1- alignas(64) Empty：64 2. alignas&emsp;&emsp;指定类型或对象的对齐要求。语法为 (1)alignas(表达式)、(2)alignas(类型标识)、(3)alignas(包 ...)。 alignas(表达式) 必须是求值为零或合法的对齐或扩展对齐的整型常量表达式。 等价于 alignas(alignof(类型)) 等价于对同一说明应用多个 alignas 说明符，逐个对应于形参包的各个成员，形参包可以是类型或非类型形参包。 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 每个 struct_float 类型对象都将被对齐到 alignof(float) 边界// （通常为 4）：struct alignas(alignof(float)) struct_float&#123; // 定义在此&#125;;// sse_t 类型的每个对象将对齐到 32 字节边界struct alignas(32) sse_t&#123; float sse_data[4];&#125;;// 数组 &quot;cacheline&quot; 将对齐到 64 字节边界alignas(64) char cacheline[64];#include &lt;iostream&gt;int main()&#123; struct default_aligned &#123; float data[4]; &#125; a, b, c; sse_t x, y, z; std::cout &lt;&lt; &quot;alignof(struct_float) = &quot; &lt;&lt; alignof(struct_float) &lt;&lt; &#x27;\\n&#x27; &lt;&lt; &quot;sizeof(sse_t) = &quot; &lt;&lt; sizeof(sse_t) &lt;&lt; &#x27;\\n&#x27; &lt;&lt; &quot;alignof(sse_t) = &quot; &lt;&lt; alignof(sse_t) &lt;&lt; &#x27;\\n&#x27; &lt;&lt; &quot;alignof(cacheline) = &quot; &lt;&lt; alignof(alignas(64) char[64]) &lt;&lt; &#x27;\\n&#x27; &lt;&lt; std::hex &lt;&lt; std::showbase &lt;&lt; &quot;&amp;a: &quot; &lt;&lt; &amp;a &lt;&lt; &#x27;\\n&#x27; &lt;&lt; &quot;&amp;b: &quot; &lt;&lt; &amp;b &lt;&lt; &#x27;\\n&#x27; &lt;&lt; &quot;&amp;c: &quot; &lt;&lt; &amp;c &lt;&lt; &#x27;\\n&#x27; &lt;&lt; &quot;&amp;x: &quot; &lt;&lt; &amp;x &lt;&lt; &#x27;\\n&#x27; &lt;&lt; &quot;&amp;y: &quot; &lt;&lt; &amp;y &lt;&lt; &#x27;\\n&#x27; &lt;&lt; &quot;&amp;z: &quot; &lt;&lt; &amp;z &lt;&lt; &#x27;\\n&#x27;;&#125;可能的输出:alignof(struct_float) = 4sizeof(sse_t) = 32alignof(sse_t) = 32alignof(cacheline) = 64&amp;a: 0x7ffc835270d0&amp;b: 0x7ffc835270e0&amp;c: 0x7ffc835270f0&amp;x: 0x7ffc83527100&amp;y: 0x7ffc83527120&amp;z: 0x7ffc83527140 &emsp; · 多线程内存模型&emsp;&emsp;应该指的是对原子操作那个库的相关支持吧，深入一点说实话我也不太了解。可以参考一下这位大佬的文：C++11多线程-内存模型 &emsp; · 线程局部存储&emsp;&emsp;线程局部存储在其它语言中都是以库的形式提供的(库函数或类)。但在C++11中以关键字的形式，做为一种存储类型出现，由此可见C++11对线程局部存储的重视。C++11中有如下几种存储类型: 序号 类型 备注 1 auto 该关键字用于两种情况：1. 声明变量时，根据初始化表达式自动推断变量类型。2. 声明函数作为函数返回值的占位符。 2 static static变量只初始化一次，除此之外它还有可见性的属性：1. static修饰函数内的“局部”变量时，表明它不需要在进入或离开函数时创建或销毁。且仅在函数内可见。2. static修饰全局变量时，表明该变量仅在当前(声明它的)文件内可见。3. static修饰类的成员变量时，则该变量被该类的所有实例共享。 3 register 寄存器变量。该变量存储在CPU寄存器中，而不是RAM(栈或堆)中。该变量的最大尺寸等于寄存器的大小。由于是存储于寄存器中，因此不能对该变量进行取地址操作。 4 extern 引用一个全局变量。当在一个文件中定义了一个全局变量时，就可以在其它文件中使用extern来声明并引用该变量。 5 mutable 仅适用于类成员变量。以mutable修饰的成员变量可以在const成员函数中修改。 6 thread_local 线程周期 thread_local 修饰的变量具有如下特性: 变量在线程创建时生成(不同编译器实现略有差异，但在线程内变量第一次使用前必然已构造完毕)。 线程结束时被销毁(析构，利用析构特性，thread_local 变量可以感知线程销毁事件)。 每个线程都拥有其自己的变量副本。 thread_local 可以和 static 或 extern 联合使用，这将会影响变量的链接属性。 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;mutex&gt; thread_local unsigned int rage = 1; std::mutex cout_mutex; void increase_rage(const std::string&amp; thread_name)&#123; ++rage; // 在锁外修改 OK；这是线程局部变量 std::lock_guard&lt;std::mutex&gt; lock(cout_mutex); std::cout &lt;&lt; thread_name &lt;&lt; &quot; 的愤怒计数：&quot; &lt;&lt; rage &lt;&lt; &#x27;\\n&#x27;;&#125; int main()&#123; std::thread a(increase_rage, &quot;a&quot;), b(increase_rage, &quot;b&quot;); &#123; std::lock_guard&lt;std::mutex&gt; lock(cout_mutex); std::cout &lt;&lt; &quot;main 的愤怒计数：&quot; &lt;&lt; rage &lt;&lt; &#x27;\\n&#x27;; &#125; a.join(); b.join();&#125;输出:a 的愤怒计数：2main 的愤怒计数：1b 的愤怒计数：2 &emsp; · GC 接口&emsp;&emsp;C++11中新增了对 GC(垃圾回收) 的支持，但是好像在C++23的目标里要进行删除…这部分感觉用的也挺少的，我也没怎么研究，就简单贴个图过了吧。 &emsp; · 范围 for （基于 Boost 库）&emsp;&emsp;在C++11中新增了一种范围for，这东西用的蛮多的，使用场景基本都是为了遍历各种容器，搭配 auto 使用非常方便。 &emsp;&emsp;注意：此类范围for循环在遍历过程中只会访问一次容器。 在第一次也是唯一一次访问中，其会确认边界，随后根据边界进行遍历。因此其不会每次遍历都判定条件，这也可能造成在遍历中增减元素会出现问题。 1234567891011vector&lt;int&gt;test&#123;1, 2, 3, 4, 5, 6&#125;;//此处i为拷贝，无法修改原值for(auto i : test)&#123; cout &lt;&lt; i &lt;&lt; endl;&#125;//此处i为引用，可以修改原值for(auto&amp; i : test)&#123; cout &lt;&lt; i++ &lt;&lt; endl;&#125; &emsp; · static_assert （基于 Boost 库）&emsp;&emsp;其功能为编译时进行断言检查，即静态断言。语法为 static_assert(布尔常量表达式, 字符串字面量)，当布尔常量表达式为 false 时，则会出现后面指定的字符串字面量，同时编译失败。 &emsp;&emsp;静态断言的好处就是可以在编译期就更早的发现错误，以及减少运行时开销。我看了一小部分C++标准库源码，发现静态断言出现的频率还挺高的，感觉标准委员会是挺推崇这东西的。&emsp;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"}],"tags":[{"name":"C++标准库学习","slug":"C-标准库学习","permalink":"https://zgg2001.github.io/tags/C-%E6%A0%87%E5%87%86%E5%BA%93%E5%AD%A6%E4%B9%A0/"},{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/tags/C-C/"}]},{"title":"dpdk源码分析：交互式命令行的实现(二) 初始化与退出","slug":"20211121_dpdk源码分析：交互式命令行的实现(二)初始化与退出","date":"2021-11-21T05:04:51.000Z","updated":"2021-11-21T05:04:51.000Z","comments":true,"path":"2021/11/21/20211121_dpdk源码分析：交互式命令行的实现(二)初始化与退出/","permalink":"https://zgg2001.github.io/2021/11/21/20211121_dpdk%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E5%AE%9E%E7%8E%B0(%E4%BA%8C)%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E9%80%80%E5%87%BA/","excerpt":"本文中使用的dpdk库版本为：16.04 此文为分析的第二篇，接上文 dpdk源码分析：交互式命令行的实现(一) 命令添加 上一篇中已经分析了命令添加相关的实现和写法，接下来目标为交互式命令行初始化和退出相关内容的分析。","text":"本文中使用的dpdk库版本为：16.04 此文为分析的第二篇，接上文 dpdk源码分析：交互式命令行的实现(一) 命令添加 上一篇中已经分析了命令添加相关的实现和写法，接下来目标为交互式命令行初始化和退出相关内容的分析。 一、从一段代码入手&emsp;&emsp;下面这段代码为dpdk例程 examples/qos_sched/cmdline.c 中的内容，是对封装好的交互式命令行内容进行调用的完整流程。&emsp;&emsp;可以看到，此段代码总共有两个部分，第一部分为 main_ctx[] 的定义过程，第二部分为一个函数 prompt()。 &emsp;&emsp;根据上一篇的内容，可以知道 main_ctx[] 中定义的内容为具体的命令。图中代码中一共定义了11组命令，此篇笔记中不再进行赘述。 &emsp;&emsp;第二部分为函数 prompt()，其中一共调用了三个函数，另外此处的 struct cmdline 即为命令行的结构体。根据传参的内容、函数的返回值以及函数名称，即可简单的猜出这三个函数的作用： cmdline_stdin_new：传参为命令组以及提示符，返回值为一个 struct cmdline。联系下文中对空值的判定以及函数名，即可推断出此函数作用大致为传入命令组与提示符生成相对应命令行。 cmdline_interact：传参为 cmdline_stdin_new 函数生成的命令行，返回值不详。联系函数名可推断出此函数作用大致为开始与指定命令行的交互(interact)，即开始接收并解析命令。 cmdline_stdin_exit：传参为 cmdline_stdin_new 函数生成的命令行，返回值不详。联系函数名可推断出此函数作用大致为退出指定的交互式命令行。 &emsp;&emsp;接下来，将对初始化和退出这两个函数的流程和实现进行分析。&emsp; 二、初始化函数 cmdline_stdin_new()&emsp;&emsp;首选查看其定义，其定义位于lib/librte_cmdline/cmdline_socket.c。&emsp;&emsp;从上图源码中可以发现，此函数有两个传参，传参一为命令组，传参二为提示符。简单来看，函数中大概可以分为两部分，第一部分是对终端设置的操作，第二部分是调用了一个新的函数cmdline_new()。&emsp; 1. 终端设置&emsp;&emsp;首先看一下第一部分，一共是五行。 此行调用函数 tcgetattr，作用是获取指定终端的设置并储存至一个 termios 结构体内。此处传参一为0，即文件操作符为0的流，为此进程的标准输入流；传参二为获取到的内容储存的位置，为函数中声明的结构体 oldterm。 此行调用函数 memcpy，将 oldterm 中的内容(即上一行中获取到的设置)copy至 term 中。 此行为修改 term 中的输入模式标志 c_lflag，此处为关闭三个设置：ICANON(使用标准输入模式)、ECHO(显示输入字符)、ISIG(当输入INTR、QUIT、SUSP或DSUSP时，产生相应的信号)。 此行调用函数 tcsetattr，作用是设置终端参数。此函数的参数一为终端的文件描述符；参数二为用于控制修改起作用的时间；参数三为结构体 struct termios，其中储存了输入输出模式等设置参数。此处传参一为0，即此进程的标准输入流；传参二为 TCSANOW，代表不等数据传输完毕就立即改变属性；传参三为结构体 term，即上一行配置后的终端设置。 此行调用函数 setbuf，作用为设置用于流操作的内部缓冲区。此处传参一为标准输入流 stdin，传参二中缓冲区设置为 NULL，即关闭缓冲区。此处关闭缓冲区的意义我认为是方便后续及时对单个输入字符的处理。&emsp; 2. cmdline_new()&emsp;&emsp;接着来看一下第二部分，此处调用了函数cmdline_new()。首先查看一下这个函数的定义，其定义位于lib/librte_cmdline/cmdline.c。&emsp;&emsp;此函数的传参一共有四个，根据 cmdline_stdin_new 中的调用来看：传参一是命令组；传参二是提示符；传参三是输入描述符(传入fd为0，即本进程输入流)；传参四为输出描述符(传入fd为1，即本进程输出流)。 &emsp;&emsp;函数中首先是对命令组和提示符的合法性进行了非空判定。随后是 malloc 并 memset 了一块 cmdline 结构体大小的空间，用来储存申请的命令行数据。接着直接对 cmdline 结构体内容进行赋值，输入输出流设为传入的输入输出流，命令组设为传入的命令组。最后就是若干初始化命令行的函数，下面会挨个分析。&emsp; 2.1 rdline_init()&emsp;&emsp;首先看一下 rdline_init() 其定义位于 lib/librte_cmdline/cmdline_rdline.c。&emsp;&emsp;注释如下，我也加上了一部分内容方便理解： 123456789101112131415/** * Init fields for a struct rdline. Call this only once at the beginning * of your program. * 只需要在初始化rdline前执行一次 * \\param rdl A pointer to an uninitialized struct rdline * 参数一为一个未初始化的rdline，即用户申请的cmdline中包含的rdline * \\param write_char The function used by the function to write a character * 参数二为一个函数指针，指向用来写字符的函数 * \\param validate A pointer to the function to execute when the * user validates the buffer. * 参数三为一个函数指针，指向用户验证缓冲区时要执行的函数 * \\param complete A pointer to the function to execute when the * user completes the buffer. * 参数四为一个函数指针，指向用户完成缓冲区时要执行的函数 */ &emsp;&emsp;再次查看 cmdline_new() 中的调用，来确定三个函数的位置。另外可以看到此函数中return语句调用了函数 cirbuf_init()，接下来将对这四个函数进行分析。&emsp; 2.1.1 cmdline_write_char()&emsp;&emsp;其定义位于lib/librte_cmdline/cmdline.c。&emsp;&emsp;此函数中，首先是根据 rdline 获取到其所属的 cmdline，随后进行检测，当输出流中存在内容时，使用 write 函数进行单个字符的写入。&emsp; 2.1.2 cmdline_valid_buffer()&emsp;&emsp;其定义位于lib/librte_cmdline/cmdline.c。&emsp;&emsp;此函数中，首先是根据 rdline 获取到其所属的 cmdline，随后使用命令行解析函数 cmdline_parse() (此篇笔记中不对此函数进行分析)对传入的字符串进行解析，根据解析的结果进行验证和提示。&emsp; 2.1.3 cmdline_complete_buffer()&emsp;&emsp;其定义位于lib/librte_cmdline/cmdline.c。&emsp;&emsp;此函数中，首先是根据 rdline 获取到其所属的 cmdline，随后使用缓冲区操作函数 cmdline_complete_buffer() (此篇笔记中不对此函数进行分析)对缓冲区进行处理。&emsp; 2.1.4 cirbuf_init()&emsp;&emsp;其定义位于lib/librte_cmdline/cmdline_cirbuf.c。&emsp;&emsp;此函数的作用是初始化循环缓冲区。此处函数里主要是对 &amp;rdline-&gt;history 这部分初始化，包括大小、起始、缓冲区地址等。&emsp; 2.2 cmdline_set_prompt()&emsp;&emsp;在执行此函数前，cmdline_new() 中先执行 cl-&gt;rdl.opaque = cl;，作用是将 cmdline cl 中含有的 rdline rdl 与其所属 cmdline cl 绑定。随后来看函数cmdline_set_prompt()，其定义位于lib/librte_cmdline/cmdline.c。&emsp;&emsp;此处的传参二为命令行提示符，此处的主要作用就是将提示符设置进 cmdline 中。这里使用格式化写入函数 snprintf，将提示符写入 cmdline-&gt;prompt 部分。&emsp; 2.3 rdline_newline()&emsp;&emsp;其定义位于lib/librte_cmdline/cmdline_rdline.c。&emsp;&emsp;此函数里主要是对 rdline 中的元素进行初始化，包括左右缓冲区(rdline-&gt;left&#x2F;right)和 rdline 对应的提示符相关内容等。&emsp;&emsp;这里值得一提的是 write_char 函数实际是 2.1.1 cmdline_write_char() 传入的函数，所以这里的实际操作是将输出流内的内容存入rdline-&gt;prompt。我思考了一下这部分的逻辑，觉得应该是为了让输出流中的提示符与 rdline 中的提示符相对应，也有可能是为了清除缓冲区。&emsp;&emsp;&emsp;至此，初始化函数 cmdline_stdin_new() 结束，可以看到其中主要流程为： 对终端之前的设置进行保存，设置三个终端选项。 cmdline 的初始化，设定输入输出流、命令组以及提示符等。 rdline 的初始化，设定三个回调函数(写字符、检测、完成)，对历史命令缓冲区、左右缓冲区进行初始化，以及对提示符的设定等。&emsp; 三、交互函数 cmdline_interact() (略过)&emsp;&emsp;本篇笔记主要记录初始化和退出部分，解析部分暂且略过，在之后的笔记中记录分析。&emsp; 四、退出函数 cmdline_stdin_exit()&emsp;&emsp;首选查看其定义，其定义位于lib/librte_cmdline/cmdline_socket.c。&emsp;&emsp;其中函数 tcsetattr 的作用是设置linux下终端参数。此函数的参数一为终端的文件描述符；参数二为用于控制修改起作用的时间；参数三为结构体 struct termios，其中储存了输入输出模式等设置参数。具体含义如下： 参数一为 fileno(stdin)，其中 fileno() 的作用是获取传参流的文件描述符，此处传入输入流 stdin 并获取到其文件操作符。 参数二为 TCSANOW，代表不等数据传输完毕就立即改变属性。 参数三为 &amp;c1-&gt;oldterm，为在调用 cmdline_stdin_new 创建 cmdline 时保存的未修改的终端设置，即交互式命令行创建之前的终端设置。 &emsp;&emsp;所以，退出函数 cmdline_stdin_exit 的实际操作仅仅是恢复了创建交互式命令行之前的终端设置。&emsp; 五、总结&emsp;&emsp;总的来说，dpdk中这部分源码非常严谨，参数、宏非常多。其中一些概念，比如说vt100，我也是搜了一下才知道是什么。&emsp;&emsp;源码中对 cmdline 和 rdline 结构体的定义，都可以说是非常的“庞大”，本篇笔记中记录的初始化和退出相关的内容，涉及到非常多的函数，但实际上都是为了初始化这两个结构体。发现了这一点之后，再汇总一下初始化的内容，整体就非常清晰了。&emsp;&emsp;其中一些对流的操作，我还是没有理解透彻，比如说 rdline_newline() 中为何要执行 rdl-&gt;write_char()，在接下来我应该会再去更深入的了解一下linux下流的内容，来理解源码中的意图和意义。当然，这系列中还剩最后也是最重要的一部分——命令解析，在下一篇中会进行分析。","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"}],"tags":[{"name":"源码阅读","slug":"源码阅读","permalink":"https://zgg2001.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"},{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/tags/C-C/"},{"name":"dpdk","slug":"dpdk","permalink":"https://zgg2001.github.io/tags/dpdk/"}]},{"title":"golang学习记录：二进制文件判断实现与思路","slug":"20211024_golang学习记录：二进制文件判断实现与思路","date":"2021-10-24T03:55:51.000Z","updated":"2021-10-24T03:55:51.000Z","comments":true,"path":"2021/10/24/20211024_golang学习记录：二进制文件判断实现与思路/","permalink":"https://zgg2001.github.io/2021/10/24/20211024_golang%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E5%88%A4%E6%96%AD%E5%AE%9E%E7%8E%B0%E4%B8%8E%E6%80%9D%E8%B7%AF/","excerpt":"go version go1.15.14 linux&#x2F;amd64 相关项目地址为：点我跳转 一、前言&emsp;&emsp;最近在写一个golang实现的字符串搜索与替换程序练手，其中一个很大的问题就是程序不能识别二进制文件与文本文件，导致搜索出来的内容会乱码，非常的不雅观。如果再不小心替换一下的话，就会造成很大的影响，所以这个问题必须解决。 &emsp;&emsp;我简单看了一下相关的标准库函数，发现golang标准库内并没有提供相关的函数来实现分辨二进制文件的功能。于是学习了一下编码相关的知识来自己实现一个二进制文件判断的功能。","text":"go version go1.15.14 linux&#x2F;amd64 相关项目地址为：点我跳转 一、前言&emsp;&emsp;最近在写一个golang实现的字符串搜索与替换程序练手，其中一个很大的问题就是程序不能识别二进制文件与文本文件，导致搜索出来的内容会乱码，非常的不雅观。如果再不小心替换一下的话，就会造成很大的影响，所以这个问题必须解决。 &emsp;&emsp;我简单看了一下相关的标准库函数，发现golang标准库内并没有提供相关的函数来实现分辨二进制文件的功能。于是学习了一下编码相关的知识来自己实现一个二进制文件判断的功能。 二、思路&emsp;&emsp;文本文件其实本质也是二进制文件，只不过可以被计算机内置的编码方式来解读为可阅读的文本。所以本文中需要解决的问题实质为如何识别出无法被正常编码的文件。 &emsp;&emsp;总所周知，ASCII为最初的编码方式，故基础字母数字和操作符都可以按照ASCII标准被编码。但是查看ASCII编码中的内容，可以发现其中一些内容是不可读的，比如编码为0-6的一些状态符。假如文件中出现了这类编码，那么肯定此文件不是正常的可读文本文件，即二进制文件。 &emsp;&emsp;简单看一下ASCII表的内容，可以总结出正常的可视编码为32~127、\\r(13)、\\n(10)、\\t(9)，那么当文件中所有的字节都属于这个范围时，则此文件必定可以按ASCII编码正常显示，则为文本文件。 &emsp;&emsp;但是这仅仅是英文，在文件中常常会出现中文等内容。对此，需要将常见的Unicode编码、GBK编码或者UTF8等编码考虑进去。这三种编码方式都是在ASCII编码的基础上实现的，其主要原理就是将ASCII编码中未使用的128~255范围进行使用，再使用多字节来组合出不同的内容。其均默认一个共识，即低字节(0-127)保持ASCII原本的内容，高字节(128-255)为新编码方式中定义的内容。 故将白名单编码范围扩展到32~255即可，主要的辨别对象还是0~31中的内容。 &emsp;&emsp;故，主要的思路即为判定字节的内容，若存在非常规内容，即可进行判定。 三、实现&emsp;&emsp;我本来是直接遍历文件的前100个字节，若属于32~255、\\r(13)、\\n(10)、\\t(9)则continue，否则则说明为二进制文件。但是这样在实际中存在一些问题。比如说100个字节可以不够，即可能文件的前100个字符都是正常的。另外判定方式也有一些参差，比如说\\a响铃符也是可能存在的(之前我就写过音乐软件练手)。&emsp;&emsp;初版写法如上，此种写法可以识别大多数的二进制文件，但是也有部分的漏网之鱼，所以还存在改进的空间。 &emsp;&emsp;然后今天我抽空上网冲浪了一会，找到了一种更全面的算法(zlib的算法)，本文中的最终版本识别二进制文件也是使用的这种算法，算法内容如下： 将一个字节的内容分为三类，白名单中包括32~255、\\r(13)、\\n(10)、\\t(9)；灰名单中包括\\a(7)、\\b(8)、\\v(11)、\\f(12)、 sub(26)、esc(27)；黑名单中包括0~6、14~31 如果文件包含至少一个白名单中的字节，而且不包含黑名单中的字节，其即为文本文件；否则则为二进制文件 &emsp;&emsp;算法主要就是上面那个，很简单，但是判定了空文件等若干情况。在此次的完善中，我规定的读取范围为前1024个字节，因为之前实现中100个字节有些少，但是全文读取又会影响效率，所以读取1024个字节。核心的判定算法更改为上文中的那个。代码如下：(github地址：点我跳转) 1234567891011121314151617181920212223242526272829303132333435363738package detectimport ( &quot;os&quot; &quot;log&quot; &quot;bufio&quot;)func DetectBinary(path string) bool &#123; file, err := os.Open(path) if err != nil &#123; ┊ log.Printf(&quot;\\033[31merror : IO error - \\033[0m%s&quot;, err) ┊ return false &#125; defer file.Close() r := bufio.NewReader(file) buf := make([]byte, 1024) n, err := r.Read(buf) var white_byte int = 0 for i := 0; i &lt; n; i++ &#123; ┊ if (buf[i] &gt;= 0x20 &amp;&amp; buf[i] &lt;= 0xff) || ┊ ┊ buf[i] == 9 || ┊ ┊ buf[i] == 10 || ┊ ┊ buf[i] == 13 &#123; ┊ ┊ white_byte++ ┊ &#125; else if buf[i] &lt;= 6 || (buf[i] &gt;= 14 &amp;&amp; buf[i] &lt;= 31) &#123; ┊ ┊ return true ┊ &#125; &#125; if white_byte &gt;= 1 &#123; ┊ return false &#125; return true&#125; &emsp;&emsp;如上即为实现，返回值为true即为二进制文件。就我进行的测试来看，可以很好的判定二进制文件。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://zgg2001.github.io/categories/Golang/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://zgg2001.github.io/tags/Linux/"},{"name":"Golang","slug":"Golang","permalink":"https://zgg2001.github.io/tags/Golang/"}]},{"title":"dpdk源码分析：交互式命令行的实现(一) 命令添加","slug":"20211014_dpdk源码分析：交互式命令行的实现(一)命令添加","date":"2021-10-14T11:53:28.000Z","updated":"2021-10-14T11:53:28.000Z","comments":true,"path":"2021/10/14/20211014_dpdk源码分析：交互式命令行的实现(一)命令添加/","permalink":"https://zgg2001.github.io/2021/10/14/20211014_dpdk%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E5%AE%9E%E7%8E%B0(%E4%B8%80)%E5%91%BD%E4%BB%A4%E6%B7%BB%E5%8A%A0/","excerpt":"在实习的时候就对dpdk中 cmdline 的实现方式感兴趣，苦于待干的事情太多，一直没有空记录。 最近抽出时间准备进行一次较为深入的分析，来看一下dpdk是如何使用c语言来实现 cmdline 的. 本文中使用的dpdk库版本为：16.04","text":"在实习的时候就对dpdk中 cmdline 的实现方式感兴趣，苦于待干的事情太多，一直没有空记录。 最近抽出时间准备进行一次较为深入的分析，来看一下dpdk是如何使用c语言来实现 cmdline 的. 本文中使用的dpdk库版本为：16.04 一、分析1. 从一段代码入手本段代码摘自 app/test-pmd/cmdline.c，这是dpdk例程 testpmd 其中的一个命令实现。 123456789101112131415161718192021222324252627282930313233343536373839/* *** SHOW PORT INFO *** */struct cmd_showport_result &#123; cmdline_fixed_string_t show; cmdline_fixed_string_t port; cmdline_fixed_string_t what; uint8_t portnum;&#125;;static void cmd_showport_parsed(void *parsed_result, __attribute__((unused)) struct cmdline *cl, __attribute__((unused)) void *data)&#123; struct cmd_showport_result *res = parsed_result; ...若干实现&#125;cmdline_parse_token_string_t cmd_showport_show = TOKEN_STRING_INITIALIZER(struct cmd_showport_result, show, &quot;show#clear&quot;);cmdline_parse_token_string_t cmd_showport_port = TOKEN_STRING_INITIALIZER(struct cmd_showport_result, port, &quot;port&quot;);cmdline_parse_token_string_t cmd_showport_what = TOKEN_STRING_INITIALIZER(struct cmd_showport_result, what, &quot;info#stats#xstats#fdir#stat_qmap#dcb_tc&quot;);cmdline_parse_token_num_t cmd_showport_portnum = TOKEN_NUM_INITIALIZER(struct cmd_showport_result, portnum, UINT8);cmdline_parse_inst_t cmd_showport = &#123; .f = cmd_showport_parsed, .data = NULL, .help_str = &quot;show|clear port info|stats|xstats|fdir|stat_qmap|dcb_tc X (X = port number)&quot;, .tokens = &#123; (void *)&amp;cmd_showport_show, (void *)&amp;cmd_showport_port, (void *)&amp;cmd_showport_what, (void *)&amp;cmd_showport_portnum, NULL, &#125;,&#125;; &emsp;&emsp;这便是 testpmd 中一个很关键的命令 show port info X 的实现。其中可以发现上面的实现，从上到下可以分为四个部分： 一个 struct 定义，其中储存着命令行中输入命令的参数。这段源码中即为 struct cmd_showport_result，其中储存着三个 string，一个 int 成员。这四个成员则依次对应 show port info X 这四个部分。 一个回调函数，其中对命令输入的内容进行处理，命令功能的实现就在这个函数里。从上面的源码里可以看出此函数的第一个传参为输入命令解析后的结果，其类型是第一部分 struct 的结构体指针。 若干 cmdline_parse_token，与第一部分 struct 定义的内容相关。 一个被封装好的类型 cmdline_parse_inst_t，一共有四个参数，其中第一个参数为第二部分的函数，第二个部分为空，第三部分为帮助信息 help_str，第四部分为第三部分新建的若干令牌 cmdline_parse_token。 &emsp;&emsp;接下来将从第四部分，最关键的 cmdline_parse_inst_t 来分析。&emsp; 2. 命令类型 cmdline_parse_inst_t&emsp;&emsp;cmdline_parse_inst_t 的定义在 lib/librte_cmdline/cmdline_parse.h 中，内容如上，可以看到其是将结构体 cmdline_inst 封装后的类型。联系上文内容以及此段代码内的注释，dpdk cmdline 中命令的类型已经大致清楚。 &emsp;&emsp;在 dpdk cmdline 中，每一个 cmdline_parse_inst_t 都代表一个命令，其包含有四个成员。第一个成员为一个回调函数，内容为此条命令需要执行的内容。第三个成员为帮助信息 help_str，在按tab或是help的时候，则会补全或是弹出相关信息。第四个成员即为一个令牌数组，其中储存着命令中的参数，这块内容接下来会进行分析。&emsp; 3. 令牌类型 cmdline_parse_token_hdr_t&emsp;&emsp;cmdline_token_hdr_t 的定义也在 lib/librte_cmdline/cmdline_parse.h 中，内容如上。 &emsp;&emsp;cmdline_token_hdr_t 是对结构体 cmdline_token_hdr 封装后的类型，其中共有两个成员。其中一个是结构体 cmdline_token_ops 的指针，另一个是 uint 类型的偏移量。通过注释可以得知，此处的偏移量为解析结果存入结构的位置，但是 ops 结构体还是不知道是什么东西。&emsp; 4. 结构体 cmdline_token_ops&emsp;&emsp;cmdline_token_ops 的定义仍在 lib/librte_cmdline/cmdline_parse.h 中，内容如上。 &emsp;&emsp;ops 结构体里含义四个回调函数，是比较复杂的…粗略来看，需要自定义一些回调函数来实现不同种类令牌的解析与补全等操作。这四个回调函数的具体内容这里不再赘述，预计会单独开一篇记录来分析 cmdline_token_ops 结构体内的回调函数的功能、流程和思路。 &emsp;&emsp;从这里以及前文可以得知一个东西，那就是根据令牌类型的不同，某些回调函数的实现也存在差异。比如说最开始摘出的代码，其对 uint8 类型令牌的定义流程如下： 12345678910111213141516struct cmd_showport_result &#123; ... uint8_t portnum;&#125;;...cmdline_parse_token_num_t cmd_showport_portnum = TOKEN_NUM_INITIALIZER(struct cmd_showport_result, portnum, UINT8);...cmdline_parse_inst_t cmd_showport = &#123; ... .tokens = &#123; ... (void *)&amp;cmd_showport_portnum, NULL, &#125;,&#125;; &emsp;&emsp;可以看到，在 uint8 令牌的创建流程中，令牌的类型是 cmdline_parse_token_num_t，而不是 cmdline_parse_token_hdr_t，且在构造中使用了宏函数 TOKEN_NUM_INITIALIZER。在向命令结构体 cmd_showport 中传递上面生成好的令牌时，使用 (void*) 进行强制转换来避免类型上的不匹配。这样可以保证多种类型共用一个 cmdline_parse_token_hdr_t 接口，我感觉这有点C语言多态的感觉。&emsp;目前来看，cmdline 中的令牌类型一共有以下四种，接下来将来简单看一下这四种类型的实现方法。 字符串令牌：匹配静态字符串，静态字符串列表或任何字符串。 数字令牌：匹配一个可以签名或无符号的数字，从8位到32位。 IP地址令牌：匹配IPv4或IPv6地址或网络。 以太网*地址令牌：匹配MAC地址。&emsp; 5. 子令牌类型 以 cmdline_parse_token_num_t 为例相关路径为：lib/librte_cmdline/cmdline_parse_num.h&emsp;&emsp;可以看到在num类型的令牌结构体中，其中包含有两个成员，第一个为一个 cmdline_token_hdr 结构体(即总令牌结构体，其中包含一个ops结构体和一个偏移量)，第二个则是一个 cmdline_token_num_data 结构体，其定义如下。&emsp;&emsp;cmdline_token_num_data 结构体中存储着一个枚举类型 type，即为num的具体类型，可以看到支持8到64位的无符号&#x2F;有符号整型。&emsp;&emsp;最上面的样例代码中，一个num类型的令牌是按如上的步骤来生成的，此令牌的类型即为 cmdline_parse_token_num_t，然后等号后是一个宏函数，传入参数为命令结果结构体、该令牌对应的结构体中的参数以及该令牌中的 numtype。其中宏函数的定义如下：&emsp;&emsp;其中hdr相关内容中，ops结构体是已经定义好的 cmdline_token_num_ops，这是依据num类型令牌定制的ops结构体。下面就是offset偏移量，其为一个宏函数，定义为 #define offsetof(type, field) ((size_t) &amp;( ((type *)0)-&gt;field) )，通过这个宏函数，即可计算出指定成员在其所属结构体内的位置，实现的非常优雅可以说。然后最后则是一个numtype，储存具体类型。 &emsp;&emsp;等于说子令牌类型，相比于令牌类型 cmdline_parse_token_hdr_t 来讲，在hdr结构体的基础上，增加了一个type。而在传的时候，用一个 (void*) 来进行强制转换，个人感觉算是一种C风格的向上转型吧。 总结：每个子令牌类型都有其独特的ops结构体，储存在hdr结构体中；hdr结构体中还有一个offset，来储存指定成员的位置，从而可以把处理结果放进成员中。另外还存在一个type来储存类型的具体内容，从而配合ops中定制的回调函数。 &emsp; 二、新增命令流程总结1. 新建命令结构体&emsp;&emsp;如下新建命令结构体 test，定义其回调函数为 fun_test，其 token 令牌仅一个，为 cmd_test。 123456789cmdline_parse_inst_t test = &#123; .f = fun_test, .data = NULL, .help_str = &quot;这里是帮助信息&quot;, .tokens = &#123; (void *)&amp;cmd_test, NULL, &#125;,&#125;; 2. 新建命令参数结构体&emsp;&emsp;如下新建命令参数结构体 test_result，其中只含一个 string 类型的成员 cmd。 123struct test_result &#123; cmdline_fixed_string_t cmd;&#125;; 3. 生成相关令牌&emsp;&emsp;如下生成 string 类型令牌 cmd_test，其对应的命令为 test。 12cmdline_parse_token_string_t cmd_test = TOKEN_STRING_INITIALIZER(struct test_result, cmd, &quot;test&quot;); 4. 编写回调函数&emsp;&emsp;如下编写回调函数 fun_test，规定当输入命令 test 后的操作。 1234567static void fun_test(void *parsed_result, __attribute__((unused)) struct cmdline *cl, __attribute__((unused)) void *data)&#123; struct test_result *res = parsed_result; ...若干实现&#125; &emsp;&emsp;由此，一个新的命令就添加完毕了。这就是添加命令的大致流程，只不过例子中的参数较少，所以比较简略，而且省去了最难的回调函数的编写过程。&emsp; 三、总结&emsp;&emsp;三个月前第一次看dpdk的源码时，可以说是看的非常艰难，其中各式各样的回调函数，以及封装了一层又一层的类型可以说是最大的阻碍。而且其中还包含不少关于硬件的知识点，我当时可以说是一窍不通。但是三个月的实习中，我逐渐是了解一些基础的内容，可以说是逐渐理解了编写的思路和一些知识点。&emsp;&emsp;dpdk的源码中，使用C实现了不少类似于多态、接口的东西，从中我学习到了很多C的写法，可以说令我叹为观止。目前我准备先研究一下cmdline的实现，看一下dpdk中是如何解析和传递命令的，剩下的(大部分)内容应该会简单了解，对有兴趣的点再尝试深入一点分析。","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"}],"tags":[{"name":"源码阅读","slug":"源码阅读","permalink":"https://zgg2001.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"},{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/tags/C-C/"},{"name":"dpdk","slug":"dpdk","permalink":"https://zgg2001.github.io/tags/dpdk/"}]},{"title":"C/C++学习记录：std::forward 源码分析 / 完美转发的作用","slug":"20211011_C-C++学习记录：std::forward源码分析-完美转发的作用","date":"2021-10-11T01:55:44.000Z","updated":"2021-10-11T01:55:44.000Z","comments":true,"path":"2021/10/11/20211011_C-C++学习记录：std::forward源码分析-完美转发的作用/","permalink":"https://zgg2001.github.io/2021/10/11/20211011_C-C++%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9Astd::forward%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%9A%84%E4%BD%9C%E7%94%A8/","excerpt":"抽空扣一点感兴趣的标准库源码，这里总结一下 std::forward() 相关的分析 本文中 gcc version: 8.4.1 20200928 (Red Hat 8.4.1-1) (GCC) 其中c++库安装路径为 /usr/include/c++/8","text":"抽空扣一点感兴趣的标准库源码，这里总结一下 std::forward() 相关的分析 本文中 gcc version: 8.4.1 20200928 (Red Hat 8.4.1-1) (GCC) 其中c++库安装路径为 /usr/include/c++/8 一、前言&emsp;&emsp;本文是基于前文 C&#x2F;C++学习记录：std::move 源码分析 进行的。前文中分析了 std::move 的源码，其中涉及到的一些东西，比如说： 类型提取结构体 std::remove_reference C++标准转换运算符 static_cast 引用折叠的概念 &emsp;&emsp;上面这三个东西在 std::forward() 中也有应用，因此在本文中也就不过多分析，这些东西的分析在上文中均可找到。点我跳转 &emsp;&emsp;本文中仅记录上文中未提及的关于 std::forward() 的思路和写法，以及个人对完美转发这一概念的理解。&emsp; 二、源码与分析1. std::forward 源码总览&emsp;&emsp;std::forward() 的定义位于 /usr/include/c++/8/bits/move.h 中，详细内容如下：&emsp;&emsp;可以看到在源码中，函数 std::forward 有两种实现，差别在于传参的类型，前者接收的传参是一个左值，而后者接收的传参是一个右值。另外在传右值的版本中存在一个静态断言，这也算是两者的区别之一吧。&emsp; 2. std::forward 分析&emsp;&emsp;还是先代入不同的类型来化简 std::forward 函数。&emsp;&emsp;当模板类型 _Tp 为 string&amp; 时，即 string 的左值引用时，std::forward 可以化简为如下形式： 123456789101112//string&amp; &amp;&amp; 引用折叠为 string&amp;//std::remove_reference 提取出的类型为stringstring&amp;forward(string&amp; __t)&#123; return static_cast&lt;string&amp;&gt;(__t); &#125;string&amp;forward(string&amp;&amp; __t)&#123; //此处静态断言忽略 return static_cast&lt;string&amp;&gt;(__t);&#125; &emsp;&emsp;而当模板类型 _Tp 为 string&amp;&amp; 时，即 string 的右值引用时，std::forward 可以化简为如下形式： 123456789101112//string&amp;&amp; &amp;&amp; 引用折叠为 string&amp;&amp;//std::remove_reference 提取出的类型为stringstring&amp;&amp;forward(string&amp; __t)&#123; return static_cast&lt;string&amp;&amp;&gt;(__t); &#125;string&amp;&amp;forward(string&amp;&amp; __t)&#123; //此处静态断言忽略 return static_cast&lt;string&amp;&amp;&gt;(__t);&#125; &emsp;&emsp;可以看到，当传入类型为左值引用时，返回值为 string&amp; : return static_cast&lt;string&amp;&gt;(__t);；当传入类型为右值引用时，返回值为 string&amp;&amp; : return static_cast&lt;string&amp;&amp;&gt;(__t);。这就实现了 std::forward 的功能，即完美转发。简单点来讲就是传入左值返回还是左值，传入右值返回还是右值，保持原来的值属性不变。std::forward 就相当于一个转发点，可以将类型原封不动的转发走。&emsp; 三、完美转发&emsp;&emsp;上文中说到 std::forward 的功能，即完美转发。那么，何时需要它的存在呢？ 通过下面这个例子我觉得可以很好的说明：执行结果如下： &emsp;&emsp;可以看到，当传参为左值时，直接转发和完美转发的结果都是左值，是正确的。但是当传参是右值时，直接转发和完美转发的结果却不同了。&emsp;&emsp;分析其原因，当一个右值作为传参被传入后，函数内便会分配栈空间来保存传参。此时的右值已经被传参中的变量名所指向，所以再次传入此右值时，实际传入的是指向它的变量名，即一个左值。所以会出现上图中传参为右值但是直接转发却为左值的情况。&emsp;&emsp;std::forward 完美转发的大致应用场景便是上面那种，当存在中间转发点时，如果想要保持原来类型，则可以使用 std::forward 来实现。比如写一个筛选站，符合条件放 vector1 里，不符合放 vector2 里，总所周知 vector 在 push_back 右值的时候会调用 emplace_back，它可以直接拿走右值，提高效率。所以为了可以正确的把右值push进去，就得使用std::forward 来进行完美转发。&emsp; 四、总结&emsp;&emsp;总的来说，std::forward 可以说是对模板、引用折叠特性的一个巧妙利用。它和 std::move 的思路上有很大的相似之处，实现上也可以说是很相似。&emsp;&emsp;之前说实话，对模板用的并不算太多，仅仅实现了一些小东西。但是目前管中窥豹，了解了自己对于模板方面的不足，之后应该会写一些东西来熟悉，比如说尽力按STL标准写个跳表之类的。总之在模板方面还是有很大的进步空间。","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"C++标准库学习","slug":"C-标准库学习","permalink":"https://zgg2001.github.io/tags/C-%E6%A0%87%E5%87%86%E5%BA%93%E5%AD%A6%E4%B9%A0/"},{"name":"源码阅读","slug":"源码阅读","permalink":"https://zgg2001.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"}]},{"title":"C/C++学习记录：std::move 源码分析","slug":"20211010_C-C++学习记录：std::move 源码分析","date":"2021-10-10T06:15:11.000Z","updated":"2021-10-10T06:15:11.000Z","comments":true,"path":"2021/10/10/20211010_C-C++学习记录：std::move 源码分析/","permalink":"https://zgg2001.github.io/2021/10/10/20211010_C-C++%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9Astd::move%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"抽空扣一点感兴趣的标准库源码，这里总结一下 std::move() 相关的分析 本文中 gcc version: 8.4.1 20200928 (Red Hat 8.4.1-1) (GCC) 其中c++库安装路径为 /usr/include/c++/8","text":"抽空扣一点感兴趣的标准库源码，这里总结一下 std::move() 相关的分析 本文中 gcc version: 8.4.1 20200928 (Red Hat 8.4.1-1) (GCC) 其中c++库安装路径为 /usr/include/c++/8 一、源码与分析1. std::move 源码总览&emsp;&emsp;std::move() 的定义位于 /usr/include/c++/8/bits/move.h 中，详细内容如下：&emsp;&emsp;可以看到 std::move 的定义只有短短4行… &emsp;&emsp;第二行和第三行关键字 constexpr 和 noexcept 都是c++11的新增关键字。其中 constexpr 把后面的 typename 声明为常量表达式，便于编译器对代码进行优化 。而 noexcept 则声明此函数不会抛出异常，遇到问题直接调用 std::terminate 退出进程。这两个关键字可以说是为规范和优化 std::move 而存在的，对其实现并无参与，所以这里跳过这俩关键字，不做过多分析。 &emsp;&emsp;此外还存在两个东西：类型提取结构体 std::remove_reference 和 C++标准转换运算符static_cast 下面单独进行分析。&emsp; 2. std::remove_reference 源码分析&emsp;&emsp;std::remove_reference 的定义位于 /usr/include/c++/8/type_traits 中，详细内容如下：&emsp;&emsp;可以看到，std::remove_reference 结构体的实现非常简单，功能就是依靠模板把传参 _Tp 的类型分离出来，当调用 std::remove_reference::type 时即为分离出的最底层类型。 测试如下内容：结果如下：说明 std::remove_reference 可以很好的将类型提取出来，即 int&amp; 和 int&amp;&amp; 都可以提取出基础类型 int&emsp; 3. static_cast 分析&emsp;&emsp;static_cast 也是c++11中的新特性，简单来说用处就是类型转换。语法为： 1static_cast&lt;新类型&gt;(表达式) &emsp;&emsp;其返回值为 “新类型” 类型的值，例如 n = static_cast&lt;int&gt;(3.14) 后，此时 n = 3。我个人认为可以粗略的将 static_cast 当作一个更高级的强制类型转换，相比传统的强制类型转换，static_cast 会对转换类型进行检测，所以相对更加安全。&emsp;&emsp;可以说，任何具有明确定义的类型转换，只要不包含底层const，都可以使用 static_cast。&emsp; 4. std::move 分析&emsp;&emsp;由上文可知两个关键内容的作用，则可首先带入一个实例来化简分析 std::move 的实际作用。 首先是一小部分代码： 123std::string s = &quot;Hello&quot;;std::vector&lt;std::string&gt; v;v.push_back(std::move(s)); 根据 std::move 的流程，std::move(s) 中的 return 语句执行过程如下： 123456string&amp;&amp; move(string&amp; &amp;&amp; t) //此处string&amp; &amp;&amp;等于string&amp;，下文会提及&#123;1. return static_cast&lt;typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(__t);2. return static_cast&lt;typename std::remove_reference&lt;string&amp;&gt;::type&amp;&amp;&gt;(s);//提取出基础类型string3. return static_cast&lt;string&amp;&amp;&gt;(s)&#125; 所以，某种意义上来说，std::move(lvalue) 就约等于 static_cast&lt;T&amp;&amp;&gt;(lvalue)，即将左值强制转换为右值。而 std::move 中封装了一个类型提取器 std::remove_reference 来方便使用。&emsp; 5. std::move 中的引用折叠&emsp;&emsp;通过上文的内容，可以发现 std::move 中的传参类型为 _Tp&amp;&amp; ，如下： 1234template&lt;typename _Tp&gt; constexpr typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp; move(_Tp&amp;&amp; __t) noexcept &#123; return static_cast&lt;typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(__t); &#125; &emsp;&emsp;那么，在执行过程中，传参s的类型是什么呢？&emsp;&emsp;由于传参类型为 _Tp&amp;&amp;，那么当传参类型为 string&amp;(即左值) 时，当时的场景则为： 12std::string s = &quot;Hello&quot;;std::move(s) =&gt; std::move(string&amp; &amp;&amp;) &emsp;&emsp;此时的类型 string&amp; &amp;&amp; 又是什么？此处便涉及到了引用折叠。概念如下，简单来说就是除了右值的&amp;&amp;是右值，其他都是左值。 X&amp; &amp;、X&amp;&amp; &amp;、X&amp; &amp;&amp; —— 折叠成X&amp;，用于处理左值 X&amp;&amp; &amp;&amp; —— 折叠成X&amp;&amp;，用于处理右值 &emsp;&emsp;引用折叠的意义就是让参数可以与任何类型的实参匹配，简单说就是右值传进来还是右值，左值传进来还是左值。例如上文传进来的就是左值，最后还是左值；如果传进来的是右值则最终还是右值。另外我粗略看了下 forward 的源码，其实它实现完美转发也是很大程度依赖于引用折叠这个东西。&emsp; 二、总结&emsp;&emsp;C++的标准库源码依旧封装的很”繁琐”，以及配着贼长的命名。当然 std::move 这个函数还好，涉及的东西不算太多，所以看着还是非常清晰的。之前看智能指针源码才是真的给我看的烦躁无比。&emsp;&emsp;小结一下，std::move 中只进行了一个类型转换，而各种所谓右值数据迁移基本都是在构造函数中实现的。&emsp;&emsp;总的来说标准库里的源码写的还是相对很严谨和标准的，很多思路和写法确实能让我学到很多。接下来我准备再去仔细研究一下 forward 的实现和思路。当然 std::move 里那个最关键的 static_cast 我还是没有深入的探索，只是浅尝辄止，可能等未来实力和精力足够再来一探究竟吧。","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"C++标准库学习","slug":"C-标准库学习","permalink":"https://zgg2001.github.io/tags/C-%E6%A0%87%E5%87%86%E5%BA%93%E5%AD%A6%E4%B9%A0/"},{"name":"源码阅读","slug":"源码阅读","permalink":"https://zgg2001.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"}]},{"title":"linux学习记录：记一次手动编译安装组件的过程","slug":"20210920_linux学习记录：记一次手动编译安装组件的过程","date":"2021-09-20T15:37:04.000Z","updated":"2021-09-20T15:37:04.000Z","comments":true,"path":"2021/09/20/20210920_linux学习记录：记一次手动编译安装组件的过程/","permalink":"https://zgg2001.github.io/2021/09/20/20210920_linux%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%89%8B%E5%8A%A8%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E7%BB%84%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B/","excerpt":"&emsp;&emsp;本次安装的组件为 Apache HTTP Server，本篇笔记中记录了全部过程，以供参考。&emsp;&emsp;apache组件的依赖项比较多，所以安装起来会繁杂一点，不过流程都是大同小异。本次升级中采用的是源码手动编译升级的方法，原因是遇到过没有rpm的系统…所以还是自己操作更踏实点。","text":"&emsp;&emsp;本次安装的组件为 Apache HTTP Server，本篇笔记中记录了全部过程，以供参考。&emsp;&emsp;apache组件的依赖项比较多，所以安装起来会繁杂一点，不过流程都是大同小异。本次升级中采用的是源码手动编译升级的方法，原因是遇到过没有rpm的系统…所以还是自己操作更踏实点。 零、安装目录总结&emsp;&emsp;linux下常见的有三个和库有关系的目录，分别是/lib、/usr/lib和/usr/local/lib。其中usr并不是user的缩写，而是unix system resource的缩写，即系统资料。 &emsp;&emsp;那么这三个目录有何区别？简单来说，/lib是内核级的, /usr/lib是系统级的, /usr/local/lib是用户级的。其中/lib中包含的基本上都是/bin和/sbin中程序所使用的库，而另外两个其中就存放了很多用于用户程序的库。 &emsp;&emsp;这次安装的Apache HTTP Server，是用来构建web服务器的，所以很明显是用户级的。由此相关组件我均安装至/usr/local/lib下。 一、安装依赖项&emsp;&emsp;Apache HTTP Server主要是有三个依赖项apr、apr-util和pcre，所以需要先行安装。下面会记录安装的过程。 1. apr下载并解压apr库，这里选择的版本是1.7.0 12$ wget http://archive.apache.org/dist/apr/apr-1.7.0.tar.gz$ tar -zxf apr-1.7.0.tar.gz 进入目录并使用configure配置makefile，这里选择的目标路径为/usr/local/lib/apr 12$ cd apr-1.7.0/$ ./configure --prefix=/usr/local/lib/apr 编译 1$ make 安装 1$ make install 进入/usr/local/lib即可查看到apr目录 12$ cd /usr/local/lib$ ll | grep apr 2. apr-util下载并解压apr-util库，这里选择的版本是1.6.1 12$ wget http://archive.apache.org/dist/apr/apr-util-1.6.1.tar.gz$ tar -zxf apr-util-1.6.1.tar.gz 进入目录并使用configure配置makefile，选择目标路径为/usr/local/lib/apr-util，并配置apr路径为/usr/local/lib/apr 12$ cd apr-util-1.6.1/$ ./configure --prefix=/usr/local/lib/apr-util --with-apr=/usr/local/lib/apr 编译 1$ make 此时出现报错如下，提示确实头文件expat.h，经查询原因为缺少expat库 123xml/apr_xml.c:35:10: fatal error: expat.h: No such file or directory #include &lt;expat.h&gt; ^~~~~~~~~ 安装expat库 (下载地址为 https://github.com/libexpat/libexpat/releases ) 12345$ tar -zxf expat-2.4.1.tar.gz$ cd expat-2.4.1/$ ./configure$ make$ make install 再次编译 apr-util 1$ make 安装 1$ make install 进入/usr/local/lib即可查看到apr-util目录 12$ cd /usr/local/lib$ ll | grep apr-util 3. pcre下载并解压pcre库，这里选择的版本是1.7.0 12$ wget http://jaist.dl.sourceforge.net/project/pcre/pcre/8.45/pcre-8.45.tar.gz$ tar -zxf pcre-8.45.tar.gz 进入目录并使用configure配置makefile，这里选择的目标路径为/usr/local/lib/pcre 12$ cd pcre-8.45/$ ./configure --prefix=/usr/local/lib/pcre 编译 1$ make 安装 1$ make install 进入/usr/local/lib即可查看到pcre目录 12$ cd /usr/local/lib$ ll | grep pcre &emsp;自此，所有的依赖项就安装完成了。&emsp; 二、安装Apache HTTP Server下载并解压apache组件，这里选择的版本是2.4.9 12$ wget https://mirrors.bfsu.edu.cn/apache//httpd/httpd-2.4.49.tar.gz$ tar -zxf httpd-2.4.49.tar.gz 进入目录并使用configure配置makefile，这里选择的目标路径为/usr/local/apache，并指定前面安装的三个依赖项的路径 12$ cd httpd-2.4.49/$ ./configure --with-included-apr --prefix=/usr/local/apache --with-apr=/usr/local/lib/apr --with-apr-util=/usr/local/lib/apr-util --with-pcre=/usr/local/lib/pcre 此时出现报错如下，原因是需要将apr和apr-util的目录放到.&#x2F;srclib&#x2F;下configure: error: Bundled APR requested but not found at ./srclib/. Download and unpack the corresponding apr and apr-util packages to ./srclib/.注：.&#x2F;srclib&#x2F;下apr和apr-util文件夹需要去掉版本号！ 1234$ cp -r apr-1.7.0 httpd-2.4.49/srclib/$ mv httpd-2.4.49/srclib/apr-1.7.0/ httpd-2.4.49/srclib/apr/$ cp -r apr-util-1.6.1 httpd-2.4.49/srclib/$ mv httpd-2.4.49/srclib/apr-util-1.6.1/ httpd-2.4.49/srclib/apr-util/ 再次生成makefile 12$ cd httpd-2.4.49/$ ./configure --with-included-apr --prefix=/usr/local/apache --with-apr=/usr/local/lib/apr --with-apr-util=/usr/local/lib/apr-util --with-pcre=/usr/local/lib/pcre 编译 1$ make 安装 1$ make install 进入/usr/local/即可查看到apache目录 12$ cd /usr/local/$ ll | grep apache 由此Apache HTTP Server组件安装完成！执行如下命令可以确认 123$ ./apache/bin/httpd -vServer version: Apache/2.4.49 (Unix)Server built: Sep 20 2021 23:23:29 三、总结&emsp;&emsp;可以看到手动编译安装组件虽然麻烦点，但是主要是麻烦在找依赖项上。安装的过程其实都是大同小异。基本都是如下三部曲： configure 检查编译环境； make 对源代码进行编译； make insall 将生成的可执行文件安装到当前计算机中 &emsp;&emsp;可以发现configure的很多参数也是高度相似的，我感觉其中需要重点注意的是目标路径--prefix。在不了解可选参数时，也可以通过./configure -h来查看，总而言之虽然繁杂一点，但是其实是不难的。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zgg2001.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://zgg2001.github.io/tags/Linux/"}]},{"title":"linux问题解决：多种方法处理ssh暴力攻击","slug":"20210910_linux问题解决：多种方法处理ssh暴力攻击","date":"2021-09-10T15:16:06.000Z","updated":"2021-09-10T15:16:06.000Z","comments":true,"path":"2021/09/10/20210910_linux问题解决：多种方法处理ssh暴力攻击/","permalink":"https://zgg2001.github.io/2021/09/10/20210910_linux%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%EF%BC%9A%E5%A4%9A%E7%A7%8D%E6%96%B9%E6%B3%95%E5%A4%84%E7%90%86ssh%E6%9A%B4%E5%8A%9B%E6%94%BB%E5%87%BB/","excerpt":"linux问题解决：多种方法处理ssh暴力攻击","text":"linux问题解决：多种方法处理ssh暴力攻击 一、前言&emsp;&emsp;说实话挺离谱的，昨晚登我云服务器的时候，感觉root登录有点卡，然后登进去阿里云那边提醒说自上次登录至现在有xxx条登录失败结果。我一瞅，这量有点大啊，然后用命令lastb看了眼登录失败的日志。如下图：&emsp;&emsp;可以看出来，这人应该是广撒网瞎捕鱼，因为攻击频率不算高并且IP都源自一个地方江苏省宿迁市 电信。说实话我感觉这人没跳代理，应该是真实IP，结合攻击频率不够，应该是个技术不咋地的**。但是说实话，他给我来这么一手，正好让我可以实操相关的内容，感恩就完事了。&emsp;&emsp;昨天因为有点事情没空管他，结果今天一看他还在冲我的服务器，所以把这事办了，下面记录一下我思考与实操的处理方式。 二、处理方式1. 更改ssh端口&emsp;&emsp;这是最简单的方式，因为这种**都是扫一个IP段的22端口暴力破解，所以改一下ssh的端口，换个别的隐藏一下ssh的端口就行。不过如果别人的目标就是我，nmap扫描一下也能把端口扫出来，这样改只是躲了流弹罢了。 具体操作如下： vim /etc/ssh/sshd_config 进去ssh的配置文件 找到配置项 Port 22 改成别的端口 如果没 Port 配置项或者被注释掉了就自己改一下 service sshd restart 重启ssh服务 &emsp;&emsp;但是说实话这种处理方式有点怂，我不想这样搞。而且这样搞了的话，以后跳转登录ssh还得带个-p选项，我觉得麻烦，所以我就放弃这么搞了。&emsp;&emsp; 2. 禁止root用户登录&emsp;&emsp;这是个更怂的方法，就是直接禁止root登录，通过首先登录普通用户再su root来实现root的登录。这玩意流程想想就麻烦，我这又不是什么机密服务器，不至于因噎废食，所以也放弃这么搞。 禁止root用户登录的方法： （这部分内容我在笔记用户与&#x2F;etc&#x2F;passwd与&#x2F;etc&#x2F;shadow中有详细介绍） 修改/etc/passwd或/etc/shadow文件 使用命令usermod -L xxx&emsp;&emsp; 3. RSA密钥登录&emsp;&emsp;就是通过生成公私钥来通过ssh协议登录，公私钥相关的内容可以看我的这篇笔记公钥、私钥与证书 —— 相关内容分析与实践。简单来说就是取消密码登录，改为通过密钥登录。优点是不用登录，缺点是每个机子都需要生成公钥再放到机子里，有点麻烦，所以我也不用这种方法。 因为我也没试过，所以我就不写步骤了&emsp;&emsp; 4. 修改配置文件&emsp;&emsp;在linux中，存在两个文件白名单 /etc/hosts.allow和黑名单 /etc/hosts.deny，二者中可以添加IP或IP段来实现黑白名单的效果。&emsp;&emsp;有一说一啊，这个可能是效果最好的处理方法了，只需要在白名单里加上自己用的IP段，再在黑名单里禁止所有IP段登录即可。因为白名单的优先级比黑名单高，所以这样可以完美的规避ssh暴力攻击。但是缺点也有，就是如果想在一个新的IP段环境下登录，必须得在白名单内添加新内容。 我更改后的内容如下： 123456[root@Zhao_Server ~]# cat /etc/hosts.allowsshd:xx.xxx.*.*:allowsshd:xxx.xxx.*.*:allow[root@Zhao_Server ~]#[root@Zhao_Server ~]# cat /etc/hosts.denysshd:all:deny &emsp;&emsp;上面的白名单IP数字被我用x替换掉了，sshd:xx.xxx.*.*即代表sshd服务允许向IP地址为xx.xxx开头的IP地址提供服务。而黑名单里的sshd:all:deny即代表sshd服务不允许向所有IP地址提供服务。&emsp;&emsp;这样一来，即可避免ssh暴力攻击。 说明： 一个IP请求连入，linux的检查策略是先看/etc/hosts.allow中是否允许，如果允许直接放行；如果没有，则再看/etc/hosts.deny中是否禁止，如果禁止那么就禁止连入 实验发现对/etc/hosts.allow和/etc/hosts.deny的配置不用重启就立即生效，但不管重启不重启当前已有会话都不会受影响；也就是说对之前已经连入的，即便IP已配置为禁止登录会话仍不会强制断开&emsp;&emsp; 5. 使用iptables工具&emsp;&emsp;这个也是个很好的解决方案，iptables是linux下的一个防火墙工具，可以很好的实现包过滤功能。在这里我们只要能把攻击来源方的IP给ban掉，即可避免ssh暴力攻击。 这里简单列一下可能会用到的命令： iptables -I INPUT -s 221.0.0.0/8 -j DROP 封禁整个221开头的网段 iptables -I INPUT -s 221.181.185.159 -j DROP 封禁指定IP iptables -L --line-numbers 展示iptables策略列表并显示序号 iptables -D INPUT 1 根据上一条显示的序号，删除INPUT链的第一条 &emsp;&emsp;按照上面的命令对想要封禁的IP段进行封禁即可。 总结：&emsp;&emsp;这玩意是真的好用，而且功能远不止如此，可能抽空我会在csdn上补充记录一下iptables的使用方法。&emsp;&emsp;这个东西在重启后会失效，所以需要做持久化的措施，具体步骤我会在下面记录。&emsp;&emsp; 三、后续补充1. iptables 持久化操作&emsp;&emsp;在系统重启后，iptables的策略并不会保存，所以就会面临着持久化的问题。但是持久化还是相对方便的。 下面是步骤： iptables-save &gt; /etc/sysconfig/iptables 使用该命令将 iptables 的配置保存在/etc/sysconfig/iptables中 在/etc/rc.d/rc.local中添加iptables-restore &lt; /etc/sysconfig/iptables 即在开机后自动导入之前保存的 iptables 策略 &emsp;&emsp;按如上几步操作，即可完成 iptables 的持久化操作。&emsp;&emsp; 2. 关于/etc/hosts.allow和/etc/hosts.deny失效的问题&emsp;&emsp;配好这俩文件以后，我发现没有用，还是能被攻击到。就找了哥们测试了一下，发现防火墙策略没有生效。所以就研究了下是怎么回事。 下面是解决步骤： 首先是查看是否存在libwarp库，通过命令ll /lib64/libwrap.so.0即可查看这个库是否存在 如果这个库不存在的话，则使用命令yum install -y tcp_wrappers来安装这个库 ldd /usr/sbin/sshd | grep libwrap 可以查看sshd功能是否支持libwarp库，如果没用结果则说明是不支持的问题 但是有一点需要注意…openssh6.7开始默认关闭TCPwrappers支持，所以想要支持libwarp库，就需要安装6.6及以下的版本，或者重新编译一次openssh。下面我预计会记录一下重新编译openssh的方法。 &emsp;&emsp; 四、总结&emsp;&emsp;在绿盟实习俩月多了，好歹也是安全公司，而且这段时间的实习内容也和操作系统底层的安全策略有关，所以接触学习到了很多关于系统安全的内容。这次加强我服务器安全配置的经历可以说是让我对相关内容有了更深入的了解，毕竟可以大刀阔斧的在我的系统上大改乱改。&emsp;&emsp;在实习中学习并分析系统上的配置，在自己的服务器上根据自己的理解进行改动查看结果，并尝试各种操作深入理解。我觉得目前我这种学习流程还是蛮好的。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zgg2001.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://zgg2001.github.io/tags/Linux/"}]},{"title":"linux问题解决：Shell中处理包含空格的文件名","slug":"20210903_linux问题解决：Shell中处理包含空格的文件名","date":"2021-09-03T15:21:44.000Z","updated":"2021-09-03T15:21:44.000Z","comments":true,"path":"2021/09/03/20210903_linux问题解决：Shell中处理包含空格的文件名/","permalink":"https://zgg2001.github.io/2021/09/03/20210903_linux%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%EF%BC%9AShell%E4%B8%AD%E5%A4%84%E7%90%86%E5%8C%85%E5%90%AB%E7%A9%BA%E6%A0%BC%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8D/","excerpt":"&emsp;&emsp;今天在写脚本的时候碰见了一个问题，在使用脚本对一些文件进行权限更改的时候，报出了意料之外的错误。经过对相关内容的查看，发现罪魁祸首是文件名中的空格。","text":"&emsp;&emsp;今天在写脚本的时候碰见了一个问题，在使用脚本对一些文件进行权限更改的时候，报出了意料之外的错误。经过对相关内容的查看，发现罪魁祸首是文件名中的空格。 下面在我的服务器上进行复现： 首先是touch一个名字里带空格的文件，这里我新建的是文件test 1，如下图。 随后是以常规命令chmod 777 test 1来对其进行权限更改操作，如下图。 可以看到，test 1被理解为了两个文件，所以操作失败，提示这两个文件不存在。对于这种情况，很明显需要加上引号来提示系统这是一个整体，或是加上\\来对空格进行转义，如下图可以看到命令成功的被执行了。 但是，对于shell脚本来讲没有办法这么简单的处理，尤其是脚本中需要修改的文件是通过find找出来的变量。由此遇到困难开始想办法解决。 关于解决此问题的思考： 首先脚本中没有办法添加引号来使得变量被划为一个整体，所以单独操作时最常用的引号无法使用。 其次是否可以通过shell里的字符串函数在文件名中加入转义符\\来避免空格的影响，但是我觉得这个应该会影响处理速度。 最后能否从根本上直接解决问题，即将文件名中的空格先替换为别的内容，待处理完后再替换为空格。这个说实话我感觉有点麻烦，而且最重要的是在替换时选择替换为什么内容？如果替换的内容本来就在文件名中存在，那么可能在替换回去时会改变原文件名，所以我觉得这个应该不大可行。 最终解决方案：&emsp;&emsp;我在网上冲浪了一会，发现一个应该是效率最高改动最小的解决方案，即修改解释器的单词分隔符。这个东西在bash中被储存在变量$IFS中，初始值为 \\n\\t，即空格、回车、tab。在bash处理内容时会根据这个变量来对字符串进行分割，所以对其中的内容进行修改删去空格，即可让bash在处理带空格字符串时，不进行分割，从而从根本上解决问题。当然在脚本执行后还得把$IFS改回去，避免之后出现问题。&emsp;&emsp;相比上文思考中的更改字符串，我觉得还是这个更方便效率高，所以决定使用这个方法对问题进行处理。 这是我更改后的代码实例，其中把分隔符IFS改为了\\n\\b，待脚本执行完毕后再切回原来的 \\n\\t，从而在不影响bash的情况下完成IFS的更改。 123456789101112#!/bin/bash#由于文件名中可能有空格，所以需要更改IFSSAVEIFS=$IFSIFS=$(echo -en &quot;\\n\\b&quot;)for file in `find ~ -perm -002 -type f 2&gt;/dev/null`do chmod o-wx &quot;$file&quot;doneIFS=$SAVEIFS 这是运行后的结果。可以发现，权限已经被成功的修改了。由此可以验证该写法，对于文件名包含空格的文件和文件名含\\\\的文件都可以成功的进行选取，从而正确的解决命令。 如果不更改IFS的话，就会出现下面这个问题，所以我认为该问题已解决。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zgg2001.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://zgg2001.github.io/tags/Linux/"}]},{"title":"linux学习记录：shell脚本","slug":"20210831_linux学习记录：shell脚本","date":"2021-08-31T13:56:04.000Z","updated":"2021-08-31T13:56:04.000Z","comments":true,"path":"2021/08/31/20210831_linux学习记录：shell脚本/","permalink":"https://zgg2001.github.io/2021/08/31/20210831_linux%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9Ashell%E8%84%9A%E6%9C%AC/","excerpt":"这是本人在学习shell脚本时的记录，方便日后查询。 里面会记录一些自己写的shell脚本，都是在实习中用到的。由此这篇笔记的内容也会不断扩充，也算是记录一下心路历程。 默认使用解释器/bin/bash","text":"这是本人在学习shell脚本时的记录，方便日后查询。 里面会记录一些自己写的shell脚本，都是在实习中用到的。由此这篇笔记的内容也会不断扩充，也算是记录一下心路历程。 默认使用解释器/bin/bash 零、shell基础&emsp;&emsp;通过命令cat /etc/shells可以查看当前系统支持的解释器。如下图，可以看到这个系统支持解释器sh和bash。可以直接执行解释器文件来进入新的shell命令行，相当于套娃，并可以输入命令exit来退出shell命令行。 &emsp;&emsp;然后是几个很常见的快捷键。&emsp;&emsp;bash和sh都是支持使用键盘的上下方向键来查询历史记录的。这样在操作有共同之处时，就可以对之前的命令进行简单修改来更快捷的执行命令。此时ctrl a与ctrl e就会显得很好用，可以避免光标挨个移动到头…&emsp;&emsp;关于清屏的ctrl l，命令clear和它的效果是一样的。但是有一点需要注意，由于现在很多终端是支持鼠标滑轮上下翻滚的(例如图形化发行版的终端和各类模拟终端)，所以当输出太多时，清屏后的输出并不能很好的与上文分割。所以我一般会长按回车手动清屏，这样在输出刷屏后，也可以很轻易的翻出此次输出的开头。而ctrl l带给我的，可能是一丝源自强迫症的清爽。 操作 效果 ctrl a 移动到最前 ctrl e 移动到最后 ctrl c 撤销当前命令 ctrl l 清屏 &emsp;&emsp;接着是很重要的输出重定向。&emsp;&emsp;在shell执行完命令后，一般来说都会有输出。这个输出可能是错误输出，例如提示权限不足、参数错误等等；也可能是常规的输出，即命令正确执行后的输出。但是有时候可能只想让输出显示错误信息或正确信息或是都不显示，当然也有可能是想把输出信息保存下来，这时就需要用到输出重定向了。&emsp;&emsp;这里不细说符号功能，只记录一下我在脚本中使用的感受。就目前我用到的场景来看，大部分用到的是2&gt;/dev/null，这个意思是忽略报错信息。比如在find /全盘扫描，扫到/proc进程目录时，由于进程信息改变，很有可能报错找不到文件，这种错误是不重要的所以可以忽略报错信息来确保输出的纯净性。&emsp;&emsp;当然有时也需要把一些内容重定向输出到文件里，比如上面的find找到内容后可能要把找到的内容存放在一个文本文件中保存，这时候就可以使用&gt;或&gt;&gt;。这里要根据情况来选择是&gt;追加还是&gt;&gt;覆盖。总而言之输出重定向用的还是蛮多的。当然输入重定向&lt;我感觉用的也不少，只不过可能没有输出重定向&gt;用的多罢了。 符号 功能 &gt; 正确(覆盖) &gt;&gt; 正确(追加) 2&gt; 错误(覆盖) 2&gt;&gt; 错误(追加) &amp;&gt; 正确&amp;错误(覆盖) &amp;&gt;&gt; 正确&amp;错误(追加) &emsp;&emsp;最后要提一嘴的是最常用的符号之一，管道|。&emsp;&emsp;这个涉及到流的概念，可以理解为把管道前面命令的结果流向管道后面的命令，使得流入的结果成为后面命令的输入。&emsp;&emsp;在脚本中，可以对命令进行慢慢的涉及和尝试，所以很可能一个命令会变得很长很复杂，而其中少不了的就是这个管道。在使用管道时要注意一下参数传递的格式，例如在find寻找完数据后，往往要在管道后用xargs处理一下，把结果转为命令行参数，从而可以正常执行后续命令，这东西我感觉用的也挺多的。 一、变量1. 基础&emsp;&emsp;格式为变量名=变量值，取消变量用unset 变量名，在引用时用$变量名。需要注意的是，**等号两边不能有空格，且变量不可以使用数字开头(组成：字母&#x2F;数字&#x2F;下划线)**，当变量已经存在时，会覆盖原来的值，所以如果想要添加变量的值，可以使用变量=$&#123;变量&#125;要添加的值这种操作扩充变量。&emsp;&emsp;这里提一嘴：shell脚本里应该是没有Makefile里的:=等操作的，所以想扩充变量内容得使用上面那种重声明覆盖的方法(当然也有别的方法)，就这一部分来看，感觉还是Makefile那边方便点。 2. 各种变量类型2.1 环境变量 这部分内容都储存在/etc/profile内，也有可能在依据某用户配置的~/.bash_profile内 使用命令env可以查看所有环境变量 个人感觉常用的环境变量有PWD、PATH、UID、USER、SHELL、HOME等 2.2 位置变量 就是bash内置的变量，储存脚本执行时的参数 在执行脚本时可以直接在后面加上参数，而脚本里不用声明，这就是位置变量 例如我写了一个脚本test.sh，启动命令为bash test.sh hello world，则hello和world均为参数(由位置变量储存)，在脚本中通过$1、$2这样的格式来指定($1为hello、$2为world) 2.3 预定义变量 用来保存进程内相关信息 这些变量可以直接使用，且不能赋值 个人感觉$?是我使用最多的预定义变量 符号 意义 在bash内直接调用的结果(bash没有位置变量) $0 当前所在进程或脚本名 $$ 当前运行进程的PID号 $? 命令执行后的状态 0为正常 其他值为异常 $# 已加载的位置变量个数 $* 所有位置变量的值 2.4 自定义变量 就是用户自己定义的变量 3. 变量扩展内容3.1 三种定界符 符号 含义 单引号&#39; &#39; 禁止扩展 比如$变量视为普通字符 双引号&quot; &quot; 允许扩展 比如$变量会进行替换 反引号`` 执行反引号内的命令 并将结果返回 等同于$(命令) 3.2 read 通过read可以从键盘接收内容使其赋值到指定变量上 格式为：read [-p &quot;提示信息&quot;] 变量名 -t可以指定超时时间 -s可以指定是否在shell里显示输入的内容(在设定密码之类的内容时候用) 3.3 局部变量和全局变量 使用变量名=变量名这种格式声明的变量，只能在当前shell环境下使用。一旦不在当前shell，这些变量就不存在了。这就是局部变量 可以通过export 变量名=变量名这种格式来声明全局变量，这样所有的shell环境中都可以使用这个变量。这就是全局变量 3.4 变量初始化判定 有时候不知道变量是否已经存在且初始化，需要有一个默认值，可以通过这样来实现： $&#123;变量:-关键词&#125; 当变量已初始化，则结果为变量的值；否则结果为后面的关键词 二、运算1. $[] 运算 $[]等同于$(()) 格式为：$[整数1 运算符 整数2 ... ...]，其中并不支持小数运算，需要注意 计算结果会替换这个表达式本身，可以赋值或者直接echo 2. 自加自减 运算 直接let就行，还是那一套东西 三、条件测试1. 字符串条件 格式 作用 [ -z 字符串 ] 字符串是否为空 [ -n 字符串 ] 字符串是否存在 [ 字符串1 == 字符串2 ] 字符串判等 [ 字符串1 != 字符串2 ] 字符串判不等 2. 整数条件 格式为[ 整数1 参数 整数2 ]，注意要有空格 参数 含义 -eq 等于 -ne 不等于 -ge 大于等于 -le 小于等于 -gt 大于 -lt 小于 3. 文件条件 格式为[ 参数 文件或目录 ]，注意要有空格 参数 含义 -e 是否存在 -d 是否为目录 -f 是否为文件 -r 是否有r权限 -w 是否有w权限 -x 是否有x权限 4. 控制符 三个常用的控制符 &amp;&amp;、||、; ;用来分割语句，比如说cd /etc; pwd就是先执行cd再执行pwd &amp;&amp;不管其前面的命令执行是否成功，均执行后面的命令 ||当前面的命令执行成功时就不执行后面，前面执行失败了就执行后面的命令 &amp;&amp;优先级比||高，所以优先执行&amp;&amp;。比如这条命令[ a == a ] &amp;&amp; echo Y || echo N，输出就是Y；命令[ a == b] &amp;&amp; echo Y || echo N，输出就是N 同理可以这么用：[ 判断1 ] &amp;&amp; [判断2]或[ 判断1 ] || [判断2] 四、if语句&emsp;&emsp;最常用的句式，我一般是按下面这个结构写，then放上面。 123if 条件测试;then 操作fi &emsp;&emsp;然后呢，多重判断结构语法是这样的，就是记住有个then就行。 1234567if 条件测试;then 操作elif 条件测试;then 操作else 操作fi 五、for循环&emsp;&emsp;有两种写法，分别是： 1234567891011# 第一种for 变量 in 值列表do 操作done# 第二种for ((初值;条件;步长))do 操作done &emsp;&emsp;第一种的话，我感觉用的比较多，一般是find或是什么检索出的结构列表，通过for来挨个判定操作。比如说下面这种用法： 12345# 挨个显示/etc/passwd里的用户名for user in `cat /etc/passwd | awk -F: &#123;&#x27;print $1&#x27;&#125;`;do echo $user;done; &emsp;&emsp;第二种的话，反正我目前没咋用过，可能以后会用到吧。 1234for ((i=0;i&lt;=5;i++))do echo hellodone 六、while循环&emsp;&emsp;语法格式是这样的： 1234while 条件测试do 操作done &emsp;&emsp;一个简单的例子： 123456i=0while [ $i -eq 0 ]do echo $i let i++done 七、case语句&emsp;&emsp;语法格式是这样的： 123456789case 变量 in模式1) 操作 ;;模式2) 操作 ;;...*) 操作 ;;esac &emsp;&emsp;需要注意的是，最终结尾是两个分号。这里的*)相当于c case里的default。 123456789x=4case x in1) echo this is 1 ;;2) echo this is 2 ;;*) echo erroresac 八、数组&emsp;&emsp;定义很简单，括号括起来，元素之间用空格隔开，例如test=(z h j)。调用时也很简单，大括号加中括号，例如echo $&#123;test[0]&#125;。下面是演示。&emsp;&emsp;如果不加大括号的话，就会输出数组第一个元素加上中括号内容，如下图。所以需要加上大括号来告诉系统中括号内的东西和变量是一体的。 九、shell函数&emsp;&emsp;语法格式是这样的： 1234567函数名() &#123; 操作&#125;调用的话，直接函数名 [$1 $2 $3 ...]就行 例子如下： 十、中断与退出&emsp;&emsp;就是三个东西：continue、break和exit。怎么用也不多说了，跟c里一样。 continue是结束单次循环 break是结束一个循环体 exit可以退出脚本 十一、字符串处理1. 显示指定区域 语法为$&#123;变量:起始位置:长度&#125;，和数组一样下标从0开始计数 2. 字符串替换 替换一次：$&#123;变量/旧字串/新字串&#125; 替换全部：$&#123;变量//旧字串/新字串&#125; 3. 字符串掐头 从左至右，最短匹配删除：$&#123;变量#关键词&#125; 从左至右，最长匹配删除：$&#123;变量##关键词&#125; 4. 字符串截取 语法为：$&#123;变量%关键词&#125; 十二、正则表达式！&emsp;&emsp;首先哈，我感觉这东西很常见，其次呢是非常好用很灵活。这部分内容我也用的挺多的，只能说是熟能生巧，很多符号用着用着就记住了。 基本正则符号： 符号 意义 例子 abc 匹配abc grep abc .&#x2F; ^ 匹配开头 grep ^abc .&#x2F; $ 匹配结尾 grep abc$ .&#x2F; [集合] 匹配集合 grep “[abc]” .&#x2F; [^集合] 集合取反 grep “[^abc]” .&#x2F; . 匹配任意单个字符 grep . .&#x2F; * 匹配前一个字符任意次(可以是0次) grep ab*c .&#x2F; .* 匹配任意，即上面两个连起来(匹配单个字符任意次) grep a.*c .&#x2F; {n,m} 匹配前一个字符n到m次 反斜杠是为了转义 下同 grep “[abc]{2,3}“ .&#x2F; {n,} 匹配前一个字符至少n次 grep “[abc]{2,}“ .&#x2F; {n} 匹配前一个字符n次 grep “[abc]{2}“ .&#x2F; &emsp;&emsp;上面这部分的内容是使用最多的，我个人比较常用的是^开头、$结尾以及.*匹配任意。 扩展正则符号： 符号 意义 + 匹配前面的字符至少一次 ? 匹配前面的字符0或1次 () 组合和保留 | 或者 &emsp;&emsp;上面这部分的内容需要加上-E参数，即grep -E 正则表达式。 &emsp;&emsp;这部分我用过的好像也就+，只能说用的还是偏少，我感觉上面的基础正则已经够我当前用了。 Perl兼容正则符号： 符号 意义 \\b 匹配单词边界 \\w 匹配字符数字下划线 \\W 和\\w相反 \\s 匹配空白 \\d 匹配数字 \\d+ 匹配多个数字 \\D 匹配非数字 &emsp;&emsp;上面这部分的内容需要加上-P参数，即grep -P 正则表达式。 &emsp;&emsp;这部分说实话没咋用过，不过在系统里找脚本学习的时候碰见过\\d。 十三、awk1. 基础&emsp;&emsp;awk我在写脚本的时候用的非常多，原因就是很好用，对于格式化的数据可以很轻松的筛出想要的那一部分。 语法1：前置命令 | awk [选项] &#39;[条件]&#123;指令&#125;&#39; 语法2：awk [选项] &#39;[条件]&#123;指令&#125;&#39; 文件 如果想要使用正则，则语法为/正则表达式/，~为匹配，!~为不匹配 &emsp;&emsp;awk我个人认为最常见的用法就是提取文本。例如在ls -l的命令中，如果只想要第一列的权限和第九列的文件名，就可以使用ll / | awk &#39;&#123;print $1,$9&#125;&#39;来输出第一列和第九列的内容。&emsp;&emsp;由此可知，awk默认是以空格来分列的。但是很多情况下并不是使用空格来分割，这个时候可以使用-F来指定分隔符。例如如果想读取/etc/passwd里的用户名和它的解释器，就可以使用cat /etc/passwd | awk -F : &#39;&#123;print $1,$7&#125;&#39;来获取，其中指定分隔符为:。 2. 内部变量 变量名 意义 FS 保存或设置字段分隔符，例如FS=&quot;:&quot;，与-F功能一样 $n 指定分割的第n个字段，例如$1代表第一个字段 $0 当前读入的整行文本内容 NF 记录当前处理行的字段个数(列数) NR 记录当前已读入行的数量(行数) 3. BEGIN和END 在所有行前处理，BEGIN{}· 读入第一行文本之前执行· 一般用来初始化操作 逐行处理，{}· 逐行读入文本执行相应处理· 是最常见的编辑指令块 在所有行后处理，END{}· 处理完最后一行文本后执行· 一般用来输出处理结果 4. 判断与比较 在awk里是支持分支if语句的，并且可以使用!= &gt;= &lt;这样的符号来比较，下图是一个很好的例子 例子中判断略去第一行，只对第一行以后的进行判断，因为ls -l的第一行是total xxx 十四、格式化输出 格式为：输出内容 | column -t 如下图是加与不加的区别 十五、一些自己写的实例1. 寻找系统中所有可登录的用户1234567891011121314#!/bin/bash# 可以查看所有未禁用用户id=1for user in `cat /etc/passwd | grep -E -v .*nologin$ | awk -F: &#123;&#x27;print $1&#x27;&#125;`;do cat /etc/shadow | grep -E ^$user | grep -E :\\\\$.\\\\$.*\\\\$.*: &gt; /dev/null if [ $? -eq 0 ];then echo &quot;$id: $user -- 该用户已设置密码可登录&quot;; let id++; elif [[ -z `cat /etc/shadow | grep -E ^$user` ]];then echo &quot;$id: $user -- 该用户在/etc/shadow中不存在&quot;; let id++; fidone; 执行效果如下：解析：&emsp;&emsp;这个脚本我是利用了禁用用户登录的规则来判定此用户是否被禁用(如何判断可以看我的这篇笔记linux学习记录：用户与&#x2F;etc&#x2F;passwd与&#x2F;etc&#x2F;shadow)，通过正则表达式加上awk筛出初步判定没有禁用的用户名，再前去/etc/shadow中通过正则表达式查看密码是否符合规范，即可得知此账号是否被禁。即可输出结果。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zgg2001.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://zgg2001.github.io/tags/Linux/"}]},{"title":"公钥、私钥与证书 —— 相关内容分析与实践","slug":"20210826_公钥私钥与证书相关内容分析与实践","date":"2021-08-26T13:32:35.000Z","updated":"2021-08-26T13:32:35.000Z","comments":true,"path":"2021/08/26/20210826_公钥私钥与证书相关内容分析与实践/","permalink":"https://zgg2001.github.io/2021/08/26/20210826_%E5%85%AC%E9%92%A5%E7%A7%81%E9%92%A5%E4%B8%8E%E8%AF%81%E4%B9%A6%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E8%B7%B5/","excerpt":"这是我在实习中碰到的一些内容，因为之前对这一块内容一窍不通，所以就抽了几天学习了一下，不得不说收获颇丰。 借着这次的学习，对加密解密这方面的概念有了一定的认识，对信息传输安全相关的内容算是打了个基础，正好之前我也有做网络编程，感觉是可以尝试加入一下加密策略，不让报文裸奔了。然后就是借着证书了解了一下http&#x2F;https，算是对网络有了一点新的个人理解吧。 受组里的影响，我现在所有的总结都是在有道云笔记上进行的，但是说实话上面搜索有点操蛋另外markdown不让传图，由此这种长篇大论还是适合发在CSDN上。所以我完善了一下，总结出了这一篇内容。(但是不得不说有道云记小东西是真的方便，生产力upup )","text":"这是我在实习中碰到的一些内容，因为之前对这一块内容一窍不通，所以就抽了几天学习了一下，不得不说收获颇丰。 借着这次的学习，对加密解密这方面的概念有了一定的认识，对信息传输安全相关的内容算是打了个基础，正好之前我也有做网络编程，感觉是可以尝试加入一下加密策略，不让报文裸奔了。然后就是借着证书了解了一下http&#x2F;https，算是对网络有了一点新的个人理解吧。 受组里的影响，我现在所有的总结都是在有道云笔记上进行的，但是说实话上面搜索有点操蛋另外markdown不让传图，由此这种长篇大论还是适合发在CSDN上。所以我完善了一下，总结出了这一篇内容。(但是不得不说有道云记小东西是真的方便，生产力upup ) 一、概念相关1. 一些关键词 密钥对 在非对称加密技术中，有两种密钥，分为私钥和公钥，私钥是密钥对所有者持有，不可公布，公钥是密钥对持有者公布给他人的。 公钥 公钥用来给数据加密，用公钥加密的数据只能使用私钥解密。 私钥 如上，用来解密公钥加密的数据。 摘要 对需要传输的文本，做一个HASH计算，一般采用SHA1，SHA2来获得。 签名 使用私钥对需要传输的文本的摘要进行加密，得到的密文即被称为该次传输过程的签名。 2. 公私钥2.1 公私钥的优点&emsp;&emsp;在对称加密中，加密和解密用的是同一个密钥。所以一旦密钥泄露，数据传输可能就会面临风险，由此非对称加密应运而生。 &emsp;&emsp;在非对称加密中，存在一个密钥对，即公钥和私钥，两者只能解密对方加密的内容。在私钥不被泄露的前提下对公钥进行散发，即使在散发的过程中公钥泄露也无法解密公钥端加密的数据，相比对称式加密更加安全。 2.2 公私钥的定义 公钥：是公布出去给别人用的，可以被很多人获取。用来加密和验签 私钥：只能自己持有，并且不可以被其他人知道。用来解密和签名 2.3 公私钥的作用 公钥加密的数据私钥可以解密 私钥加密的内容公钥可以解密 2.4 公私钥的关系 一个公钥对应一个私钥 密钥对中，让大家都知道的是公钥，自己知道是私钥 如果用其中一个密钥加密数据，则只有对应的那个密钥才能解密 如果用其中一个密钥可以进行解密数据，则该数据必然由对应密钥进行加密 2.5 如何确保数据安全传输&emsp;&emsp;要达到数据安全传输的目的，必须发送方和接收方都持有对方的公钥和自己私钥，即任意一方持有自己的私钥和对方的公钥。 &emsp;&emsp;则为了数据的安全性，B需要使用A的公钥来给数据加密，这样只有A的私钥才可以解密数据，这样保证了数据的安全性，这是数字签名。 &emsp;&emsp;而为了保证数据发送方的真实性，B需要使用自己的私钥来数据加密，这样其他人用B的公钥进行解密，由于只有B私钥加密的数据，B的公钥才能解密，所以他人用B的公钥若能解密此数据，则证实数据是由B发送的，若不能解密，则证明数据不是用B的私钥加密，即不是B发送的，这样保证了发送的真实性。 3. 证书3.1 证书是什么 证书可以为公钥做认证，从而可以验证公钥是否真实可信，防止他人伪造公钥 3.2 何时会用到证书&emsp;&emsp;很明显，在一些情况下，不存在像上文中说的那种双方均持有完善密钥对的条件，比如说访问网页。 &emsp;&emsp;在申请访问网页时，本机是不存在网页端的公钥的，由此网页端在收到访问申请时，需要把公钥发送给本机。在本机接收到公钥后，便可以通过公钥与网页端进行较为安全的数据传输。但是，在网页端把公钥发送给本机的过程中，公钥可能被他人篡改(比如被替换成另一个公钥)，这样在使用此公钥数据传输时就有可能被解密，从而发生泄露(比如在网页中输入的密码之类的)。此时可以确认公钥是否被篡改的证书就出现了。 3.3 证书的作用机制&emsp;&emsp;证书其实可以看作是加密后的公钥信息，其中有公钥的摘要(所以在生成证书的时候可以指定hash加密算法)，可以在发送公钥时带着证书一起发送。在本机接收到内容后，对证书进行解密即可验证随着证书一起发送的公钥是否被篡改，由此即可保证公钥的安全性。 3.4 CA机构&emsp;&emsp;如果按上面说的那个证书流程走，就会出现一个问题：谁来给公钥加密成证书？如何解密证书？此时CA机构出现了。 &emsp;&emsp;CA机构即证书颁发机构，它会用自己的私钥对用户的公钥和相关信息进行加密，生成”数字证书”，然后证书中心会公布自己的公钥给所有人，用来让用户使用此公钥验证”数字证书”是否由CA颁发，即是否真实可信。 那么CA的公钥怎么获取？就目前来说主流浏览器中均内置了CA的公钥，所以这个问题是不用担心的。 如何确保CA的公钥没有被篡改？这套信任链的起点是CA的根证书，其中存有CA的公钥。所以如果你接受了这个根证书，则代表对这个机构的信任，则所有此机构的证书均可通过该根证书来验证。所以只需要确保根证书是真的即可。 3.5 CA证书与自签名证书&emsp;&emsp;CA证书是通过验证的、可以信任的，但是在CA认证过程花费不小。所以在一般的测试或者一些情况下，可以使用自签名证书。 &emsp;&emsp;自签名证书相当于自己给自己发证书，所以没有办法被验证(除非你在浏览器里安装了相应的根证书)，由此浏览器可能会提示不安全。之前12306就没有获取CA证书，所以它推荐安装自己的根证书来避免被提示不安全以及确保传输安全，不过后来还是搞了CA的证书(如下图)。 3.6 https协议工作流程&emsp;&emsp;我感觉https协议工作流程可以很好的展示公私钥与证书之间的关系，由此记录一下。 客户端 &emsp;流向&emsp; 服务端 备注 请求https连接 &emsp;&gt;&gt;&emsp; &emsp;&lt;&lt;&emsp; 返回证书公钥 使用CA的公钥验证看证书是否有效 &emsp;×&emsp; 如果出现问题提示不安全 根据CA的验证结果看公钥是否安全 &emsp;×&emsp; 如果出现问题提示不安全 如果上面验证都正常则生成一个对称密钥 &emsp;×&emsp; 这个密钥作用在之后的密文通信 使用服务端的公钥加密上一步生成的密钥把加密结果发送给服务端 &emsp;&gt;&gt;&emsp; &emsp;×&emsp; 收到加密后的密钥使用私钥进行解密得到对称密钥 &emsp;&lt;&lt;&emsp; 使用对称密钥加密信息发送给客户端 使用对称密钥解密信息得到信息 &emsp;×&emsp; 使用对称密钥加密信息发送给服务端 &emsp;&gt;&gt;&emsp; &emsp;×&emsp; 使用对称密钥解密信息得到信息 … … … 通过对称密钥加密的密文通道 二、openssl工具1. openssl genrsa – 生成私钥用于生成RSA私钥，不会生成公钥，因为公钥提取自私钥。 openssl genrsa [-out filename] [-passout arg] [-des] [-des3] [-idea] [numbits] -out filename ：将生成的私钥保存至filename文件,若未指定输出文件,则为标准输出。 numbits ：指定要生成的私钥的长度,默认为1024。该项必须为命令行的最后一项参数。 -des ：生成的密钥使用des方式进行加密。 -des3 ：生成的密钥使用des3方式进行加密。 -passout args ：加密私钥文件时,传递密码的格式,如果要加密私钥文件时单未指定该项,则提示输入密码。传递密码的args的格式,可从密码、环境变量、文件、终端等输入。a. pass:password ：password表示传递的明文密码b. env:var ：从环境变量var获取密码值c. file:filename ：filename文件中的第一行为要传递的密码。若filename同时传递给”-passin”和”-passout”选项，则filename的第一行为”-passin”的值，第二行为”-passout”的值d. stdin ：从标准输入中获取要传递的密码 2. openssl req – 证书相关生成证书请求文件、验证证书请求文件和创建根CA。 openssl req[-new] [-newkey rsa:bits] [-verify] [-x509] [-in filename] [-out filename][-key filename] [-passin arg] [-passout arg] [-keyout filename] [-pubkey][-nodes] [-[dgst]] [-config filename] [-subj arg] [-days n] [-set_serial n][-extensions section] [-reqexts section] [-utf8] [-nameopt] [-reqopt][-subject] [-subj arg] [-text] [-noout] [-batch] [-verbose] 简单说明几个参数： -new ：创建一个证书请求文件，会交互式提醒输入一些信息，这些交互选项以及交互选项信息的长度值以及其他一些扩展属性在配置文件(默认为openssl.cnf，还有些辅助配置文件)中指定了默认值。如果没有指定”-key”选项，则会自动生成一个RSA私钥，该私钥的生成位置也在openssl.cnf中指定了。如果指定了-x509选项，则表示创建的是自签署证书文件，而非证书请求文件 -newkey args ：类似于”-new”选项，创建一个新的证书请求，并创建私钥。args的格式是”rsa:bits”(其他加密算法请查看man)，其中bits是rsa密钥的长度，如果bits省略了(即-newkeyrsa)，则长度根据配置文件中default_bits指令的值作为默认长度，默认该值为2048.如果指定了-x509选项，则表示创建的是自签署证书文件，而非证书请求文件 -nodes ：默认情况下，openssl req自动创建私钥时都要求加密并提示输入加密密码，指定该选项后则禁止对私钥文件加密 -key filename ：指定私钥的输入文件，创建证书请求时需要 -keyout filename ：指定自动创建私钥时私钥的存放位置，若未指定该选项，则使用配置文件中default_keyfile指定的值，默认该值为privkey.pem -x509 ：指定该选项时，将生成一个自签署证书，而不是创建证书请求。一般用于测试或者为根CA创建自签名证书 -days n ：指定自签名证书的有效期限，默认30天，需要和”-x509”一起使用。 -[dgst] ：指定对创建请求时提供的申请者信息进行数字签名时的单向加密算法，如-md5&#x2F;-sha1&#x2F;-sha512等. -out filename ：证书请求或自签署证书的输出文件，也可以是其他内容的输出文件，不指定时默认stdout -text ：以文本格式打印证书请求 -noout ：不输出部分信息 -subject ：输出证书请求文件中的subject(如果指定了x509，则打印证书中的subject) -pubkey ：输出证书请求文件中的公钥 3. openssl rsa – 提取公钥Rsa命令用于处理RSA密钥、格式转换和打印信息。 openssl rsa[-inform PEM|NET|DER] [-outform PEM|NET|DER] [-in filename] [-passin arg][-out filename] [-passout arg] [-sgckey][-text] [-noout] [-modulus] [-check] [-pubin] [-pubout][-engine id] [-des] [-des3] [-idea] 简单说明几个例子： 从私钥中提取公钥 1openssl rsa -in private.key -pubout -out public.key 查看公钥信息 1openssl rsa -pubin -in pubkey.key -text 查看私钥信息 1openssl rsa -in prikey.key -passin pass:&quot;123456&quot; -text 4. openssl rsautl – 加解密rsautl命令用于依据公私钥加解密数据。 下面是几个示例： 公钥进行加密 (被加密文件为testFile 加密后文件为temp) 1openssl rsautl -encrypt -in testFile -inkey pub_test.key -pubin -out temp 私钥进行解密 (被解密文件为temp 解密后文件为newFile) 1openssl rsautl -decrypt -in temp -inkey pri_test.key -out newFile 私钥进行加密(签名) (被加密文件为testFile 加密后文件为temp) 1openssl rsautl -sign -in testFile -inkey pri_test.key -out temp 公钥进行解密 (被解密文件为temp 解密后文件为newFile) 1openssl rsautl -verify -in temp -inkey pub_test.key -pubin -out newFile 5. openssl示例 – 公私钥、证书与加密下面是一组示例。 使用des3加密生成一个叫做pri_test.key的私钥，长度为2048 1openssl genrsa -des3 -out pri_test.key 2048 从私钥中提取出公钥，公钥取名为pub_test.key 1openssl rsa -in pri_test.key -pubout -out pub_test.key 生成一个叫做req1.csr的证书请求，规定证书签名算法为sha256 1openssl req -new -key pri_test.key -out req1.csr -sha256 查看证书请求req1.csr的信息 1openssl req -in req1.csr -text 验证证书请求是否被修改 1openssl req -verify -in req1.csr 依据证书请求文件创建自签名证书CA1.pem，有效期365天 1openssl req -x509 -key pri_test.key -in req1.csr -out CA1.pem -days 365 当然也可以直接通过私钥创建自签名证书CA2.pem 1openssl req -new -x509 -key pri_test.key -out CA2.pem -days 365 由此公私钥、自签名证书创建完毕，下面是加密相关。 创建测试文件 123vim testFile Hi~This 1s @ test 文件! 公钥进行加密 (被加密文件为testFile 加密后文件为temp) 1openssl rsautl -encrypt -in testFile -inkey pub_test.key -pubin -out temp 私钥进行解密 (被解密文件为temp 解密后文件为newFile) 1openssl rsautl -decrypt -in temp -inkey pri_test.key -out newFile 私钥进行加密(签名) (被加密文件为testFile 加密后文件为temp) 1openssl rsautl -sign -in testFile -inkey pri_test.key -out temp 公钥进行解密 (被解密文件为temp 解密后文件为newFile) 1openssl rsautl -verify -in temp -inkey pub_test.key -pubin -out newFile 三、在C语言中使用openssl库1. 前期准备首先得确保当前环境下存在openssl库。官网下载地址:https://www.openssl.org/source/ 具体步骤可以去网上搜一下。大致就是下载后解压，然后./config和make命令进行配置与编译，最后make install安装一下就好了。安装好以后就可以使用openssl的库文件了。 2. 程序实例 – 公私钥加密解密这个例子来自于我在网上找到的代码，我对它进行了一些注释和改动，主要目的是为了看一下openssl在C语言中相关的接口函数。 注意∶编译时应加上参数-lcrypto来连接相关的动态库 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;openssl/rsa.h&gt;#include&lt;openssl/pem.h&gt;#include&lt;openssl/err.h&gt;#define OPENSSLKEY &quot;pri_test.key&quot;//私钥#define PUBLICKEY &quot;pub_test.key&quot;//公钥#define BUFFSIZE 1024char* my_encrypt(char *str,char *path_key);//加密char* my_decrypt(char *str,char *path_key);//解密int main(void)&#123; char *source=&quot;Hi~ \\nThis 1s @ test 文件&quot;;//要加密的文件 char *ptr_en,*ptr_de; printf(&quot;source is :\\n%s\\n&quot;,source);//加密前 ptr_en=my_encrypt(source,PUBLICKEY);//加密 printf(&quot;after encrypt:\\n%s\\n&quot;,ptr_en);//加密后 ptr_de=my_decrypt(ptr_en,OPENSSLKEY);//解密 printf(&quot;after decrypt:\\n%s\\n&quot;,ptr_de);//解密后 if(ptr_en!=NULL)&#123; free(ptr_en); &#125; if(ptr_de!=NULL)&#123; free(ptr_de); &#125; return 0;&#125;//加密char *my_encrypt(char *str,char *path_key)&#123; char *p_en; RSA *p_rsa; FILE *file; int flen,rsa_len; if((file=fopen(path_key,&quot;r&quot;))==NULL)&#123; perror(&quot;open key file error&quot;); return NULL; &#125; if((p_rsa=PEM_read_RSA_PUBKEY(file,NULL,NULL,NULL))==NULL)&#123;//读公钥 ERR_print_errors_fp(stdout); return NULL; &#125; flen=strlen(str); rsa_len=RSA_size(p_rsa); p_en=(unsigned char *)malloc(rsa_len+1); memset(p_en,0,rsa_len+1); if(RSA_public_encrypt(rsa_len,(unsigned char *)str,(unsigned char*)p_en,p_rsa,RSA_NO_PADDING)&lt;0)&#123; return NULL; &#125;//这里进行加密 RSA_free(p_rsa); fclose(file); return p_en;&#125;//解密char *my_decrypt(char *str,char *path_key)&#123; char *p_de; RSA *p_rsa; FILE *file; int rsa_len; if((file=fopen(path_key,&quot;r&quot;))==NULL)&#123; perror(&quot;open key file error&quot;); return NULL; &#125; if((p_rsa=PEM_read_RSAPrivateKey(file,NULL,NULL,NULL))==NULL)&#123;//读私钥 ERR_print_errors_fp(stdout); return NULL; &#125; rsa_len=RSA_size(p_rsa); p_de=(unsigned char *)malloc(rsa_len+1); memset(p_de,0,rsa_len+1); if(RSA_private_decrypt(rsa_len,(unsigned char *)str,(unsigned char*)p_de,p_rsa,RSA_NO_PADDING)&lt;0)&#123; return NULL; &#125;//这里进行解密 RSA_free(p_rsa); fclose(file); return p_de;&#125; 如下图为执行结果：","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zgg2001.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://zgg2001.github.io/tags/Linux/"}]},{"title":"C/C++学习记录：深入理解三种传参方式","slug":"20210823_C_C++学习记录：深入理解三种传参方式","date":"2021-08-22T16:06:44.000Z","updated":"2021-08-22T16:06:44.000Z","comments":true,"path":"2021/08/23/20210823_C_C++学习记录：深入理解三种传参方式/","permalink":"https://zgg2001.github.io/2021/08/23/20210823_C_C++%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B8%89%E7%A7%8D%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F/","excerpt":"&emsp;&emsp;之前对传参这方面的东西一直是知其然不知所以然。概念用法怎么用都知道，但是其真正的内部操作流程确实是理解不足。这两天一直在总结shell脚本的笔记，写累了正好研究一下传参这方面的内容。&emsp;&emsp;这篇笔记中记录了关于这方面我的理解过程和心得。关于本篇笔记的深度，也是到汇编为止不再深入，就我个人理解来看已经是足够了。","text":"&emsp;&emsp;之前对传参这方面的东西一直是知其然不知所以然。概念用法怎么用都知道，但是其真正的内部操作流程确实是理解不足。这两天一直在总结shell脚本的笔记，写累了正好研究一下传参这方面的内容。&emsp;&emsp;这篇笔记中记录了关于这方面我的理解过程和心得。关于本篇笔记的深度，也是到汇编为止不再深入，就我个人理解来看已经是足够了。 一、关于三种传参方式1. 值传参1.1 简单总结&emsp;&emsp;这是我在编程中最早接触的传参方式，也是一开始使用最多的传参方式。它的特点很明确就是简便，非常明了。当然缺点也是被说了很多次，就是慢+占用空间+不能修改实参。因为所谓的值传参是把实参的值复制了一遍，所以会有上面的特点。 1.2 我的疑问&emsp;&emsp;总是说值传参的执行过程会复制实参的值，那么它的流程是怎么样的？ 2. 引用传参2.1 简单总结&emsp;&emsp;这是C++里的概念，C里是没有的。它解决了值传参不能修改实参的问题，另外也比传值要快。就我目前接触到的C++代码中，里面均常常用到&amp;和const &amp;，例如stl的源码。 2.2 我的疑问&emsp;&emsp;我看网上说传引用其实也是传的指针，所以一直对引用的流程很有兴趣。如果真的也是传指针，那么它的意义就是更简单明了的传指针吗？另外很多源码中都使用const &amp;，我一直很好奇传引用究竟能比传值快多少。 3. 指针传参3.1 简单总结&emsp;&emsp;第一次接触传指针，还是在当时学习链表的时候。在此之前，我对于指针作用的印象仅仅是文件指针和一丢丢字符串的内容，而对于学习中碰到的那些什么*p,&amp;p的完全没有实际应用中的感受，甚至产生了疑问，为何大伙都说指针牛p？&emsp;&emsp;在接触到链表头结点的指针后，我首次发现原来传值是不能改变内容的(太菜了当时)，得传指针，所以链表函数传参时，节点得取个地址传进去，由此我打开了新世界的大门，感受到了指针的牛p。以至于后面再接触java的时候感觉浑身难受，感受到了一种局限感，所以后面我决定以C&#x2F;C++为方向。&emsp;&emsp;对我而言，指针传参相当于是一种 **”降维打击”**，相当于“你收拾不了他就去找他爹收拾他”。总而言之，向下层操作性很大(提领指针的内容)，可以修改实参并且速度也很快。但是，传指针相当于把传值的内容改为指针，所以指针层面也是不能被修改的(虽然我也没见过要修改最高层指针)，由于指针的大小是固定的而且很小，传指针的速度也会很快。 3.2 我的疑问&emsp;&emsp;底层流程是什么？是先获取地址，再走值传递那一套流程吗？ 二、汇编层面剖析1. 操作&emsp;&emsp;我的理解方式是通过vs2019的反汇编功能查看低层汇编代码进行比对分析，而下面是我的操作过程。&emsp;&emsp;首先是实验源码如下，可以看到我声明了三个函数，分别用了三种传参方法。 1234567891011121314151617181920212223242526272829303132333435/** 三种传参方式测试* 2021/8/22*/#include&lt;cstdio&gt;//值传参void func_value(int x)&#123; x = 22;&#125;//引用传参void func_ref(int&amp; x_ref)&#123; x_ref = 2222;&#125;//指针传参void func_ptr(int* x_ptr)&#123; *x_ptr = 22222;&#125;int main()&#123; int test_arg = 222; //值传参 func_value(test_arg); //引用传参 func_ref(test_arg); //指针传参 func_ptr(&amp;test_arg); return 0;&#125; &emsp;&emsp;接着，我开启调试反汇编，查看调用三个函数时的汇编源码，结果如下： 2. 总结&emsp;&emsp; 说实话，我没想到传引用和传指针的汇编源码竟然完全一样…而传值和另外两者的唯一区别就是第一条汇编指令。其中传值用的是汇编指令mov，而传引用和传指针用的都是汇编指令lea。&emsp;&emsp;然后我搜了下，mov是把内容复制到寄存器eax，而lea是把地址复制到寄存器里。所以这里传值是把变量test_arg的内容复制到寄存器，而后两者是把变量test_arg的地址复制到寄存器。而内容复制一般复制量都比地址复制要大，这也就造成了效率上的差距。且传值修改的是复制的内容，所以实参不会受影响；但后两者修改的是传入指针里的内容，这两个指针(传参和实参指针)指向的内容是一致的，所以实参会收到影响。 所以总结下，函数传参的流程如下： 执行lea或mov指令将内容或指针拷贝到寄存器上。 执行push指令把寄存器里的内容push进栈。 执行call指令调用函数。 执行add指令确保堆栈平衡，相当于执行pop操作把前面push的内容弹出。而add的值跟参数个数有关(之前push的值)。 三、运行时间对比实践&emsp;&emsp;一直好奇三者之间运行时间的差异，正好借着这次实践测试一下。 1. 传参类型偏小&emsp;&emsp;首先是测试传参类型偏小的情况吧。这里选择的传参类型是int，在32位环境下，int和int*大小是一致的4字节。根据上面的汇编源码来看，我个人认为mov4字节和lea一个地址时间消耗可能是五五开的，于是我进行了以下的测试。 &emsp;&emsp;测试代码如下，其中我使用到了一个自己实现的计时器，计时器内容在这篇博客里C++学习记录：基于chrono库的高精度计时器。 1.1 函数内单运算操作&emsp;&emsp;这部分我在函数内均仅进行单运算操作，如下。&emsp;&emsp;函数执行一定次数TIME后的结果如下。果然在传参实际传入大小差不多的情况下，实际时间消耗也是差不多的。在我理解上，其实引用和指针传参可能也是算一种值传参吧，只不过它们传的值是指针。所以在传值大小相似的情况下时间消耗也相似。 1.2 函数内多运算操作&emsp;&emsp;然后我想到，不同的传参方式，操作传参的时间消耗一致吗？于是在函数内新增了几条运算。既然该情况下传参速度相同，如果执行速度也相同，则说明操作传参的时间消耗一致。 &emsp;&emsp;函数内均修改为如下操作：&emsp;&emsp;函数执行一定次数TIME后的结果如下。果然在操作增多的情况下，实际时间消耗也是差不多的。这说明操作传参的时间消耗是一致的。 2. 传参类型偏大“在我理解上，其实引用和指针传参可能也是算一种值传参吧，只不过它们传的值是指针。所以在传值大小相似的情况下时间消耗也相似。” &emsp;&emsp;为了证明我的这个猜测，我对传参类型进行了改变，这次选择使用的数据类型是c++的数据结构std::string。在32位环境下，std::string的大小是28字节，std::string*的大小还是4字节，即两者大小是七倍的关系。则如果时间消耗差距较大的话，则说明真正影响传参速度是传的大小，就说明我的猜测算是对的吧。 &emsp;&emsp;测试代码如下，还是用到了上文中提到的计时器。&emsp;&emsp;这部分函数的操作如下，仅仅是简单的sizeof操作。&emsp;&emsp;运行结果如下，可以看到时间如下，果然时间差距是非常的大。说明传参时间根本上还是受传参大小影响。不过我好奇的是为何时间差距这么大，我猜测可能是内存分配时间不同或是调用了std::string的构造参数吧。 四、体会&emsp;&emsp;随着和C&#x2F;C++打交道的时间越来越长，我探索的内容也越发深入、复杂。但是当真正理解了之前疑惑的内容，说实话还是很开心的。&emsp;&emsp;另外吐槽下csdn上鱼龙混杂，发的大部分都是很基础没有营养的东西，或者不知道哪抄的错误百出的内容，当然也有很多大佬的内容让我受益匪浅(深表感谢orz)，现在我搜个东西都得“发掘”半天。但是从某种意义上来讲我是有一点开心的，这说明我至少已经算入门了嘛XD","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"C++标准库学习","slug":"C-标准库学习","permalink":"https://zgg2001.github.io/tags/C-%E6%A0%87%E5%87%86%E5%BA%93%E5%AD%A6%E4%B9%A0/"},{"name":"源码阅读","slug":"源码阅读","permalink":"https://zgg2001.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"}]},{"title":"linux学习记录：用户与/etc/passwd与/etc/shadow","slug":"20210818_linux学习记录：用户与passwd","date":"2021-08-18T15:05:56.000Z","updated":"2021-08-18T15:05:56.000Z","comments":true,"path":"2021/08/18/20210818_linux学习记录：用户与passwd/","permalink":"https://zgg2001.github.io/2021/08/18/20210818_linux%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E7%94%A8%E6%88%B7%E4%B8%8Epasswd/","excerpt":"这部分内容也是在实习中接触到的，其中关于各个伪用户关联的内容，我都一一进行了查询，于是记录一下相关内容，方便日后查看。","text":"这部分内容也是在实习中接触到的，其中关于各个伪用户关联的内容，我都一一进行了查询，于是记录一下相关内容，方便日后查看。 一、&#x2F;etc&#x2F;passwd&emsp;&emsp;这个文件中储存了系统中的各个用户，它记录了用户的一些基本属性。如下图，其中每一行都是一个用户。&emsp;&emsp;可以很明显的看出来每一行的开头都是一个用户名，而各个字段直接之间是由:来进行分隔的。其中字段格式与含义如下： 1注册名：口令：用户标识号：组标识号：用户名：用户主目录：命令解释器 注册名&emsp;&emsp;用于区分不同的用户。在同一系统中注册名是惟一的，且用户名是区分大小写的。 口令&emsp;&emsp;通俗来讲就是密码，用来验证用户的合法性。但是目前来看，现在的口令不再直接保存在passwd文件中，通常将passwd文件中的口令字段使用一个x来代替，而真正的口令储存在/etc/shadow中。所以可以看到上图中，第二个字段的内容均为 x 。 用户标识号&emsp;&emsp;英文缩写叫做UID，它是一个数值，是Linux系统中惟一的用户标识，用于区别不同的用户。在系统内部管理进程和文件保护时使用 UID字段。在Linux系统中，注册名和UID都可以用于标识用户，只不过对于系统来说UID更为重要。而对于用户来说注册名使用起来更方便。在某些特定目的下，系统中可以存在多个拥有不同注册名、但UID相同的用户，事实上，这些使用不同注册名的用户实际上是同一个用户。&emsp;&emsp;在find命令中可以使用-uid来对用户标识号进行检索，例如-uid +0即为检索所有UID大于0的内容。&emsp;&emsp;在linux系统中(linux7及以上)，UID为0的即为管理员用户，UID在1~999的为系统用户，UID在1000及往上的为普通用户。所以一个很简单的给普通用户管理员权限的方法就是把他的UID改为0。 组标识号&emsp;&emsp;英文缩写叫做GID，是用户的工作组标识，而每个用户可以同时属于多个组。在/etc/passwd文件中指定一个用户归属的基本组，而在/etc/group文件中指明一个组所包含的用户。 描述性信息&emsp;&emsp;这个字段包含用户的一些信息，可以算作一个小备注。就我的体验来看没有什么。 用户主目录&emsp;&emsp;这个字段标明了各个用户的个人主目录。在shell中可以通过cd ~来进入自己的个人主目录。&emsp;&emsp;就一般的规则来看，root用户的个人主目录为/root，而普通用户的个人主目录为/home下的同用户名目录。 命令解释器&emsp;&emsp;这个字段的内容是指定用户的shell程序，可以看到上图中root的shell为/bin/bash。通过命令cat /etc/shells可以查看本系统下支持的shell。 二、&#x2F;etc&#x2F;shadow&emsp;&emsp;这个文件中储存了系统中的各个用户的密码信息，被称为”影子文件”。&emsp;&emsp;可以很明显的看出来每一行的开头都是一个用户名，而各个字段直接之间也是由:来进行分隔的。其中字段格式与含义如下： 12用户名 : 加密密码 : 最后一次修改时间 : 最小修改时间间隔 : 密码有效期 : \\密码需要变更前的警告天数 : 密码过期后的宽限时间 : 账号失效时间 : 保留字段 用户名&emsp;&emsp;和上文中passwd文件中的用户名含义一样，也是用于区分不同的账户。 加密密码&emsp;&emsp;这里保存的是真正加密的密码。目前 Linux 的密码采用的是 SHA512 散列加密算法，原来采用的是 MD5 或 DES 加密算法。SHA512 散列加密算法的加密等级更高，也更加安全。&emsp;&emsp;而且这部分加密后的密码是不能更改的，更改后会无法登录。当使用usermod -L命令禁用账户时，也是在这部分最前面加上了!来达到使账户无法登录的目的。&emsp;&emsp;所有伪用户的密码都是 “!!” 或 “*”，代表没有密码是不能登录的。当然，新创建的用户如果不设定密码，那么它的密码项也是 “!!”，代表这个用户没有密码，不能登录。 1234567星号代表帐号被锁定，将无法登录；双叹号表示这个密码已经过期了， 如果是\\$x\\$xxxxxxxx\\$的形式，则代表密码正常。$6$ 表明是用SHA-512加密的，密文长度86$1$ 表明是用MD5加密的，密文长度22个字符$2$ 是用Blowfish加密的，$5$ 是用 SHA-256加密的，密文长度43 最后一次修改时间&emsp;&emsp;此字段表示最后一次修改密码的时间，在1970 年 1 月 1 日的基准上，加上该字段显示的天数，即为最后修改的时间。通过命令date -d &quot;1970-01-01 18818 days&quot;可以获取具体是哪一天。 最小修改时间&emsp;&emsp;最小修改间隔时间，也就是说，该字段规定了从第 3 字段（最后一次修改密码的日期）起，多长时间之内不能修改密码。如果是 0，则密码可以随时修改；如果是 10，则代表密码修改后 10 天之内不能再次修改密码。 密码有效期&emsp;&emsp;这个字段可以指定距离第 3 字段（最后一次更改密码）多长时间内需要再次变更密码，否则该账户密码进行过期阶段。&emsp;&emsp;该字段的默认值为 99999，也就是 273 年，可认为是永久生效。如果改为 90，则表示密码被修改 90 天之后必须再次修改，否则该用户即将过期。管理服务器时，通过这个字段强制用户定期修改密码。 密码需要变更前的警告天数&emsp;&emsp;与第 5 字段相比较，当账户密码有效期快到时，系统会发出警告信息给此账户，提醒用户密码需要变更。&emsp;&emsp;该字段的默认值是 7，也就是说，距离密码有效期的第 7 天开始，每次登录系统都会向该账户发出 “修改密码” 的警告信息。 密码过期后的宽限时间&emsp;&emsp;也称为“口令失效日”，简单理解就是，在密码过期后，用户如果还是没有修改密码，则在此字段规定的宽限天数内，用户还是可以登录系统的；如果过了宽限天数，系统将不再让此账户登陆，也不会提示账户过期，是完全禁用。&emsp;&emsp;比如说，此字段规定的宽限天数是 10，则代表密码过期 10 天后失效；如果是 0，则代表密码过期后立即失效；如果是 -1，则代表密码永远不会失效。 账号失效时间&emsp;&emsp;同第 3 个字段一样，使用自 1970 年 1 月 1 日以来的总天数作为账户的失效时间。该字段表示，账号在此字段规定的时间之外，不论你的密码是否过期，都将无法使用。 保留字段&emsp;&emsp;目前没有功能，保留。 三、如何禁用一个用户？&emsp;&emsp;从结果来看，只要让这个用户没办法登录，就可以说是禁用这个用户了。所以可以通过以下方式来实现禁用。 1. 修改&#x2F;etc&#x2F;passwd&emsp;&emsp;把想要禁用的用户的解释器选项配置为/sbin/nologin即可。 2. 修改&#x2F;etc&#x2F;shadow&emsp;&emsp;改动一下第二个密码字段即可，可以在该字段添加一些字符或者更改为*或!或!!即可使得该账户无法登录。 3. 使用usermod命令&emsp;&emsp;usermod -L user禁用用户， usermod -U user解禁用户。经过执行可以发现，其实这个命令的原理其实就是在/etc/shadow中的密码字段前添加!。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zgg2001.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://zgg2001.github.io/tags/Linux/"}]},{"title":"Linux学习记录：sudo相关","slug":"20210812_Linux学习记录：sudo相关","date":"2021-08-12T14:04:14.000Z","updated":"2021-08-12T14:04:14.000Z","comments":true,"path":"2021/08/12/20210812_Linux学习记录：sudo相关/","permalink":"https://zgg2001.github.io/2021/08/12/20210812_Linux%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9Asudo%E7%9B%B8%E5%85%B3/","excerpt":"在实习中接触到了系统安全相关的内容，其中一个重点就是对sudo权限的控制。正好我对这块东西不太熟悉，于是对相关的内容做了笔记汇总。 这篇笔记中重点放在sudo的配置文件/etc/sudoers上，下面的关键字(或其他)基本都是这个配置文件里的内容。关于这个配置文件，它是仅可读的，使用管理员账号修改时直接使用w!强制修改即可。 正好了解完相关的内容把我的那台阿里云服务器完善下","text":"在实习中接触到了系统安全相关的内容，其中一个重点就是对sudo权限的控制。正好我对这块东西不太熟悉，于是对相关的内容做了笔记汇总。 这篇笔记中重点放在sudo的配置文件/etc/sudoers上，下面的关键字(或其他)基本都是这个配置文件里的内容。关于这个配置文件，它是仅可读的，使用管理员账号修改时直接使用w!强制修改即可。 正好了解完相关的内容把我的那台阿里云服务器完善下 targetpw使能后，让普通用户需要用root密码使用sudo 默认off 1Defaults targetpw always_set_home使能后，sudo将HOME环境变量设置为目标用户（默认为root，除非使用-u指定）的home目录。效果相当于每次执行包含-H选项。 默认off 1Defaults always_set_home env_reset使能后，sudo将在一个最小集的环境变量中运行命令，此时环境变量包括： a)TERM, PATH, HOME, MAIL, SHELL, LOGNAME, USER, USERNAME and SUDO_*变量； b)与env_keep和env_check匹配的所有调用者的环境变量； c)env_file选项指定的文件中的变量。 在关闭此命令后 使用sudo后环境变量不会被重置为默认 默认on 1Defaults env_reset authenticate布尔类型，如果设置(为on)的话，用户在用sudo执行命令之前必须通过口令(或者通过其他的方式)来验证身分。这个默认选项可以通过设置PASSWD和NOPASSWD标签来覆盖。 默认on 1Defaults authenticate fast_globfast_glob控制sudo在进行路径匹配时使用的匹配函数。在进行路径名匹配时，Sudo一般使用glob(3)函数做shell-style globbing，因为它会访问文件系统，因此对于某些模式glob(3)可能需要很长时间才能完成，特别是当模式引用按需安装的网络文件系统（自动挂载）时。 fast_glob选项导致sudo使用fnmatch(3)函数，该函数不访问文件系统进行匹配。fast_glob的缺点是它无法匹配相对路径名，例如.&#x2F;ls或..&#x2F;bin&#x2F;ls。当包含通配符的路径名与否定运算符“!”一起使用时，会产生安全隐患，这样的规则可以被轻易绕过。 默认off 1Defaults fast_glob passwd_tries整数类型，sudo向日志中写入一个登录失败记录并退出之前允许用户输入口令的次数。 默认值为3 1Defaults passwd_tries=3 timestamp_timeout整数类型，sudo再次询问口令之前的时间(以分钟记)。如果想要总是询问口令的话请把此值设置为0。如果设置为负数的话，用户的时间戳永远不会过期，这可以用来允许用户分别使用sudo -v和sudo -k来建立或者删除他们自己的时间戳。 默认值为5 1Defaults timestamp_timeout=5 passwd_timeout整数类型，sudo询问口令的超时时间(分钟记)。设置为0可以取消口令超时。 默认值为5 1Defaults passwd_timeout=5 runas_default字符串类型，使用sudo但没有指定-u标志时使用的默认用户。 默认值为root 1Defaults:zhj runas_default=root logfile字符串类型，sudo日志的存放位置。设置一个路径来打开日志功能，取消设置将关闭日志功能。默认情况sudo通过syslog记录日志。 说明：如果启用syslog，则无需开启此选项，否则建议设置为&#x2F;var&#x2F;log&#x2F;sudo.log。 1Defaults logfile=/var/log/sudo.log 标签一个命令可以具有与它相关联的零个或多个标签。有十个可能的标记值：EXEC, NOEXEC, FOLLOW, NOFOLLOW, LOG_INPUT,NOLOG_INPUT, LOG_OUTPUT, NOLOG_OUTPUT, MAIL, NOMAIL, PASSWD, NOPASSWD, SETENV, NOSETENV。 一旦标签被设置在某个命令上，在该命令列表中随后的所有命令将继承该标记，直到由相反的标记项覆盖（例如PASSWD覆盖NOPASSWD，NOEXEC覆盖EXEC），这里需要重点关注的是NOPASSWD和SETENV选项。 1）NOPASSWD标签：默认情况下，sudo要求用户运行一个命令之前对目标用户进行验证，这种行为可以通过NOPASSWD标签进行修改，使用NOPASSWD后表示此后的命令都不需要进行验证。 2）SETENV标签：为命令设置SETENV标签后，用户可以通过-E选项从命令行禁用env_reset选项，同时，在命令行上设置的环境变量不受env_check，env_delete或env_keep的限制，用户就可以使用自己的环境变量。因此，只允许受信任的用户以这种方式设置变量。 用户规则用户可以在#User privilege specification下配置用户规则，用户规则确定用户可以在指定主机上运行哪些命令（以及作为哪个用户）。默认情况下，命令以root身份运行，但可以基于每个命令进行更改。用户规范的基本结构是“who where &#x3D; (as_whom) what”，通常的配置格式为： 123456789user host = run_as [option:] commanduser：一位或几位用户，组对象的名称用百分号%开头；host：一个或几个主机名，ALL表示所有主机；run_as：命令运行的目标用户，常见选项是root和ALL，ALL表示所有用户；option：影响命令运行的选项；command：可执行一个或几个命令，ALL表示所有命令；比如：jack ALL= (root) NOPASSWD: /usr/bin/cat表示用户jack可以在所有主机上已root用户执行/usr/bin/cat命令，且不需要root密码。 用户规则中的命令指定用户规则中，可配置的命令包括命令名和目录。命令名称是完全限定的文件名，比如系统命令(&#x2F;bin&#x2F;ls)、自定义的命令（&#x2F;opt&#x2F;sudobin&#x2F;test）、任意脚本（&#x2F;opt&#x2F;sudobin&#x2F;a.sh），这些命令可以包含shell样式的通配符。目录是以’&#x2F;‘结尾的完全限定路径名，当指定目录时，用户将能够运行该目录中的任何文件（但不能在其中的任何子目录中）。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zgg2001.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://zgg2001.github.io/tags/Linux/"}]},{"title":"Linux学习记录：Makefile","slug":"20210808_Linux学习记录：Makefile","date":"2021-08-08T15:33:05.000Z","updated":"2021-08-08T15:33:05.000Z","comments":true,"path":"2021/08/08/20210808_Linux学习记录：Makefile/","permalink":"https://zgg2001.github.io/2021/08/08/20210808_Linux%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9AMakefile/","excerpt":"这是本人在学习makefile时的记录，方便日后查询。 所有我遇到的makefile相关的内容都会被记录在这篇笔记中，所以在之后接触到makefile相关的新内容后，会对这篇笔记的内容进行更新。 相关内容学习主要在B站和C语言中文网上进行。","text":"这是本人在学习makefile时的记录，方便日后查询。 所有我遇到的makefile相关的内容都会被记录在这篇笔记中，所以在之后接触到makefile相关的新内容后，会对这篇笔记的内容进行更新。 相关内容学习主要在B站和C语言中文网上进行。 零、Makefile简介 描述了整个工程的编译、链接规则 · 工程中的哪些源文件需要编译以及如何编译 · 需要创建哪些库文件以及如何创建这些库文件 · 如何产生期望得到的最终可执行文件 · 可以快速的构建和管理工程 make的执行机制 · makefile文件的命名: Makefile 或 makefile · 在make执行时，会依次寻找GNUmakefile、Makefile、makefile，如未找到则报错，找到则执行此makefile文件。 · 在执行makefile文件时，make会检测每一条命令的返回值，如果失败的话会报错并终止make，否则会继续进行。 · 可以使用 make -f 来指定make命令读取的脚本名 makefile的执行流程 · 从makefile的第一个目标开始执行(从上往下数第一个) · 首先看该目标的依赖项，看依赖项是否存在 · 如果不存在依赖项，则执行命令后结束。 · 如果存在就先执行依赖项相关目标(然后看依赖项目标是否有依赖项…以此不断寻找最内层，有点dfs的感觉) PS: 这里简单提一嘴编译和链接的过程… 步骤号 执行前 要干嘛 过程 执行后 1 源文件(.c, .cpp, .h) 预处理器(Preprocessor)进行预处理 引入头文件、进行宏替换等 预编译文件(.i, .ii) 2 预编译文件(.i, .ii) 编译器(Compiler)进行编译处理 比如使用gcc或者g++进行编译 汇编码(.s) 3 汇编码(.s) 汇编程序(Assembler)进行汇编 把汇编码转为机器码 机器码(.o, .obj) 4 机器码(.o, .obj) 链接器(Linker)进行链接 对静态库(.lib, .a)进行连接 得到可执行文件 一、基础语法基础语法如下： 12345678target...: prerequisttes... command... ...其中：1.target为目标文件，可以是obj文件也可以是可执行文件2.prerequisttes为依赖性，即生成目标文件所关联到的文件3.command为指令，即make所需要执行的指令 1. 单源文件例子下面是一个简单的单源文件makefile例子：&emsp;&emsp;如上图所示，在当前文件夹内有两个文件 main.c 和 makefile，而文件中的内容分别如下： 123456789101112131415161718/** main.c* 为简单的打印HelloWorld*/#include&lt;stdio.h&gt;int main()&#123; printf(&quot;HelloWorld\\n&quot;); return 0;&#125;/** makefile* 设定目标文件为main，依赖项为main.c，命令语句为gcc main.c -o main*/main: main.c gcc main.c -o main &emsp;&emsp;如下图，执行make命令后，可以看到它执行了预设的gcc命令，随后正常生成了main可执行文件，并可以正常执行。由此，一个最简单的基础makefile示例就完成了。 2. 多源文件例子下面是一个简单的多源文件makefile例子：&emsp;&emsp;如下，是一个文件夹里的四个文件：func.h、func.c、main.c、makefile，具体内容都列在下方。其中func为一个简单的加法函数，而makefile中涉及了变量和伪目标的概念，具体内容在下面都会记录。 123456789101112131415161718192021222324252627282930313233343536373839/*func.h*/#ifndef _FUNC_H_#define _FUNC_H_int func(int a, int b);#endif/*func.c*/#include&quot;func.h&quot;int func(int a, int b)&#123; return a + b;&#125;/*main.c*/#include&lt;stdio.h&gt;#include&quot;func.h&quot;int main()&#123; printf(&quot;HelloWorld\\n1 + 2 = %d\\n&quot;, func(1, 2)); return 0;&#125;/*makefile 涉及到变量和伪目标，具体概念都在下文*/TARGET = maincc = gccFILE = main.c func.oTARGET: $(FILE) $(CC) $(FILE) -w -o $(TARGET)func.o: func.c $(CC) -c func.c.PHONY: cleanclean: rm $(TARGET) *.o &emsp;&emsp;如下图，执行make命令，可以看到gcc命令由下向上执行(因为从最内层依赖项开始生成)，生成了最终目标文件main，执行main发现func函数正常被调用，说明make成功。&emsp;&emsp;如下图，执行make clean命令，可以看到rm命令被正常执行，删除了main文件和所有.o后缀的文件。说明伪目标clean建立成功。自此该多源文件例子已经完成。 二、变量相关1. 基础变量简介：&emsp;&emsp;makefile脚本中可以引入变量来使得编写更加简便以及清晰。变量的声明非常简单，格式为 变量名 = 值 ；而调用变量的格式则为 $(变量名)， 由此即可使用变量。 一个简单的例子：&emsp;&emsp;对上文单文件例子中的makefile进行简单修改，引入一些变量。修改如下： 12345678910/*修改前*/main: main.c gcc main.c -o main/*修改后*/TARGET = maincc = gccFILE = main.c$(TARGET): $(FILE) $(CC) $(FILE) -o $(TARGET) &emsp;&emsp;如下图，在修改完makefile后，make仍可正常进行。通过变量，可以方便日后的修改，比如说想把gcc换成g++，就可以把编译器设为变量，想更换编译器时直接修改变量值即可，可以大大减少修改量。 2. 一些变量相关符号 符号 意义 &#x3D; 是最基本的赋值 :&#x3D; 是覆盖之前的值 ?&#x3D; 是如果没有被赋值过就赋予等号后面的值 +&#x3D; 是添加等号后面的值 1234567891011121314151617181920212223之前一直纠结makefile中“=”和“:=”的区别到底有什么区别，因为给变量赋值时，两个符号都在使用。看一篇博客，无意中发现作者对于这个问题做了很好的解答。1、“=”make会将整个makefile展开后，再决定变量的值。也就是说，变量的值将会是整个makefile中最后被指定的值。看例子：x = fooy = $(x) barx = xyz在上例中，y的值将会是 xyz bar ，而不是 foo bar 。2、“:=”“:=”表示变量的值决定于它在makefile中的位置，而不是整个makefile展开后的最终值。x := fooy := $(x) barx := xyz在上例中，y的值将会是 foo bar ，而不是 xyz bar 了。 三、伪目标&emsp;&emsp;通常makefile中第一个目标为最终目标，后续目标和最终目标有依赖关系。但是有时候想要执行清空生成的文件等一些单独执行的命令时，很明显这些命令并不会生成目标文件，由此和生成最终目标也没有必要关系，需要与普通的command进行区分，这时就出现了伪目标的概念。&emsp;&emsp;伪目标不是一个输出文件，而是一个标签。在执行make指令时，并不会主动执行伪目标的命令(因为伪目标没有依赖项)，想要执行伪目标就必须使用命令 make 伪目标名 或者把伪目标放到makefile最上面。而显式声明伪目标的语法为 .PHONY: 伪目标名，随后设定调用此伪目标时执行的命令即可。 一个简单的例子：&emsp;&emsp;对上文单文件例子中的makefile进行简单修改(多文件例子中已经存在clean)，在末尾引入伪目标，使其可以删除掉生成的main可执行文件。修改如下： 123456789/*修改后*/TARGET = maincc = gccFILE = main.c$(TARGET): $(FILE) $(CC) $(FILE) -o $(TARGET).PHONY: cleanclean: rm $(TARGET) &emsp;&emsp;如下图，在执行伪目标clean后，删除掉了设定好的最终目标main。在make后，再次生成最终目标main文件。 四、make嵌套执行&emsp;&emsp;在大的工程会把源文件分为很多个目录，为了逻辑上的简单，会为每个子目录写一个makefile文件，而最上层的makefile文件被称为总控makefile。通过执行总控makefile，即可自动执行下层的makefile文件，从而使得项目总体进行make操作。 下面是一个例子：&emsp;&emsp;我在当前文件夹内创建了三个新文件夹：main存放main.c源码、func存放func.h&#x2F;c源码、build中存放obj文件和最终可执行文件。并且三个文件夹内都有自己的makefile文件，而当前文件夹下有总控makefile文件。源码如下： .&#x2F;func:1234567891011121314151617181920212223242526/* func.h */#ifndef _FUNC_H_#define _FUNC_H_int func(int a, int b);#endif/* func.c */#include&quot;func.h&quot;int func(int a, int b)&#123; return a + b;&#125;/* makefile */CC = gccfunc.o: func.c $(CC) -c func.c -o func.o cp func.o ../build/func.o.PHONY: cleanclean: rm *.o .&#x2F;main:1234567891011121314151617181920/* main.c */#include&lt;stdio.h&gt;#include&quot;../func/func.h&quot;int main()&#123; printf(&quot;HelloWorld\\n1 + 2 = %d\\n&quot;, func(1, 2)); return 0;&#125;/* makefile */CC = gccmain.o: main.c $(CC) -c main.c -o main.o cp main.o ../build/main.o.PHONY: cleanclean: rm *.o .&#x2F;build: 12345678CC = gcctest: func.o main.o $(CC) func.o main.o -I ../func -o test.PHONY: cleanclean: rm test *.o .&#x2F;:1234567891011.PHONY: allall: cd func;make cd main;make cd build;make.PHONY: cleanclean: cd build;make clean cd main;make clean cd func;make clean &emsp;&emsp;可以看到上面四部分文件存在一个总控makefile和三个子makefile，通过make最终在build文件夹内生成可执行文件test，而test输出HelloWorld已经一个简单的加法式子。&emsp;&emsp;由上图可以看到，在执行make命令后，其按顺序依次进入各个文件夹并执行make命令(蓝框内)，在make完成后，挨个查看各个文件夹，发现文件均正常生成。最后执行可执行文件test，发现正常执行，说明本次make成功。&emsp;&emsp;由上图可以看到，在执行make clean命令后，其按顺序进入各个文件夹并执行make clean命令，随后相关文件均被清除。自此该例子完成，其已经实现了make嵌套的功能。 五、条件判断1. ifeq &#x2F; ifneq 关键字 作用 ifeq 判断参数是否不相等，相等为 true，不相等为 false。 ifneq 判断参数是否不相等，不相等为 true，相等为 false。 使用方式如下，ifeq和ifneq使用方法相同。 12345ifeq (ARG1, ARG2)ifeq &#x27;ARG1&#x27; &#x27;ARG2&#x27;ifeq &quot;ARG1&quot; &quot;ARG2&quot;ifeq &quot;ARG1&quot; &#x27;ARG2&#x27;ifeq &#x27;ARG1&#x27; &quot;ARG2&quot; 例子如下，例子中进行判定，若编译器为gcc则链接gnu库，否则不链接库。其中用到了ifeq、else、endif。 12345678libs_for_gcc= -lgnunormal_libs=foo:$(objects)ifeq($(CC),gcc) $(CC) -o foo $(objects) $(libs_for_gcc)else $(CC) -o foo $(objects) $(normal_libs)endif 2. ifdef &#x2F; ifndef 关键字 作用 ifdef 判断是否有值，有值为 true，没有值为 false。 ifndef 判断是否有值，没有值为 true，有值为 false。 使用方法如下，ifdef和ifndef 使用方法相同。 1ifdef VARIABLE-NAME 两个例子 123456789101112131415161718/* 例1 */bar =foo = $(bar)all:ifdef foo @echo yeselse @echo noendif/* 例2 */foo =all:ifdef foo @echo yeselse @echo noendif &emsp;&emsp;通过执行make可以发现例1打印的结果是yes，例2打印的结果是no。其原因就是例1中变量foo的定义是foo &#x3D; $(bar)，虽然变量bar的值为空，但是ifdef的判断结果为真。这种方式判断显然是不行的，所以当需要判断一个变量的值是否为空的时候需要使用ifeq而不是ifdef。如下即可进行判空： 1#ifeq(变量,) 六、shell特殊变量 变量名 意义 $@ 表示目标文件 $^ 表示所有的依赖文件 $&lt; 表示第一个依赖文件 $? 表示比目标还要新的依赖文件列表 七、通配符&emsp;&emsp;在makefile文件中也可以使用通配符来模糊指定，比如说上面就存在rm *.o来删除所有的.o文件，通配符的具体用法如下： 通配符 使用说明 * 匹配0个或者是任意个字符 ? 匹配任意一个字符 [] 可以指定匹配的字符放在 “[]” 中 &emsp;&emsp;但是有一点需要注意，当需要在变量中使用通配符时，比如想要用变量OBJ来指向所有.c文件，写成OBJ = *.c是错误的，因为这里是把OBJ的值设为一个叫*.c的文件。这里需要使用关键字wildcard来告诉系统这里用到了通配符，所以正确写法是OBJ = $(wildcard *.c)，这算是通配符相关的一个重点。 还有一个和通配符*相类似的字符，这个字符是%，也是匹配任意个字符，使用在相关规则当中。1234test:test.o test1.o gcc -o $@ $^%.o:%.c gcc -o $@ $^ &emsp;&emsp;如上面这个例子， %.o把需要的所有的.o文件组合成为一个列表，从列表中挨个取出的每一个文件，则%表示取出来文件的文件名（不包含后缀），然后找到文件中和 %名称相同的.c文件，执行下面的命令，直到列表中的文件全部被取出来为止。&emsp;&emsp;这个属于Makefile中静态模规则：规则存在多个目标，并且不同的目标可以根据目标文件的名字来自动构造出依赖文件。与多规则目标的意思相近，但是又不相同。 八、目标文件搜索1. 一般搜索 VPATH语法如下： 1234567891011//单文件：VPATH := src//多文件：VPATH := src carVPATH := src:car//例子：VPATH=src cartest:test.o gcc -o $@ $^ &emsp;&emsp;注意：无论你定义了多少路径，make 执行的时候会先搜索当前路径下的文件，当前目录下没有我们要找的文件，才去 VPATH 的路径中去寻找。如果当前目录下有我们要使用的文件，那么 make 就会使用我们当前目录下的文件。 2. 选择搜索vpath区别：VPATH 是搜索路径下所有的文件，而 vpath 更像是添加了限制条件，会过滤出一部分再去寻找。语法如下： 123456789101112131415vpath支持模糊搜索%.c 代表.c文件//单文件：vpath test.c src //在src目录下寻找test.c文件//多文件：vpath test.c src car //在src car目录下寻找test.c文件 vpath test.c src : car//清除符合文件 test.c 的搜索目录vpath test.c//清除所有已被设置的文件搜索路径vpath 九、include文件包含&emsp;&emsp;当 make 读取到 include关键字的时候，会暂停读取当前的 Makefile，而是去读include包含的文件，读取结束后再继读取当前的 Makefile 文件。其使用的具体方式如下： 1include &lt;filenames&gt; 其中 filenames 是 shell 支持的文件名（可以使用通配符表示的文件）。 &emsp;&emsp;使用时，通常用-include来代替include来忽略文件不存在或者是无法创建的错误提示，使用格式如下： 1-include &lt;filename&gt; 使用方法和 “include” 的使用方法相同。 使用include &lt;filenames&gt;，make 在处理程序的时候，文件列表中的任意一个文件不存在的时候或者是没有规则去创建这个文件的时候，make 程序将会提示错误并保存退出。 使用-include &lt;filenames&gt;，当包含的文件不存在或者是没有规则去创建它的时候，make 将会继续执行程序，只有真正由于不能完成终极目标重建的时候我们的程序才会提示错误保存退出。 include通常使用在以下的场合： 在一个工程文件中，每一个模块都有一个独立的 Makefile 来描述它的重建规则。它们需要定义一组通用的变量定义或者是模式规则。通用的做法是将这些共同使用的变量或者模式规则定义在一个文件中，需要的时候用include包含这个文件。 当根据源文件自动产生依赖文件时，我们可以将自动产生的依赖关系保存在另一个文件中。然后在 Makefile 中包含这个文件。 十、字符串处理函数1. patsubst123456789$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)函数说明：函数功能是查找 text 中的单词是否符合模式 pattern，如果匹配的话，则用 replacement 替换。返回值为替换后的新字符串。实例： //执行 make 命令，我们可以得到的值是 &quot;1.o 2.o 3.o&quot; OBJ=$(patsubst %.c,%.o,1.c 2.c 3.c) all: @echo $(OBJ) 2. subst12345678 $(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt;)函数说明：函数的功能是把字符串中的 form 替换成 to，返回值为替换后的新字符串。实例： //执行 make 命令，我们得到的值是&quot;fEEt on the strEEt&quot; OBJ=$(subst ee,EE,feet on the street) all: @echo $(OBJ) 3. strip123456789 $(strip &lt;string&gt;)函数说明：函数的功能是去掉字符串的开头和结尾的字符串，并且将其中的多个连续的空格合并成为一个空格。返回值为去掉空格后的字符串。实例： //执行完 make 之后，结果是“a b c” OBJ=$(strip a b c) all: @echo $(OBJ) 4. findstring123456789 $(findstring &lt;find&gt;,&lt;in&gt;)函数说明：函数的功能是查找 in 中的 find ,如果我们查找的目标字符串存在。返回值为目标字符串，如果不存在就返回空。实例： //执行 make 命令，得到的返回的结果就是&quot;a&quot; OBJ=$(findstring a,a b c) all: @echo $(OBJ) 5. filter123456789 $(filter &lt;pattern&gt;,&lt;text&gt;) 函数说明：函数的功能是过滤出 text 中符合模式 pattern 的字符串，可以有多个 pattern 。返回值为过滤后的字符串。实例： //执行 make 命令，我们得到的值是&quot;1.c 2.o&quot; OBJ=$(filter %.c %.o,1.c 2.o 3.s) all: @echo $(OBJ) 6. filter-out123456789 $(filter-out &lt;pattern&gt;,&lt;text&gt;) 函数说明：函数的功能是功能和 filter 函数正好相反，但是用法相同。去除符合模式 pattern 的字符串，保留符合的字符串。返回值是保留的字符串。实例： //执行 make 命令，打印的结果是&quot;3.s&quot; OBJ=$(filter-out 1.c 2.o ,1.o 2.c 3.s) all： @echo $(OBJ) 7. sort12345678910 $(sort &lt;list&gt;) 函数说明：函数的功能是将 &lt;list&gt; 中的单词排序（升序）。返回值为排列后的字符串。实例： //执行 make 命令，我们得到的值是&quot;bar foo lost&quot; OBJ=$(sort foo bar foo lost) all: @echo $(OBJ)注意：sort会去除重复的字符串。 8. word123456789 $(word &lt;n&gt;,&lt;text&gt;) 函数说明：函数的功能是取出函数 &lt;text&gt; 中的第n个单词。返回值为我们取出的第 n 个单词。实例： //执行 make 命令，我们得到的值是&quot;2.c&quot; OBJ=$(word 2,1.c 2.c 3.c) all: @echo $(OBJ) 十一、一些小东西1. @echo&emsp;&emsp;在makefile中执行echo命令(例echo &quot;HelloWorld&quot;)时，会出现回显情况，即先输出一次echo命令(echo &quot;HelloWorld&quot;)，再输出相关内容(HelloWorld)。&emsp;&emsp;为了避免这种情况，可以使用@echo命令(例@echo &quot;HelloZHJ&quot;)，此时就只会输出内容(HelloZHJ)了。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zgg2001.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://zgg2001.github.io/tags/Linux/"}]},{"title":"数据结构实操：STL标准红黑树(一)","slug":"20210802_数据结构实操：STL标准红黑树(一)","date":"2021-08-02T14:49:11.000Z","updated":"2021-08-02T14:49:11.000Z","comments":true,"path":"2021/08/02/20210802_数据结构实操：STL标准红黑树(一)/","permalink":"https://zgg2001.github.io/2021/08/02/20210802_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E6%93%8D%EF%BC%9ASTL%E6%A0%87%E5%87%86%E7%BA%A2%E9%BB%91%E6%A0%91(%E4%B8%80)/","excerpt":"之前一直在看侯捷大佬的《STL源码剖析》，透过标准库里的代码学到了许多。随后便想着按照STL标准来简单重写一个红黑树。当然，这里的简单是指对空间配置器结构的一些省略。 代码部分本来在6月底就基本完成了，但是因为7月忙着吸收总结实习中学习的内容，所以一直搁置了红黑树的总结。由于《STL源码剖析》中并没有红黑树节点删除相关以及一些小细节的讲解，所以相关的内容是我在别的地方学习后根据STL标准自己补全的代码，如有纰漏，还请提醒。 本次总结预计分为三篇，(一)中主要记录相关的代码思路结构，(二)中重点分析添加红黑树节点相关的内容，(三)中重点分析删除红黑树节点相关的内容。","text":"之前一直在看侯捷大佬的《STL源码剖析》，透过标准库里的代码学到了许多。随后便想着按照STL标准来简单重写一个红黑树。当然，这里的简单是指对空间配置器结构的一些省略。 代码部分本来在6月底就基本完成了，但是因为7月忙着吸收总结实习中学习的内容，所以一直搁置了红黑树的总结。由于《STL源码剖析》中并没有红黑树节点删除相关以及一些小细节的讲解，所以相关的内容是我在别的地方学习后根据STL标准自己补全的代码，如有纰漏，还请提醒。 本次总结预计分为三篇，(一)中主要记录相关的代码思路结构，(二)中重点分析添加红黑树节点相关的内容，(三)中重点分析删除红黑树节点相关的内容。 零、我认为的STL标准&emsp;&emsp;首先，对于STL中的数据结构，不难发现它们除了自身的数据结构外还配套有空间配置器以及专属的迭代器。其中空间配置器中维护了一个内存池，符合标准的内存申请均从中获取；而迭代器则是为了更方便的对数据结构进行遍历，或是为了配合在之后STL中的算法模块。&emsp;&emsp;所以，我认为数据结构+空间配置器+专属迭代器&#x3D;STL标准数据结构。但是由于篇幅有限，且我主要是为了学习红黑树相关的内容，所以在本文中对空间配置器进行了一些省略——直接进行new和delete操作。&emsp;&emsp;当然，STL里更直观的一个特点就是无数被typedef封装的详细(繁琐)的类型名，在下面的记录中，将会直观的展示它。 一、本文中红黑树的结构1234567891011121314151617181920212223242526272829303132总体分为三大块：1.红黑树的空间配置器2.红黑树的迭代器3.红黑树数据结构相关/* *** ***** *** */其中红黑树的数据结构包括：1.红黑树节点相关的定义 1.1 红黑树节点颜色的定义(即红/黑) 1.2 红黑数节点数据结构的定义(包括父/孩子节点、值、寻子节点最大/最小值函数)2.红黑树相关的定义(围绕着红黑树节点) 2.1 红黑树节点的创建、删除、获取(调用空间配置器) 2.2 红黑树中获取节点内容(父/孩子节点、值等)的函数 2.3 红黑树基础操作函数(插入、删除、寻找) 2.4 一些基础的STL函数，例如begin()、end()、size()等等3.红黑树的一些操作函数 3.1 红黑树的左旋右旋操作函数 3.2 红黑树的平衡性调整函数/* *** ***** *** */其中空间配置器包括：1.空间配置器的基础定义 1.1 分配内存 1.2 释放内存/* *** ***** *** */其中迭代器包括：1.迭代器的基础定义 1.1 由于是双向迭代器，所以要有基础的前进和后退功能(++/--重载) 1.2 要能实现提领和成员访问功能，所以要进行一些操作符重载 二、红黑树的数据结构1. 红黑树的节点1.1 节点颜色&emsp;&emsp;红黑树之所以叫做红黑树，是因为它的节点除了基础的值外，还具有颜色的属性，即红色和黑色。所以首先需要对红色和黑色进行定义： 1234//颜色类型定义typedef bool _rb_tree_color_type;const _rb_tree_color_type _rb_tree_red = false;//红色为0const _rb_tree_color_type _rb_tree_black = true;//黑色为1 1.2 基础节点结构&emsp;&emsp;随后，我们对红黑树的基础单位——节点进行定义，其中节点数据结构中除了常规树节点里的左右孩子节点还需要有父节点以及颜色定义。其中，还需要声明两个函数，其作用是寻找到当前节点下最大和最小的孩子。由于红黑树是满足二叉排序树的特性的，所以最大子节点即为最右节点、最小子节点即为最左节点。定义如下： 12345678910111213141516171819202122232425262728293031//rb_tree 基础节点结构定义struct _rb_tree_node_base&#123; typedef _rb_tree_color_type color_type; typedef _rb_tree_node_base* base_ptr; color_type color;//节点颜色 base_ptr parent;//父亲 base_ptr left;//左孩子 base_ptr right;//右孩子 //找孩子最小值 static base_ptr minimum(base_ptr x) &#123; while (x-&gt;left != 0) &#123; x = x-&gt;left; &#125; return x; &#125; //找孩子最大值 static base_ptr maximux(base_ptr x) &#123; while (x-&gt;right != 0) &#123; x = x-&gt;right; &#125; return x; &#125;&#125;; 1.3 完整节点结构&emsp;&emsp;上面是对于基础节点的定义，但是很明显，其中并没有值。要声明值的话就需要用到泛型，而上面的基础定义不需要用到，由此可以进行分离。我感觉STL里很多东西都分离的很细，应该是为了逻辑和方便修改吧。再说到值，我们可以继承上面的base类型并引入泛型，创造出完整的红黑树节点数据结构： 1234567//rb_tree 节点结构定义template&lt;class Value&gt;struct _rb_tree_node : public _rb_tree_node_base&#123; typedef _rb_tree_node&lt;Value&gt;* link_type; Value value_field;//节点值&#125;; &emsp;&emsp;由此，一个完整的红黑树节点数据结构_rb_tree_node就被构造出来了，随后可以在节点的基础上，来构造红黑树以及它的相关操作函数。 2. 红黑树2.1 构造思路&emsp;&emsp;由于前面已经构造出了红黑树的节点，那么可以像链表的数据结构一样，创建一个header头结点，这样就可以通过操作这个头结点来控制整个红黑树，这里先暂且不谈这个头结点里储存的内容(后面插入函数部分会说)。&emsp;&emsp;有了这个基础思路之后，我们就可以以该头结点为媒介和底层，定义各式各样的函数来操作或是获取以该头结点为根的红黑树中的内容。例如每个STL数据结构都有的begin()和end()，或是insert()和erase()等等非静态函数。然后是一些静态函数，方便获取传入节点的内容，毕竟对于用户而言，红黑树节点这个数据结构是被封装的，是不明的，所以需要一些静态函数来获取其中的内容。当然，也得有树&#x2F;节点的构造&#x2F;析构函数，这是建树的基础。 2.2 泛型内容&emsp;&emsp;在真正构造红黑树的数据结构前，还需要考虑的一个东西是其泛型的结构。那么都需要准备什么泛型呢？首先红黑树是二叉排序树，这就需要在插入中进行比较，所以需要引入键值对概念。由此这里就需要两种泛型，一个是key的泛型，一个是value的泛型。此外，前文对节点的定义中只存在值，所以需要有一个获取key的函数。对此，STL的做法是传入一个仿函数泛型来获取key。此外还需要传入一个比较函数(仿函数)来比较key，以及传入一个空间配置器泛型，所以标准的STL红黑树一共有五个泛型。但是，这里我省略了空间配置器泛型，来减少任务量，所以一共只有四个泛型，即键、值、取键函数、比较函数。 2.3 静态函数&emsp;&emsp;其中，我们需要定义一些构造函数，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//以下六个函数获取节点x的成员static link_type&amp; left(link_type x)&#123; return (link_type&amp;)(x-&gt;left);&#125;static link_type&amp; right(link_type x)&#123; return (link_type&amp;)(x-&gt;right);&#125;static link_type&amp; parent(link_type x)&#123; return (link_type&amp;)(x-&gt;parent);&#125;static reference value(link_type x)&#123; return x-&gt;value_field;&#125;static const Key&amp; key(link_type x)&#123; return (key_type)KeyOfValue()(value(x));&#125;static color_type&amp; color(link_type x)&#123; return (color_type&amp;)(x-&gt;color);&#125;//以下六个函数获取节点x的成员static link_type&amp; left(base_ptr x)&#123; return (link_type&amp;)(x-&gt;left);&#125;static link_type&amp; right(base_ptr x)&#123; return (link_type&amp;)(x-&gt;right);&#125;static link_type&amp; parent(base_ptr x)&#123; return (link_type&amp;)(x-&gt;parent);&#125;static reference value(base_ptr x)&#123; return ((link_type)x)-&gt;value_field;&#125;static const Key&amp; key(base_ptr x)&#123; return (key_type)KeyOfValue()(value((link_type)x));&#125;static color_type&amp; color(base_ptr x)&#123; return (color_type&amp;)((link_type)x-&gt;color);&#125;//求极大值和极小值 节点基类方法已实现static link_type minimum(link_type x)&#123; return (link_type)_rb_tree_node_base::minimum(x);&#125;static link_type maximum(link_type x)&#123; return (link_type)_rb_tree_node_base::maximum(x);&#125; &emsp;&emsp;其中包含了基础的取父、孩子节点的函数和取键值、颜色的函数，使得使用者不需要直接操作节点结构，而是通过红黑树里封装好的link_type以及上面定义的这些函数来获取自己想要得到的内容。 2.4 树&#x2F;节点的构造&#x2F;析构函数&emsp;&emsp;首先，需要最基础的配置和释放空间的函数，这里通过调用空间配置器内的函数来完成操作，空间配置器的内容在下文。&emsp;&emsp;随后，是创建节点函数，在获取到空间后，调用其构造函数赋值。STL中也存在一个clone_node()来复制一个节点的颜色和值。&emsp;&emsp;最后就是销毁函数，不用多说什么了。这一部分具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950全局：//构造函数调用template&lt;class T1, class T2&gt;inline void construct(T1* p, const T2&amp; value)&#123; new (p) T1(value);&#125;//析构函数调用template&lt;class T&gt;inline void destroy(T* pointer)&#123; pointer-&gt;~T();&#125;红黑树内protected： link_type get_node()//获取节点(配置空间) &#123; return rb_tree_node_allocator::allocate(); &#125; void put_node(link_type p)//释放节点(回收空间) &#123; rb_tree_node_allocator::deallocate(p); &#125; link_type create_node(const value_type&amp; x)//创建节点 &#123; link_type temp = get_node(); try &#123; construct(&amp;temp-&gt;value_field, x); &#125; catch (const std::exception&amp;) &#123; put_node(temp); &#125; return temp; &#125; link_type clone_node(link_type x)//复制节点值与色 &#123; link_type temp = create_node(x-&gt;value_field); temp-&gt;color = x-&gt;color; temp-&gt;left = 0; temp-&gt;right = 0; return temp; &#125; void destroy_node(link_type p)//销毁节点 &#123; destroy(&amp;p-&gt;value_field);//析构内容 put_node(p);//释放内存 &#125; 2.5 非静态函数思路&emsp;&emsp;总体来说就是一些服务于红黑树的函数，例如初始化、插入、移除、寻找等等。还有一些基础的empty()、size、begin()、end()等等，服务于后面的迭代器和STL的算法部分。插入和移除等后面会细说，其余的也没有什么说的必要，就略过了。 2.6 红黑树数据结构部分代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194//红黑树的定义与声明template&lt;class Key, class Value, class KeyOfValue, class Compare&gt;class rb_tree&#123;protected://基础 typedef void* void_pointer; typedef _rb_tree_node_base* base_ptr; typedef _rb_tree_node&lt;Value&gt; rb_tree_node; typedef _rb_tree_color_type color_type;public://类型封装 typedef Key key_type; typedef Value value_type; typedef value_type* pointer; typedef const value_type* const_pointer; typedef value_type&amp; reference; typedef const value_type&amp; const_reference; typedef rb_tree_node* link_type; typedef size_t size_type; //空间配置器 typedef _rb_tree_node_allocator&lt;Value&gt; rb_tree_node_allocator;protected://内存管理相关 link_type get_node()//获取节点(配置空间) &#123; return rb_tree_node_allocator::allocate(); &#125; void put_node(link_type p)//释放节点(回收空间) &#123; rb_tree_node_allocator::deallocate(p); &#125; link_type create_node(const value_type&amp; x)//创建节点 &#123; link_type temp = get_node(); try &#123; construct(&amp;temp-&gt;value_field, x); &#125; catch (const std::exception&amp;) &#123; put_node(temp); &#125; return temp; &#125; link_type clone_node(link_type x)//复制节点值与色 &#123; link_type temp = create_node(x-&gt;value_field); temp-&gt;color = x-&gt;color; temp-&gt;left = 0; temp-&gt;right = 0; return temp; &#125; void destroy_node(link_type p)//销毁节点 &#123; destroy(&amp;p-&gt;value_field);//析构内容 put_node(p);//释放内存 &#125;protected://基本数据与方法 size_type node_count;//节点数量 link_type header;//树根头 树根为parent 最小值为left 最大值为right Compare key_compare;//节点间键值比较准则 //以下三个函数获取header的成员 link_type&amp; root() const &#123; return (link_type&amp;)header-&gt;parent; &#125; link_type&amp; leftmost() const &#123; return (link_type&amp;)header-&gt;left; &#125; link_type&amp; rightmost() const &#123; return (link_type&amp;)header-&gt;right; &#125; //以下六个函数获取节点x的成员 static link_type&amp; left(link_type x) &#123; return (link_type&amp;)(x-&gt;left); &#125; static link_type&amp; right(link_type x) &#123; return (link_type&amp;)(x-&gt;right); &#125; static link_type&amp; parent(link_type x) &#123; return (link_type&amp;)(x-&gt;parent); &#125; static reference value(link_type x) &#123; return x-&gt;value_field; &#125; static const Key&amp; key(link_type x) &#123; return (key_type)KeyOfValue()(value(x)); &#125; static color_type&amp; color(link_type x) &#123; return (color_type&amp;)(x-&gt;color); &#125; //以下六个函数获取节点x的成员 static link_type&amp; left(base_ptr x) &#123; return (link_type&amp;)(x-&gt;left); &#125; static link_type&amp; right(base_ptr x) &#123; return (link_type&amp;)(x-&gt;right); &#125; static link_type&amp; parent(base_ptr x) &#123; return (link_type&amp;)(x-&gt;parent); &#125; static reference value(base_ptr x) &#123; return ((link_type)x)-&gt;value_field; &#125; static const Key&amp; key(base_ptr x) &#123; return (key_type)KeyOfValue()(value((link_type)x)); &#125; static color_type&amp; color(base_ptr x) &#123; return (color_type&amp;)((link_type)x-&gt;color); &#125; //求极大值和极小值 节点基类方法已实现 static link_type minimum(link_type x) &#123; return (link_type)_rb_tree_node_base::minimum(x); &#125; static link_type maximum(link_type x) &#123; return (link_type)_rb_tree_node_base::maximum(x); &#125;public://迭代器封装 typedef _rb_tree_iterator&lt;value_type, reference, pointer&gt; iterator;private://一些私有方法 iterator _insert(base_ptr x_, base_ptr y_, const value_type&amp; v); void _erase(link_type x); void init()//初始化header &#123; header = get_node();//产生应该节点空间，令header指向它 color(header) = _rb_tree_red;//header为红色 与root区分 root() = 0;//root为空 leftmost() = header;//令header的左子节点为自己 rightmost() = header;//令header的右子节点为自己 &#125;public://构造与析构 rb_tree(const Compare&amp; comp = Compare()) : node_count(0), key_compare(comp) &#123; init(); &#125; ~rb_tree() &#123; //clear(); put_node(header); &#125; rb_tree&lt;Key, Value, KeyOfValue, Compare&gt;&amp; //重载= operator=(const rb_tree&lt;Key, Value, KeyOfValue, Compare&gt;&amp; x);public://STL的一些基础方法 Compare Key_comp() const &#123; return key_compare; &#125; iterator begin() &#123; return leftmost(); &#125; iterator end() &#123; return header; &#125; bool empty() const &#123; return node_count == 0; &#125; size_type size() const &#123; return node_count; &#125; size_type max_size() const &#123; return size_type(-1); &#125;public: //不可重复插入 std::pair&lt;iterator, bool&gt; insert_unique(const value_type&amp; v); //可重复插入 iterator insert_equal(const value_type&amp; v); //删除-传入迭代器 iterator erase(iterator x); //删除-传入值 iterator erase(value_type&amp; v); //寻找 iterator find(const key_type&amp; k);&#125;; 3. 红黑树的操作函数3.1 左旋函数&emsp;&emsp;首先这是一个全局函数，是用来调整树的平衡性的。红黑树相比普通树查找快的原因就是它是平衡二叉树，有着较平衡的查找次数，由此需要左旋以及右旋函数来调整平衡性；但它又没有AVL树那么严格的平衡要求，所以总体插入&#x2F;查找效率达到最大化。&emsp;&emsp;左旋示意图如上，可以看到简而言之就是旋转点x变为其右子节点y的左子节点，随后y的左子节点变为x的右子节点。代码如下，其中需要注意边界条件以及父子关系的改变： 12345678910111213141516171819202122232425262728//rb_tree 左旋函数inline void _rb_tree_rotate_left(_rb_tree_node_base* x, _rb_tree_node_base*&amp; root)&#123; //printf(&quot;左旋\\n&quot;); //x为旋转点，root为树根 _rb_tree_node_base* y = x-&gt;right;//新建y为旋转点的右子节点 x-&gt;right = y-&gt;left;//令x的右子节点为y的左子节点 if (y-&gt;left != 0)//若y的左子树不为空 &#123; y-&gt;left-&gt;parent = x;//y的左子树的父亲改为x &#125; y-&gt;parent = x-&gt;parent;//y的父亲改为x的父亲 //令y顶替x的位置 if (x == root)//当x为根 &#123; root = y; &#125; else if (x == x-&gt;parent-&gt;left)//当x为parent的左子节点 &#123; x-&gt;parent-&gt;left = y; &#125; else//当x为parent的左子节点 &#123; x-&gt;parent-&gt;right = y; &#125; y-&gt;left = x;//x、y父子关系互换 x-&gt;parent = y;&#125; 3.2 右旋函数&emsp;&emsp;总体来说右旋函数和左旋函数差不多，只是操作方法变了一些。总体就是旋转点x变为其左子节点y的右子节点，随后y的右子节点变为x的左子节点。右旋示意图以及相关代码如下，仍然需要注意边界条件以及父子关系的改变： 123456789101112131415161718192021222324252627//rb_tree 右旋函数inline void _rb_tree_rotate_right(_rb_tree_node_base* x, _rb_tree_node_base*&amp; root)&#123; //printf(&quot;右旋\\n&quot;); //x为旋转点，root为树根 _rb_tree_node_base* y = x-&gt;left;//新建y为旋转点的左子节点 x-&gt;left = y-&gt;right;//令x的左子节点为y的右子节点 if (y-&gt;right != 0)//若y的右子树不为空 &#123; y-&gt;right-&gt;parent = x;//y的右子树的父亲改为x &#125; y-&gt;parent = x-&gt;parent;//y的父亲改为x的父亲 if (x == root)//当x为根 &#123; root = y; &#125; else if (x == x-&gt;parent-&gt;right)//当x为parent的右子节点 &#123; x-&gt;parent-&gt;right = y; &#125; else//当x为parent的左子节点 &#123; x-&gt;parent-&gt;left = y; &#125; y-&gt;right = x;//x、y父子关系互换 x-&gt;parent = y;&#125; 3.3 平衡性调整函数&emsp;&emsp;平衡性调整函数可以说是红黑树里最重要也是最精髓的点，这里不过多解释，待后面记录插入、删除过程时再细细分析。 三、红黑树的空间配置器&emsp;&emsp;关于红黑树的空间配置器，我只是简单留了个接口，算是有了空间配置器的形式，也方便日后更改(虽然也不大可能会改了 )，就是把new和delete的部分改一下就好。具体如下： 1234567891011121314151617181920212223242526272829303132333435//rb_tree 空间配置器template&lt;class Value&gt;struct _rb_tree_node_allocator&#123; typedef Value value_type; typedef value_type* pointer; typedef _rb_tree_node&lt;Value&gt; rb_tree_node; typedef _rb_tree_node&lt;Value&gt;* link_type; //分配内存 static link_type allocate() &#123; link_type temp = new rb_tree_node; return temp; &#125; //释放内存 static void deallocate(link_type p) &#123; delete p; &#125;&#125;;红黑树结构内相关调用： ... //空间配置器 typedef _rb_tree_node_allocator&lt;Value&gt; rb_tree_node_allocator;protected://内存管理相关 link_type get_node()//获取节点(配置空间) &#123; return rb_tree_node_allocator::allocate(); &#125; void put_node(link_type p)//释放节点(回收空间) &#123; rb_tree_node_allocator::deallocate(p); &#125; ... 四、红黑树的迭代器&emsp;&emsp;上面提到过，STL中完整的红黑树节点是继承红黑树基础节点来完善的。由此，STL中红黑树的迭代器的层次结构也有两层，其中基础迭代器iterator_base对应基础红黑树节点node_base，而完整迭代器iterator则对应完整红黑树节点node。 1. 基础迭代器结构&emsp;&emsp;先来看基础迭代器结构。在我看来，迭代器就相当于一种封装的指针类型，指向被STL数据结构封装后的一个”节点”。而人们通过操作这个”节点”，就可以遍历整个数据结构，而不用操纵底层的结构。比如在本文的红黑树数据结构中，如果想遍历整个树，就不需要自己声明底层的节点结构类型，而是直接用迭代器就好。&emsp;&emsp;由上，迭代器中必然有一个底层一些的结构指针来指向可操作的单元，在这个基础迭代器中，这个结构指针就是_rb_tree_node_base::base_ptr，即_rb_tree_node_base*。所以说基础迭代器iterator_base对应基础红黑树节点node_base。&emsp;&emsp;迭代器最重要的就是”可移动”，即可以指向逻辑上的上一个和下一个，由此需要实现迭代器增加和减少函数。随后还需要重载一些运算符，让迭代器变得好用和方便。由于基础节点中只存在关系并不存在值，所以我们不需要重载*、-&gt;、==等操作符，因为它们都涉及到值。由此在这里只需要把重点放到迭代器增加和减少上。&emsp;&emsp;由于红黑树是二叉排序树，所以一个节点的左子树一定小于等于它，它的右子树一定大于它。按照这个规律，迭代器增加即为： 123451.如果有右子节点，则先向右走，随后向左走到底2.如果没有右子节点，则上溯父节点 2.1若当前节点为右子节点，则接着上溯直到不为右子节点 2.1.1若此时的右子节点不等于此时的父节点，其父节点即为解答 2.1.2否则直接返回即可(这两个判断主要是防止上溯到根节点) 随后即可找到第一个比它大的节点。迭代器减少即为： 1231.如果是根节点，则右子节点为解答(这个涉及到根节点的设计，以后会分析)2.如果有左子节点，则先向左走，随后一直向右走3.如果非根节点也无左子节点，上溯直至当前节点不为左子节点，其父节点即为解答 随后即可找到第一个比它小的节点。详细代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//rb_tree 基础迭代器结构定义struct _rb_tree_iterator_base&#123; typedef _rb_tree_node_base::base_ptr base_ptr; base_ptr node;//当前节点 //迭代器增加 void increment() &#123; if (node-&gt;right != 0)//如果有右子节点，则先向右走，随后向左走到底 &#123; node = node-&gt;right; while (node-&gt;left != 0) &#123; node = node-&gt;left; &#125; &#125; else//如果没有右子节点，则上溯父节点 &#123; base_ptr y = node-&gt;parent; while (node == y-&gt;right)//若当前节点为右子节点，则接着上溯直到不为右子节点 &#123; node = y; y = y-&gt;parent; &#125; if (node-&gt;right != y)//若此时的右子节点不等于此时的父节点，其父节点即为解答 &#123; node = y; &#125; &#125; &#125; //迭代器减少 void decrement() &#123; if (node-&gt;color == _rb_tree_red &amp;&amp; node-&gt;parent-&gt;parent == node)//为根节点 &#123;//若当前节点为红色，且父亲的父亲为自身，则右子节点为解答 node = node-&gt;right; &#125; else if (node-&gt;left != 0)//若有左子节点，则先向左走，随后一直向右走 &#123; base_ptr y = node-&gt;left; while (y-&gt;right != 0) &#123; y = y-&gt;right; &#125; node = y; &#125; else//既非根节点也无左子节点 &#123; base_ptr y = node-&gt;parent; while (node == y-&gt;left)//上溯直至当前节点不为左子节点 &#123; node = y; y = node-&gt;parent; &#125; node = y;//则父节点即为小值 &#125; &#125;&#125;; 2. 完整迭代器结构&emsp;&emsp;完整迭代器iterator对应完整红黑树节点node，其中引入了值泛型，所以在完整迭代器中需要进行操作符的重载。由于在之后的使用中，也是操作这个完整迭代器，所以需要定义构造函数。关于重载，重点就是在++和--上，其核心就是调用上面基础迭代器中的增加和减少函数。具体代码如下，非常清晰： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//rb_tree 迭代器结构定义template&lt;class Value, class Ref, class Ptr&gt;struct _rb_tree_iterator : public _rb_tree_iterator_base&#123; typedef Value value_type; typedef Ref reference; typedef Ptr pointer; typedef _rb_tree_iterator&lt;Value, Value&amp;, Value*&gt; iterator; typedef _rb_tree_iterator&lt;Value,const Value&amp;,const Value*&gt; const_iterator; typedef _rb_tree_iterator&lt;Value, Ref, Ptr&gt; self; typedef _rb_tree_node&lt;Value&gt;* link_type; //三种构造 _rb_tree_iterator() &#123; &#125; _rb_tree_iterator(link_type x) &#123; node = x; &#125; _rb_tree_iterator(const iterator&amp; it) &#123; node = it.node; &#125; //重载操作符 reference operator*() const//提领 &#123; return link_type(node)-&gt;value_field; &#125; pointer operator-&gt;() const//箭头 &#123; return &amp;(operator*()); &#125; bool operator==(const iterator&amp; y) const//== &#123; return this-&gt;node == y.node; &#125; bool operator!=(const iterator&amp; y) const//!= &#123; return this-&gt;node != y.node; &#125; self&amp; operator++()//++i &#123; increment(); return *this; &#125; self operator++(int)//i++ &#123; self temp = *this; increment(); return temp; &#125; self&amp; operator--()//--i &#123; decrement(); return *this; &#125; self operator--(int)//i-- &#123; self temp = *this; decrement(); return temp; &#125;&#125;;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"STL","slug":"STL","permalink":"https://zgg2001.github.io/tags/STL/"}]},{"title":"学习记录：二层网络环路相关","slug":"20210718_学习记录：二层网络环路相关","date":"2021-07-18T13:52:01.000Z","updated":"2021-07-18T13:52:01.000Z","comments":true,"path":"2021/07/18/20210718_学习记录：二层网络环路相关/","permalink":"https://zgg2001.github.io/2021/07/18/20210718_%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E4%BA%8C%E5%B1%82%E7%BD%91%E7%BB%9C%E7%8E%AF%E8%B7%AF%E7%9B%B8%E5%85%B3/","excerpt":"上周实习过程中由于对此相关内容不熟悉，造成了事故。由此对相关内容加强学习，特此记录。","text":"上周实习过程中由于对此相关内容不熟悉，造成了事故。由此对相关内容加强学习，特此记录。 一、交换机相关&emsp;&emsp;总的来说，交换机是一种基于MAC地址识别，能完成封装转发数据包功能的网络设备。&emsp;&emsp;在实习中，我接触到的应该都是第二层交换机(数据链路层)。其内部存在着一个映射表，记录着设备MAC地址与交换机端口之间的关系。&emsp;&emsp;当交换机从某端口收到一个数据包，它首先读取包头中的源MAC地址，这样它就知道源MAC地址的机器是连在哪个端口上的。随后它再去读取包头中的目的MAC地址，并在地址表中查找相应的端口，如果表中有与这目的MAC地址对应的端口，则把数据包通过该端口进行传输；如果在表中找不到相应的端口则把数据包广播到所有端口上，当目的机器对源机器回应时，交换机又可以记录目的MAC地址与哪个端口对应，在下次传送数据时就不再需要对所有端口进行广播了。 总结&emsp;&emsp;交换机内维护了一张表，其中记录了MAC地址与端口的对应关系。当交换机收到包时，会首先更新包源MAC地址与端口的关系。随后读取包的目标MAC地址，接着在映射表内进行查询，此时有两种结果：&emsp;&emsp;1.如果目标MAC地址已经被记录，则直接通过对应的端口进行转发。&emsp;&emsp;2.如果目标MAC地址未被记录，则所有的端口都进行发包操作即广播(即泛洪)，来确保包能被交换机转发出去。&emsp;&emsp;而当目标MAC地址的设备收到包进行回应时，则回到流程第一步的“当交换机收到包时”，此时会更新映射表，添加该MAC地址与端口的对应关系。今后这两台设备进行通信时，交换机则不会再进行广播操作而是直接找到相应端口进行转发。 二、网络环路的产生&emsp;&emsp;环路大概就是：A交换机网络从B交换机网络收到了要发给X的消息，随后再次转发给B交换机网络(其中A和B网络所属可能是同一台交换机)，这样该消息就会在A和B网络中不断被转发，造成环路问题。&emsp;&emsp;原因大多是因为线路连接问题或是硬件设备自身的问题。 三、网络环路的影响&emsp;&emsp;首先的影响就是MAC地址表震荡。因为交换机收到包时会进行表的更新，即交换机在收到包时会更新该包源端口与设备MAC之间的映射关系。但是如果构成环路的话，则代表该路由器会在不同的端口收到同一个包，该包源MAC地址是相同的，则MAC地址表中的映射关系会一直发生“跳跃”，即表内同一个MAC地址在不同的端口上进行“跳跃”，这便是MAC地址表的震荡。&emsp;&emsp;随后最大的影响便是广播风暴。因为造成了环路，且在二层交换机中是没有TTL机制来约束包的转发的，所以数据包会在环路内被无限次的转发，由此造成广播风暴。更严重的是可能数据包在环路内不是单播而是广播(比如说该包的源和目的相同，则由于MAC地址表震荡造成泛洪)，由此对相关资源的消耗更为巨大。&emsp;&emsp;同时网络环路也可能造成重复数据帧。当拓扑关系出现问题时，可能会出现多端口可致目的MAC地址，则数据可能会在广播中被复制转发，目的地则会收到相同的两份数据。当出现环路时，这两份数据会转发给初始交换机，重复上述操作，造成数据不断的被复制，从而占用越来越多的资源。 四、如何避免网络环路&emsp;&emsp;最简单的方法就是设定生存时间值TTL，来避免无限次的转发从而避免环路带来的广播风暴等影响。但是二层交换机不支持该内容，且这样是治标不治本，环路并没有被解决。&emsp;&emsp;随后我们可以引入一些算法和破坏协议来避免网络环路，使可以及时发现并切断网络环路。&emsp;&emsp;当然在日常接线中，也要注意，从根本上避免网络环路的产生。例如： 例如A与B已连接交换机C，则A与B之间不可再连线。 不可用网线连接同一交换机的两个端口。 假如A连接了B，B连接了C，则A不可连接C。 等等… 五、二层环路的直观异常情况","categories":[{"name":"网络","slug":"网络","permalink":"https://zgg2001.github.io/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"网络","slug":"网络","permalink":"https://zgg2001.github.io/tags/%E7%BD%91%E7%BB%9C/"}]},{"title":"C++网络编程学习：线程退出安全优化","slug":"20210528_C++网络编程学习：线程退出安全优化","date":"2021-05-28T05:18:42.000Z","updated":"2021-05-28T05:18:42.000Z","comments":true,"path":"2021/05/28/20210528_C++网络编程学习：线程退出安全优化/","permalink":"https://zgg2001.github.io/2021/05/28/20210528_C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E7%BA%BF%E7%A8%8B%E9%80%80%E5%87%BA%E5%AE%89%E5%85%A8%E4%BC%98%E5%8C%96/","excerpt":"使用的语言为C&#x2F;C++ 源码支持的平台为：Windows（本文中内容使用windows平台下vs2019开发，故本文项目不完全支持linux平台） C++网络编程学习：心跳机制与定时发送数据 &emsp;点我查看之前的代码开发记录 0：本次增改方向 封装自己的线程类，使其可以控制线程及时关闭 使得程序可以按合适的顺序正常退出，避免因退出顺序问题引发崩溃","text":"使用的语言为C&#x2F;C++ 源码支持的平台为：Windows（本文中内容使用windows平台下vs2019开发，故本文项目不完全支持linux平台） C++网络编程学习：心跳机制与定时发送数据 &emsp;点我查看之前的代码开发记录 0：本次增改方向 封装自己的线程类，使其可以控制线程及时关闭 使得程序可以按合适的顺序正常退出，避免因退出顺序问题引发崩溃 1：封装线程类相关&emsp;&emsp;首先，为何要及时使得线程退出？因为我的接收、发送线程与主线程是分离的，当我在主线程中析构线程类时，线程中所使用的变量遂被释放，但此时接收、发送线程可能还未从上次循环中结束，仍然在调用已被释放的变量，此时就会出现崩溃等问题。所以我需要自己封装一个线程类，来实现对线程退出的控制，使得可以获得线程已经正常退出的信号，从而再安全的释放各种变量。&emsp;&emsp;对此，该如何实现？首先可以采用本方法：即新建一个bool类型的信号量，在主线程发出关闭线程信号后，使用while(1)进行阻塞。当线程退出时，更改bool信号量的状态，当while(1)中检测到信号量发生变化后，则跳出循环解除阻塞，正常向下运行释放变量。伪代码如下： 1234567891011121314151617181920主线程内：&#123; _state = false;//线程是否运行 while(1) &#123; if(_semaphore == true)//查看信号量状态 break; &#125; 释放变量等;&#125;子线程内:&#123; while(_state) &#123; 工作; &#125; printf(&quot;线程已退出\\n&quot;); _semaphore = true;&#125; &emsp;&emsp;如上，好处是可以确保线程可以按顺序退出，使得释放变量等操作不会出错。但是坏处是这个while(1)循环会占用大量的系统资源，影响程序效率。以及可能出现信号量未能正确变化，从而陷入死循环。首先是占用资源太多的问题，我们可以引用C++11中的condition_variable条件变量，其中含有的wait()可以减少资源消耗，且使用notify_one()可以进行唤醒。伪代码如下： 123456789101112131415161718192021#include&lt;condition_variable&gt;//条件变量std::condition_variable _cv;主线程内：&#123; std::unique_lock&lt;std::mutex&gt; lock(_mutex);//需上锁 _state = false;//线程是否运行 _cv.wait(lock);//阻塞等待 释放变量等;&#125;子线程内:&#123; while(_state) &#123; 工作; &#125; printf(&quot;线程已退出\\n&quot;); _cv.notify_one();//唤醒&#125; &emsp;&emsp;如上，阻塞资源消耗太大的问题已经得到了改善，接下来将着重于如何避免死循环状态。首先新建信号量类CellSemaphore，对信号量操作进行封装，使得线程类内可以直接调用信号量相关操作。结构如下： 12345678910111213141516171819class CellSemaphore&#123;public: CellSemaphore(); ~CellSemaphore(); //开始阻塞 void wait(); //唤醒 void wakeup();private: //等待数 int _wait = 0; //唤醒数 int _wakeup = 0; //条件变量 std::condition_variable _cv; //锁 std::mutex _mutex;&#125;; &emsp;&emsp;如上，CellSemaphore封装了wait和wakeup方法，通过调用这两个方法，即可实现阻塞与唤醒。而成员变量方面，我声明了一个等待计数器_wait和一个唤醒计数器_wakeup。每当成功调用wakeup方法，都会使等待计数器和唤醒计数器加一；而每当成功调用wait方法，都会使等待计数器和唤醒计数器减一。所以正常情况下，一组操作后，两个计数器的值都为0。而由此也可以判断不同的情况，比如当调用wait方法时，唤醒计数器的值大于0，则说明之前已经进行了唤醒操作，则直接跳过阻塞即可。而当调用wakeup方法时，若等待计数器数值不正常，则也直接跳过唤醒操作。相关代码如下： 123456789101112131415161718192021222324//开始阻塞void CellSemaphore::wait()&#123; std::unique_lock&lt;std::mutex&gt; lock(_mutex); if (--_wait &lt; 0) &#123; //阻塞开始 等待唤醒 _cv.wait(lock, [this]()-&gt;bool &#123; return _wakeup &gt; 0; &#125;); --_wakeup; &#125;&#125;//唤醒void CellSemaphore::wakeup()&#123; std::lock_guard&lt;std::mutex&gt; lock(_mutex); if (++_wait &lt;= 0) &#123; ++_wakeup; _cv.notify_one(); &#125;&#125; &emsp;&emsp;由此，信号量相关的封装完成了，接下来将进行线程类相关的封装。首先，线程类中需要有一个CellSemaphore信号量对象以便于我们对线程的掌握。其次，线程的基础函数：启动Start()、关闭Close()、退出Exit()、是否运行isRun()需要存在。接着，是最重要的线程工作函数OnWork()。在工作函数OnWork()中，我预计执行三个匿名函数：_onCreate、_onRun、 _onDestory，这三个匿名函数分别执行线程创建时的操作、线程运行时的操作、线程销毁时的操作。最后还需要一个锁和一个bool变量来保证数据的正常更改以及线程运行状态的判定。线程类CellThread结构如下： 12345678910111213141516171819202122232425262728class CellThread&#123;private: typedef std::function&lt;void(CellThread*)&gt; EventCall;public: //启动线程 void Start(EventCall onCreate = nullptr, EventCall onRun = nullptr, EventCall onDestory = nullptr); //关闭线程 void Close(); //工作中退出 void Exit(); //是否运行中 bool isRun();protected: //工作函数 void OnWork();private: //三个事件 匿名函数 EventCall _onCreate; EventCall _onRun; EventCall _onDestory; //改变数据时 需要加锁 std::mutex _mutex; //控制线程的终止与退出 CellSemaphore _semaphore; //线程是否启动 bool _state = false;&#125;; &emsp;&emsp;在启动线程时，需要传入三个匿名函数(默认为空)；当关闭线程时，需要调用wait()方法；而当退出线程时，由于一般都是出现错误时调用该方法，所以不需要阻塞，直接停止线程即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//启动线程void CellThread::Start(EventCall onCreate, EventCall onRun, EventCall onDestory)&#123; //上锁 std::lock_guard&lt;std::mutex&gt; lock(_mutex); if (!_state) &#123; //事件赋值 if (onCreate) _onCreate = onCreate; if (onRun) _onRun = onRun; if (onDestory) _onDestory = onDestory; //线程启动 _state = true; std::thread t(std::mem_fn(&amp;CellThread::OnWork), this); t.detach(); &#125;&#125;//关闭线程void CellThread::Close()&#123; //上锁 std::lock_guard&lt;std::mutex&gt; lock(_mutex); if (_state) &#123; _state = false; _semaphore.wait(); &#125;&#125;//退出线程void CellThread::Exit()&#123; //上锁 std::lock_guard&lt;std::mutex&gt; lock(_mutex); if (_state) &#123; _state = false; //这里的目的是退出线程 没必要阻塞等信号量 &#125;&#125;//线程是否运行bool CellThread::isRun()&#123; return _state;&#125; &emsp;&emsp;OnWork方法内按顺序依次执行三个匿名函数，当销毁阶段函数执行后，调用信号量类的唤醒操作，来告知线程已安全退出。由此，封装线程类相关操作已经完成。我们可以通过相关方法来更精准的操作线程。 12345678910111213void CellThread::OnWork()&#123; //开始事件 if (_onCreate) _onCreate(this); //运行 if (_onRun) _onRun(this); //销毁 if (_onDestory) _onDestory(this); _semaphore.wakeup();&#125; 2：退出顺序相关&emsp;&emsp;在上文完成线程类的封装后，我对源码中的线程相关进行更换。如下，即为线程的创建与关闭操作。 12345678910111213//启动接收线程 _thread.Start( //onCreate nullptr, //onRun [this](CellThread*) &#123; OnRun(&amp;_thread);//工作函数OnRun &#125;, //onDestory nullptr);//关闭接收线程 _thread.Close(); &emsp;&emsp;接下来对程序退出的顺序进行规范，大制思路如下： 在TcpServer(主线程)宣布程序退出时，首先对接收线程类进行析构，进入接收线程的析构函数。 在接收线程的析构函数中，首先对接收线程类中配套的发送线程类进行析构，进入发送线程的析构函数。 在发送线程的析构函数中，调用发送线程的Close()操作，在线程关闭后，释放发送线程内的相关变量。 在发送线程的析构结束后，调用接收线程的Close()操作，在线程关闭后，释放接收线程内的相关变量，随后挨个释放储存的客户端连接对象。 在释放客户端连接对象时，会进入其析构函数，进行释放相关变量以及关闭socket连接的操作。 此时接收线程的析构函数完毕，若还有未释放的接收线程，则重复上述操作。 当子线程全部析构后，回到第一步主线程的退出函数中，此时执行关闭主机socket、清除环境、释放变量等操作。 至此程序安全退出。 &emsp;&emsp;具体更改就不一一叙述了，按照上述思路即可。下图为四条接收&#x2F;发送线程情况下，程序各部分的退出日志。其中exit为线程退出日志，start&#x2F;end为析构函数日志。 ※ - 项目源码 (github)提交名：v1.1 线程退出优化github项目连接 guguServer为服务端项目 guguAlloc为内存池静态库项目 guguDll为相关动态库项目 debugLib内为debug模式的静态库文件 lib内为release模式的静态库和动态库文件","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"网络编程","slug":"网络编程","permalink":"https://zgg2001.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"C++学习记录：C++连接Redis数据库","slug":"20210523_C++学习记录：C++连接Redis数据库","date":"2021-05-23T04:01:02.000Z","updated":"2021-05-23T04:01:02.000Z","comments":true,"path":"2021/05/23/20210523_C++学习记录：C++连接Redis数据库/","permalink":"https://zgg2001.github.io/2021/05/23/20210523_C++%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9AC++%E8%BF%9E%E6%8E%A5Redis%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"&emsp;&emsp;之前学习了Redis数据库相关的内容，但是并没有在编写C++代码中用到Redis相关内容。&emsp;&emsp;本篇笔记记录了个人在 Linux 环境下使用 C++ 连接 Redis 数据库的过程。实现了一个简单的排行榜功能。&emsp;&emsp;由于现在的主流是使用 java 连接 redis，所以在网上查询 C语言 的API消耗了一部分时间，在本篇笔记中，我将记录相关数据结构和API的使用方法。","text":"&emsp;&emsp;之前学习了Redis数据库相关的内容，但是并没有在编写C++代码中用到Redis相关内容。&emsp;&emsp;本篇笔记记录了个人在 Linux 环境下使用 C++ 连接 Redis 数据库的过程。实现了一个简单的排行榜功能。&emsp;&emsp;由于现在的主流是使用 java 连接 redis，所以在网上查询 C语言 的API消耗了一部分时间，在本篇笔记中，我将记录相关数据结构和API的使用方法。 一、基础准备1. 找到hiredis.h&emsp;&emsp;一般来讲，这个文件在你的redis文件夹下deps/hiredis目录中。将其include到源码中即可使用redis的API。 2. 编译并且连接库&emsp;&emsp;此时可以尝试写一个基础代码，随后编译。例如： 12345678/*此文件位于redis文件夹下 test.cpp*/#include&quot;deps/hiredis/hiredis.h&quot;int main()&#123; return 0;&#125; &emsp;&emsp;随后编译： 1g++ test.cpp -o test -l hiredis &emsp;&emsp;若可以正常编译，则说明没问题。若是提示找不到hiredis库文件，则按下面进行操作： 12345678//首先进入redis文件夹中，安装# cd redis-x.x.xx# make# make install//随后进入 redis/deps/hiredis 文件夹中，安装# cd deps/hiredis/# make# make install &emsp;&emsp;随后即可正常编译。 3. 运行&emsp;&emsp;找到上面编译生成的文件，运行，若成功执行即可跳过本节内容。&emsp;&emsp;若提示找不到链接文件，则说明动态库无法被正确连接。则按下面步骤操作： 123456//进入动态库链接文件# vim /etc/ld.so.conf//在新的一行中加入库文件所在目录添加： .../redis-x.x.x/deps/hiredis//更新/etc/ld.so.cache文件# ldconfig &emsp;&emsp;随后即可正常运行编译生成的文件。 二、代码相关1. 常用 建立redis连接12345redisContext* myredis = redisConnect(&quot;127.0.0.1&quot;,6379);/*如果 myredis-&gt;err = true，则说明连接失败字符串 myredis-&gt;errstr 即为失败原因*/ 执行redis语句并接收结果1234redisReply* reply = (redisReply*)redisCommand(myredis, &quot;set zzz 1&quot;);/*语句执行的结果，储存在 redisReply结构体类型 的 reply 中*/ 释放reply结构体1freeReplyObject(reply); 断开redis连接1redisFree(myredis); 2. redisReply结构体&emsp;&emsp;我感觉这算是redis相关内容中比较重要的内容了，语句执行的结果全在这个结构体中。 下面是这个结构体的定义： 12345678typedef struct redisReply &#123; int type; /* 返回值类型 */ long long integer; /* 当返回类型为 REDIS_REPLY_INTEGER 时 */ size_t len; /* 返回的字符串长度 */ char *str; /* 当返回值类型为 REDIS_REPLY_ERROR 和 REDIS_REPLY_STRING */ size_t elements; /* 返回的数组长度 */ struct redisReply **element; /* 当返回值类型为 REDIS_REPLY_ARRAY */&#125; redisReply; type的类型 123456REDIS_REPLY_STRING： 1 REDIS_REPLY_ARRAY： 2REDIS_REPLY_INTEGER：3 REDIS_REPLY_NIL： 4REDIS_REPLY_STATUS： 5REDIS_REPLY_ERROR： 6 我们首先通过type来确认返回值的类型： 返回值为1即为字符串，通过reply-&gt;str获取。 返回值为2即为数组，通过reply-&gt;element获取到redisReply数组，再遍历该数组，通过type正确获取其中信息。 返回值为3即为数字，通过reply-&gt;integer获取。 返回值为4即为空。 返回值为5即为执行语句的状态，通过reply-&gt;str获取，若结果为”OK”即为成功执行。 返回值为6即为执行错误。 &emsp;&emsp;返回值的类型和执行语句的类型是相关的，例如我执行get命令，则type应该为1；若我执行zrevrange命令，则type应该为2。在下文中，我简单实现了一个排行榜功能，其中使用的结构为sorted_set，则其返回的排行榜结果type应为2，通过遍历其element数组，即可获取排行榜信息。 三、一个简单的排行榜demo1. 思路&emsp;&emsp;简单来说就是获取key和范围，使用sprintf拼接redis查询语句，通过返回的redisReply结构体输出结果。 2. 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&quot;deps/hiredis/hiredis.h&quot;using namespace std;redisContext* myredis = new redisContext;redisReply* reply = new redisReply;char query[150];//查询语句 void get_rank(const char* key_name, int start, int stop)&#123; sprintf(query, &quot;zrevrange %s %d %d&quot;, key_name, start, stop); reply = (redisReply *)redisCommand(myredis, query); //printf(&quot;命令执行结果 reply type: %d\\n&quot;, reply-&gt;type); if (reply-&gt;type == 2) &#123; for(int i=0;i&lt;reply-&gt;elements;i++) &#123; if(reply-&gt;element[i]-&gt;type != 1) &#123; printf(&quot;Error-Please check that the input is correct\\n&quot;); freeReplyObject(reply); return; &#125; if(i == 0) &#123; printf(&quot;\\nRANK:\\n|----------|\\n&quot;); &#125; printf(&quot;| %2d -- %2s |\\n&quot;, i+1, reply-&gt;element[i]-&gt;str); &#125; printf(&quot;|----------|\\n\\n&quot;); &#125; else &#123; printf(&quot;Error-Please check that the input is correct\\n&quot;); &#125; freeReplyObject(reply);&#125;void get_rank_withscores(const char* key_name, int start, int stop)&#123; sprintf(query, &quot;zrevrange %s %d %d withscores&quot;, key_name, start, stop); reply = (redisReply *)redisCommand(myredis, query); //printf(&quot;命令执行结果 reply type: %d\\n&quot;, reply-&gt;type); if (reply-&gt;type == 2) &#123; for(int i=0;i&lt;reply-&gt;elements;i+=2) &#123; if(reply-&gt;element[i]-&gt;type != 1) &#123; printf(&quot;Error-Please check that the input is correct\\n&quot;,reply-&gt;element[i]-&gt;type); freeReplyObject(reply); return; &#125; if(i == 0) &#123; printf(&quot;\\nRANK:\\n|-----------------|\\n&quot;); &#125; printf(&quot;| %2d -- %2s -- %3s |\\n&quot;, i/2+1, reply-&gt;element[i]-&gt;str, reply-&gt;element[i+1]-&gt;str); &#125; printf(&quot;|-----------------|\\n\\n&quot;); &#125; else &#123; printf(&quot;Error-Please check that the input is correct\\n&quot;); &#125; freeReplyObject(reply);&#125;int main()&#123; myredis = redisConnect(&quot;127.0.0.1&quot;,6379); if(myredis-&gt;err)//if error &#123; cout &lt;&lt; &quot;Connection Error:&quot; &lt;&lt; myredis-&gt;errstr &lt;&lt; endl; &#125; //查询key:score的前十名 get_rank(&quot;score&quot;, 0, 9); //查询key:score的前十名 并且带上分数 get_rank_withscores(&quot;score&quot;, 0 ,9); redisFree(myredis); return 0;&#125; 3. 执行结果（上为不带分数 下为带分数）","categories":[{"name":"Redis","slug":"Redis","permalink":"https://zgg2001.github.io/categories/Redis/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"Redis","slug":"Redis","permalink":"https://zgg2001.github.io/tags/Redis/"}]},{"title":"C++学习记录：C++连接MySql数据库","slug":"20210522_C++学习记录：C++连接MySql数据库","date":"2021-05-22T04:28:17.000Z","updated":"2021-05-22T04:28:17.000Z","comments":true,"path":"2021/05/22/20210522_C++学习记录：C++连接MySql数据库/","permalink":"https://zgg2001.github.io/2021/05/22/20210522_C++%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9AC++%E8%BF%9E%E6%8E%A5MySql%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"&emsp;&emsp;之前学习了MySql数据库相关的内容，但是并没有在编写C++代码中用到MySql相关内容。&emsp;&emsp;本篇笔记记录了个人在 VS2019 中使用 C++ 连接 MySql 数据库的过程。使C++代码中可以实现连接数据库、执行语句、显示查询结果等基础功能。","text":"&emsp;&emsp;之前学习了MySql数据库相关的内容，但是并没有在编写C++代码中用到MySql相关内容。&emsp;&emsp;本篇笔记记录了个人在 VS2019 中使用 C++ 连接 MySql 数据库的过程。使C++代码中可以实现连接数据库、执行语句、显示查询结果等基础功能。 一、基础准备1. 在目录中添加路径&emsp;&emsp;首先找到 MySql 所在的文件夹，其中有include和lib文件夹，随后打开VS项目属性页，把include文件夹路径填入 包含目录 内，把 lib 文件夹路径填入 库目录 内。 2. 添加依赖项&emsp;&emsp;在lib文件夹中找到这个libmysql.lib库文件，在VS项目属性页中，把该库文件添加至 附加依赖项 即可。 3. 移动DLL文件&emsp;&emsp;为了使动态库可以正确被使用，我们需要把lib文件夹内的libmysql.dll文件复制到之后编译生成的可执行文件目录下，随后程序方可正常运行。 ※ 注意 注意自己的 MySQL 版本位数，由此在编译器中选择 32位&#x2F;64位 编译。 如果libmysql.dll文件放置的位置不对，会报错找不到libmysql.dll文件。 二、代码相关0. 基础123456789101112MySQL的相关头文件是：#include&lt;mysql.h&gt;连接数据库：mysql_real_connect(...);执行MySQL语句:mysql_query(...);获取上一条MySQL语句执行结果：mysql_store_result(...);获取上一条MySQL语句执行结果行数：mysql_affected_rows(...);等等... 1. 样例代码&emsp;&emsp;本测试代码实现了基础的连接数据库、执行数据库语句、输出查询结果等基础功能。 mysql.h12345678910111213141516171819202122232425262728293031323334#ifndef MY_SQL_H#define MY_SQL_H#include&lt;iostream&gt;#include&lt;Windows.h&gt;#include&lt;WinSock.h&gt;#include&lt;mysql.h&gt;class DataBase&#123;public: DataBase(); ~DataBase(); //连接数据库 参数为ip 用户名 密码 数据库名 端口 bool Connect(const char* ip, const char* name, const char* cypher, const char* database_name, const int port); //获取表内的字段数 int GetTableField(const char* table_name); //查询表 参数为表名 bool Query(const char* table_name); //自由执行指令 bool Implement(const char* sentence); private: bool _state;//连接状态 true为已连接 MYSQL* _mysql;//mysql连接 MYSQL_FIELD* _fd;//字段列数组 char _field[32][32];//存字段名二维数组 MYSQL_RES* _res;//这个结构代表返回行的一个查询结果集 MYSQL_ROW _column;//一个行数据的类型安全(type-safe)的表示，表示数据行的列 char _query[150];//查询语句 &#125;;#endif // !MY_SQL_H mysql.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &quot;mysql.h&quot;DataBase::DataBase()&#123; _state = false; _mysql = new MYSQL; _fd = nullptr; memset(_field, NULL, sizeof(_field)); _res = nullptr; _column = nullptr; memset(_query, NULL, sizeof(_query));&#125;DataBase::~DataBase()&#123;&#125;bool DataBase::Connect(const char* ip, const char* name, const char* cypher, const char* database_name, const int port)&#123; if (true == _state) &#123; printf(&quot;Database connected\\n&quot;); return false; &#125; //初始化mysql mysql_init(_mysql); //返回false则连接失败，返回true则连接成功 if (!(mysql_real_connect(_mysql, ip, name, cypher, database_name, port, NULL, 0))) //中间分别是主机，用户名，密码，数据库名，端口号（可以写默认0或者3306等），可以先写成参数再传进去 &#123; printf(&quot;Error connecting to database:%s\\n&quot;, mysql_error(_mysql)); return false; &#125; else &#123; _state = true; printf(&quot;Connected succeed\\n\\n&quot;); return true; &#125; return true;&#125;int DataBase::GetTableField(const char* table_name)&#123; if (false == _state) &#123; printf(&quot;Database not connected\\n&quot;); return -1; &#125; //查询内容 sprintf_s(_query, &quot;desc %s&quot;, table_name); //desc 语句获取字段数 //设置编码格式（SET NAMES GBK也行），否则cmd下中文乱码 mysql_query(_mysql, &quot;set names gbk&quot;); //返回0 查询成功，返回1查询失败 if (mysql_query(_mysql, _query)) //执行SQL语句 &#123; printf(&quot;Query failed (%s)\\n&quot;, mysql_error(_mysql)); return false; &#125; //获取结果集 if (!(_res = mysql_store_result(_mysql))) //获得sql语句结束后返回的结果集 &#123; printf(&quot;Couldn&#x27;t get result from %s\\n&quot;, mysql_error(_mysql)); return false; &#125; //数据行数即为字段个数 return mysql_affected_rows(_mysql);&#125;bool DataBase::Query(const char* table_name)&#123; if (false == _state) &#123; printf(&quot;Database not connected\\n&quot;); return false; &#125; //获取字段数 int field = GetTableField(table_name); //查询内容 sprintf_s(_query, &quot;select * from %s&quot;, table_name); //执行查询语句 //设置编码格式（SET NAMES GBK也行），否则cmd下中文乱码 mysql_query(_mysql, &quot;set names gbk&quot;); //返回0 查询成功，返回1查询失败 if (mysql_query(_mysql, _query)) //执行SQL语句 &#123; printf(&quot;Query failed (%s)\\n&quot;, mysql_error(_mysql)); return false; &#125; else &#123; printf(&quot;query success\\n&quot;); &#125; //获取结果集 if (!(_res = mysql_store_result(_mysql))) //获得sql语句结束后返回的结果集 &#123; printf(&quot;Couldn&#x27;t get result from %s\\n&quot;, mysql_error(_mysql)); return false; &#125; //打印数据行数 printf(&quot;number of dataline returned: %lld\\n&quot;, mysql_affected_rows(_mysql)); //获取字段的信息 char* str_field[32]; //定义一个字符串数组存储字段信息 for (int i = 0; i &lt; field; i++) //在已知字段数量的情况下获取字段名 &#123; str_field[i] = mysql_fetch_field(_res)-&gt;name; &#125; for (int i = 0; i &lt; field; i++) //打印字段 &#123; printf(&quot;%10s\\t&quot;, str_field[i]); &#125; printf(&quot;\\n&quot;); //打印获取的数据 while (_column = mysql_fetch_row(_res)) //在已知字段数量情况下，获取并打印下一行 &#123; for (int i = 0; i &lt; field; i++) &#123; printf(&quot;%10s\\t&quot;, _column[i]); //column是列数组 &#125; printf(&quot;\\n&quot;); &#125; return true;&#125;bool DataBase::Implement(const char* sentence)&#123; if (false == _state) &#123; printf(&quot;Database not connected\\n&quot;); return false; &#125; //查询内容 sprintf_s(_query, &quot;%s&quot;, sentence); //desc 语句获取字段数 //设置编码格式（SET NAMES GBK也行），否则cmd下中文乱码 mysql_query(_mysql, &quot;set names gbk&quot;); //执行SQL语句 if (mysql_query(_mysql, _query)) &#123; printf(&quot;Query failed (%s)\\n&quot;, mysql_error(_mysql)); return false; &#125; return true;&#125; main.cpp12345678910111213141516171819#include&quot;mysql.h&quot;int main()&#123; DataBase* d1 = new DataBase; //连接 d1-&gt;Connect(&quot;localhost&quot;, &quot;root&quot;, &quot;123456&quot;, &quot;test&quot;, 0); printf(&quot;\\n&quot;); //查询表 d1-&gt;Query(&quot;t_student&quot;); printf(&quot;\\n&quot;); //添加内容 d1-&gt;Implement(&quot;insert into t_student values(201916010001, &#x27;赵四&#x27;, &#x27;2019-09-09&#x27;, now())&quot;); printf(&quot;\\n&quot;); //查询表 d1-&gt;Query(&quot;t_student&quot;); printf(&quot;\\n&quot;); return 0;&#125; 三、GitHub项目点我跳转github","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://zgg2001.github.io/categories/Mysql/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"Mysql","slug":"Mysql","permalink":"https://zgg2001.github.io/tags/Mysql/"}]},{"title":"C++网络编程学习：心跳机制与定时发送数据","slug":"20210508_C++网络编程学习：心跳机制与定时发送数据","date":"2021-05-08T11:29:13.000Z","updated":"2021-05-08T11:29:13.000Z","comments":true,"path":"2021/05/08/20210508_C++网络编程学习：心跳机制与定时发送数据/","permalink":"https://zgg2001.github.io/2021/05/08/20210508_C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%AE%9A%E6%97%B6%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE/","excerpt":"网络编程学习记录 使用的语言为C&#x2F;C++ 源码支持的平台为：Windows（本文中内容使用windows平台下vs2019开发，故本文项目不完全支持linux平台） 点我查看之前的代码开发记录 0：本次增改内容 更改服务端中，客户端对象储存的方式，由vector改为map。 改变任务队列中任务储存方式，由任务基类改为匿名函数。 加入心跳检测机制，及时剔除未响应客户端。 加入定时发送消息检测机制，及时发送缓冲区内的内容。 将内存池静态库分离，使客户端源码也可以引用。","text":"网络编程学习记录 使用的语言为C&#x2F;C++ 源码支持的平台为：Windows（本文中内容使用windows平台下vs2019开发，故本文项目不完全支持linux平台） 点我查看之前的代码开发记录 0：本次增改内容 更改服务端中，客户端对象储存的方式，由vector改为map。 改变任务队列中任务储存方式，由任务基类改为匿名函数。 加入心跳检测机制，及时剔除未响应客户端。 加入定时发送消息检测机制，及时发送缓冲区内的内容。 将内存池静态库分离，使客户端源码也可以引用。 1：更改客户端储存方式&emsp;&emsp;之前，我的服务端程序储存客户端对象ClientSocket的方式是std::vector&lt;ClientSocket*&gt;，在select筛选后的fd_set中使用FD_ISSET函数获取需接收报文的客户端。&emsp;&emsp;但是FD_ISSET函数是使用for循环进行暴力检索，消耗较大，我们可以改为使用std::map::find进行检索。这样就需要把储存客户端对象的方式改为std::map。因为我们需要通过socket进行查找，所以我把std::map的键设为SOCKET，值设为客户端对象ClientSocket的指针，这样我们需要改为std::map&lt;SOCKET,ClientSocket*&gt;。&emsp;&emsp;在改变储存数据结构后，若想获取客户端socket，则调用iter-&gt;first；若想获取客户端对象指针，则调用iter-&gt;second；获取已连接客户端数量则还是_clients.size()。&emsp;&emsp;在更换数据结构后，我们通过fdRead.fd_count进行循环，由于linux下fd_set内容与windows下不一致，所以本次要分环境进行检索，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#ifdef _WIN32 for (int n = 0; n &lt; (int)fdRead.fd_count; n++) &#123; auto iter = _clients.find(fdRead.fd_array[n]); if (iter != _clients.end()) &#123; if (-1 == RecvData(iter-&gt;second)) &#123; if (_pNetEvent)//主线程中删除客户端 &#123; _pNetEvent-&gt;OnNetLeave(iter-&gt;second); &#125; closesocket(iter-&gt;first); delete iter-&gt;second; _clients.erase(iter);//移除 _client_change = true;//客户端退出 需要通知系统重新录入fdset集合 &#125; &#125; &#125;#else std::vector&lt;ClientSocket*&gt; ClientSocket_temp; for(auto iter = _clients.begin(); iter != _clients.end(); ++iter) &#123; if (FD_ISSET(iter-&gt;first, &amp;fdRead)) &#123; if (-1 == RecvData(iter-&gt;second))//处理请求 客户端退出的话 &#123; if (_pNetEvent)//主线程中删除客户端 &#123; _pNetEvent-&gt;OnNetLeave(iter-&gt;second); &#125; ClientSocket_temp.push_back(iter-&gt;second); _clients.erase(iter);//移除 _client_change = true;//客户端退出 需要通知系统重新录入fdset集合 &#125; &#125; &#125; for (auto client : ClientSocket_temp) &#123; closesocket(client-&gt;GetSockfd()); _clients.erase(client-&gt;GetSockfd()); delete client; &#125;#endif // _WIN32 &emsp;&emsp;将所有相关位置的代码进行更改后，即可完成 客户端对象储存 数据结构的更改。 2：更改任务队列储存方式&emsp;&emsp;之前，我是声明了一个抽象任务基类，通过重写基类的DoTask()方法来规定如何执行任务。但是这样利用多态可以执行重写后的任务。但是对于每一个新的任务类型，都需要定义一个新类重写一次DoTask()方法，有点麻烦。所以我使用C++11中新引入的匿名函数，来更改任务队列的储存方式，定义一个匿名函数类型，使任务内容可以更加灵活。 1234567891011121314151617//定义typedef std::function&lt;void()&gt; CellTask;//任务数据 std::list&lt;CellTask&gt;_tasks;//处理任务for (auto pTask : _tasks)&#123; pTask(); &#125;//使用lambda式添加匿名函数_tasks.push_back([pClient,pHead]() &#123; pClient-&gt;SendData(pHead); delete pHead;&#125;); 3：加入心跳检测机制&emsp;&emsp;首先，心跳检测的前提是存在一个计时器，这里我在动态库中新实现了一个计时器类HBtimer(代码如下)，通过调用getNowMillSec方法，返回当前时间戳。这样通过一个变量来储存上一次获取的时间戳，从而可以计算两次获取时间戳之间的时间差，从而实现计时功能。 123456789101112131415class __declspec(dllexport) HBtimer&#123;public: HBtimer(); virtual ~HBtimer(); //获取当前时间戳 (毫秒) static time_t getNowMillSec();&#125;;time_t HBtimer::getNowMillSec()&#123; //获取高精度当前时间(毫秒) high_resolution_clock::now(); //duration_cast是类型转换方法 return duration_cast&lt;milliseconds&gt;(high_resolution_clock::now().time_since_epoch()).count();&#125; &emsp;&emsp;随后我在客户端类中定义一个心跳计时变量，并且声明两个相关方法，实现对心跳计时变量的归零与检测操作。当心跳计时器超过规定的客户端死亡时间后，CheckHeart方法会返回true告知该客户端已死亡。 1234567891011121314151617181920//客户端死亡时间 20000毫秒#define CLIENT_HREAT_TIME 20000//心跳计时器time_t _dtHeart;//计时变量归零void ClientSocket::ResetDtHeart()&#123; _dtHeart = 0;&#125;//dt为时间差 传入两次检测之间的时间差，检测心跳计时器是否超过心跳检测的阈值bool ClientSocket::CheckHeart(time_t dt)&#123; _dtHeart += dt; if (_dtHeart &gt;= CLIENT_HREAT_TIME) &#123; printf(&quot;CheakHeart dead:%d,time=%lld\\n&quot;,_sockfd,_dtHeart); return true; &#125; return false;&#125; &emsp;&emsp;接着需要在合适的函数中进行客户端的心跳检测。我在子线程的OnRun方法中，即对客户端进行select操作的方法中，加入CheckTime方法，之后对客户端相关的检测操作均在此方法中进行。在CheckTime中，我们首先要获取两次checktime之间的时间差，随后遍历所有客户端对象，挨个使用CheckHeart方法进行检测是否超时，若发现超时，则主动断开与该客户端之间的连接。 12345678910111213141516171819202122232425void CellServer::CheckTime()&#123; //获取时间差 time_t nowTime = HBtimer::getNowMillSec(); time_t dt = nowTime - _oldTime; _oldTime = nowTime; //遍历所有客户端对象 for (auto iter = _clients.begin(); iter != _clients.end();) &#123; //检测心跳是否超时 if (iter-&gt;second-&gt;CheckHeart(dt) == true) &#123; if (_pNetEvent)//主线程中删除客户端 &#123; _pNetEvent-&gt;OnNetLeave(iter-&gt;second); &#125; closesocket(iter-&gt;second-&gt;GetSockfd()); delete iter-&gt;second; _clients.erase(iter++);//移除 _client_change = true;//客户端退出 需要通知系统重新录入fdset集合 continue; &#125; iter++; &#125;&#125; &emsp;&emsp;接着是心跳信号，可以在每次收到客户端报文时都对心跳计时变量归零，也可以声明单独的心跳报文，当接收到此报文时，重置心跳计时变量。 123456789101112131415161718//包6 心跳 client to serverstruct C2S_Heart : public DataHeader&#123; C2S_Heart()//初始化包头 &#123; this-&gt;cmd = CMD_C2S_HEART; this-&gt;date_length = sizeof(C2S_Heart); &#125;&#125;;//包7 心跳 server to clientstruct S2C_Heart : public DataHeader&#123; S2C_Heart()//初始化包头 &#123; this-&gt;cmd = CMD_S2C_HEART; this-&gt;date_length = sizeof(S2C_Heart); &#125;&#125;; 4：加入定时发送缓存消息机制&emsp;&emsp;之前，我仅进行了客户端消息定量发送功能，即当客户端对象发送缓冲区满后，进行消息的发送。这样当消息发送效率不够高时，很容易造成消息反馈的延迟，于是本次也实现了定时发送的功能。&emsp;&emsp;上面实现心跳检测时，已经新建了CellServer::CheckTime方法，这个定时发送检测，我们也可以放在这个方法里。思路和心跳检测大同小异，也是在客户端类中定义一个发送计时变量，并且声明两个相关方法，实现对发送计时变量的归零与检测操作。&emsp;&emsp;当发现需要发送消息时，需要一个方法把客户端对象发送缓冲区内的内容全部发送，并且清空缓冲区(指针归零)，随后重置计时变量。该方法为ClientSocket::SendAll。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//客户端定时发送时间 200毫秒#define CLIENT_AUTOMATIC_SEND_TIME 200//定时发送计时器time_t _dtSend;//重置void ClientSocket::ResetDtSend()&#123; _dtSend = 0;&#125;//判断bool ClientSocket::CheckSend(time_t dt)&#123; _dtSend += dt; if (_dtSend &gt;= CLIENT_AUTOMATIC_SEND_TIME) &#123; //printf(&quot;AutomaticSend:%d,time=%lld\\n&quot;, _sockfd, _dtSend); return true; &#125; return false;&#125;//发送缓冲区内全部消息int ClientSocket::SendAll()&#123; int ret = SOCKET_ERROR; if (_Len_Send_buf &gt; 0 &amp;&amp; SOCKET_ERROR != _sockfd) &#123; //发送 ret = send(_sockfd, (const char*)_Msg_Send_buf, _Len_Send_buf, 0); //发送后缓冲区归零 _Len_Send_buf = 0; //重置发送计时器 ResetDtSend(); //发送错误 if (SOCKET_ERROR == ret) &#123; printf(&quot;error 发送失败&quot;); &#125; &#125; return ret;&#125;//检测void CellServer::CheckTime()&#123; //获取时间差 time_t nowTime = HBtimer::getNowMillSec(); time_t dt = nowTime - _oldTime; _oldTime = nowTime; //遍历所有客户端对象 for (auto iter = _clients.begin(); iter != _clients.end();) &#123; //检测是否到定时发送消息 if (iter-&gt;second-&gt;CheckSend(dt) == true) &#123; iter-&gt;second-&gt;SendAll(); iter-&gt;second-&gt;ResetDtSend(); &#125; iter++; &#125;&#125; 5：将内存池静态库分离&emsp;&emsp;没什么好说的，简单在vs2019上建一个空项目，随后把项目属性改为静态库，随后把内存池源码搬过去就好。需要注意的一点是静态库分 Debug &#x2F; Release 版本，记得让源码连接合适的版本。 ※ - 项目源码 (github)提交名：v1.0 定时检测github项目连接 guguServer为服务端项目 guguAlloc为内存池静态库项目 guguDll为相关动态库项目 debugLib内为debug模式的静态库文件 lib内为release模式的静态库和动态库文件","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"网络编程","slug":"网络编程","permalink":"https://zgg2001.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"C++网络编程学习：项目化 (加入内存池静态库 / 报文动态库)","slug":"20210426_C++网络编程学习：项目化(加入内存池静态库-报文动态库)","date":"2021-04-26T15:09:03.000Z","updated":"2021-04-26T15:09:03.000Z","comments":true,"path":"2021/04/26/20210426_C++网络编程学习：项目化(加入内存池静态库-报文动态库)/","permalink":"https://zgg2001.github.io/2021/04/26/20210426_C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E9%A1%B9%E7%9B%AE%E5%8C%96(%E5%8A%A0%E5%85%A5%E5%86%85%E5%AD%98%E6%B1%A0%E9%9D%99%E6%80%81%E5%BA%93-%E6%8A%A5%E6%96%87%E5%8A%A8%E6%80%81%E5%BA%93)/","excerpt":"使用的语言为C&#x2F;C++ 源码支持的平台为：Windows（本文项目全部使用windows平台下vs2019开发，故本文项目不支持linux平台） 一、思路与准备&emsp;&emsp;之前的客户端虽然可以跑起来，但是声明和实现全写于一个hpp文件中，随着代码日渐增多，增删改变得越发困难。所以我决定尝试将其实现的更加标准。本次我准备的内容如下： 服务端源码 —— C++网络编程学习：消息接收与发送分离（即笔记九版本的源码） 内存池源码 —— C++学习记录：内存池设计与实现 及其详细代码 计时器类 —— C++学习记录：基于chrono库的高精度计时器 报文CMD文件 —— 即报文类型定义，在之前的网络编程笔记中可以找到","text":"使用的语言为C&#x2F;C++ 源码支持的平台为：Windows（本文项目全部使用windows平台下vs2019开发，故本文项目不支持linux平台） 一、思路与准备&emsp;&emsp;之前的客户端虽然可以跑起来，但是声明和实现全写于一个hpp文件中，随着代码日渐增多，增删改变得越发困难。所以我决定尝试将其实现的更加标准。本次我准备的内容如下： 服务端源码 —— C++网络编程学习：消息接收与发送分离（即笔记九版本的源码） 内存池源码 —— C++学习记录：内存池设计与实现 及其详细代码 计时器类 —— C++学习记录：基于chrono库的高精度计时器 报文CMD文件 —— 即报文类型定义，在之前的网络编程笔记中可以找到 &emsp;&emsp;我首先准备将之前服务端源代码的hpp文件进行分离，分离成单独类声明与实现。且服务端本体源码放在一个项目中。随后新建静态库项目存储内存池源码，使服务端源码项目链接内存池静态库。最后新建一个动态库项目，里面存放计时器类代码和报文CMD文件，因为服务端和客户端程序都要用这个库里的文件，为了今后方便改动，我选择使用动态库。 二、服务端本体 项目1. 思路&emsp;&emsp;首先，服务端源码按功能可分为五个部分： 服务端基础接口部分。此部分定义了几个服务端的基本操作，可以通过继承重写这几个基本操作实现不同的功能。 服务端主线程部分。此部分调用基础的socket函数，与客户端建立socket连接，仅监控是否有新客户端加入。 客户端类部分。每当有新客户端加入，都会新建一个客户端对象，通过该客户端对象(获取socket&#x2F;使用缓冲区)发送网络报文。 子线程类任务处理(发送)部分。此类每一个对象即为一条新的子线程，用来处理服务端与客户端之间的网络报文发送任务。任务处理接口。通过重写该接口，实现自己的任务处理方式。 子线程类接收部分。此类每一个对象即为一条新的子线程，用来处理监控服务端与客户端之间的网络报文接收。重写任务处理接口方法。实现自己的任务处理方式。 &emsp;&emsp;按照五个部分的关系等，可画出如下的关系图：&emsp;&emsp;由此，我令 ⑤部分 include ①③④部分，再令 ②部分 include ⑤部分，即可实现项目各文件间的关联。 2. 头文件源码①服务端基础接口部分INetEvent.h 123456789101112131415161718192021222324252627282930/** 本文件中定义了服务端的基础接口* 在TcpServer.h中服务端类继承了该接口* * 目前仅定义了四个基础事件* 2021/4/22*/#ifndef _INET_EVENT_H_#define _INET_EVENT_H_//相关预声明class ClientSocket;class CellServer;struct DataHeader;//服务端基础接口class INetEvent&#123;public: //客户端退出事件 virtual void OnNetJoin(ClientSocket* pClient) = 0; //客户端退出事件 virtual void OnNetLeave(ClientSocket* pClient) = 0; //服务端发送消息事件 virtual void OnNetMsg(CellServer* pCellServer, ClientSocket* pClient, DataHeader* pHead) = 0; //服务端接收消息事件 virtual void OnNetRecv(ClientSocket* pClient) = 0;&#125;;#endif ②服务端主线程部分TcpServer.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** 服务端类* 实现基础的socket连接操作* 通过start方法生成子线程 监控收包* 主线程仅进行客户端加入退出监控* 2021/4/22*/#ifndef _TCP_SERVER_H_#define _TCP_SERVER_H_#include&quot;CellServer.h&quot;#include&lt;stdio.h&gt;#include&lt;atomic&gt;//服务端类 class TcpServer : INetEvent&#123;public: //构造 TcpServer(); //析构 virtual ~TcpServer(); //初始化socket 返回1为正常 int InitSocket(); //绑定IP/端口 int Bind(const char* ip, unsigned short port); //监听端口 int Listen(int n); //接受连接 int Accept(); //关闭socket void CloseSocket(); //添加客户端至服务端 void AddClientToServer(ClientSocket* pClient); //线程启动 void Start(int nCellServer); //判断是否工作中 inline bool IsRun(); //查询是否有待处理消息 bool OnRun(); //显示各线程数据信息 void time4msg(); //客户端加入事件 virtual void OnNetJoin(ClientSocket* pClient); //客户端退出 virtual void OnNetLeave(ClientSocket* pClient); //客户端发送消息事件 virtual void OnNetMsg(CellServer* pCellServer, ClientSocket* pClient, DataHeader* pHead); virtual void OnNetRecv(ClientSocket* pClient);private: //socket相关 SOCKET _sock; std::vector&lt;CellServer*&gt; _cellServers;//线程处理 //计时器 mytimer _time; //发送包的数量 std::atomic_int _msgCount; //接收包的数量 std::atomic_int _recvCount; //客户端计数 std::atomic_int _clientCount;&#125;;#endif ③客户端类部分ClientSocket.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** 客户端类 * 服务端对象中每加入一个新的客户端，都会新建一个客户端对象* 通过该客户端对象向客户端进行发送消息等操作* * 目前来说只实现了定量发送数据，即发送缓冲区满后发送消息，下一步预备完善为定时定量发送信息* 2021/4/22*/#ifndef _CLIENT_SOCKET_H_#define _CLIENT_SOCKET_H_//socket相关内容#ifdef _WIN32 #define FD_SETSIZE 1024 #define WIN32_LEAN_AND_MEAN #include&lt;winSock2.h&gt; #include&lt;WS2tcpip.h&gt; #include&lt;windows.h&gt; #pragma comment(lib, &quot;ws2_32.lib&quot;)//链接此动态链接库 windows特有 //连接动态库 此动态库里含有计时器类timer 和 cmd命令 #include &quot;pch.h&quot; #pragma comment(lib, &quot;guguDll.lib&quot;) //连接静态库 此静态库里含有一个内存池 #pragma comment(lib, &quot;guguAlloc.lib&quot;)#else #include&lt;sys/socket.h&gt; #include&lt;arpa/inet.h&gt;//selcet #include&lt;unistd.h&gt;//uni std #include&lt;string.h&gt; #define SOCKET int #define INVALID_SOCKET (SOCKET)(~0) #define SOCKET_ERROR (-1)#endif//缓冲区大小 #ifndef RECV_BUFFER_SIZE #define RECV_BUFFER_SIZE 4096 #define SEND_BUFFER_SIZE 40#endif//客户端类 class ClientSocket&#123;public: //构造 ClientSocket(SOCKET sockfd = INVALID_SOCKET); //析构 virtual ~ClientSocket(); //获取socket SOCKET GetSockfd(); //获取接收缓冲区 char* MsgBuf(); //获取接收缓冲区尾部变量 int GetLen(); //设置缓冲区尾部变量 void SetLen(int len); //发送数据 int SendData(DataHeader* head);private: SOCKET _sockfd; //缓冲区相关 char* _Msg_Recv_buf;//消息缓冲区 int _Len_Recv_buf;//缓冲区数据尾部变量 char* _Msg_Send_buf;//消息发送缓冲区 int _Len_Send_buf;//发送缓冲区数据尾部变量&#125;;#endif ④子线程类任务处理(发送)部分CellTask.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** 子线程发送部分* 本头文件中实现了任务执行的分离操作* 通过list结构存储需要执行的任务* start()启动线程进行任务处理* 为防止出现冲突，所有临界操作均进行上锁，且首先使用缓冲区储存新任务* * 2021/4/22*/#ifndef _CELL_Task_hpp_#define _CELL_Task_hpp_#include&lt;thread&gt;#include&lt;mutex&gt;#include&lt;list&gt;#include &lt;functional&gt;//mem_fn//任务基类接口class CellTask&#123;public: //执行任务 virtual void DoTask() = 0;&#125;;//发送线程类class CellTaskServer&#123;public: CellTaskServer(); virtual ~CellTaskServer(); //添加任务 void addTask(CellTask* ptask); //启动服务 void Start();protected: //工作函数 void OnRun();private: //任务数据 std::list&lt;CellTask*&gt;_tasks; //任务数据缓冲区 std::list&lt;CellTask*&gt;_tasksBuf; //锁 锁数据缓冲区 std::mutex _mutex;&#125;;#endif ⑤子线程类接收部分CellServer.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/** 子线程接收部分* 本文件中实现线程类以及DoTask接口* 使服务端线程分离 主线程接收连接 其余子线程处理消息* * 初步实现了发送任务的接口，使其调用客户端对象的SendData方法发送消息* 目前采用的是select结构 未来可能尝试其他结构* 2021/4/22*/#ifndef _CELL_SERVER_H_#define _CELL_SERVER_H_#include&quot;INetEvent.h&quot;#include&quot;CellTask.h&quot;#include&quot;ClientSocket.h&quot;#include &lt;vector&gt;//网络消息发送任务class CellSendMsgTask : public CellTask&#123;public: CellSendMsgTask(ClientSocket* pClient, DataHeader* pHead) &#123; _pClient = pClient; _pHeader = pHead; &#125; //执行任务 virtual void DoTask() &#123; _pClient-&gt;SendData(_pHeader); delete _pHeader; &#125;private: ClientSocket* _pClient; DataHeader* _pHeader;&#125;;//线程类class CellServer&#123;public: //构造 CellServer(SOCKET sock = INVALID_SOCKET); //析构 virtual ~CellServer(); //处理事件 void setEventObj(INetEvent* event); //关闭socket void CloseSocket(); //判断是否工作中 bool IsRun(); //查询是否有待处理消息 bool OnRun(); //接收数据 int RecvData(ClientSocket* t_client);//处理数据 //响应数据 void NetMsg(DataHeader* pHead, ClientSocket* pClient); //增加客户端 void addClient(ClientSocket* client); //启动线程 void Start(); //获取该线程内客户端数量 int GetClientCount() const; //添加任务 void AddSendTask(ClientSocket* pClient, DataHeader* pHead);private: //select优化 SOCKET _maxSock;//最大socket值 fd_set _fd_read_bak;//读集合备份 bool _client_change;//客户端集合bool true表示发生改变 需重新统计 fd_read集合 //缓冲区相关 char* _Recv_buf;//接收缓冲区 //socket相关 SOCKET _sock; //正式客户队列 std::vector&lt;ClientSocket*&gt; _clients;//储存客户端 //客户缓冲区 std::vector&lt;ClientSocket*&gt; _clientsBuf; std::mutex _mutex;//锁 //线程 std::thread* _pThread; //退出事件接口 INetEvent* _pNetEvent; //发送线程队列 CellTaskServer _taskServer;&#125;;#endif 三、内存池静态库 项目1. 思路&emsp;&emsp;在服务端源码基本完成后，我开始为内存池的连接进行准备。我打算在VS2019上尝试动态库和静态库的生成与链接。内存池我打算首先用静态库来链接，在之后可能我会改为动态库链接。&emsp;&emsp;在网上查阅资料后，我按如下步骤进行静态库生成与链接： 更改该项目配置类型为静态库类型 关闭预编译头(我是关掉了，也可以把内存池放在预编译头中) 在解决方案属性中，使得应用程序项目(即服务端项目)依赖于内存池静态库项目。这样在编译服务端项目时，会自动编译更新静态库 在应用程序项目(即服务端项目)属性中，在链接器选项中的附加依赖项中，添加上lib静态库文件 由于两个项目(服务端和静态库)在同一个解决方案，所以可以不用用代码链接静态库(我个人实验得出结论，不一定对)12//连接静态库 此静态库里含有一个内存池 在该解决方案代码中不加也可以连接上#pragma comment(lib, &quot;guguAlloc.lib&quot;) 2. 头文件源码①重载new&#x2F;delete部分Alloctor.h 12345678910111213141516/** 本文件中重载了new/delete操作* 使new/delete调用内存池* 2021/4/22*/#ifndef _Alloctor_h_#define _Alloctor_h_void* operator new(size_t size);void operator delete(void* p);void* operator new[](size_t size);void operator delete[](void* p);void* mem_alloc(size_t size);void mem_free(void* p);#endif ②内存池类部分MemoryAlloc.h 12345678910111213141516171819202122232425262728293031323334353637383940/*内存池类对内存块进行管理2021/4/22*/#ifndef _Memory_Alloc_h_#define _Memory_Alloc_h_//导入内存块头文件#include&quot;MemoryBlock.h&quot;class MemoryAlloc&#123;public: MemoryAlloc(); virtual ~MemoryAlloc(); //设置初始化 void setInit(size_t nSize, size_t nBlockSize); //初始化 void initMemory(); //申请内存 void* allocMem(size_t nSize); //释放内存 void freeMem(void* p);protected: //内存池地址 char* _pBuf; //头部内存单元 MemoryBlock* _pHeader; //内存块大小 size_t _nSize; //内存块数量 size_t _nBlockSize; //多线程锁 std::mutex _mutex;&#125;;#endif ③内存块类部分MemoryBlock.h 123456789101112131415161718192021222324252627282930313233343536373839404142/*内存块类内存管理的最小单位2021/4/22*/#ifndef _Memory_Block_h_#define _Memory_Block_h_//声明内存池类class MemoryAlloc;//最底层导入内存头文件/断言头文件/锁头文件#include&lt;stdlib.h&gt;#include&lt;assert.h&gt;#include&lt;mutex&gt;//如果为debug模式则加入调试信息#ifdef _DEBUG#include&lt;stdio.h&gt;#define xPrintf(...) printf(__VA_ARGS__)#else#define xPrintf(...)#endifclass MemoryBlock&#123;public: //内存块编号 int _nID; //引用情况 int _nRef; //所属内存池 MemoryAlloc* _pAlloc; //下一块位置 MemoryBlock* _pNext; //是否在内存池内 bool _bPool;private:&#125;;#endif ④内存管理工具类MemoryMgr.h 123456789101112131415161718192021222324252627282930313233343536373839404142/*内存管理工具类对内存池进行管理2021/4/22*/#ifndef _Memory_Mgr_h_#define _Memory_Mgr_h_//内存池最大申请#define MAX_MEMORY_SIZE 128//导入内存池模板类#include&quot;MemoryAlloc.h&quot;class MemoryMgr&#123;public: //饿汉式单例模式 static MemoryMgr* Instance(); //申请内存 void* allocMem(size_t nSize); //释放内存 void freeMem(void* p); //增加内存块引用次数 void addRef(void* p);private: MemoryMgr(); virtual ~MemoryMgr(); //内存映射初始化 void init_szAlloc(int begin, int end, MemoryAlloc* pMem);private: //映射数组 MemoryAlloc* _szAlloc[MAX_MEMORY_SIZE + 1]; //64字节内存池 MemoryAlloc _mem64; //128字节内存池 MemoryAlloc _mem128;&#125;;#endif 四、计时&#x2F;报文动态库 项目1. 思路&emsp;&emsp;内存池静态库链接完成后，我开始准备新建动态库项目，存放自实现计时器类和报文命令类型。&emsp;&emsp;在网上查阅资料后，我按如下步骤进行静态库生成与链接： 新建动态库项目，配置类型为动态库 此项目中，我使用了预编译头文件 添加自实现计时器类和报文命令类型文件（下图中guguTimer.h/guguTimer.cpp为计时器类声明&#x2F;定义、CMD.h为报文命令类型文件) 添加库导出关键字__declspec(dllexport) 将计时类的成员变量改为全局变量，保证生命周期(cpp文件需要include&quot;pch.h&quot;来保证预编译正常进行) 编译动态库，得到dll文件和lib文件 将dll文件、lib文件、动态库中所有的头文件复制到服务端项目的源码文件夹下(如下图所示，复制的文件有:guguDll.dll、guguDll.lib、pch.h、framework.h、guguTimer.h、CMD.h) 链接动态库、include预编译文件，此时动态库链接完成123//连接动态库 此动态库里含有计时器类timer 和 cmd命令#include &quot;pch.h&quot;#pragma comment(lib, &quot;guguDll.lib&quot;) 2. 头文件源码①pch.h123456789101112131415// pch.h: 这是预编译标头文件。// 下方列出的文件仅编译一次，提高了将来生成的生成性能。// 这还将影响 IntelliSense 性能，包括代码完成和许多代码浏览功能。// 但是，如果此处列出的文件中的任何一个在生成之间有更新，它们全部都将被重新编译。// 请勿在此处添加要频繁更新的文件，这将使得性能优势无效。#ifndef PCH_H#define PCH_H// 添加要在此处预编译的标头#include &quot;framework.h&quot;#include &quot;guguTimer.h&quot;#include &quot;CMD.h&quot;#endif //PCH_H ②framework123456#pragma once//懒得改了(#define WIN32_LEAN_AND_MEAN // 从 Windows 头文件中排除极少使用的内容// Windows 头文件#include &lt;windows.h&gt; ③guguTimer.h123456789101112131415161718192021222324252627/** 计时器类* 2021/4/23*/#ifndef MY_TIMER_H_#define MY_TIMER_H_#include&lt;chrono&gt;class __declspec(dllexport) mytimer&#123;private: public: mytimer(); virtual ~mytimer(); //调用update时，使起始时间等于当前时间 void UpDate(); //调用getsecond方法时，经过的时间为当前时间减去之前统计过的起始时间。 double GetSecond();&#125;;#endif ④CMD.h12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** 报文数据类型* 2021/4/23*/#ifndef _CMD_H_#define _CMD_H_//枚举类型记录命令 enum cmd&#123; CMD_LOGIN,//登录 CMD_LOGINRESULT,//登录结果 CMD_LOGOUT,//登出 CMD_LOGOUTRESULT,//登出结果 CMD_NEW_USER_JOIN,//新用户登入 CMD_ERROR//错误 &#125;;//定义数据包头 struct DataHeader&#123; short cmd;//命令 short date_length;//数据的长短 &#125;;//包1 登录 传输账号与密码struct Login : public DataHeader&#123; Login()//初始化包头 &#123; this-&gt;cmd = CMD_LOGIN; this-&gt;date_length = sizeof(Login); &#125; char UserName[32];//用户名 char PassWord[32];//密码 &#125;;//包2 登录结果 传输结果struct LoginResult : public DataHeader&#123; LoginResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGINRESULT; this-&gt;date_length = sizeof(LoginResult); &#125; int Result;&#125;;//包3 登出 传输用户名 struct Logout : public DataHeader&#123; Logout()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUT; this-&gt;date_length = sizeof(Logout); &#125; char UserName[32];//用户名 &#125;;//包4 登出结果 传输结果struct LogoutResult : public DataHeader&#123; LogoutResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUTRESULT; this-&gt;date_length = sizeof(LogoutResult); &#125; int Result;&#125;;//包5 新用户登入 传输通告 struct NewUserJoin : public DataHeader&#123; NewUserJoin()//初始化包头 &#123; this-&gt;cmd = CMD_NEW_USER_JOIN; this-&gt;date_length = sizeof(NewUserJoin); &#125; char UserName[32];//用户名 &#125;;#endif 五、项目完整源码(github)github链接如下图：guguServer为服务端程序、guguAlloc为内存池静态库、guguDll为动态库","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"网络编程","slug":"网络编程","permalink":"https://zgg2001.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"Redis学习记录：总结与扩展","slug":"20210329_Redis学习记录：总结与扩展","date":"2021-03-29T09:20:12.000Z","updated":"2021-03-29T09:20:12.000Z","comments":true,"path":"2021/03/29/20210329_Redis学习记录：总结与扩展/","permalink":"https://zgg2001.github.io/2021/03/29/20210329_Redis%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E6%80%BB%E7%BB%93%E4%B8%8E%E6%89%A9%E5%B1%95/","excerpt":"&emsp;&emsp;本文将个人在Redis数据库学习中记录的知识点进行了总结，方便日后的复习以及对明年春招实习的准备。","text":"&emsp;&emsp;本文将个人在Redis数据库学习中记录的知识点进行了总结，方便日后的复习以及对明年春招实习的准备。 一、基础1234567891011121314151617181920212223242526272829Redis是什么： Redis是一种NoSql，即Not-Only-Sql。是一种&quot;高性能键值对数据库&quot;，是对常规数据库的一种补充。Redis的存在需求： 当一些数据需要被频繁操作时，不断的从常规sql中读取/更改数据会大大提高磁盘IO次数，消耗大量时间。 此时就需要一个中间件对热点数据进行储存与操作，从而提高操作效率。Redis的思路： 通过&#x27;在内存进行储存&#x27;的思路，降低磁盘的IO次数。 通过&#x27;不储存关系，仅储存数据&#x27;的思路，去除数据间的关系，从而减少内存消耗。Redis的优点： 1.可扩容，可伸缩 2.大数据下高性能 3.灵活的数据类型 4.高可用Redis的速度快的原因： 1.内存操作 2.IO多路复用机制，减少了阻塞 3.单线程避免了线程切换的开销和竞争问题 4.C语言编写，与操作系统交互，命令执行快Redis的使用场景： 1.对热点数据进行储存，提高热点数据的操作效率。 2.排行榜等实时变化性强的数据存储。 3.具有时效性的数据存储，方便删除与更新。 4.... 总之，我认为Redis相当于一个缓存区，对于操作频率高的数据可以放在该缓存区里，方便客户端进行操作。 二、数据类型1. 基础数据类型① string12345678910111213141516171819202122232425string类型 最大纯数值范围为long long 512M &#x27;讲究整体性，更新少时用&#x27;基础操作:· set key value 添加修改键值对· get key 根据键 获取值· del key 根据键 删除键值对· strlen key 根据键 获取值字符个数· append key value 追加内容到原始信息尾部，不存在则新建· mset key1 value1 key2 value2... 添加/修改多个键值对· mget key1 key2... 根据键 获取多个值设置数值增加指定的值: #实现按次案例 加一个负数即为减· incr key · incrby key increment· incrbyfloat key increment设置数值减少指定的值:· decr key· decrby key increment设置数值具有指定的生命周期: #实现按时案例· setex key seconds value· psetex key milliseconds value ② hash 1234567891011121314151617181920212223242526272829hash类型 &#x27;一个空间保存多个键值对数据&#x27;基础操作:· hset key field value 添加/修改 键/字段/值· hget key field 获取值· hgetall key 获取全部值· hdel key field1... 删除· hmset key field1 value1 field2 value2... 多个添加/修改 键/字段/值· hmget key field1 field2... 获取多个值· hexists key field 获取表中是否存在指定字段· hlen key 获取字段数量· hkeys key 查看所有字段名· hvals key 查看所有字段值· hsetnx key field value 添加 键/字段/值，有就不改，无则添加设置数值增加指定的值: #实现按次案例 加一个负数即为减 · hincrby key field increment· hincrbyfloat key field increment注意:1.value只能是字符串/数值，不能嵌套数据结构。2.每个hash最多 2^32-1 个键值对3.不可滥用，不可以全面作为对象列表使用4.&#x27;hgetall&#x27;在field很多时，效率低，存在瓶颈5.hash更新方便 ③ list123456789101112131415161718192021222324list类型 底层为双向链表 实现消息队列&#x27;一个空间储存多个数据，且体现顺序&#x27;· lpush key value1 value2... 从左 添加/修改数据· rpush key value1 value2... 从右 添加/修改数据· lrange key start stop 取start到stop的数据 #下标从0开始 -1为倒数第一个数据· lindex key index 依据index索引取数据· llen key 获取长度· lpop key 从左 获取并移除数据 #类似java的pop· rpop key 从右 获取并移除数据# time单位为秒 当list内为空时，不会立刻返回，直到时间归零返回空，或者有人入队返回数据· blpop key... time 从左 在规定的时间内获取并移除数据 · brpop key... time 从右 在规定的时间内获取并移除数据 · lrem key count value 移除指定数据 #count为移除数量，value为要移除的值注意:1.每个list最多 2^32-1 个元素2.可以实现栈/队列3.&#x27;-1&#x27;表示的是倒数第一4.可以分页 #&#x27;lrange&#x27;取指定个数据 ④ set 1234567891011121314151617181920212223242526272829303132333435set类型 hash结构 hash中field储存值 hash中value为空&#x27;储存大量数据，查询效率高&#x27;基础操作:· sadd key member1 member2... 添加/修改 键/值· smembers key 获取全部数据· srem key member1 member2... 删除数据· scard key 获取集合数据总量· sismember key member 判断集合中是否包含指定数据# 可以实现随机推荐· srandmember key [count] 随机获取集合中指定数量的数据· spop key [count] 随机获取集合中指定数量的数据，并将其移出集合# 可以实现相关推送、共同好友等求集合的交、并、差集:· sinter key1 [key2]· sunion key1 [key2]· sdiff key1 [key2]# 数据合并求集合的交、并、差集并储存到指定的集合中:· sinterstore destination key1 [key2]· sunionstore destination key1 [key2]· sdiffstore destination key1 [key2]# 数据合并将指定数据从原始集合中移动到目标集合中:smove source destination member注意:1.不会重复2.与hash的储存空间相同，但是无法启用hash中储存值的空间 #全为空3.去重可以实现记录访问数据4.由上可以实现黑/白名单 #ID/IP/设备 ⑤ sorted_set 12345678910111213141516171819202122232425262728293031323334353637383940sorted_set类型 在set的基础上增加了score模块 可以根据score进行排序&#x27;可排序的set&#x27;基础操作:· zadd key score1 member1 score2 member2... 添加/修改 键/值/分· zrem key member1 member2... 删除数据依据排名获取全部数据: #withscores为值带分· zrange key start stop [withscores] 小到大 · zrevrange key start stop [withscores] 大到小依据分数获取全部数据: #withscores为值带分· zrangebyscore key min max [withscores] 小到大 · zrevrangebyscore key max min [withscores] 大到小按条件删除数据:· zremrangebyrank key start stop 按从大到小的排名· zremrangebyscore key min max 按分数获取集合数据数量:· zcard key· zcount key min max# 数据合并求集合的交、并集并储存到指定的集合中:· zinterstore destination numkeys key1 [key2] #后续参数为score最终结果:求和/最大/最小· zunionstore destination numkeys key1 [key2]获取数据对应的索引排名 #下标0开始· zrank key member· zrevrank key memberscore值获取与修改:· zscore key member· zincrby key increment member #increment为加值注意:1.有set的特性，反复添加会覆盖2.long long为范围，64位，小数则为double，可能丢失精度3.可以实现：时间队列、优先队列、VIP、权重 2. 高级数据类型① Bitmaps12345678910111213141516Bitmaps类型 &#x27;状态统计&#x27;· getbit key offset 获取指定key对应偏移量上的bit值· setbit key offset value 设置指定key对应偏移量上的bit值 #只能是0或1· bitop op destkey key1 key2... 进行&#x27;操作&#x27;结果保存到destkey op: and交 or并 not非 xor异或# 一个字节有八个bit 后面的start和end是字节· bitcount key [start end] 统计指定key中1的数量注意:1.可以进行单日数据的统计 例如某电影今日是否被点播2.可以进行并操作来对多日数据进行合并等等3.可以通过统计1的数量来实现类似&#x27;统计今日电影被点播种数&#x27;的功能 ② HyperLogLog123456789101112HyperLogLog类型 底层为loglog算法 统计独立的元素个数&#x27;基数统计&#x27;· pfadd key element1 element2... 添加数据· pfcount key1 key2... 统计数据· pfmerge destkey sourcekey1 sourcekey2... 合并数据注意:1.HyperLogLog只进行基数统计，不记录具体数据2.核心是基数统计算法，存在一定误差，大概是百分之0.81 #该算法中存储的都是近似值 所以有误差3.该数据类型消耗内存最大为12K，相比set上M的内存消耗很小4.HyperLogLog数据不断累积最大为12K，合并数据后结果消耗直接为最大的12K ③ GEO12345678910111213141516171819GEO类型&#x27;地理信息&#x27;· geoadd key logitude latitude member [logitude latitude member] 添加坐标点· geopos key member [member] 获取坐标点· geodist key member1 member2 [unit] 计算距离 默认为m [unit]参数是m/km根据坐标求范围内的数据:· georadius key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count]根据点求范围内的数据:· georadiusbymember key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count]获取指定点对应的坐标hash值:· geohash key member [member ...]注意:1.基本都是估算，存在误差，但是不追求高精度也够用2.可以实现&#x27;附近的人&#x27;之类的功能 三、通用指令1. key操作基本操作: 123· del key 删除指定的key· exists key 获取key是否存在· type key 获取key的类型 时效性控制: 123456789101112为指定的key设置有效期: #前两个是秒/毫秒 后两个是时间戳· expire key seconds· pexpire key milliseconds· expireat key timestamp· pexpireat key milliseconds-timestamp获取key的有效时间: #剩余秒/毫秒 xx为时效 -1为永久 -2为失效· ttl key· pttl key切换key从时效性至永久· persist key 查询模式: 123keys pattern 查询keypattern: *为所有 ?为匹配一个任意符号 []为匹配一个指定符号 eg: keys u[st]er:1 匹配一个以u开头，以er:1结尾，中间包含一个字母s/t的key 其他操作: 123456789为key改名:· rename key newkey #会覆盖· renamenx key newkey #不会覆盖对所有key排序:· sort key #支持set list zset 只排序结果 不动原表其他:· help @generio 2. 数据库操作123456789101112切换数据库: #默认0 0-15 共16个 可以从配置文件里改总数· select index· quit 退出· ping 测联通· echo message 控制台日志· move key db 数据移动· dbsize 获取当前库中key的数量· flushdb 删当前库· flushall 删全部 四、Linux下Redis的配置相关123456789101112131415161718192021打开服务端: · redis-server [--port 6379] 打开客户端: · redis-cli [-h ip] [-p host]按配置文件打开服务端:· redis-server redis-6379.conf配置文件基础:· port 端口 设置当前服务启动端口· daemonize yes|no 若yes则以守护进程方式启动，日志不再打印到命令窗口· logfile &quot;xxx.log&quot; 设置日志文件名，便于查阅· dir &quot;/.../redis/data&quot; 设置当前服务文件保存位置 [日志/持久化等]· bind 127.0.0.1 设置本机地址· databases 16 设置库数量· maxclients 0 设置最大连接数· timeout 300 设置客户端限制最大时长 #0为关· loglevel debug|verbase|notice|warning 设置日志级别 #默认是verbase 线上一般用notice简化日志· include /path/server-host.conf 导入/加载指定conf 便于维护注:1.使用&#x27;ps -ef | grep redis-&#x27;命令即可筛选出redis相关进程2.当以守护进程方式启动时，日志不再显示，可以通过上述ps命令找到进程，使用&#x27;kill -s 9 进程ID&#x27;关闭服务端 五、持久化12持久化主要分为两种: RDB与AOF其中AOF是相对主流的持久化方案 1. RDB - 快照相关: 123456789首先，RDB的原理是生成一张当前redis的状态的快照(二进制压缩文件)。恢复则是根据该快照进行全面的恢复。快照的占用空间较少(因为进行了压缩)，存取的速度相对较慢(全部保存)，但恢复速度快(整体恢复)。rdb保存分为两种: save 和 bgsave· save是直接保存，当保存数据较多时，由于是单线程，会阻塞进程。同步/阻塞/无额外内存/不启动新进程· bgsave是后台保存，执行该命令后，redis新建子进程进行save保存，不会阻塞进程。但是CPU消耗会相对增大。异步/不阻塞/有额外内存/启动新进程 配置文件相关: 12345678910111213· dbfilename dump-6379.rdb 设置本地数据库rdb名· dir &quot;/.../redis/data&quot; 设置当前服务文件保存位置 [日志/持久化等]· rdbcompression yes|no 储存本地库时是否压缩(LZF压缩) #通常开启 否则节省CPU运行时间 但是数据文件增大· rdbchecksum yes|no 设置是否进行RDB文件格式校验(读/写时) #通常开启 否则节省约10%时间 但可能损坏数据· stop-writes-on-bgsave-error yes|no 若bgsave出现错误，是否停止写入 #默认开启 如果为yes，redis会创建一个新的后台进程dump rdb。假设创建快照需要20s时间，redis主进程在这20s内则会继续接受客户端命令。若在这20s内创建快照出错，那么redis会拒绝新的写入。# 满足在指定时间 second 中改变 changes 个 key 即会执行 bgsave· save second changes 自动save #执行的是bgsave 根据业务量进行设置在执行命令返回结果后，系统会对该命令进行判定，服务器成功执行一个数据库修改命令，则计数器+1 相关命令: 12345· save 手动执行一次保存操作· bgsave 手动执行一次后台保存操作· debug reload 重启服务端并执行rdb· shutdown save 关机并执行rdb bgsave流程: 12341.bgsave指令2.发送指令至服务器3.服务器调用fork函数生成子进程，并返回&#x27;Background saving started&#x27;4.成功创建rdb文件后，返回成功消息至log日志文件 RDB优缺点: 123456789优点:1.效率高 使用压缩二进制保存2.使用快照 进行全量复制3.恢复快缺点:1.无法实时持久化 两次快照之间必定存在时间2.牺牲了性能 快照时消耗较大3.不同redis版本可能对rdb文件不兼容 2. AOF - 日志相关: 1234567AOF为记录数据产生的工程，即日志。主要注重&#x27;实时性&#x27;。AOF有三种日志策略· always(每次) 零误差，性能低· everysec(每秒/默认) 准确性较高，性能较高，宕机丢失一秒数据 #每秒操作先存在aof缓存区中· no(系统控制) 整体不可控，操作系统控制周期 配置文件相关: 12345678910111213· appendonly yes|no 是否开启aof #默认no· appendfsync always|everysec|no 选择策略· appendfilename appendonly-6379.aof 设置本地数据库aof名· dir &quot;/.../redis/data&quot; 设置当前服务文件保存位置 [日志/持久化等]· auto-aof-rewrite-min-size size 最小尺寸· auto-aof-rewrite-percentage percentage 百分比自动参数: #info查看aof_current_size 当前大小aof_base_size 条件: #满足则系统更新1.aof_current_size &gt; auto-aof-rewrite-min-size2.(aof_current_size - aof_base_size) / aof_base_size &gt;= auto-aof-rewrite-percentage percentage AOF重写机制: 123456789101112日志中大量重复命令存在会大大增加资源消耗，此时可以进行数据重写。按照以下规律:1.已超时数据不再写入文件2.忽略无效命令 重写时使用进程内的数据生成 这样新的AOF文件只保存最终写入命令3.对同一数据的多条命令合并为一条命令注:在aof缓存区后，有aof重写缓存区提供数据好处:1.降低占用空间 利用率up2.提高效率 降低时间 提高IO性能3.恢复时间减少 提高恢复效率 相关命令: 1· bgrewriteaof 手动重写 #和 bgsave 机制差不多 AOF流程:AOF与RDB对比: 项目 RDB AOF 占用空间 小(压缩) 大(重写) 存储速度 慢 快 恢复速度 快 慢 安全性 会丢失数据 依据策略不同 资源消耗 高&#x2F;重量级 低&#x2F;轻量级 启动优先 优先级低 优先级高 选择 呈现阶段有效性(如回档) 数据敏感 注: 1.灾难恢复一般选择RDB 2.可以进行双保险备份 六、事务1&#x27;一个队列中，一次性，顺序性，排他性的执行一系列命令&#x27; 1. 基本指令12345678· multi 开启事务 执行后，后续指令加入事务· exec 执行事务 执行事务，与multi成对使用· discard 取消事务注意:1.出现语法错误后，销毁队列，所有不执行 #书写错误2.出现命令执行错误后，对正确的命令执行，错误的不执行3.redis事务执行后不会回滚，需要程序员自己备份 2. 锁123456789101112131415监视锁/乐观锁:· watch key1 [key2] 添加监视锁· unwatch 取消监视锁如果在事务提交之前，监视的key进行了变动，则该事务失效公共锁/悲观锁: #个人觉得类似线程锁· setnx lock-key value 设置公共锁# 返回设置成功 说明有控制权 # 返回设置失败 则说明不具有控制权 进行排队/等待· del lock-key 删除公共锁为公共锁添加时间限定: #时间到了自动解锁 防止死锁· expire lock-key seconds · pexpire lock-key milliseconds 注:一般都是微秒或毫秒级，具体需要测试 #推荐: 最大耗时 * 120% + 平均网络延迟 * 110% 七、删除策略1. 数据删除1234567891011121314151617181920·定时删除 #时间换空间优点:节约内存缺点:CPU压力大·惰性删除 &quot;过期后，不做处理，下次访问时删除，不过期则返回&quot; #空间换时间优点:节约CPU缺点:内存压力大·定期删除 &quot;随机抽查，重点检查&quot; #每秒消耗固定的CPU资源 可以自由调整1.读取配置server.hz的值，默认为02.每秒钟执行server.hz次serverCron()3.serverCron()会调用databasesCron()获取数据4.获取数据后，调用activeExpireCycle()随机抽取数据检测5.若该数据超时，则删除注意:1.抽取判定数据的时长为250ms/server.hz2.W取值为ACTIVE_EXPIRE_CYCLE_LOOKUPS_PRE_LOOP属性值，若本次删除数据 &gt; W*25%，则再次执行删除过程3.若本次删除数据 &lt; W*25%，则检查下一个库4.有参数current_db记录本次检测执行到哪个库，下次继续即可5.通常使用定期删除和惰性删除 删除策略 优缺点 特性 总结 定时删除 节约内存，无占用 不分时段占用CPU资源，频度高 拿时间换空间 惰性删除 内存占用严重 延时执行，CPU利用率高 拿空间换时间 定期删除 内存定期随机清理 每秒花费固定的CPU资源维护内存 随机抽查，重点抽查 2. 数据逐出12345678910主要依靠&quot;逐出算法&quot; #可能失效执行命令前，调用freeMemoryIfNeeded()检测内存是否够多不够则临时删除一些数据清理空间info命令可以看缓存hit和miss的次数，根据业务进行调优conf配置:· maxmemory 最大可使用内存 #默认为0即不限 通常设置50%以上· maxmemory-sampless 设置每次选取待删除数据个数 #默认为5· maxmemory-policy 设置删除策略 #选项见下图 八、Redis集群1. 主从连接理论基础: 1234567891011121314我们建立服务器的最终目标是:1.高并发 2.高性能 3.高可用其中，高可用的理论目标是全年宕机低于315秒。对此，我们可以建立主从连接来提高可用性，即一台主服务器对应多台从服务器。主服务器只进行写操作，从服务器只进行读操作，读写分离提高效率。而当主服务器出现问题时，可以让一台从服务器接替成为主服务器，从而保证服务器集群正常运行。主从连接的特点:1.读写分离 提高效率。2.负载均衡 基于主从结构，配合读写分离，slave分担master负载。根据需求改变slave的数量，分担负载，提高并发与吞吐。3.故障恢复 由于主从服务器上的数据是一致的，当需要恢复数据时，直接复制另一台服务器上的数据即可。4.数据冗余持久化 由于是集群形态，相同数据在多个服务器上，造成数据冗余，易于持久化。5.高可用基础 主从连接是高可用服务器的基础。 主从连接的方式: 12345678方法一: 客户端发送命令· slaveof &lt;masterip&gt; &lt;masterport&gt;方法二: 启动服务器参数· redis-server -slaveof &lt;masterip&gt; &lt;masterport&gt;方法三: 服务器配置 #主流· slaveof &lt;masterip&gt; &lt;masterport&gt; 主从复制的三个阶段: 阶段一：建立连接阶段123456789101112131415161718192021221.slave - 发送&#x27;slaveof ip port&#x27;，申请建立连接2.master - 接收到指令，发送信息响应对方3.slave - 保存master的IP和端口4.slave - 与master建立socket连接5.slave - ping6.master - pong7.slave - 发送指令8.master - 验证授权9.slave - 发送指令 port端口10.master - 保存端口号相关:# 从属客户端发送命令· slaveof &lt;masterip&gt; &lt;masterport&gt; 主从连接· slaveof no one 主从断开连接· requirepass &lt;password&gt; master配置文件设置密码· config set requirepass &lt;password&gt; master客户端发送命令设置密码· config get requirepass· auth &lt;password&gt; slave客户端发送命令设置密码· masterauth &lt;password&gt; slave配置文件设置密码· redis-cli -a &lt;password&gt; 启动客户端设置密码 阶段二：数据同步阶段1234567891011121314151617181920212223242526服务器运行ID (runid) # info Server 查看相关信息· 是每一台服务器每次运行的身份识别码，一台服务器多次运行可用生成多个运行id· id由40位字符组成，是一个随机的十六进制字符· 用于识别身份，进行操作时需要首先进行id比对# 以下为全量复制 复制大部分整体1.slave - 发送指令&#x27;psync2 &lt;runid&gt; &lt;offset&gt;&#x27; # ? -1 此时不知道runid 和 offset2.master - 接收指令，执行bgsave生成RDB文件，记录当前的复制偏移量3.master - 发送&#x27;+FULLRESYNC runid offset&#x27;，通过socket发送RDB文件给slave，期间接收客户端命令，offset发生了变化4.slave - 收到&#x27;+FULLRESYNC&#x27;，保存master的runid和offset，清空当前全部数据，通过socket接收RDB文件，恢复RDB数据# 以下为部分复制 复制发送RDB文件期间master接收到的命令5.slave - 发送指令&#x27;psync2 runid offset&#x27;6.master - 接收命令，判定runid是否匹配，判定offset是否在复制缓冲区内7.master - 如果runid或offset有一个不满足，执行全量复制 #执行步骤2 7.master - 如果runid和offset校验通过，offset与本机offset相同，忽略7.master - 如果runid和offset校验通过，offset与本机offset不相同，发送&#x27;+CONTINUE offset&#x27; 通过socket发送复制缓冲区中offset到本机offset的数据8.slave - 收到&#x27;+CONTINUE&#x27;，保存master的offset，接收消息后，执行bgrewriteaof恢复数据相关: #配置文件· repl-backlog-size 1mb 设置复制缓冲区大小· slave-serve-stale-data yes|no slave在同步期间是否关闭对外服务· master一般占用内存的50%-70%，剩下的30%-50%给bgsave和缓冲区用· 同时请求复制，发送的RDB文件多，所以需要错峰请求· 或者采用拓扑结构，一主多从改成树状结构，但是一致性会变差 阶段三：命令传播阶段1234567891011121314151617181.master发送命令:ping / slave发送命令:replconf ack offset2.master - 接收命令，判定offset是否在复制缓冲区内3.master - 如果不在缓冲区，则执行全量复制3.master - 如果在缓冲区，且offset与offset相同，忽略3.master - 如果在缓冲区，且offset与offset不同，发送&#x27;+CONTINUE offset&#x27; 通过socket发送复制缓冲区中offset到本机offset的数据4.slave - 收到&#x27;+CONTINUE&#x27;，保存master的offset，接收消息后，执行bgrewriteaof恢复数据相关:# 心跳机制 master:ping slave:REPLCONF ACK· repl-ping-slave-period 10 master不断&#x27;ping&#x27;的周期，判断slave是否在线# 当slave数量少于2个，或者所有slave的延迟都大于等于10秒时，强制关闭master写功能，停止数据同步 · min-slaves-to-write 2 #保障数据稳定性· min-slaves-max-lag 10 #发送 REPLCONF ACK 命令 获取当前数量与延迟闪断闪联: 忽略短时间中断: 部分复制长时间终端: 全量复制 主从复制常见问题: 2. 哨兵思路: 12345671.宕机master下线2.找一个slave成为新master3.通知所有slave连接新master4.启动新的master与slave5.全量复制/部分复制其中观测下线服务器以及推选新master的服务器，就被称为哨兵。 结构与作用: 12345678&#x27;分布式系统，监控全部&#x27;· 监控 检查master和slave是否正常· 通知 出问题时，通知哨兵和客户端· 自动故障转移 断开master和slave连接，推选新的master，其他slave连接到新master，告知客户端新地址注:1.哨兵也是redis服务器，只是不提供数据2.哨兵数量通常为单数，便于投票选举 哨兵基础配置文件与启动: 123456789· port 26379 服务端口 通常最前加2· dir &quot;/.../redis/data&quot; 哨兵工作信息储存目录· sentinel monitor mymaster 127.0.0.1 6379 2 监控的主服务器 当有2个哨兵觉得它挂了，它就算挂了 #数量一半+1 · sentinel down-after-milliseconds mymaster 30000 30秒连接无响应，该哨兵认定它挂了· sentinel failover-timeout mymaster 180000 180秒未同步完成，认定同步超时· sentinel parallel-syncs mymaster 1 重连了以后，一次一台进行同步· redis-sentinel sentinel-port.conf 启动哨兵启动顺序: 主-从-哨 哨兵工作原理: 3. 集群简介: 123456789当redis单机提供的服务OPS不足，或者单机内存容量不足时，可用采用集群的方式解决上述问题。架构:· 集群就是使用网络将若干台计算机联通起来，并提供统一的管理方式，使其对外呈现单机的服务效果作用:· 分散单台服务器的访问压力，实现负载均衡· 分散单台服务器的存储压力，实现可扩展性· 降低单台服务器宕机带来的业务灾难 设计: 1234567891011121314数据存储设计:· 通过算法设计，计算出key应该保存的位置· 将所有的存储空间计划切割成16384份，每台主机保存一部分 #槽 每份代表的是一个储存空间，不少一个key的保存空间· 将key按照计算出的结结果放到对应的存储空间· 当一台新的服务器加入集群时，每台服务器拿出一部分存储空间(槽)给新的服务器，即可将新的服务器加入集群· 增强可扩展性内部通讯设计:· 每个服务器数据库互相通信，保存各个库里储存空间(槽)的编号数据· 如果客户端访问的数据库中有想要的数据，直接返回 #一次命中，直接返回· 如果客户端访问的数据库中没有想要的数据，根据编号数据，去新的库里找 #一次未命中，告知具体位置# 这样可以保证最多查询两次，可以返回结果，提高查询效率 相关配置与命令: 123456789101112131415161718192021配置:· clusetr-enabled yes|no 设置加入cluster，成为其中的节点· cluster-config-file &lt;filename.conf&gt; cluster配置文件名，该文件自动生成，仅用于查找文件并查询文件内容· cluster-node-timeout &lt;milliseconds&gt; 响应超时判定，判定该节点是否下线或切换为从节点 #一秒连接一次· cluster-migration-barrier &lt;count&gt; master连接的slave最小数量命令:· cluster nodes 查看集群节点信息· cluster replicate &lt;master-id&gt; 进入一个从节点redis，切换其主节点· cluster meet ip:port 发现一个新节点，新增主节点· cluster forget &lt;id&gt; 忽略一个没有solt的节点· cluster failover 手动故障转移集群构建启动:· 先把服务端全部启动，按照上面的配置文件· ./redis-trib.rb create --replicas 1 127.0.0.1:6379# 1代表一个master连一个slave 后面写master的IP:PORT集群操控:· redis-cli -c 登陆集群的客户端· redis-cli -c -p 6382 九、企业级解决方案1. 缓存预热情况 1启动后迅速宕机 问题排查 121. 请求数量较高2. 主从之间数据吞吐量较大，数据同步操作频度较高 解决方案 123456789前置准备工作:1. 日常例行统计数据访问记录，统计访问频度较高的热点数据2. 利用LRU数据删除策略，构建数据留存队列 (例如: storm与kafka配合)准备工作:3. 将统计结果中的数据分类，设置级别，redis优先加载级别较高的热点数据4. 利用分布式多服务器同时进行数据读取，提速数据加载过程实施:1. 使用脚本程序固定触发数据预热过程2. 如果条件允许，使用了CDN(内容分发网络)，效果会更好 总结 123· 缓存预热就是系统启动前，提前将相关的缓存数据直接加载到缓存系统。· 避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题。 用户直接查询事先被预热的缓存数据。 2. 缓存雪崩情况 123456789101. 系统平稳运行过程中，忽然数据库连接量激增2. 应用服务器无法及时处理请求3. 大量408/500错误页面出现4. 客户反复刷新页面获取数据5. 数据库崩溃6. 应用服务器崩溃7. 重启应用服务器无效8. Redis服务器崩溃9. Redis集群崩溃10. 重启数据库后再次被瞬间流量放倒 问题排查 123456789101. 在一个较短的时间内，缓存中较多的key集中过期2. 此周期内请求访问过期的数据，redis未命中，redis向数据库获取数据3. 数据库同时接收到大量的请求无法及时处理4. Redis大量请求被积压，开始出现超时现象5. 数据库流量激增，数据库崩溃6. 重启后仍然面对缓存中无数据可用7. Redis服务器资源被严重占用，Redis服务器崩溃8. Redis集群呈现崩塌，集群瓦解9. 应用服务器无法及时得到数据响应请求，来自客户端的请求数量越来越多，应用服务器崩溃10. 应用服务器/redis/数据库全部重启，效果不理想 解决方案(理论) 1234567891011121314151617181.更多的页面静态化处理(减少请求)2.构建多级缓存架构(Nginx缓存+redis缓存+ehcache缓存)3.检测Mysql严重耗时业务进行优化(对数据库的瓶颈排查:例如超时查询、耗时较高事务等)4.灾难预警机制监控redis服务器性能指标:· CPU占用、CPU使用率· 内存容量· 查询平均响应时间· 线程数5.限流、降级(短时间范围内牺牲一些客户体验，限制一部分请求访问，降低应用服务器压力，待业务低速运转后再逐步放开访问) 解决方案(方法) 1234567891011121314151.LRU与LFU切换(内存替换算法)2.数据有效期策略调整· 根据业务数据有效期进行分类错峰 eg:A类90分钟，B类80分钟，C类70分钟· 过期时间使用固定时间+随机值的形式，稀释集中到期的key的数量3.超热数据使用永久key(避免key过期)4.定期维护(自动+人工)(对即将过期数据做访问量分析，确认是否延时，配合访问量统计，做热点数据的延时)5.加锁(慎用!) 总结 123· 缓存雪崩就是瞬间过期数据量太大，导致对数据库服务器造成压力。· 如能够有效避免过期时间集中，可以有效解决雪崩现象的出现(约40%)， 配合其他策略一起使用，并监控服务器的运行数据，根据运行记录做快速调整。 3. 缓存击穿情况 1234561. 系统平稳运行过程中2. 数据库连接量瞬间激增3. Redis服务器无大量key过期4. Redis内存平稳，无波动5. Redis服务器CPU正常6. 数据库崩溃 问题排查&#x2F;分析 1234561. Redis中某个key过期，该key访问量巨大2. 多个数据请求从服务器直接压到Redis后，均未命中3. Redis在短时间内发起了大量对数据库中同一数据的访问· 单个key高热数据· key过期 解决方案 1234567891011121314151.预先设定· 以电商为例，每个商家根据店铺等级，指定若干款主打商品，在购物节期间，加大此类信息key的过期时长· 注意: 购物节不仅仅指当天，以及后续若干天，访问峰值呈现逐渐降低的趋势2.现场调整(监控访问量，对自然流量激增的数据延长过期时间或设置为永久性key)3.后台刷新数据(启动定时任务，高峰期来临之前,刷新数据有效期，确保不丢失)4.二级缓存(设置不同的失效时间，保障不会被同时淘汰就行)5.加锁(分布式锁，防止被击穿，但是要注意也是性能瓶颈，慎重!) 总结 1234· 缓存击穿就是单个高热数据过期的瞬间，数据访问量较大，未命中redis后， 发起了大量对同一数据的数据库访问，导致对数据库服务器造成压力。· 应对策略应该在业务数据分析与预方面进行，配合运行监控测试与即时调整策略， 毕竟单个key的过期监控难度较高，配合雪崩处理策略即可。 4. 缓存穿透情况 12345671. 系统平稳运行过程中2. 应用服务器流量随时间增量较大3. Redis服务器命中率随时间逐步降低4. Redis内存平稳，内存无压力5. Redis服务器CPU占用激增6. 数据库服务器压力激增7. 数据库崩溃 问题排查&#x2F;分析 12345671. Redis中大面积出现未命中2. 出现非正常URL访问· 获取的数据在数据库中也不存在,数据库查询未得到对应数据· Redis获取到null数据未进行持久化，直接返回· 下次此类数据到达重复上述过程· 出现黑客攻击服务器 解决方案 12345678910111213141516171.缓存null(对查询结果为null的数据进行缓存(长期使用，定期清理)，设定短时限，例如30-60秒，最高5分钟)2.白名单策略· 提前预热各种分类数据id对应的bitmaps，id作为bitmaps的offset，相当于设置了数据白名单。 当加载正常数据时，放行，加载异常数据时直接拦截(效率偏低)· 使用布隆过滤器(有关布隆过滤器的命中问题对当前状况可以忽略)3．实施监控实时监控redis命中率(业务正常范围时，通常会有一个波动值)与null数据的占比· 非活动时段波动:通常检测3-5倍，超过5倍纳入重点排查对象· 活动时段波动:通常检测10-50倍，超过50倍纳入重点排查对象根据倍数不同，启动不同的排查流程。然后使用黑名单进行防控(运营)4. key加密问题出现后，临时启动防灾业务key，对key进行业务层传输加密服务，设定校验程序，过来的key校验例如每天随机分配60个加密串，挑选2到3个，混淆到页面数据id中，发现访问key不满足规则，驳回数据访问 总结 123· 缓存击穿访问了不存在的数据，跳过了合法数据的redis数据缓存阶段，每次均访问数据库，导致对数据库服务器造成压力。· 通常此类数据的出现量是一个较低的值，当出现此类情况时要及时处理并报警。 应对策略应该在临时预案防范方面多做文章。无论是黑名单还是白名单，都是对整体系统的压力，警报解除后尽快移除。 5. 性能监控指标benchmark 12345678910· 命令redis-benchmark [-h] [-p] [-c] [-n &lt;requests]&gt; [-k]· 范例1redis-benchmark说明:50个连接，10000次请求对应的性能· 范例2redis-benchmark -c 100 -n 5000说明:100个连接，5000次请求对应的性能 monitor 123· 命令monitor打印服务器调试信息 slowlog 123456789· 命令slowlog [operator] · get:获取慢查询日志 · len:获取慢查询日志条目数 · reset:重置慢查询日志· 相关配置slowlog-log-slower-than 1000 #设置慢查询的时间下线，单位:微妙slowlog-max-len 100 #设置慢查询命令对应的日志显示长度，单位:命令数","categories":[{"name":"Redis","slug":"Redis","permalink":"https://zgg2001.github.io/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://zgg2001.github.io/tags/Redis/"}]},{"title":"MySql学习记录：基础总结","slug":"20210322_MySql学习记录：基础总结","date":"2021-03-22T11:04:40.000Z","updated":"2021-03-22T11:04:40.000Z","comments":true,"path":"2021/03/22/20210322_MySql学习记录：基础总结/","permalink":"https://zgg2001.github.io/2021/03/22/20210322_MySql%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/","excerpt":"&emsp;&emsp;本文将个人在MySql数据库学习中记录的知识点进行了总结，方便日后的复习以及对明年春招实习的准备。","text":"&emsp;&emsp;本文将个人在MySql数据库学习中记录的知识点进行了总结，方便日后的复习以及对明年春招实习的准备。 一、基础启动&#x2F;停止MySql服务： 1net start/stop mysql; MySql登录： 12345mysql -u用户 -p密码此处推荐先不填密码直接回车，随后输入密码。因为上面直接输入密码有密码泄露的风险。mysql -u用户 -pEnter password: ********** MySql中数据类型： 12345678910varchar 可变长度字符串 智能节省空间 但是速度慢char 不可变长度字符串 速度快 但是不会智能节省空间 int 整数型(11)bigint 长整型float 单精度浮点数double 双精度浮点数date 短日期 年-月-日 %Y-%m-%ddatetime 长日期 年-月-日 时:分:秒 %Y-%m-%d %h:%i:%sclob 字符大对象 最大4G字符串 超过255字节的都用它blob 图片、声音、视频的等媒体二进制数据 导入&#x2F;导出数据库文件： 12345#导出数据库mysqldump 库/表 &gt; 地址.sql -uroot -p密码;#导入数据库source 地址; 二、关键字 show / use / describe1. show查看所有数据库： 1show databases; 查看当前库的表： 1show tables; 查看数据库支持的储存引擎： 12345写法一：show engines;写法二：show engines \\g写法三：show engines \\G写法一和二结果是一样的，写法三是以每一行来显示。因为\\g和;都是结束符，所以加一个即可。 查看数据库变量： 123show variables like &#x27;have%&#x27;;#此句即为模糊搜索have开头的变量。 查看建表语句： 1234show create table 表名;#其中最下面一行信息为：使用的储存引擎、默认编码方式ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci 2. use选择使用数据库： 1use 数据库名; 3. describe查看表结构： 12describe 表名;desc 表名; (缩写) 三、关键字 create / drop / alter1. create创建数据库： 1create database 数据库名; 创建表： 12345678910111213141516#表名推荐 t_ 或 tbl_ 开头 数据类型看最上面create table 表名( 字段1 数据类型1 default 默认值(可选), 字段2 数据类型2 列级约束(可选), 字段3 数据类型3, ... 表级约束(可选), #约束的内容在后面 ) ENGINE=指定引擎 default CHARSET=指定字符编码方式 #此句可选 ; MySql默认储存引擎为：InnoDB 默认字符编码方式为：utf8mb4#将一个select查询结构建立为新表create table 表名 as select _______; 2. drop删除数据库： 12drop database 数据库名;drop database if exists 数据库名; #如果数据库存在则进行删库操作 删除表： 12drop table 表名;drop table if exists 表名; #如果表存在则进行删表操作 3. alter改表名： 12alter table 老名字 rename 新名字;alter table 老名字 rename to 新名字; 改字段名： 12alter table 表名 change 原字段名 新字段名 数据类型;alter table 表名 change column 原字段名 新字段名 数据类型; 添加字段： 12alter table 表名 add column 字段名 数据类型;alter table 表名 add column 字段名 数据类型 after 字段名; 删除字段： 1alter table 表名 drop column 字段名; 四、分组函数1. 单行处理函数123456789101112131415select中函数使用:select 函数(字段名) from 表名;lower(数据) 全小写upper(数据) 全大写substr(数据,起始下标,长度) 取字符串 #和c++的substr差不多 不过下标是从1开始length(数据) 取长度str_to_date(数据,&#x27;格式&#x27;) 字符串转日期 date_format(数据,&#x27;格式&#x27;) 格式化日期format(数据,保留小数位数,分隔符位置(可选)) 格式化round(数据) 四舍五入rand() 取随机数ifnull(数据,变值) 把null转为具体值concat(数据1，数据2,...) 拼接字符串trim(数据) 去前后空格 2. 多行处理函数12345678单行处理函数即为：对某一字段一行的数据进行处理多行处理函数即为：对该字段下所有数据进行处理count(字段) 计数 即统计数据个数 count(*)为总行数sum(字段) 求和avg(字段) 平均值max(字段) 最大值min(字段) 最小值 五、关键字 select / distinct 及查询相关1. select查看版本号： 1select version(); 查看当前选择的数据库： 1select database(); 查看表: 123#查多个字段则逗号隔开select 字段名(as 别名) from 表名;select * from 表名; #查看整张表 2. distinct去重关键字： 123select distinct 字段名1,字段名2,... from 表名;字段内容去重，该关键字只能放在最前面，表示对后面 字段集合 查询结果进行去重。 3. 查询语句顺序1234567891011121314151617语法顺序：select... 查询from... 获取数据where... 筛选group by... 分组having... 分组后筛选order by... 排序limit... 取指定条数数据执行顺序：from... 获取数据where... 筛选group by... 分组having... 分组后筛选select... 查询order by... 排序limit... 取指定条数数据 4. 条件查询相关1234567891011121314151617条件查询关键字：where例：select 字段 from 表 where 字段 = 值;&lt; 小于&lt;= 小于等于&gt; 大于&gt;= 大于等于!= 或 &lt;&gt; 不等于between...and... 两个值之间，即 &gt;= and &lt;=is null 为空 is not null 不为空and 并且or 或者in(值1,值2,...) 包含not in(值1,值2,...) 不包含not 可以取非 主要用于 in 和 is 中like 模糊搜索 %为多个字符 _为一个字符 例：%z% 即为包含z的字符串 5. 分组查询相关12345678910111213多行处理函数的原理是先对数据进行分组，随后对该组数据进行处理。所以多行处理函数需要在分组后才能使用(会默认进行分组)。所以在where语句后面无法使用多行处理函数。因为此时还没进行分组操作，详情请看上面的执行顺序。当你需要对函数操作后的数据进行判断时，例如该行数据是否等于此组数据的平均值，就需要使用group by进行分组。分组后，使用having进行判定。例：select count,name from t_student group by count,name having count = avg(count);此句中，对分数与姓名进行分组，当分数等于分数的平均值时，输出学生姓名与分数。注：group by分组后，select后只能跟参加分组的字段，以及分组函数。 重点： having的效率是偏低的，我们尽量用where进行筛选。where实在实现不了时，再用having进行筛选。 6. 连接查询相关12345当我们需要对多张表的内容进行查询汇总时，例如取表1里的a字段与表2里的b字段，就需要进行表的连接。表的连接分为内连接和外连接。而连接的机制类似两个集合相乘，所以当无限制连接查询时，会产生笛卡尔积现象。我们尽量要少进行表的连接，因为过多的连接会大大增大遍历的次数。 内连接1234567891011inner join即为内连接，内连接查询后的结果不含NULL，只包含符合条件的结果。SQL99写法: (推荐) SQL92写法: (不推荐)select 字段 select 字段from 表1, from 表1,表2(inner)join 表2, where 条件;on 条件(连接条件),where 条件(查询条件);可以看出，sql99语法将连接条件分离出来，使连接操作更加清晰明了。 外连接123456789101112131415outer join即为外连接，外连接中分为左外连接与右外连接。如上图，左/右即为包含左/右表的全部内容，以及另外一张表里符合条件的内容。外连接结果去掉含NULL的结果，即为内连接查询结果。左外连接： 右外连接： select 字段 select 字段from 表1, from 表1, left (outer) join 表2, right (outer) join 表2, on 条件(连接条件), on 条件(连接条件),where 条件(查询条件); where 条件(查询条件);当查询中不存在主表，只需要符合条件的结果时，使用内连接。当存在主表，需要依据主表得出结果时，使用外连接。 &emsp;&emsp;一个连接查询语句中，可以连接多个表，且内连接和外连接可以混合。 union 合并 123456select _________unionselect _________;将两次查询的结果合并，要求列数相同，数据类型一致。好处是减少连接，效率高。 7. order by 与 limit1234order by 字段名 desc; 降序排序order by 字段名 asc; 升序排序(默认)limit 起始下标,长度; 显示从起始下标开始的指定数量信息。起始下标从0开始。(这个重要) 六、关键字 insert / update / delete1. insert 插入数据： 1234567insert into 表名(字段1,字段2,...) values (值1,值2,...);#表名后面那一部分可以省略，如省略则等于全写，后面值 得按顺序写全。insert into 表名 values (值1,值2,...);#同时插入多条数据insert into 表名(字段1,字段2,...) values (值1,值2,...),(值1,值2,...),(值1,值2,...); 2. update 修改数据： 123update 表名 set 字段1=值1,字段2=值2,... where 条件;如果无条件，则对整张表进行修改 3. delete 与 truncate 删除数据： 1234567#条件删除delete from 表名 where 条件;空间不释放，效率低，但是在开启事务时支持回滚。#此为删除整张表 truncate table 表名;物理删除，非常快，但是不支持回滚。 七、约束123456789约束一共有四种：非空约束： not null唯一性约束： unique主键约束： primary key外键约束： foreign key列级约束：直接create建表时在字段后加。表级约束：在建表语句后面添加，详情看上面的create关键字相关。 not null1顾名思义，添加此约束后，此字段不能为空。 unique12添加此约束后，该字端内容唯一，不会重复。在尝试insert重复信息后，会报错。可以 unique(字段1,字段2,...) 添加联合唯一表级约束。 primary key1234主键约束即为 不可重复 且 不为空。mysql中同时添加非空约束和唯一约束，则自动添加主键约束。primary key auto_increment 自增主键，从1开始。主键分为 业务主键 和 自然主键(和业务无关)，一般推荐自然主键，方便日后的修改。 foreign key1234外键约束即为将 此字段 与 另外一张表内的指定字段 相关。使得该字段内的值，只能为另外一张表内的指定字段的内容。foreign key(字段) references 表名(字段) #添加外键约束 子 父 八、事务1. transaction123456789101112131415161718事务即为 &#x27;一个完整的业务逻辑&#x27; ，是最小工作单元。批量的DML语句 同时成功 或 同时失败，即为事务transaction。 (即增删改) #首先应该开启事务start transaction;#提交事务 相当于存档commit;#回滚事务 相当于读档rollback;特性：原子性 ———— 最小工作单元，不可分一致性 ———— 同时成功/失败隔离性 ———— 两事务直接存在隔离持久性 ———— 事务结束的一个保障 2. 隔离级别1234567891011121314事务隔离级别一共有四种：1.read uncommited 读未提交2.read commited 读已提交3.repeatable read 可重复读(mysql默认隔离级别)4.serializable 序列化/串行化以上四种级别，隔离程度由低到高。#设置级别set global transaction level 级别;#查看当前隔离级别select @@tx_isolation;select @@transaction_isolation;以上有一个可用。 read uncommited123事务A可读取到事务B的未提交数据。也就是说事务B输入了DML语句，但是没有commit，从事务A中也可以读到没有commit的结果。可能造成&#x27;脏读&#x27;，即读入脏数据。 read commited12事务A只可读取到事务B提交后的数据。即事务A中只可以读到事务B commit后的结果。 repeatable read1234事务A读取一次数据后，以后每次读取数据都和第一次读到的数据一样(开启事务时的数据)。即使事务B commit数据后，事务A读取到的还是一开始的数据。应用场景为：事务A只想查询一个时间的数据，随后commit的数据不影响事务A的查询。由此可能造成&#x27;幻影读&#x27;。 serializable12最强的隔离，当事务B未commit时，事务A查不到东西。即事务不可并发执行，效率最低，但是隔离性最高。 九、视图1234567891011视图相当于一个&#x27;表&#x27;，由一个DQL语句查询结果建成。与表不同的是，在对视图对象进行增删改时，原表上的数据也会发生改变。所以我们可以面向视图更新原表。好处是利于维护，简化开发。#建立视图create view 视图名 as select ______;#删除视图drop view 视图名; 十、索引1. 关于索引12345678910111213141516171819202122232425262728查询有两种：1.全表查询2.根据索引检索索引index 由B-Tree实现底层，通过地址查询。主键会自动添加索引，unique也会。索引分类：单一索引 ———— 一个字段上添加索引。复合索引 ———— 两个字段或者更多的字段上添加索引。主键索引 ———— 主键上添加索引。唯一性索引 ———— 具有unique约束的字段上添加索引。注意:唯一性比较弱的字段上添加索引用处不大。添加索引的前提：1.数据量庞大2.经常出现在where后，即字段总是被扫描3.很少DML操作，即增删改#创建索引create index 对象别名 on 表名(字段名);#删除索引drop index 对象别名 on 表名;#查看select执行详情explain select * from 表名 where 条件;type栏中，all为无索引，ref为有索引。 2. 索引失效123456某些情况下，可能会出现索引失效的情况。1. 模糊查询，并且以%开头。少用like%2. or两边字段若有一个没有索引，则索引失效。少用or3. 复合索引，若没有使用左侧的字段查找，则失效。4. 索引字段参与运算。例如id是索引字段，&#x27;where id+1 = 2&#x27; 则索引失效。5. 索引字段使用函数也会失效。 十一、常用储存引擎 MyISAM123456使用三个文件表示每个表：1.定义 .frm2.内容 .MYD3.索引 .MYI特点:可转换为压缩只读表，从而节省空间。 InnoDB 123456分为三部分：1.目录 .frm2.表空间 tablespace 里面存了表内容和索引3.日志文件 处理事务特点:非常安全，支持事务，支持崩溃后自动恢复机制，但是效率较低。 MEMORY1234由一个.frm文件储存。特点:储存在内存中，查询效率最高。但是不安全，关机后数据消失，数据和索引都在内存中。且不支持blob字段。 十二、数据库设计三范式123456一：必须有主键，字段原子性不可再分。二：在一的基础上，所有非主键字段完全依赖主键，不产生部分依赖。三：在二的基础上，所有非主键字段直接依赖主键，不产生传递依赖。但是以满足客户需求为主。有时候不拆表，空间占用大，冗余大，但是查询速度快且开发较为容易。根据情况选择。 小结&emsp;&emsp;目前数据库基础学习已经告一段落，随后如果再次进行数据库的学习的话，可能就会对底层一点的东西进行研究了，例如索引的底层之类的。&emsp;&emsp;马上要开始redis的学习了，在redis学习结束后，我预备写一个关于sql和redis的小demo加深印象。本篇笔记的内容日后也会不断完善，希望一切顺利。","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://zgg2001.github.io/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://zgg2001.github.io/tags/Mysql/"}]},{"title":"2020 蓝桥杯 Java实现 10月B组省赛","slug":"20210303_2020蓝桥杯Java实现10月B组省赛","date":"2021-03-03T13:34:01.000Z","updated":"2021-03-03T13:34:01.000Z","comments":true,"path":"2021/03/03/20210303_2020蓝桥杯Java实现10月B组省赛/","permalink":"https://zgg2001.github.io/2021/03/03/20210303_2020%E8%93%9D%E6%A1%A5%E6%9D%AFJava%E5%AE%9E%E7%8E%B010%E6%9C%88B%E7%BB%84%E7%9C%81%E8%B5%9B/","excerpt":"2020 蓝桥杯 Java实现 10月B组省赛 题目 &amp; 题解","text":"2020 蓝桥杯 Java实现 10月B组省赛 题目 &amp; 题解 试题 A: 门牌制作本题总分： 5 分 问题：小蓝要为一条街的住户制作门牌号。这条街一共有 2020 位住户，门牌号从 1 到 2020 编号。小蓝制作门牌的方法是先制作 0 到 9 这几个数字字符，最后根据需要将字符粘贴到门牌上，例如门牌 1017 需要依次粘贴字符 1、 0、 1、 7，即需要 1 个字符 0， 2 个字符 1， 1 个字符 7。请问要制作所有的 1 到 2020 号门牌，总共需要多少个字符 2？ 思路： 暴力 答案： 624 123456789101112131415161718192021222324252627public class Main&#123; public static void main(String[] args) &#123; int ans=0; for(int i=1;i&lt;=2020;i++) &#123; ans += judge(i); &#125; System.out.print(ans); &#125; //判断这个数字里有几个 2 public static int judge(int a) &#123; int temp = 0; while(a!=0) &#123; int t = a%10; if(t==2) &#123; temp++; &#125; a/=10; &#125; return temp; &#125;&#125; 试题 B: 寻找 2020本题总分：5 分 附件在本篇末尾 问题： 小蓝有一个数字矩阵，里面只包含数字 0 和 2。小蓝很喜欢 2020，他想找到这个数字矩阵中有多少个 2020 。小蓝只关注三种构成 2020 的方式： 同一行里面连续四个字符从左到右构成 2020。同一列里面连续四个字符从上到下构成 2020。在一条从左上到右下的斜线上连续四个字符，从左上到右下构成 2020。例如，对于下面的矩阵： 123456220000000000002202000000000022002020 一共有 5 个 2020。其中 1 个是在同一行里的，1 个是在同一列里的，3 个是斜线上的。小蓝的矩阵比上面的矩阵要大，由于太大了，他只好将这个矩阵放在了一个文件里面，在试题目录下有一个文件 2020.txt，里面给出了小蓝的矩阵。请帮助小蓝确定在他的矩阵中有多少个 2020。 思路： 暴力 答案： 16120 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.io.*;public class HelloWorld &#123; public static void main(String[] args) throws IOException &#123; BufferedReader in = new BufferedReader(new InputStreamReader(new FileInputStream(&quot;D:/demo/1.txt&quot;))); char[][] map = new char[300][]; for (int i = 0; i &lt; 300; i++) &#123; map[i] = in.readLine().toCharArray(); &#125; int ans=0; for(int y=0;y&lt;300;y++) &#123; for(int x=0;x&lt;300;x++) &#123; //横排 if(x&lt;=296) &#123; if(map[y][x]==&#x27;2&#x27;&amp;&amp;map[y][x+1]==&#x27;0&#x27;&amp;&amp;map[y][x+2]==&#x27;2&#x27;&amp;&amp;map[y][x+3]==&#x27;0&#x27;) &#123; ans++; &#125; &#125; //竖排 if(y&lt;=296) &#123; if(map[y][x]==&#x27;2&#x27;&amp;&amp;map[y+1][x]==&#x27;0&#x27;&amp;&amp;map[y+2][x]==&#x27;2&#x27;&amp;&amp;map[y+3][x]==&#x27;0&#x27;) &#123; ans++; &#125; &#125; //斜排 if(y&lt;=296&amp;&amp;x&lt;=296) &#123; if(map[y][x]==&#x27;2&#x27;&amp;&amp;map[y+1][x+1]==&#x27;0&#x27;&amp;&amp;map[y+2][x+2]==&#x27;2&#x27;&amp;&amp;map[y+3][x+3]==&#x27;0&#x27;) &#123; ans++; &#125; &#125; &#125; &#125; System.out.print(ans); &#125;&#125; 试题 C: 蛇形填数本题总分： 10 分 问题：如下图所示，小明用从 1 开始的正整数“蛇形”填充无限大的矩阵。容易看出矩阵第二行第二列中的数是 5。请你计算矩阵中第 20 行第 20 列 的数是多少？ 思路： 由题意可看出，求第x行第x列数的规律为：值 &#x3D; (x-1)*2的累加 + x 则这一题中20行20列的值为：1+2+3+…+(19*2-1)+(19*2) + 20 &#x3D; 761 答案： 761 12345678910111213public class Main&#123; public static void main(String[] args) &#123; int ans=0; for(int i=1;i&lt;=38;i++) &#123; ans += i; &#125; ans+=20; System.out.print(ans); &#125;&#125; 试题 D: 七段码本题总分：10 分 问题：小蓝要用七段码数码管来表示一种特殊的文字。上图给出了七段码数码管的一个图示，数码管中一共有 7 段可以发光的二极管，分别标记为 a, b, c, d, e, f, g。小蓝要选择一部分二极管（至少要有一个）发光来表达字符。在设计字符的表达时，要求所有发光的二极管是连成一片的。 例如：b 发光，其他二极管不发光可以用来表达一种字符。例如：c 发光，其他二极管不发光可以用来表达一种字符。这种方案与上一行的方案可以用来表示不同的字符，尽管看上去比较相似。 例如：a, b, c, d, e 发光，f, g 不发光可以用来表达一种字符。例如：b, f 发光，其他二极管不发光则不能用来表达一种字符，因为发光的二极管没有连成一片。请问，小蓝可以用七段码数码管表达多少种不同的字符？ 思路： dfs出所有情况，然后用并查集判断是否属于同一子集 答案： 80 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105import java.util.ArrayList;import java.util.Collection;public class test &#123; static int ans = 0; static int[] jl = new int[10]; static int[][] map = new int[10][10]; static int[] father = new int[10]; public static void main(String[] args) &#123; //储存关系 a~g对应1~7 map[1][2] = map[2][1] = 1;//a b map[1][6] = map[6][1] = 1;//a f map[2][7] = map[7][2] = 1;//b g map[2][3] = map[3][2] = 1;//b c map[3][4] = map[4][3] = 1;//c d map[3][7] = map[7][3] = 1;//c g map[4][5] = map[5][4] = 1;//d e map[5][6] = map[6][5] = 1;//e f map[5][7] = map[7][5] = 1;//e g map[6][7] = map[7][6] = 1;//f g //dfs遍历所有情况 dfs(0); // System.out.print(ans); &#125; public static void dfs(int n) &#123; //当7个灯都有状态时 进行判定 if(n==7) &#123; //把亮着的灯统计下来 ArrayList&lt;Integer&gt; a = new ArrayList&lt;&gt;(); for(int i=1;i&lt;=7;i++) &#123; if(jl[i]==1) &#123; a.add(new Integer(i)); &#125; &#125; //判断 if(a.size()!=0) &#123; if(judge(a)==1) &#123; ans++; &#125; &#125; a.clear(); return; &#125; //否则dfs灯情况 jl[n+1] = 1; dfs(n+1); jl[n+1] = 0; dfs(n+1); &#125; public static int judge(ArrayList&lt;Integer&gt; a) &#123; //System.out.println(++js); //并查集父集重置 for(int i=0;i&lt;10;i++) &#123; father[i] = i; &#125; //并集 for(int i=0;i&lt;a.size();i++) &#123; for(int ii=0;ii&lt;a.size();ii++) &#123; //如果两边相连的话 进行并集操作 if(map[a.get(i).intValue()][a.get(ii).intValue()]==1) &#123; int fx = find(a.get(i).intValue()); int fy = find(a.get(ii).intValue()); if(fx!=fy) &#123; father[fx] = fy; &#125; &#125; &#125; &#125; //查看是否都属于一个集合 int temp = find(a.get(0).intValue()); for(int i=1;i&lt;a.size();i++) &#123; if(find(a.get(i).intValue())!=temp) &#123; return 0; &#125; &#125; return 1; &#125; //查集 public static int find(int x) &#123; return father[x]==x ? x : (father[x] = find(father[x])); &#125; &#125; 试题 E: 排序本题总分： 15 分思路： 不能有相同字符的话就从a开始倒着加，因为14+13+12+11+10+9+8+7+6+5+4+3+2+1+0 &#x3D; 105，所以一共有15个字母。然后让总排序次数减五次，因为字典序要求最小，则让第六位向前挪5次即可。 答案即为：9 14 13 12 11 10 8 7 6 5 4 3 2 1 0 答案： jonmlkihgfedcba 以下题目均能通过AcWing和蓝桥杯题库的数据测试 试题 F: 成绩分析试题 F: 成绩分析 本题总分： 15 分时间限制: 1.0s 内存限制: 512.0MB 问题： 小蓝给学生们组织了一场考试，卷面总分为 100 分，每个学生的得分都是 一个 0 到 100 的整数。请计算这次考试的最高分、最低分和平均分。 输入： 输入的第一行包含一个整数 n，表示考试人数。 接下来 n 行，每行包含一个 0 至 100 的整数，表示一个学生的得分。 输出： 输出三行。 第一行包含一个整数，表示最高分。 第二行包含一个整数，表示最低分。第三行包含一个实数，四舍五入保留正好两位小数，表示平均分。 样例输入： 12345678780925674889910 样例输出： 123991071.29 评测用例规模与约定：对于 50% 的评测用例， 1 ≤ n ≤ 100。对于所有评测用例， 1 ≤ n ≤ 10000。 思路： 送分题，挨个统计即可 AC代码： OJ链接 123456789101112131415161718192021222324252627282930313233import java.util.Scanner;public class Main&#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int max = 0; int min = 101; double he = 0; for(int i=0;i&lt;n;i++) &#123; int t = sc.nextInt(); if(t&gt;max) &#123; max = t; &#125; if(t&lt;min) &#123; min = t; &#125; he += t; &#125; double ans = (double)(int)((he/n+0.005)*100)/100; System.out.println(max); System.out.println(min); System.out.println(ans); &#125;&#125; 试题 G: 单词分析时间限制: 1.0s 内存限制: 512.0MB本题总分：20 分 问题：小蓝正在学习一门神奇的语言，这门语言中的单词都是由小写英文字母组成，有些单词很长，远远超过正常英文单词的长度。小蓝学了很长时间也记不住一些单词，他准备不再完全记忆这些单词，而是根据单词中哪个字母出现得最多来分辨单词。现在，请你帮助小蓝，给了一个单词后，帮助他找到出现最多的字母和这个字母出现的次数。 输入：输入一行包含一个单词，单词只由小写英文字母组成。 问题：输出两行，第一行包含一个英文字母，表示单词中出现得最多的字母是哪个。如果有多个字母出现的次数相等，输出字典序最小的那个。第二行包含一个整数，表示出现得最多的那个字母在单词中出现的次数。 样例输入： 1lanqiao 样例输出： 12a2 样例输入： 1longlonglongistoolong 样例输出： 12o6 评测用例规模与约定：对于所有的评测用例，输入的单词长度不超过 1000。 思路： 暴力统计即可 代码： OJ链接 12345678910111213141516171819202122232425import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); String s = sc.nextLine(); int[] ans = new int[30]; for(int now=0;now&lt;s.length();now++) &#123; ans[(int)(s.charAt(now)-&#x27;a&#x27;)+1]++; &#125; int end = 1; for(int now=1;now&lt;=26;now++) &#123; if(ans[end]&lt;ans[now]) &#123; end = now; &#125; &#125; System.out.println((char)(&#x27;a&#x27;+end-1)); System.out.println(ans[end]); &#125;&#125; 试题 H: 数字三角形时间限制: 1.0s 内存限制: 512.0MB本题总分：20 分问题：上图给出了一个数字三角形。从三角形的顶部到底部有很多条不同的路径。对于每条路径，把路径上面的数加起来可以得到一个和，你的任务就是找到最大的和。路径上的每一步只能从一个数走到下一层和它最近的左边的那个数或者右边的那个数。此外，向左下走的次数与向右下走的次数相差不能超过 1。 输入：输入的第一行包含一个整数 N (1 &lt; N ≤ 100)，表示三角形的行数。下面的N 行给出数字三角形。数字三角形上的数都是 0 至 100 之间的整数。 输出：输出一个整数，表示答案。 样例输入： 123456573 88 1 02 7 4 44 5 2 6 5 样例输出： 127 思路： B组这题是简化过的，数据量少了，也多了条件，所以直接dfs暴力就好。当左右差减一大于剩下行数时，说明走到末尾时必定相差超过1，可以进行剪枝。 AC代码：OJ链接1 链接里是本题版本，用DFS写OJ链接2 链接里是未简化的版本，用DP写 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.Scanner;public class Main &#123; static int ans = 0; static int num = 0; static int[][] map = new int[510][510]; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); num = sc.nextInt(); for(int i=1;i&lt;=num;i++) &#123; for(int ii=1;ii&lt;=i;ii++) &#123; map[i][ii]=sc.nextInt(); &#125; &#125; dfs(1,1,0+map[1][1],0); System.out.print(ans); &#125; public static void dfs(int y,int x,int he,int cha)//y x 和 左右差 &#123; if(x&lt;=0||x&gt;y)//剪枝 越界 &#123; return; &#125; if(Math.abs(cha)-1&gt;(num-y))//剪枝 左右差大于剩下行数 &#123; return; &#125; if(y==num)//到达最底层 &#123; if(he&gt;ans&amp;&amp;Math.abs(cha)&lt;=1) &#123; ans = he; &#125; return; &#125; dfs(y+1,x,he+map[y+1][x],cha-1);//左下 dfs(y+1,x+1,he+map[y+1][x+1],cha+1);//右下 &#125;&#125; 试题 I: 子串分值和时间限制: 1.0s 内存限制: 512.0MB本题总分：25 分 问题：对于一个字符串 S，我们定义 S 的分值 f(S) 为 S 中出现的不同的字符个数。 例如 f(“aba”)&#x3D;2，f(“abc”)&#x3D;3,f(“aaa”)&#x3D;1。 现在给定一个字符串 S[0..n−1]（长度为 n），请你计算对于所有 S 的非空子串 Si..j，f(S[i..j]) 的和是多少。 输入：输入一行包含一个由小写字母组成的字符串 S。 输出：输出一个整数表示答案。 样例输入： 1ababc 样例输出： 128 样例说明： 12345678910111213141516子串 f值a 1ab 2aba 2abab 2ababc 3 b 1 ba 2 bab 2 babc 3 a 1 ab 2 abc 3 b 1 bc 2 c 1 评测用例规模与约定：对于 20% 的评测用例，1≤n≤10；对于 40% 的评测用例，1≤n≤100；对于 50% 的评测用例，1≤n≤1000；对于 60% 的评测用例，1≤n≤10000；对于所有评测用例，1≤n≤100000。 思路： 总体思路和C组的那道题有点类似，不过这个更绕一点，没那个直接。 思路就是每一个字符的权值为：(上一次出现的与当前出现的位置间隔+1) * (末尾与当前位置差值+1) 如果是第一次出现，前间隔值就为当前位置-1 123456789例如： ababc 末尾长度为5a的当前位置为1，前间隔值为0，权值为 (0+1) * (5-1+1) = 5b的当前位置为2，前间隔值为1，权值为 (1+1) * (5-2+1) = 8a的当前位置为3，前间隔值为1，权值为 (1+1) * (5-3+1) = 6b的当前位置为4，前间隔值为1，权值为 (1+1) * (5-4+1) = 4c的当前位置为5，前间隔值为4，权值为 (4+1) * (5-5+1) = 5累加：5+8+6+4+5 = 28 代码： OJ链接 12345678910111213141516171819202122232425262728293031323334353637import java.util.Scanner;public class Main&#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); String s = sc.nextLine(); //前数组 int[] piror = new int[s.length()+10]; //答案值 long ans = 0; //中间值数组 用来储存每个字母的前后值位置 int[] temp = new int[26]; //初始化 for(int i=0;i&lt;s.length()+10;i++) &#123; piror[i] = 0; &#125; //找每个位置字符的上一位 for(int i=1;i&lt;=s.length();i++) &#123; int t = s.charAt(i-1)-&#x27;a&#x27;;//计算出数组位置 piror[i] = i-temp[t];//计算出与上一位相同字母位置的差值 temp[t] = i; &#125; //计算答案 前差值*后值等于当前字符的权值 累加即可 for(int i=1;i&lt;=s.length();i++) &#123; ans += (long)(piror[i]) * (long)(s.length()-i+1); &#125; System.out.println(ans); &#125;&#125; 试题 J: 装饰珠本题总分： 25 分时间限制: 1.0s 内存限制: 512.0MB 样例输入： 123456789101 12 1 21 12 2 21 11 331 5 1 2 3 5 82 4 2 4 8 153 2 5 10 样例输出： 120 样例说明： 按照如下方式镶嵌珠子得到最大价值 18，括号内表示镶嵌的装饰珠的种类编号： 1234561: (1)2: (1) (2)3: (1)4: (2) (2)5: (1)6: (2) 思路： AC代码： OJ链接 试题 B: 寻找 2020 附件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300002000000220202000222000202200222220202202020002220002020022202200220220202002002220020200000000220022200202222022220222000022220220020020222020022220022220220000022022002020220002200220020020022200020222020200200000020220020022002202000202222020220020020022020000202022220222200022220000000020020020000020002002200002022222200222002020000200020220000022020002020200000222000000202202220222000222202200202202200200222222220202022020022002220200022020200222002220202202022202222002000220202200202202022000000222220222200200022220202200200020202222202222220022202220020002000000200022222202020020222220220002002202200022020020202000220002000020220202222020000020022222002000002222220022022020002022200020022020202020022200022200202202220200000202020220022200222020020222020020022200222220222000020202000020022220222022202222002002002000002020202200220200222202002002202002020202222220020002020220200000022200022002022002220002002222022020220002222200002002222002222222022200002022002002200220020002220002020002222222022020220020200000022022022220220222002222220000022200002002020000000022220202020020222202222200200220200220222220020202020002022002222022022022222002200220202202002022000022200020220000202222202222222000000022222022202022220000222002002000022202022002220220220022002002200000222200222002222002220000220022002202220222220222002002220200222200020222000202200022022020002222020022202002000200000222200020222020002020022222222222220202002200200200220020002020200000020022000202002000022000020200222020020222002020000022220022020220002220220220200222222000222222002202002200002000220022220020002200020020220002000020002002200200200000200200220202002020022202002002222222222200222020020000020220002222020202202222220202220200202002202220020220200000022020222002222020200200022202202202200002020222000220220200222000000202020022200022002020222220220200202000200200202222020020200220002200000020000002022000020020002220202002222220222000220220222222000002000000000002220022000220022202202202020222202202200002220200022222002000020020220200002200202220022220020002220020002222220220220200022000022002200222022222020022202000002222200002022002020220000220200000002002022000000022000022202022200002000000020200000020002202200020200002200000202002222002220020220200020222002000022002022020000020200000202020200020222200020022222222000222202020200200222000202020020000200022020202202222002020200002202020200000020002020022202222022220002222022222022200200002002220020220220222202000220022002220020022000202022022222200220020022202020202202222002202222000202200020020222222200202200220002222200220002202202220222022222200002220022002222000220002020220000220220022000020200220200022000202020220200222220002222000220022000222020020202220220002000002200222220002000020000000000202202002222022202220220200020202202200220202202022022222020220202202020002222200002020220202022200002222222200020022022202220000020002022020222020022022222022202220222002020000002022000020220020220222200200002202002220222002200222022022022200200220202202200200220222220022022000022000022022020200222020220000220220020020000020222022222002020220020220222000202200222222200020022002220222222002222200020002000202022202220222202020000020022202022002200020220002022022002002000022020202002020022000000220202200022022200020022220002002202022020200022222220022000022202220002202200000220000020220000020022200200020020222000000200022000202002022200222200222000000000202222200222022020202200020020202220022200200022200222022202202002202020222022002022002222222020202022220202020202002222222022220220002220022022002220022202002222002220022002222002220222000220000002200220020022000220022222220202200020022000222022202220220022202222020002020200202202002222022222020220200020000020022020022200000000000022202022022200220222022220222020000020222000200022202202220202002002222000220202220200220000220202022000202222020222000200000000000002220020002202202002220022220222002220002200022200002222002200020200202000000222222220022222200202220002222220000000220220022200002200022202022020200200002202000022202200002220220020220020022220022200000000220200200020022020222200202002200220222222202220202220002022020022020020200002022200222222020002200202020202220200020220220002002022022020022200202000220202220220222200002000020222022000002220020002002022022200002200000222222200022002222000200000220220220022022020022000200220022220002002200002022020200220000020000002002002020222202000202022220000220200200200020002002200220202000220002222002200200202222000020022220222022022002222220200002022222000020002222220200020220222220022220222220220000202022020222022220202000002222000200220202002202200022020220002220020022002202022022000000222020220002222222002020222000022222220200020000000200020200020220220222220020000222000220222222222200222202000200202020220002002020022020022020000202220202022222220020202220220202022220200002000222200000200200220002222202022200022020222022202002000022002200222222000222000202002022222020220202200020022220222022000002020022002000220220022202220202002200202000200222002000202200202222220222222002202200002220020220002002020000002002220020022022020220022022202202220202222222200020020020222222022020000000220222000220020202022202002020200002002202200200222022022020022000020002000222022000200000020000020002022020020200202200222222022222022000002002220220002202022020222000202002222000022022000000200020022022002002002002022220000022220020022222220002200222002200020202000202222002020020222020002200020002002202022220002022020000020022222200002202000020222220020000022000020220002220000202000220020202002220022000022002202000000220020202002202200202220220022002002202222222020220222222020020000222000000002022000202222220222222002202200200200220002022022000002200020202002020200002002202000220000222002020022020002000022020222000000202220220002022220022222220222002200220222220002020202202022002222202222202222002222200020000220020222002000022002222202220020222202202200202000000002200200222020022220220220202022200200022222020002022002000222000020002002222020002002222222020200022020002022220000200000002000020202002020220200020020002200020222000202200202222220020200020202222220200220200222202222002202200200202002222002002200022200022002200222002002000022022022002220002002002202022002222220020220022000022020020200200000000222202222220222020202202220200220022222202002200022022220002002200000202002002020000000220200222222020022220002000200022220202000002022220200002000000222220200020200002202002200200022220002220002220022202002202020220220200002222002020202020220220202000200020222200200222222000222020022200200200000002220002202002022202202220000222202222220220022002022220022002000022002202202000202002220200002002002000000220202200220202220002200002020000222220222020020202000222200202202020200000022002000022220000200020000202222200222200222022020200220200222200222202022202020222020020020200020222000022022222220222222220222000202200022022002000200022022220002020222222202222020200220200222202220002200002000200202022022022020222020200202020000000020000000220000002002200202200202022020200020000220000200000222002002000022220022220022200202202020002022200202220020222020222002222220020202000202222000022202020202002000222002222222200002220222202222022020200000200202002002202022220000202202020200222022220000202022020020022002220222022020000000020022222022020020200220022220020202202022002220202202202222222200002222020000022022220022200022200002202020022200200020202222000002022200000002222002022000200020020220002020022020020202022022200200020000200222202222000000002000200020222000020002020000202202202000000220202002222200202200222202002220222202002020222000202022022022020000022202200220220222000220020220000020000200200222220000222020002222020220020202020022002202002002022022020200220002000000000020200020200020020002202022020220022202002020022002020020020000202020022022200202202200000202220022222000002020020220202002022002222200200000222022022202000020000220000200200000220220200202200222220220202000200020200020200200202020020002000022000200220222020222022002000022202202222222200220020222200222020220220000202200000002020200202002202020200022002222022022000202022200202200020020202020020222200222200000220002200200000202220020202200222000222202000200020202022222000200022020200202220000220000222202202022020022200022002202020022200200000220002220200002222220200000220202222220020222000202222202000020222222220000022000222022020200000020222020220222222220202002222002200020022002200020002020000220000220200002202202200220220202002020222222000220020202200222002020002020222220222202002020202202200200002202202200022220222002222222000020222022000002022222000022200002000000220200200002000002020200202220222202020222220200222000002202022002200202202200220000222000202022002002200200000200202000200000220200020222222202202002222220000020222202222220002002222002222202222020000220222000200200220020020002022222002000002020220022000022220000022220222222000020000020220022002222202220022202022022000200200000002022222200022220222022220000222202002020222200220020020000220002202022022002222200002002020202220022222000200222002200000002222202202000022000000000222022000020200020200000200000020020002200222220202022222000020022202200202000000220000200200022220200222002000202220002000002020020002002022200002022002202002020220002020202222202220022022020202202200002200220022220202022202000220002002200020222222220020200222020200222020020022220200002022202022200200020002020200222200000020222202020000202022220222222222220200020202000202222220000202222220000200000202222222000222220220200220022202000202200220020002222000002200220222022200000202202220202220022220002002022202022222220002002002002000202002020200202202002022202222020202020000020020220000202202202222200000002022200222220000020000022200202022002202022002020200002020022202022222202020000220022220202002200022202000202000200220202222200022020220002222020000222002022022000020220000220200222022000202000002222200020222202022222000000202020002202202002000200222220002020222220020002200000220222222000222002022222002020200022002000222202220202020202020022200020222002200002222002202222000200020222222002222202000020200022022220020222220202020020000222000022220200022200002220200000220000200002002202022202222022020220000220202000020222022222222000020220020200002222002200202002200000020200202020222020020020002222200022002220200200022002022220022222222002220220000222022020222202000200000000220002002000200022022200002202002002220000022002022220022220220200020220020202022022220000020202002222000222222022002222200220020002222020020020220002200220202222222000202222220022002222220222022002222020222200000022002000220200220222000002022002020222202000020020200022000002200200222202202000020220220202220002222020000020200220200020200020022022002202022220000202020220002020002200220222002002220222000022022200000020020022002020000220202202002000002020020222000022000220000200002020202020022022200020022022202022000020020022000200222222020000220202222200022000200202002020022002000202002202220022020022022220020220220200002202022222022002002200200200020000002200222002202200020200202002220000022200200002020220222200000022200022002000000000002222222202220220220202022000002002222222020220202002222020200020020002220000022020022202002002202220020200222202222002200020222222202220200020202020002002202020002220220002000200200020020022000202202020000022220222222220000200222202220220020222202220000200020200020220202200222200220020200200020202020222202220202020000200220220220000002000200222002002002000022202022202222222002020020220000000220002220022202220002000002002000202220000220000222020200020220020000200020222020002222220200200200022202000202222222222002202202200200200002022020000202000200200002222002200020202020220020222200000000020000222222222202000002020002000020020000000000022000220220000200202202000200020002000202020022020200220202222202000020002002020002220222000202000022200000222222022020200222220002020202220202000020022000020022002020000002220000000002220200000000000002020022200220020002220220022002020200220020000222020020020222200000222002022202020020222020020202202202220200222020022200222000220202202202000222200200220000222200200200022022000022022000202000222222022022220002020202202022202002000220200202022020022000000002002002220220222002200000002000002002000222202220022222020202202200220002022002002202222002202200200220022022200020020022020020000220220002220002220022022222220200200022222020000020000000022002002020002220000220202000222200200000202002220020202002220200222002000220000000022220002222200002200002222222002000202020002022022200022002200220202020002220000002000202020200002002020000002002020002220020222002020200000020000022000022022222002202020020202022222220022000022200222022002000220000220202202002000202200222200220222202002220222220200022222002220200202002020002022020020222000220202222022202000220220020200000220202200222022222202000220202022220220000020202222222022202200202220002022002002202220200002000202022020002202222202220222022022222202222002220002020022022022022000022000202220022220220222202022222002202220022222020222002202200022002220022022020022002202000002220222222022002220000200022200020202220222022202022002022202200000000000202000022202200020002022200000222020000222002002002002200220202002000000202222002000200220222202220020020002220222000002202200022220022020202002220222002200222022220002022000222222000000000000000202220000222000200022202000202200222022000220202202002222002000022200202022222220202020000020000022022022200020220202200002220000222000200002202222220220002222022020222020200020020000020222020202022200020002200222002022200002220202022220022022020200020202020000020022200020000002222200022220022000222022020020020222222220222002202020020202222020002022220202202022002000220022020200220220220020002202222202220222002202200222200020022022200020222202202202200200222000202000002222220202020000202002220200200222020002200022000200020202200220002202222020002000020002000002202202220202220002022222222020220000000022200202002022000202002202200022022002202020020020022020000022202022200000200200022000220020022002022002200220002200200000222200202002000022202200022020022020200222220222200002000200200222000200200222022020022222222200002202200222022000000002000022000002220202020202002222020202000020020002022000200002002000200202222020222202200000222222220022220002202000200002022222022222002022222220020202222222020022220220002222022022022200202000000202002000020202200202200000022022200200220002220020020002200022022220000200002202002002200200222002000220020200200022002202020000202020002002222002220200200200200222022000002002022220002202002002002220000022222220002202020220002002200002020022220000220200222002022202220202202200222202220200222202202202022222020022200200220000022220000000220020022222222002022202022200202222020200022202220222200020022202222222020202200022002222000220002202022020000200222022220022200202002200020202222202000000000222200022002002002020000020022000222202202200220000220220000022200020220200200022000000022022000222022022200020202220002002200200220202200002022220200020222020200202022022002220202000220000202222200020002202022022200222222222020200022222002222200022002222222000202020222022200220002000020000022020000202202002200222202002222220222220220020000020022200220022220222202222202200220222220022222222020222000002202022200200222000000222220002002002222020200022220020020002002202200022222220000222200200202000202200202222202202202222200022200200020020220022202220000202020000020000000000220200020220000000002202000020022022020020020020020202020220202022022200002022022002200002202220202002022002002202200000200202200220222220020200220222000022202222022022020202200222000020020220220202222000220002200000000202202002002022200222200022220002022020002000202000000002002022002020220022020000022200200000000000000202202020000000022022000202020000020022222222002202202202000002000222020022002022020020222220202002000022200202222002000200222002220020202000022000002002202000002002002000222022200000202220020202222000220020000222200200222022000200200222222022220002020000202220222220202220002222022020002022220000022200202220002220022002000220222000002200222202220200200020022222000220020200002022222202002220022000022200220202000220000020020020000220002220202220002002002220020002020000200022020002022220202020220022202022200000220222220002200222022000020020020020200200022200220222222220022002200000220000220000022022020222002002002022000000200022220222020202022202022220000200022022220022222000200022000220020202200202222222020002000220222202002000020222220022020002020020222200020002002020022022200002200020020202202220202022020202020202022222202000202022002022002002022200202022000020202000022022022002222200220200222220200202020020022222020220000000000220222220220202220222000220020220022002222200000200020020202202020002022000000002202200222022020002000202000222022202000020002020220222200200202022202222020022002202022022200020002220222002000220220202220022222002200200000222202202222020000222202220222220202222022222200020200020022200020002202002000002220000202220200002202022200000200202220202200220022022020002200022000002202200000022222022222002022022220202022200220220200020022202202020000002022020000202200200000222020020220002000222200220200220000220220200020202000220020222022220020202000222020022000020220020000002220022222020022200022200020022202000020000200202202220200020002000220000000000220020020002202002222022020200022022000020002220022020020222020002220000222200000020022022020022220220200202022202020200022022020220202000020020220020022220202200000220220002000020000200222020220000222020022220022220200022022200000002020002022222000020220020020200022000020022002220200222202002022020002020202002002202020222002202202002020200020202022200220020200222002222222022200022022200222222220020000002220222000002002022200022020002000202222200200002202202000020200202000020002220002222200022020022202200200020220000002022022200222002220020202222220002002222222022000220220200020220220222202220200202222220000000000202022000020000220220202202200022222200000220200222000200222020220202022200020022000000002200220000220222202000002022222022002020222202202220022220022200022222220022202022202000202022202002020020220022202202022220220222220220000202200202002020000022202222020000002002000200002002000022200200220020022002020200202200200020022020202220202202220200002020200002220002000022200000000220220220022202000002000022202220202202202020002220000002202202220022202020022002200202000022022222002000202222202200222022222202022022222000022020222020020022020022202000020002202220200020200220202022222020202222220022220200202022022200022022002222222002220200222222202200222020202002002222022202222000222222202020200022000222000222200202200000020202020200222220000002002002200002020220220220002022202000020000020220020200220222000200002002002202022220220220222200000022200202222000022002202200000000002200022220000202000000002222200222000020200020000020202022220022002000000002022000002002200022000222220220220202220022022222200002222022222000020200022000000020002020202000222002022220020222002202220200020000022200220202002222000222002000200000002222020202222222220020000202000000220202200202020220020020200022002222220222200222020222222202020220220220202022000020020022220000002220200200002000020220002002000222200220222002222200222000220002020022000220200200200222020220220022222020222220200022002022200022020220002002200222222020222200020202222222200220222202022200222000020020022000000200020200000222002022000200000020022002202222002022020202002020000000022222222222202002222020202002020222000202222222020022220002000200220020202022022202202200020020000222220002202002002000222002200002020022222022202002002222022200222020202220002000020000020202200000022022200000220020202202200202200022200000202200200022202222220220020202020000000202222022222020020000022202022020020222020220020022202000022220020002002202200000220222202022200200220222200220220000020202220202200222000022002020002022200202222022002222220220022220022222000020220022222022220222000002022000222020202200200002022022200202000002000020200002002000000202002202222022200202022002202200222022202002222202022202020202020200222000220022220022000020020200200202200020222000200220020020020020220222022020222000002002220202220020222200020000202222002020022202220022020000022220022222002000022220202220000200022022020002200002222222000022020020222002202200220220022000002002000220200002020000020220020220200020200202200000200220002020020202202020222022022002220020022202202000222222202022022020022202222002020002022022200022200222022022020222020222002202222020020200220202002000000222002000002000202020022222000022002020002222020020020200222000022000220022000022220020002022002220002000002002002202202020222020202202022000202222220022220220222000002000002222200220222222200020020002222000000002002022202020020200220002022202200202220220220020202202002022200202222220202022222002200022002200200222202000202222000020000200000202002022220220220000200022002020220000200022020020222020202220220222220000200002022222002202020222202002020000000200002022222202220022222220200222000202000202222222002202022002202202220020002202220002202222002022220020000002220200022200200220202220022220022022222002220220002020000000002222020222200002022222220220220222222000200002022220200022220220200000002200202220222002002200002220222000020002002220022022202222200000220200000000202220002022202222000222200222020000222000002000222022202022220202022220002020220002222000220002002000222022222020022220022220222002000222000022200020020002020222222020202002200020002202200022022200022200200200200222202200220002200020002220022220222220020220200222222000222220220020000220022222202202022020020022200000022200022022002020220000000000020200200202220022002200020000222200000022002222000220200002000220220000002022202202200022200202000022202000002000002002000022002222000220200022222220202002202000202200002022200202000202000200220000000020200222000002200000020022202022000020020202020222202200022020022002002202220200202200220202202020222220222000000002002000022222200222002202020222220020002000222022200202020022200220200020022202022222202022222022002022220222000202222200220202000220220222222000220022002202022020202000222222222200002020002202020002002002020022220200220020202020220222202222202222222020220020002200000020002222200222200002000220000002200000222020022022220220000002222022002220022222200020222220202202020020220022220200020000200002220220222220000000022000002202022202022002022222022220220000002020200022000220020022200220000202002202020222220022202222000222202022220000220220020222220222222202202020220202220200002200000222020022220200000200022020000020200002220002000202000202202222222022022000000220202202222000020000022022222020222020022020002000200220202200202202202200000200000000200000202202002022220222200002202220222222200200222022020222220222220020222000202020200020022020000222020202002002000202020202200220022202220222000000022000022220222220020002222200222020202000222202222020220000022200000020200202220220200020002002000220222220222020222222202220020222222020002000020020220002220222200002220002020220220200220200020002200220202200220200200000002202020022022222220200222220000220022222222222000222002220020202020002002000020020020200222020220000002002022022222200000202200000222220202020220020220222202022202000002202022220200000220200222200000220222220000220202002220202000020222202200020000200222200200020220002022202020002202222220200000022022222222222002202002202020200202202200220000222020000002200222222002220000220220000202220222220202002200002020022200002022222222202000020202220200200000222200000222002202222222200000220000000022220020222022020020202002022000000002202200220222202200222222200200020000220002222222222202002002022000200200222220222020022000022222002002202222022202000020220020020002022000222202000000002200222020002022200000020222200202202022000022002002200020000022202002022002000202202200002022022000200220000222220222002200020202220220000220202022002200020200222002202220222200202022202002222000022222200220220202002220200002000200000000202002200000222000220000022020220002022202000000022000202222200022020022202000002002002202000200000002222002202022200202202002222002220200222220020222000222020020002222000200002220000002000202000002000222200200020002220202220222200020222220220202200200200020202000202200022020200220222222002202000002000200220222020000200002000200020000222202220202222202002022022202000000022222200220200022000202000222000022202000020222000000002022220202002222222002220220222020020222222222002202002000000202020202220200200022022000200222022220002000000202200020000022002022220020200200222200020022022000000000002002022202022020002202020202202000000220002220200222202022200200002002002200220000200202222220002202220002002220202222002002000020022020022220200220022000022002222220002020222000002022000200020022200022022222000222222220220200002000022222222022200000000220220202200002202002202022202220200020002222220020222022000002020220222002200222220202002202002222000200220200002222020202200022000202202002222220202022202020200020220200222022220022020022202002202002220200020200002222000222002200202202220020022000020000002220220200202202222020002220220200002202222020000020222000222022020000002220200002020000200000222022200000202222002002220020002022002220022000202000220000222002202000000002222202202200000002000000222222000222200222200000022022020202002202220000002020000022000202000200020022002022020200222002022222200202200002022200020202000222202222002002222222202200220220202200020000022222002000200202020002002000222222202002002200202020000022220200000220222000000200000002202222220222022220202020022222002000020220222000002220000200222022202222200220020000202220202222020222000000022220022020000002002020220002222022200000202222002022222200200202200002202002002020200222002202000002000022022200022022220002200200022002220222000022000022202200222022220200220020002200202002220000200202220022222222200222022020222000200002220000020220220222000222200022220202002002002020020200020200220222200002200200222020000000222202202000200220220200202220202222000000022022220022222200000222002022222200202002000200220000222000202000022222002220000202222002000002002020200220002002022020220222000202020020000022000022002020200202022000022000000202002220220202002022222002202000022220020202022022000220202222202000200000002002200022202022002020000222022022002002202000200000000220220002002220202202222000020000200200002220002002020020020202202002202202020222000022000020002220220220000022020220220020220022202020202220020020200222200020020002020222000200202000020200020000000202220020200222220022022020222022002002222020000220220002000222202022020200002202020002020002220022022002222200220002202000220022220020002220022020220220200200222222022220220000222220002000020002020220000202222020002200022202220200000000202002000022200022200220020020220000200020002022220002220002002222022222220222222022020222200202022200000220220002020200002022200002002020002022200222222200000200220200200020020200022020000022220020020222222202002000220222000202002020202220020220022222000220022220220020020220022202000022020200220220220200222200020222220000200022002000200220020002002002220000022202020202022020220202002022200220202202002222220020022200222202002222002200202200222000022200022000000022022020222002220002202202022202020022022202222202022222200002200202022002000200002200202022220200200020200020220202000000222020220222002222222002020002202020220220000002022200200202020200202002022020002022220222002020022222002222202000202002202020200220002220000000222002200020220020202000020002200200022022020002200000000200220222222020222202002022002200022000200002220022022200020220200022002020202220000202002202022020000000000200220222022000002202220000002200020022020000022022220000222022020002222022000202020220202200220200002022020002000022202202022202002000200220002220020222020220222202002020200022000200220002002020022222220220020002200222000200022000020022200222022222220022022222202020220222200200020202020220200020000022220000020202022200000202222222220200202202000020200002202220220000002220020200020020002020200000022202022002020000202022022002002020202200200002222022002020000000002020220002022002220002020002222002020222000202020220000002022202000000022222002200220220002200200000002200222222000000002020002002022202220020202020222222022000000022200020000220220200200200000220020222000202000020000220220220220222220202222000002022020022020000020020222220000000000002202022022002200220220200222202000200020002022222202200200002020202220002222020022022200000220220002022222020020000202022200020000000222222200200020002022020222000022202002020220000220222000000200220000202022022222202222022022200220022222202022000002222000220200222020200002020022202220020200000022202022202222200200222002020222000020020202022220202222202220200002220200022202222202000002202000022220020000020020022020202200000000020022200222200000202022202022000020020202000200002022202200020200200020000200222222000000202020220000022222002000222002220222220000002002220202022020020220020000222220222020000222200002022022222202020220002022002020220002220020020202002202022200220020020002220022200020220002000002020020020020200200002222000020202220002222000000022202002200220222002202022202000202202220000222020202002022022000020002020022220200202202220000000022020222020000000200200002022022200000200222002220202220222002020200020022202002020002222002222020022022000200022000002000222020002202020202200020002000000000000020220220022220000220200002002222200000020222000000020000022202200220022020022220200000020020020022000020022222202022002202200000200022000002022220202020202000022200200002000000000200022002202002022220222000002220000020002022022000200222200020000020000022200222220200000002222200022202202220002002220202000202200220020222000222000020200022202022222222220220020202200200022200020202222202002202020202000022222002222202222000002200202022222000022022020220000000022222200002220000020022202202000022222202020000000220202220020200020002220202202020220222000002020202022202200220020000200000200222200000200022020200002200222022022002000022020202222002202200002202000200220200220220220000222022222200020220022200200220022022200202222202022002222202202202020202020002000002200200222000220022220220202000220222002200000022000000022022200202000002202000220020020000200022002020020200220020222002002202022002000220200000020020000222200200020202200002002022222020200222222020220222200022020022222022222202020222002000200020000220000222022222222220020220220220200202002202002000200220200020022002220222022202020200020020200202002220020000202220020002020222020200220022020202222202220202222020020200002200022002202020000222200022222000222200202022020202002002202002202022222200200022020002020022002222202202022202002222220020222000000000022222222020022000002002002202222002222002222222022220000222002020222022002222020000202202020020222220022020000220220022200002002222222002222002222202222220022202000222222022002200022020020022202000222002000220222000222000200022000202002220022222222200020022202222002000022200000222202202020002222222202200020220222020022202000002222202002222000200002222002022220202022220202000200200020202222220022022220022000020020002022002202202222220000200202002222200220020022000002222020200000200220202200020002200222022222220202222020220222002200000222002220200220000022002202020020200200220202222020202000222020022222020220222020220002220200200022002000022020200020020222222222022200022220000002202220200020202020002022022000002202222002202200222020222202220022200200000002202022222200220200200200220222000202020220202202200002002020000200202202202202022020222020202022000202000022000002202022002220000002202020220200220222022200002002002220200200020200002202020202000022002020000000222022220220022002222000222200222002220020000222222020220220222202220202000022000002202002220022000202022020202000000020022202202020220200222020222000222022200020200200020200022020202002002200200200020222000002220200200220200200002202222020020002002020020022220020222002202220222202002022000202020202020222200002220222002022022222222202022000222000020222000022222202220002220202220020220202002022002022220000200200200202220220002002202000000002222202020022000002220002220000022220200202200022022022020002002220002220200202002002220222020220000000220202222002002020202220000022020220222000000020002222000020002222222022022202222020002002022022002002202202000002022020200222022222020020200022220200222002002022022020202220020000022200200220020002200022020222222020022000220202000200202202020220000000002200220000200202020020202202200020222002202000202200002222022020002220002002002202002202202202202202022000222220200002022020220220000222222222222022222020222022020202002202202020202202002200020200222222000022200022222022220022002202220202022220000200022022222002002002020002000000002000220222222202022222202220200002222202202222202022002222022000022020222022222022222200020222220202002020022022202220202202000020000020020200202002222000020022220220020020002220220200220020022220002202002002020202222200220022002200020200220002200002020000222200200222220020222000220200200000022220000002000020000000222002222022220022202200020022022022222220000222200000222002220200022200220222202002020200220020000220002000222220202200020000020202022000200020200202202000020020020002002002220202200222020222202220222222222002020200220202000202020200202202200200222000222220222222202220000000200022202000020202222202020220200222220222222200002200000220000020200200222200202002022220000220022220222200002222020220222202220220002000000202202200202002222022022002020200202202000222200020200200000222020022002000220002002200002000200202022020222222022020220200022022022002022222022202202200002020022202022220002200020220020222020222222002222002202002000002022200022200022020020002020020002202220202022202000220022002222002020022002022200222202200220002200202222002220200222000222222022002020202022022000220202002000000200000202000220022222222220002200002200022000220222020222200000220220022222000220000022022202220222200020002202220020000022000220200020222220222202022000202220222200202000002220200202220022000200002202200200020000202000222020220222002200202202200200220222022220002202000200220000222022220202200220022200020002200002202000222200022200022220202000020000200202022020220000220200022022020022000222200200200200002000022002000000000222002020002000000220002002022200020022202020022022220002202000020020000202000200002222202002200200002020020002200200020220222000002002000202200202020202002020002220020200000220200200202200220022002222200002022000200020000020020200022002000022000000222202200020200200022022220222200022222220202022200200022000222200000022000222202200020202200222002002002220222002222222222000002002020222020222202202220202000202002020220002000002200222202000000022002200000200000000200020020202020220020202222200000020020222022022220220000022020220022000220002022020000002000220020202002202002200020020000020222220020020220000202200202022222222202022222020200020002220002222222022220000000200002022202222202022222020222220220220002200000022220200020022022020000220202002002002022222022000202020020022020020222220002020000220222220200200200020020002020002200022002020202022022020000200200020220202220200222222200222220000002022200000022002222000220020200020202000022002220220220022020220000002222022220022202000022220020200000220000020202020022200202202222022200000022220200002222200222222020222202020000222000002022200220222220202002022220202222000002222202020200000222000220002220000002022220220022200222000220200020202022002002022002202002200002220022002220222020002002200000200020000202220000000002222002000002000220202000000022222022202022020022000022022022200000022000022002222020000022020220020200220222000202020002200022200000222222220200000220222020022000200220200200000002220220020222022022200200202200220022000022002020022222002202022222220220222002200202220000200002202200222200202000200020220002222022002020000220022002000000022222000002020222020002202000000220200022200000000202000020000200000002202220022222222200202020020000220000022200002000022020020222222020002200200002222000022002020220200202000022220000200222000022022220000022020222000202202020020220022000200000200002202000220020202220022022020022200202002000202000202220022202220022202022002022202002202020220202220222220220000002220222020002220022202000200222002202200200000000202202200022222022202222222222002022202200222200222200200220200200000000022002200022220200002200002202202002022022000222200220000200000022222202000020220000022020200202222202022020020020222002220022200020020222200200202202222220202020020200222220002002000222222020022022020000200220000022002202222220202220002200002202222222020220000020002022202000202000220002220222022022022202002022200020200000222022202000222022222202200200000002202200222022022222220022200020022222000200220202000220022020222200000000022020022020200000220020220020222220002202022020022202220000202200022000220000202020022002020022200000222020002022222002000220202022202220002000020202020020220020022002002202022000002022222200220020020000022020002002222022200020200220002222220022222020200222202000202000002200200200202022000222200000020020220200020222020022022002222222002002200200202000000002000200002200002002200020002220202200020200002020220022202220020002222200020222200000202002000200202200020220220222020222202020220020222022220200202020220002222202202020220200202200020202202222022022000200000022000020022020202000202220022020020202022000222200020002202020202220002222202022200202222022000200202000000202020000000020002002000022020020202000022202020020022200202220200200002202020202200002020022200022200020200000002202000002220002000020000002200022222000020202000202002000002022222002202202200222022220022020020002220220222202200000022222222000202220200002202000020022000200220222020020002202002220222022202002020200000020022020200222020220220222202022202220002002000220222022200020222000002202220200022022022200222000002200020202022222200222002000020002022202002002000200220022000220000202020200202202000022200002202020200202222220202202020002020020220200220220020200202202202022200002000000200022220020200222222202220222002202020000000020002202222202022202220002222220202222022220002002022020022020222002202022020222202020200000002020202002002202220202022022200200222222222022202200220220000000020222222202200220000000020022222020222000000200220000200020200020202022002022222222202020200002002222200000222000000020000020200222220202020222222222022002222220200222002200000222000220222020000222200000222022220022020220020020000220220222202220020202222222002002022002000220200002002000220022002222200002002200000002202200022202202202022202000202200220000000220202220022220022202022222202202020202020022202200200000200220220020200202220020202202002220220220220200220020020200200202222002220220020022000022222200020002022002222002020020200222020202202020222022002020022020220222202220222220222000000202000000002220220000002020222022222220000200002000000000200020020020220002022022022202002020222020202000200002222202000202220000202220002000022020222202020222220202022222200020202002202000220020000020220222202220202020220222222200020022022002222202202022202022020000020222002202022202000000022022020202020002202022022022000000202202020022220222202020220202220020002222020202020002220202022020202022200000002222220202002200002222220002222002220222002000222000022202222000222022002002200200000222222202020020020022020202220220220222020022222200200000000020200022022000000200202200022222000202022000222200020222020002000222222222220200000200202020202220020000202002022000022020222022020220220020002202222220200000002202200000202022002000200002220002002222002200022202222020200220020220200220220200222202222022220020020020202222200022020002000222020020220002202000022020220000002202202202002002202222020222022220000002020002220022000202200002002200020020002020220020022202220200020222200000022222000020202020022200220202022200020202020002200020222220020202222222002200000220222222020200222222000220022202002020020222200220002020220002002220020220220200022020222200220222220202222200202002020002202220202200022200002222002002022200020222020200022000202222202220220222222000020000022000202202022002220020022222002002200000022020022200200000002220222200000220000202020002220000002202022022002000222020222220022020020200222222200202222020000200002222200202002202022000022022222020200220002202022000002200020202202022022000022200002000200020020202000202202002000020000222002000002000022020202020022020002022020000002022222200020202022020220202020002222202200002202000000200222222222002200202022220002000002000220000200020222220020200200020202200020200020200022202020200002000200222020020202022022020202222002020022222200002022000202222222000002002020200000020222022000022020222200200000200202200002000020200222222000220220002200200222200202000222022002022222020000020222000020220200022200220002020002020000200200202202220000202022220022022002200222002000222002200222220002200220022222000022202202220020020002222220220002200020002202220220020222200200200202202020000222220222200222202202200220220020220200002002002020202200000200220200222200222002020202022220200020020022222022222022200222020002200022020200222222022002002220200020202000200000020002202002202020202200202020000020002222202222220222202200002200202202002020002220222020022020222002222220220220000200220022202222222202200222202000022000200220020220002220020222200020002202000202200222202020222202022000220020022200022202222222022200222220000220222022020220222000020020022020200002222220220222020200020220220220220202022220200022220202022002020020200002202002000222220200222002020200200020220202222002022200200002020200002002222000000220022002222022200220000220200220220222002022002222020202222022202220022222220200020200200002202202000002220002220202202022220200202022222202022220202202002020020202002202020020222000202200000220222220002200200200200202220202202202200220000202202020202020220222202202202002002002220200200202022202020002002220022020222220220222202200222020000220002020220022022220000222000000202002022000002000200000220020020002000220220020002020222202020222000220222020202020002202200222220220020202020220022020222020002002022220220220000020220200002220002202202200020020000202000202222220002200002020002202020222200220222022020222222022200222002222002220222220002002000220000222222000200202000002022022200220220000002220220202222022022202002002222002020020200002020002202222202202020002022200222000000020222202222002222020220022000000220000220200000222002200000222202022020022202220202002202200222200002222222002022000220200000202022220222202200202000022022002200022200202020022002222020002202220020200020202020022200002202202220222022200022022222222200000002202002002022002222020222022022000002000002200022022022022202200002022002020222200022220002020200220220202020220020202200020020222002020022002220220220002220000222002002000020022002022222200002200200000020020222020002222220002202220022022200222022020020200022200222020022222002200002020222200020002222200220000220000002202000220022022202200220020200002020222202002202022022022002200020200020222022002200020220000020000202000202020002020202200002022000020200002002200020000200202220002022022222202022020022000200202222220000222222200002202202202020220022200220000200002222020000002000002202222220202002200200202202020202020022200000000200202002000000020000220002200220020222020022222222002220222002220020002220000020200200000200000222222002202022202002222000002222220022202202200200002202002202222222220220000200000220202000200220002222020200020220000202202022200200000200000200022020022000022020220002202000222202222000222022022022222220002020000200200002022020020200020020022220220000202202000200022000000000202222022222202022022002202222220000002200000222222220022220222002202202202222022222020022022022022220202020022000220222002020222000002000220002000200020200000222202200000220200220020020002000200002022002222200222202002000002200000220000020002000020202220020202222220202200200202022000020200222200020200002000222022222022200200002222000020000002202000022002022002200020222202000222202202002000002200002000220202220020020000002220022020222000200022000200220022000022000200220200022022200222202002022200202022020222020002222220222000000022022202022020000202000020202222020020202002200022020222020220222022202222000202202200002000222000202020022222200002220020000220222000202022222222220220020000220222222222220202220220220002020020020000002220020000002002000000000202020200200022000220200022220020002200002222200002200222022000000022222220220000200000002222222220200002220202000202222202202220000202220202000220002202002222022200202220002220000020002020220222202000022202020000022022202002002222000002002000220222020220002022020002022200002000202022000222020002000020222022202220200022022000002222202000222200020222222022222002000220222022020202020000222220200000200000022222020020000002022222002202000202220020000020222200202022222220202000020200200202200222222002000202220020200022022222220200202000222020200002022202220220220200222222222020000220220202000000222202222022200022220200222002202220002222022200022000200222020202222200200222200222000002002022220200022220002200022000020022022002002000022022002020220202000000200200022202200222002022000220220002020202222202220000022222022220002020002002000220002020222000202222022220020020220020002202200200022222222002222222022000022202000200200000002200202200202200022002202222220220220020200220220020200002220020220022002202022000002022020202022220022222202002220000222000020002202000020020000020002202020222202020022202020202200202222002200202000022220020220020020000022222220002200002022202202202200000020202200222022200020002022000000222220220200200022000020222000220202020022220220200020200220220202202222220220202220222022002202222022200020022000202200202002000020020022220000000220022202002000200020202202020002022002002022200000222020200220022222002200200202000002000020020000000000022222022200200200220002220022202200220202002022022202002222020200020022002202222220220200020022220222020220200000202200202200000220202020222000222022022022220222202220022022222200202022022202202202002020020222002222002022000022022020222022020000222002002022020200202220202202202222002222000000020022022022200202222220000002020220222202202220022200220002202020200000220200200000220222200200022200200202220200202222020002002022022202022220222002202002200022002022020202222022020022000002020222200002202222022222200200022002002222220202202220222222202202002002200222222000202022220220002020020220022022000200200222200200020202222022200000222220000002202002200002202222022220220200202000000022200020020000220020222200202222000200000000220202000020220200200002200202002200002220220020202002200022220022220222220202020022020002220200022020022220000000222200200222202202020220200222222020200002202020020022202002020022202220202222222002202220200202002022002200000200202020002020020202000020200200200222000220222202220222222220002220000020020202022000202222002220200200022202022222020220220202220002000020002022020222200222002002000202222202202200022202020002020020200020022000000220222222202020002022220002000020000002220022202200002222020220000002202202022000200020020220220002220200222022000022200000002202002020222002002222200022020200222020022002020000022000000200022220202022000020022000022002002020220222022222220002000202002220202222022222020020222220000220020200220220020020022200220022002202022022002202200202200022202202020000222002020020022002000022222202200022202020022220222000022202020200220000000222000200220000000002020022002202022020202002022202220022000200220222222002022200202022222220220222200222002000020220200020002000222022000220200222022020000202022002002200000222200020220202222022220202222202000220002202022020222220220022200200000002022000202020022222022000222000200000000022022000000002222220002000002222202020220000022200002222220222202202002000000022200020022222200202002220022220000220020222020002002220002202222000200002222202002000202020022022002020220220020222220020020020220200020020220022000002020000220002000202000000000022002022222200000022002020020222220220222022020200022222200200220200202220220222022222002020200000000022222200202000202200202022000220000002220002220002202022000202222220000222220022020202222220020002202222002222202202000002000222202020022202202022002200222000020220020200000202002220020200202220000020000022222000002222002222222020022020222002002222202000220220002220020202000022200000020020220200200202200000022202002020000020202022002202222200220020020020000220202022020000022220002220222002202022020000200200002202202202002020202200020222000200022222202200002220202220002200202022002222202220000202020022000022022200220020202022200222222222022220200202222022202220022222002002222220202220220000202222022200000002202200200200220002200000020022220000022020220020022222022220202222000200202002200220002200000222022202022000002000220202022020000202222002200002000200000222020222220222020220002200022222022000002222000200220202202022020022020222220022002200222202220022200020200222000222002000000020202000002020020202020220000202000200022020022200222002002202000202000220200222200222022222220202200002020000022222200202002002222200022002222020202022222220000220222022220002000002202202220000220220202022002200002200220000222220220002202220200002220020000020220020020000202002022022202220200202222222220002202020022022200020220020022220020002002220200022020022020202200022022020000202020000202200020202202220000000220000202002202220200002020220220220200000000020220222222220000220220020200022202222020220220002000002022202220202020220200000202000002200022000222200020000220022220000222202022002222020222022022222222200200002020002222200020022022222202200202220002022022020220200222220002222202000200202022200202202000022020002022002202220202220002200020002020222002220200002222200202022022222220000002222000222002022222220000020202220222002000022200000200222222222000222022020000202000200022002202000222200000202002202200022000002002000000020020220002020002020002222020000002202200020202020222020220002000200002002000020220020002020002222020002022200220022022020202200020002220020220202200202202002002220002000202222002000022020220202202022000222000000002020022022202022222202220002202022200200020220220222000202022202220220000020222002200020200200220000202002020002220222000022220002222020022020220200222202200220222022022022000002222020002002000002220200022000022200222002220022222020000220222000022000000020222000000222022222200200202202222000202022222022020000022020202002222022020022200020222022000222200220222000222002022222002022000022222020020222002220002002222000002222020022200000020002020002202202000022200200222222002020020200000200200200000020002200202022020002202020002220022202220202222220002220020222222020220022222000022002002220220200202202020002000020200022220002202220200220202022000200200000222022000220020220000002002200202222022002002000002002002220022202002202200002020220002220020202002202020002002000022202020222220200002202222000022200000002020000202020020220002020200220222200020020202200000222002202020000220202000020220022220222200202222000200022220020002002002222000020002222222002202200002222022002000000220222020022002000202220020200002202222220220002022000200022000022202002000202002020222220002200020220000022220022020022222220222020200200222020020022020022000000002000002202000202202002200202222222200022000020220200200222022020022022022022202222202022202222000000000222000202222020200002202222222002020220000202202020000000202022002202022002200020002200000202022202220000002222002000200202200202220000002022020000222020220020200000220222022020220200000000222220220000202220020002000220220000020022222220200222002000020022022020200220022222000000022202000000002002202002202202222200200200020022002000002222222002222000022202020020222020002020020020020200020222202020022020220022200222000220202020022020022220000202200220200000220222202202000020022022202222022020200220200222222220222022202002200200200202222020002020002022022020000200020000202202222202000220020202222000222220002002000022200222022000002200220022202022002222202002002200020202020002020222202000020220222022022222202200222002002202222000000202002022202202020220202020220022002022022002000222222220002002222222022020002000022022222222202220022202222002200202222222200020220000002020202220200022200002020222022202002020020020222022000002202000200022020020220002200022000202220022000000202000022222000202202220222020202020022220200000202202200022022022022000000022220220020222202220020022020222022222222220022022220020002022222202020020200202020020022000220200022202202200222000200020220200200002000202222200000220022002020202220200220220222002222200200220200220022022022000202200222020022002000002202202020022202000202022220000200020222020000222200000000000000022200002200220020022022022220020022000222022020222222222202000200202202222000002020222000222202022222002200022202200022022222022022200000220020222000202002022202020002220220000220000000002000022000200002220002022222020220202002000200222222200022002002020022200220022000200020222002022002002022000202002002202200202220200200022200220002222002022220022020022220202222200002222220222020220022200200220000020222222202220200202002020220222202202022002202002022222022222002202200000202022220222200220002200002020200222020200202002200000200022222220200222200020202002202022020022020222222222220000220220202200222020222200022002022022200222200022000002002020000220020002002022022020222200202020020020202220202222020202202222222200200022202222020022022202200020022220200000222002222200002002022200200022220020000002222022222220200022020000220022220220000002022222222000020202220020022020020222020000002020002022200202202200220020202222200000002200020200000022022222200200200220002222022222022200022020200220222000000020202022200220002002000002222220202220200020002000220200222220202200022202020020020022000020022022220220202000202022222020002002200020020020002220200202022020202202200222222220022200000002020200200002220020002022020200022222020202000220020202022220020222022222000022220002000020202220202202220222022020200000202022200022222002022020020002002202020002000220002000020202022022200202002220000000200222022000202220220202200000002022022002002020000000200220002220022220220200002222200202000000220200202002022020220222022220020222222200200220200202200002220202200020022220022200022200200022222022022022222022000200022202222220202020200022202200000202202200020200000202222220200202202220002022200222220200002220020202020222222220000022222200002200200002200202000200200200020220002000220202202022200200002020022000200020002002000020220220000000222020222022222022222020022022020222020222020020022202022220220020202222202022222002020202000000020202002220000002200002202200220002002020020222202002020020020222022002202022002202202022220002002222202000200202220202000220000000222020200222220022002202002020002200202000202200000000022200000222022022222002222020222000220022222200222200020200002202022200220000022000200200002200200002222202020000002220220022000002002002200222000000220202022020220022200220000000022022222022002022202220220000200222222200220002202220020222020202200002000022020020002020020000202020020002002220200002000202020020222002002022022000000022200002202200200200220220220202022022002002202202002220200000202022000000022022000002220222200002222220020220220002222202002022000020200200220200000200002000222202020020022222002222022200000200220020222020222222022220022220220002200200222022222000002022002220020020000020200222222202200002222202200022020222022222002202020022000000022000202020020000022222222020020220220000022220222220002022000022020222002002000220202020202020220200022000200220200200222202200222200220000020022000202222200002220022222022022002022002220200002222002002002222220022202220020222020202220020022000220000220020002002222222020022000002000022020202200220020220220200220020222220202000020020200200202222202200022222002020020202202200220002200000222002222200002002000200200020202000020200200222220200022202222202200202202020000002202020002202222220002222000200200020000222020202000220202220000222220020002022000000020020020022222200222020202202222022020202000020000022220020222200022222002002200202200020020002222002020200022220200202020222002022022222202222000220002220220200220002000022222220020022222202222022202202002002200202222002022000020222222200002002022022222020020022002200022022220222222222002000020202002002220222002022000022002022020222022202200022220200002222222020000022022000000220020002022220000020020002202202002002022222220222000022000202020220000022002002020200202202000022222020222200022220022220022022020200000200202202022222002020022000202200200022200022022220002000200022020020020000002202200020220200222020202022202000020222000022020022222020000202022022220222200020202022002200022200202200202020222022020200022200222022000200222020000000000002200002220222220000020020022020222002022002222002200020202020200022200020220222200000220002000022200200222002002000000000000022002222022020220002002222220220220200202200222000022020002020220222020000220022200000020022022020000000200222200202000000202022002022020000200200220022002020200022002202202200000000020222002222000220202002022220200200220222000000220202220222002022022022220202202020220202220000022222202200020002000000222020222202022222202022020002022222022000220002222022222000202020002202222220200020200020020200002020020200020200222202200022020202020222022002222022222022000020200002202200002002222222222000222022200222222200222222022200220202020022222202022202020002022000202200222200002222002222202000200222020200220202200002202220220022222202220002222002020220202220022002020002200200220202022202002200202020020002022222200220002220222022200000200200020002200202222200202002022222200020200202202022002222202002220202020002200200220220202200220002022200202022000220200222020022222000020200202002222000200202020000202222220000220222000202220022000222002222022022202000200200020222222002222002022002220002022220002002000200020200002200020200020020200000202022022220022000022022000200000020220000202220022222222200220200200222200002222200000222200220222002000022222022200200222002222000020200022000222000002000022002222222022022022200222222000020222220022000000020000020202222200222220202222000020200220222202202222222222020202202202022002020200220020220202002202220222022000220022002220022222202222200000000002002200220222222202220022002020200020000000000200222220220202220002200220002222022220000202222202000022000202002020000002000200222222202202220220200002002222022222222000002020222022000202200000202220220202000022002202000020020022002200020202222002222200200202222220000020222000200000022020022000022202020222020022022020202202020000220220222202022020000020220020022202022022022222022000000200002000020202202022202000022022202220220022200202200200202000020000220220022202200220202220200022020022002000220022020202000000222202202002022000022200000000200000022022020000002000002002200220222020202220000002200002020200220020222020022020200202020202000200222000222020002022022022022220200220202200022222022220000000022002000222220002002000002200220022022202020200020220220000020000222002220020202222200220200020002220220202202020020022200200202002000000022000000200000020222200202002220202202000200000020020200220020022020200000000202202222022200220200222020200002202202022020200222022200200020002202200222202002020220022022222222220220000222002200200220022202220022020200020020222000002000220202020022000022200200202222020202222002220222220200022220022002000022220020222020020222222020200020022200000000020220022000020222202222202220000022222000002222202222200020200220220022020002002222222220020000220202202220020020220202022220222020220022002202200000202202002002220002020200022200022000022220202220000200200020022020200002002000202020022220222022220022202202020202202200222000202002002022002222002002222200002002222202020220000220020202020220020020202000202022000002202222020220002000202022222220202222000022200200200222022202002000002200022202002002222020222200220222000022202020020200022222020220202222000222220200020022022202020220020000222222002220200020222022022022220000200022220000220022200000002002200222202002222002222222022020020000020020202022202022020202200002220202222200220020000220220202202000002000202220222222000222022202200200000220202022022202200200000020022202200200202202222222202220202200202220020000020022200002222220222202220220222020022000222002200022002200220202200202220002022220002200202022000022000020220202020220222022200200022202022000002022022222020222220220022022200002000000222222220222002200022222002220220022222020200202002000020022022002200220222222002002020002200220000002222002022020022002220222000220020222002200000020222020002002002020220200220022022202002022000222202200200222022222020002000220202222000222202002020020202220222222020020020022202000022222022220202200020000000022202200222202200202220002002022202022222220002002022220220000020020200222022022022222002000002000220202200002202222000020020200002220222222202002020020020022220200022202222000000220202202022220220222020022022220222020002000220202000220000002020202222020002200200222022022202022000222002002200000000022002022000202020222022200020200200202220000020002220202020000022022222022022222220000022202200202022020200200222002222000022000000200022002020000002220220220022022222000020200200220022202222202020200000220222000000222020220022002022222220000000202022002002202202200202222200000002220202220020220222020002200020022222000222200022202022022002002220020222000020220000000002020022202220002222220022002200222220202222200002222202202220022200002020020202202200220022002000220220200002020022020202220222200222000202020022202022002222022222002020020202022022002220000200200000220202222200000000200000200002220022220200220222020022222200022202220202200220002002022200020000000020000022222022200002022020002220020200020202202020020020002002000002000020020002000022002000200200222020202222202002000222002220220220202202002220020220202022200220002222202020200220222222202220002200200202202000200200020020000222000002222000222200202202020220022222220202200202200202220200202000222000000200002000200220222020222222002222220022022222022222020222002000202022020222022202222020202020200002220200222000020020220200202202222222202020002202022222222000222200000202220022002020020000000002002002002220020002222220200220002000022002220000002020200002222000220220220020220200020200222000002200220200022000020000222202000020220000200202222020220200002220220000200200220000020200222220222022200200002022000222200200000220202002000202022222000222020022002222202222002022220202200000202222220220002002220002200200220000202002002220222220020202222222200202200020200220000200000200220020022202200220202020220220220002200020200002000020222020000222222220022000220022200222220220202220002002202202022022000202200020222022200220222222002222200002020202000200022202002220022200000220220220020222000222022200022222220002000222222022020220002200200020200020220220200200200020000202022000202020222000200020022200202022002220000002222222000220202200020202200000022222200200222200000002000022220202002020000202220000220202020022000000220000022222200200000022200220220220000020202202202020022200000200222020200022020000022020002022002022200220222220200022022000002220220002000200200220222022200222200222002222022220222002202002200202022022020020002022000000020000202222220000022022202220200000020000202220022202200002022002000200022220002200002202000222220202020202220222200000202002222020202200222222002200020002022202022222020202022022000200020220222002020202220000002220222020222220222022000022002020022200222200200220000222022002002222002020002020022220220022202000222020222022202202200222222202202002222020020020222200002022200220200000022020002002020220222222002202220220022200000220000202222220222022222000000002220022222202202200202222020222222022000002220020020220020020202002020022020220020002022002200222202200222200020022202002200002220020000202202220220200200202222222020200022020222000002020202200000222020222202002000000222002022000000022000202020200022002020002020000200022220200220020002200222020200022002220200002022020020220000220002022202222020220022022020220222220002000222200220022202020000002202002222000200200002000020020202020020220202202222200202220222200002200220222220202002222220022200202220222220020202022200200200000022220000220022000022220022200000022200222000002000020022020020020200000022200200222002202000220200000000220020202220200000200220000220202202020220222202220202222222022022202220000202022000222220002220220200220222020200002220022000000202000222202020222000020002020200020020200020002220002222220222020202000022020002202200020002002000220022222002022200022200222222022000022002222200222022222222000000202200000222022000020002202022020000220020200220202020020022222002202222200222202000022220022220000200000000222022220022202220020220202222022000002000022000200222020220020022002202022220202222022022202000000000200000020222020202222202020200020022022022022200022000020202202000220222002200202222022202222022222200202022200022202002200000202002020222000222020220002002200200202022022000220202222222200220002202000020000200022220000200220220200020220000220000200222220020022020200222002200220220220002220200020202202222220200220220022002022202000020200220220220020222202020000200002220000222222220220220222220222022002222020000002200022020222202220200222220020222020202222200022222202002000200022200002002202002002202200000000202020020220022000202220020202200022000202002020002000022022200202002202002020022222200000200002202220000202002202220202000002000000220002000220222022222202220000002020220200000200222022002002220020220202022200222022220200202000020222220220000022022222000000220020020222020002220220020202020220002220002202002000202222202020200220002200020220200020220220002200000200022220202022220220000200020002000022022022022222020202002200202200002022022002022020202000000220222020200202222220002220022020022000222022000020020200222000002222022000022000000020002222020022022002200220222000222020222000000020020200220202222220020020000200200022000000222220002222022020222222220000202020220200002000002202200202200200000220202020222020022000020020020000022002200202002022020022220002220200222202000002000000022222220000020002020000222200022022022220002020022000200200220022022002222200002200022000022000222200220022002000200000200022022000202200002220200022202002220020020222000020220002022022202222200002220200020222020220000000000000202022002202202200220222020202222220220022202022022220022220202200020220200022020222220000220020200222000200200202200000022200000022002022002222022200220000220222002220220200222022220222022002202202222202202200202022020220002022022000000000002200020220222220200222000020202002000000202000202202022002000220200202222220020200022000020202202220002002002002222020200022200200202200022222202020220002220022020200000200202202022202202202000020220202200222002222220222222020022220220222000202022000000200022200200200000022222022222222222000220022200220002002002020200002002002222000202220000022022220220200202222002202000220000220222000220222000000200200202220022220022002200020000020220002022222000002222020022020200222200202222222022020022222220022220002020002222022222220202222220222002002220202222002222202022000022000220200202220200022022220022020020222220202222202020202220200002220220000000022200002020202202200022202020220222202220020202002000022020202222002020202222220222020220002000020000222000020000020002202222022000220200200200002022200220022000220220022202020020000002200220220002020202002000022002000022202002220220200000002202002200222000002200222002002000200020000002222000220022000022200222020200222200200220022220202200202220022202020200202200000222000022200220022200020220202000200222022222002200000222022220222222222202002022000020002000200202220202002002200202002020020000020200202002020222000002222020200202020002222000000002220220020002000222220222020020200020220020000020002000200022020222222020022220200220200200002202222002022000200022002200020020020002202200202002002202200200000220020022220022220020020202200020200222200200220220222220200020000022020200220200200022202002200000002220220022000200000022000002220222022202020002000200002020222220220002020022002220200222020020022022022220020202022020220022222200202002220020002220220000222022002020020202220000000220022220002000222002002222200222220200222220220002202220220200022222202220022202022020002200002200022222222202000002200020020202002220220202000220002202220002200020002002022002020200020022020022000000020202020000202020202022000000020000200222000220020022000220002022000022000220022000022000200022200222222002200220220022200220000000202002220220022200020002000200220002000020222020202202002022000020000020200202220222220220020220002222222222220002020020002200200020000200020222220200022202220002002000202022022000022200202000202200222200202020022202000020200022202222222222222000220222002002022000220000200022000222002220002222000022002220202202022222200000000220000002202000222000000222222200200220002222002220002020020202202222002022220002002222000200220200220220000220002222222200202202220220020200002202022002200200000002000202000222020020220020220202222020002200000020222002202020202000202220200200222022020020020220002202022200202000200200002222022220200020022222000220222022020020002222002222200000002220022000022202222200200200220020020220022202200220000222022002222020020202200222220222222022022020200002022202020000222200202202202220222022002200202022200222000022002202202000022220220000200020020022000000202222020000022220222000000202220200200000220000200000200222202020020200020000202022222000022202200202022002002220020200222000220220022002020020022222200020200222000000022020200022220000000202220222222202220202220200200200000220222200022200200000000002200002022202202020200222022020220020220020222202000202020000000220202000200202020000202222022200002222202202200222000002020002220020200020002022022220022002200000022200022202022020000020200202002220220000200020022222020220022022200200220002000202022002202022202200022022202002202000000200000022002002222000220200222022020222222022000220220020020200220020002002000202000000002220220220200000020020222222200200022200220202020002022020202222022002002202200020020020220022220222022200020022202222220222220222020020220202202002200000020000020022222022000200222002020020200022202022000022220020022222202220220020022022022022020000222220000220220000000222002200022002220202022202000022020220200020222002220222022002020000222020020222220220000002222002022220200000220222220022220200222000222202022200220202022000220022220022002022222200220202022002002202000200220022022002000000020200200000020220222200022222222020022202000000200000022002002202202200222020020022222002220202022020202222022002022200222200022020220020222022220020200022222202000200222020000220000000200022002200200000222020202002020022000002000002000022000002220222200220200022022220022000002000220200002002002202022222222002202200020220000200200202020002202220000020222020022022200022220222022000020222022000000020202220020222020000222202222222022220202022020200202220220222002220200022202002202000000220202220202000000202200202200002000022002002202202022000022022002220002220022002200022022022220020020022000222022022002020022000000220200220022220020220202202222222200002000000200020202002000202200220000002022002220020000222022002222202022022020222222200202200000020220000222022202220000202022222020000202222022222200000202220202222002022002202220000222000222000220002022002020200200202222000022020202020200200202022202220200002202200000022200020220002202202222222000222002022020002002000222200002000000200220022020000220022022220022002002022202022000202222022022022222200202002200202000222002222020222200000200020220202022200002202002020202222220022022220000222202220222202000002200002200020020202200202200002200002020002020200020220220202220200022220020000000200000000200022202002220020022022202220020000222020200000002000020202200202200002000222002222022202202020020020020200020202202020222222220222222200222222022002202002202020020202220222200222202222200022022022220000220000220002202002020222020002202000220200020200022000000220202022202000022220002020202022022200022000000002222000200002000020020202222202202022022002020000222202002020202200020000222202020020220220022000200020020222222220220000020020220202200220000220202002020022000202002002000000002222000020222220020000220002220002222002020220002202220202000022222020002222222000022020022202220220200222020220020220202020020002202220222202200002000022222222022202220200022220222020222202002002022222200202022000002202002200002022000200002022020200022202020020020020222220002002200200200022200220200222220222202202200000222200020222000020200220202020220022002022022020020020202200222022222222220202220202220220222002020020200220002022020220022020220220222202020220020002202002002222202000220000022222020220200202022020022000002202222200020020002022220222200222202202222200200202202002200000200202022202220202220202202202020220222022220022202200200020200020022022220002002000000002200220200002200020200200222202002222222020202202022002020202220022000020020022202020002202002220220202020220200002200002222200222002202222202000220202002200022200002022202220202020000022202220020202202000222200222200002002020020220002220022002020220002202222200222000202222000000202222200202000000220200022202000002022220200000000222220022200020020202222220200020200200000000202022000022002220220022002220222020222200222200202222002002002200200202022020200000022200220202002200022020222020200000200002022020202002002202222002002002220000200022000000022220200020022222020000022220002222022222200202202222022222020202202000200002020200000202200022222002020022002202002002200222200022202020022022002202222202202022202222200202220200000002002022000000222220200002000000222022000022000002000020222200200022202202200220220222020000022022222020200220022220000222220000200000022220222220200220022000002000220002020020022202202222222020000002220000200020000222200002022020200002200220220222200222002020020022000002222022020202000220000022202200022002222222000002002022220022222222200020022220202220202222202222220220222002200000202020000022220220002002202022222200222202202220000202200022022202000222022222020220222022020002222020022002022020200222020202000002000220020020202002002222002200220000202020002022200222022002220200000000220202200020202200020220220000202222020002020002202220222020202200002222220200002020222202020000200000000000202220202022202000000222202000000222202222202000000022200000200202200220002022202002200220222000022222002200200020002222202002000202000220000222022020002020000000222022022022022202022020202202002022020002000020202020222220220200222202002002000002222222020002200000222220222220002202020022002020022020202222020220002020000002020222200220000202022002220002022202022202200202000002220020200222000020222200022020020022220200222200202200020022202022222000002220200002020000022222202020222002002022022202200000222020200000220222002222200200000022200022020000022020202220022022200002000202020202020220002220200022002222000022002000022202220200000022000002022220202220020000220200000202020220222200022220000202220002222000202222200222202222022002020002000020020200222200202022220200020000000022220200220202222000022002202022002222220202202020200020220220222000002220022000202202220022020000220000000022000200222200020020200002022202222222200222022022202220020002222002022022000222220022020000220000200202220200220202020020000222220202022000022200000020022000002200220222000020220220200222002200202000000022202000000220022000000200020022000020200002222220022022200202200200022222020022020200002022220220202220022222002202200002002022220200200202000222000020222220202200202220202220220020022002020000222202020200222020222002200200022022000200022220020002222220220220022020222200202002022022222020220200022220022200222202222020202020220020002220220020002020022220220220022202200000020222200202000002220022202202022020220022022202022002000220020220020000220200200202222002020000020022022002202202220222222002200022002002220202202022000222220002202222020200200002222220002220022022222222222000000002000200200202020022222022000000020200202022000020202220220222000222220020220002022022002000220202200002000022002220200000002000202220202020222022002020222000200222022202202220220220022202002020222220000200000000222202200002000200220200002000222202220202220200202002200002200220202202220202020200002000202020222202200200200222222022202200022022022022220002020002000000022020220200222222200222000220002000222022222022022202000222200222200020202220200220222202220200020222000000202202202220002022202000000000022002002002202202222020020222202022202202222000022002220202020200220200002222222220222200000000002022222020222022220220222222222220022200200222202202002022202220222022202020220020202200202000002022220222022020222000200022202022220002222200000020020202200000222020202000202022220220022220220022020222222000222222222000202222222222222020220002200220222000200220022020202200220222200020220220200002222200022020002020220200020220202002002000202200020220002200022200202002002022200002202200222200002202202220020022220020022202022200000020020000222020202002020002022022200202202020020220022222222022022000200200022002222222022222022022200002000220000020202002002200222020022022002000022002002202200220020002220220220020220222200200222000222000220020000000202202220000020222220222222220022022020222000222200202022200002202222202022000220202022000202200022022200222222220000222000002222002222000000022022202020222020020002220022002200202020222000222222022202020202222022020222222022020222000220200022020202222220222220022220020000022002020220202020000000220022220002200020022022200222200202002022022202002200002200200002022000200000202220000022000202202022020222020020220200022200202000020002022200200220202222200202002200020000002022200202020000200222220202000000020002002202000222020022022002000202222022202020020222002000002000200020020000002000022000222020220020020020022220022202000220000200200002020000022002000220000020200022002002220022000220020020220022002022222000200000020022000222202220002220202000200020002020022020002002222222222202022220002002220222020002222200020222200022022022022002200202022022222202000022022202200200002000220220222000200022222002002220000220020202022000200022002200020000222020022200000022222222222222202000222200022202220002022202002200020022200202002022000022022220002202020000000202020222220222220020020002220200202002222000222200022202222002000000200222000020020200020202220220222220200020202020002220222002200022020002222000202020000220020020202220202020222220220002220222222000002220000220022200020020220220200000000200022002020220202000020222020000202002020022022200220020202200200200220222002000002000200022002002200002220220020002220200002002002002202200022202022222000000202020222202022000202202200020222002220022202220202002200222002000020222022220222022222002002000202000222020000000020200222222220002202022020022202022002002220020022002020220220220020222220002020002222202202220022200220220022020022002200222002202222200002202022022220002002220020220020202200000200002222022202202200022202202200020020220000000002222002002200020022222222022220022222000202020202022000020202022220220222020022202222022022202202000020200002002222200000000220000222002022202222020000020000022020000000220202000000020220000200222000020020020002202022222202022022220202002202002222220020002202200222000220220222002220020000222202222002022022002202200022022200220202202220022002020222202020222022000022000202202202202200020022222022020000222002022022022000222220000000222002020200222022002222020220000222200202200022020002000202002002200002000202200002002002020000020220002202200222220000222222200220220000000022020002020002202000020202220002000200002220220002000000020202002220022000022200222002020020222202200020000220002202022002220202000002022222222200002220022022022020222220220022200002002002200222200200222220002220200202202220022222220020022200020020002220202000222022002202200202002222020000202220200020202202020020022000202022200222202000002220222002020020002200000000020202220000022000002220022000000022202020200020002200222022220222220020222202002022002200002022000000200000200220222220220002200220000200002000002002200200000220000000020200022222002020002202200022222200000222022022000020202220000220220222022002002220000000222200002202202022202002202000002002002000002220002202220220200220002000222202020222220222222222200202220200222222222002022220220020020220220220220202020200202020020002222020020022002222002000202022020022022002002222202202002200200000220202200200022220002000020020020202002200022220220200200202000022200222002222222202002022022020002200002220000222020020222022202022222222022020022020200220020222220002202222222222222202002020222222220020022202020222220220000000022002002002022222022200020220022020020220200000202022022220002202000022022202200022000220202022220022222022002022222022022022200020002222202000220202000022200220222200002202200020022202202200000020000222020222202000200000202000222000020020222020000222220002202000222000220022022200200022222002200002000202202220220000022200220202222020000002022000220022220002200202022200222220220220222200222000202000222022022000220222020222202220020222020000202020200220002020002222200200000222002200020022220220220220202202220002200200000000220022002222200222200222220020020200022022022020022222202220000200020202020002020000222202220020000220000022202220022200220202002202000000020222022200200002022022220200000220020222020220200002220222022020220020002222002220220202002000202020020202020202020000002022202020022020022022020002202020022220202022220020020022000002200202200000202202020220220000020200222222222200200000200202000200022200220200220022000002222202220220202002020222020022222222002002200020020222022202022200020002022220222020200200002202202020002000020220022002020020002220222000200022022200200202000220000022002202222200002002000020222200002000200000202000020000002220202220220002220222002022022222000222202000202222002020002222202202000202002200220020020222002220022222002002222220000020000022020020000202020002200200202220220002002020222222020020222202002202222200020220200222022200002200202200222200200202220202022200220200020000220202022200020220022220200220222222000220000020220002220002220220002022220222202202002000202220222022200222222222200220220222002022000020020202220020022220222000220020220200020222000222200002222220220020020220000200202202020002020202220020020200202022220220200220220000202002222200200222022220222202200020200222200020220000220000202220020002222222020222020000022220200220220202220022220220022000202200002022020020222020202022022002020200022002002022020202220202020002200220202200022000000020002220020002200000000220222222000200022222022020002220020222022202000002202222002002022220202202022220222000222000002220020220002002202220200222222020020002200022000220202000000222022000000020022200200202220200200200002000202202000000222222222202020022220222200200202002002220000002222200202200022202200020200202020002220220022222222002200222200200002022222020000020022020200002002000220000220002220000000220002020002022202020002022020220200220002002020000200200000200222202002202022020222220002000020222222022022202222022022220002202200220220022020202202002202220220020202000202002000202222020202222000222022220002222222200200200220002022222022220002000202002002020222000222222002002000220002020220022002202022220020000022022202000002002200020000002020020000022220020200020220220020220002022220222002000202220202200202020000020202000000220000202202020020002220020022000000022000202200000002002200020202022022000020002000022200000002020202220022200022200002202002222220202020202200000222222022022002222020200200200222020002022220222220200220202200200022202222022022002020000200200200002222220002202000022220022002002222222222002220000222202022222222000002200022220202220222220202020000220022022222222020022222022002220022200000200200202000220020000002222000020000022220202220022222220222020202022200022020000220200022002000202220222220002200202022000022200022022202222222000020202000000000220222202022222200202002202020200220220202220022000000200002200020200000002020200200200202020022220220220000222222000202202222022220200222022022200002200200022000002200022200222020220022200202202202200020200200220000020200000202220022020002220020200222022002200000020200002220202000000002200200002020002200022220220220022222202220202222200022020022202222220220022002000022020020202022020222222220000000000002022000020202022020200022202000000020220000222022202200220202020020002002002220220222200000222002022022022200022002222020220000020002022022000020002200020202000222022220222220202002222220020002222200220202002002202002220002222202002202220002000000200220202020222222202000020000020220222220002020020220200020200220220002022220000220222022002002222200200002020002202200200002200200222220202000202002200022220022020222020002202000020022000000200220000220000022220200220000020000200022222020022200020202002202222020020002202022222022220202222022022222202022002000020002202020022002002200020002022000002020002020202020202200022200220000220022220220202202202002220200022202200220220220220200200020020200022222022000202000220200002220222202000022020220002000220020222220000220000022022220000202000222202220020020222002222000000022220020220200022002002200200220022222022022200202222020222220200220200202220202202002222202200222020220202002020200020020022000220220002002022200000002020020020220002000022020222020020002220002200020020020200020200022002000020220202200202022022222200022022222022202020220000022220022020222000020220220202200022220022200220022220000220222020022000222022222022022002002020200020202002020022202000000220000200200022222022222000002200200000002220220222000022222222022020002020220202200222020002002202000200200220202002022020002202000000202020000022002220022002202200002022202000022220222202222202022020000200200222202220022020200222202220020220200020202000200200000222202222020000022002020200002022020222222202222020000002000220000000202200022202022202000000022002020022002002000220222002000222002000022020000220222222000202220002202200202000220000220020000022000200222020222222222000020200002222020000000200200200000022202222020000202220000200202222222002202000200022022002222000200022220222022000220020002000002222200202222222202000222020002000022200002200020222200022222022200020002020000202020000222020200222000022200222022022200020000020220000220000200022022200022220002220220222020200000020202022002220222002002220020002220002202202202200002002200222002220222000220000200000220200202200000022200000200220222200220000002002020020220220002222220002220020022020200222222222220202202202000220022002220222200002222220022000022200202222022200200222222020002002002220002202022220002022222022222022022220022000022200202220000000202022002022202002222020002202022202022202200222222220202200022222002222220220002020022220220202020200002002220020220022022002000202202002200202002020200000200022222222022022220000002200022002020200000220222022200020002202020220002200202220220002020000002020000020022020000200022202000002200202022200200200000022200220022002020020202022200000000002222020222002020222022022020220000202200220202020200200002000002000000020200220222002222220222000002200002222022200222222002222200020220020000200222222000020022000220000002220200000202002020220200220000202220222202222000200200000222222220022222002020002020022020000020000200222222020202220022200220220002200222202022002020200000220002000022200002020000222200200220200000200000002002020200202000202222002222200020220000202222202220020222220202222000222022202022202002000000020020022222200202002000022220222220020000020200020220020222022202200202002202002002002222202222222202222202002022020000200002222002000200000002202200020020200000200000220200022202020202220220020222200020202022022022202020202002200220002000200022222220022220000200000220222000002200020202022200002000020200222220002222220202202000200202220222022022200200000200020200000002000220200000020222022220220200222000200002222000222020200200202200202220222002200202002200202202222222002020220020000000202200000222200220000000000022200022000220202020222022022220220220202200020200222222022020020000002222202002222200000202020200220200200002020002022222002020000202222200202200002222200200000222200202022000202022220200002002220222202200002202220200222020002020222002000000202222220020000000000022002022002020202202002002200222200020222222002200000022000222200200222202000200000202022002222020220002222020000000002022220202000202202222200002222200022002000000002222200222222220000220200020020220202022020022222222002002200200002002200000002202220222200222000000000002022022020022202202200000200020220022220000022022002000020002022220200220220222020022200002022222222002200020222020002222220200002202002020022220022022002220222220002022020022022202002002222020020022202200222200000200022002220202000200222200202020022002220202200022002000200002202020002022000022220000002200200202022000202222022202222222202022002222200022200222220020200222020002022222220022202000002220020220002022222022022002022202222222000022002020002202002022000022000202200000220200022200020220222000022202222000222222022202022222022200002202220222000202000200002220200000200202002202202","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://zgg2001.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}]},{"title":"2020 蓝桥杯 Java实现 10月C组省赛","slug":"20210301-02_2020蓝桥杯Java实现10月C组省赛","date":"2021-03-01T14:21:26.000Z","updated":"2021-03-01T14:21:26.000Z","comments":true,"path":"2021/03/01/20210301-02_2020蓝桥杯Java实现10月C组省赛/","permalink":"https://zgg2001.github.io/2021/03/01/20210301-02_2020%E8%93%9D%E6%A1%A5%E6%9D%AFJava%E5%AE%9E%E7%8E%B010%E6%9C%88C%E7%BB%84%E7%9C%81%E8%B5%9B/","excerpt":"几个月没写题了，先找找手感，从简单的C组开始吧。 2020 蓝桥杯 Java实现 10月C组省赛 题目 &amp; 题解","text":"几个月没写题了，先找找手感，从简单的C组开始吧。 2020 蓝桥杯 Java实现 10月C组省赛 题目 &amp; 题解 试题 A: 约数个数本题总分：5 分 问题：对于一个整数，能整除这个整数的数称为这个数的约数。例如：1, 2, 3, 6 都是 6 的约数。请问 78120 有多少个约数。 思路： 暴力 答案： 96 1234567891011121314151617181920public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.printf(&quot;%d&quot;,func(78120)); &#125; public static int func(int a) &#123; int temp = 0; for(int now=1;now&lt;=a;now++) &#123; if(0 == a%now) &#123; temp++; &#125; &#125; return temp; &#125;&#125; 试题 B: 寻找 2020本题总分：5 分 附件在本篇末尾 问题： 小蓝有一个数字矩阵，里面只包含数字 0 和 2。小蓝很喜欢 2020，他想找到这个数字矩阵中有多少个 2020 。小蓝只关注三种构成 2020 的方式： 同一行里面连续四个字符从左到右构成 2020。同一列里面连续四个字符从上到下构成 2020。在一条从左上到右下的斜线上连续四个字符，从左上到右下构成 2020。例如，对于下面的矩阵： 123456220000000000002202000000000022002020 一共有 5 个 2020。其中 1 个是在同一行里的，1 个是在同一列里的，3 个是斜线上的。小蓝的矩阵比上面的矩阵要大，由于太大了，他只好将这个矩阵放在了一个文件里面，在试题目录下有一个文件 2020.txt，里面给出了小蓝的矩阵。请帮助小蓝确定在他的矩阵中有多少个 2020。 思路： 暴力 答案： 16120 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.io.*;public class HelloWorld &#123; public static void main(String[] args) throws IOException &#123; BufferedReader in = new BufferedReader(new InputStreamReader(new FileInputStream(&quot;D:/demo/1.txt&quot;))); char[][] map = new char[300][]; for (int i = 0; i &lt; 300; i++) &#123; map[i] = in.readLine().toCharArray(); &#125; int ans=0; for(int y=0;y&lt;300;y++) &#123; for(int x=0;x&lt;300;x++) &#123; //横排 if(x&lt;=296) &#123; if(map[y][x]==&#x27;2&#x27;&amp;&amp;map[y][x+1]==&#x27;0&#x27;&amp;&amp;map[y][x+2]==&#x27;2&#x27;&amp;&amp;map[y][x+3]==&#x27;0&#x27;) &#123; ans++; &#125; &#125; //竖排 if(y&lt;=296) &#123; if(map[y][x]==&#x27;2&#x27;&amp;&amp;map[y+1][x]==&#x27;0&#x27;&amp;&amp;map[y+2][x]==&#x27;2&#x27;&amp;&amp;map[y+3][x]==&#x27;0&#x27;) &#123; ans++; &#125; &#125; //斜排 if(y&lt;=296&amp;&amp;x&lt;=296) &#123; if(map[y][x]==&#x27;2&#x27;&amp;&amp;map[y+1][x+1]==&#x27;0&#x27;&amp;&amp;map[y+2][x+2]==&#x27;2&#x27;&amp;&amp;map[y+3][x+3]==&#x27;0&#x27;) &#123; ans++; &#125; &#125; &#125; &#125; System.out.print(ans); &#125;&#125; 试题 C: 跑步锻炼本题总分：10 分 问题：小蓝每天都锻炼身体。正常情况下，小蓝每天跑 1 千米。如果某天是周一或者月初（1 日），为了激励自己，小蓝要跑 2 千米。如果同时是周一或月初，小蓝也是跑 2 千米。小蓝跑步已经坚持了很长时间，从 2000 年 1 月 1 日周六（含）到 2020 年10 月 1 日周四（含）。请问这段时间小蓝总共跑步多少千米？ 思路： 根据平年闰年进行暴力 答案： 8879 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class HelloWorld &#123; public static int judge(int year) &#123; if((year%4==0 &amp;&amp; year%100!=0) || year%400==0) &#123; return 1; &#125; return 0; &#125; public static void main(String[] args) &#123; int[] p = &#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;;//平年1月到12月 int[] r = &#123;0,31,29,31,30,31,30,31,31,30,31,30,31&#125;;//闰年1月到12月 //起始日期 int year = 2000; int month = 1; int day = 1; int xq = 6;//星期6 int ans = 0;//公里 while(true) &#123; if(year==2020 &amp;&amp; month==10 &amp;&amp; day==1) &#123; ans+=2;//10月1号也算上 System.out.print(ans); return; &#125; if(day==1 || xq==1) &#123; ans+=2; &#125; else &#123; ans++; &#125; xq = ++xq % 7; day+=1; int state = judge(year);//1为闰年 0为平年 if(state == 1) &#123; if(day&gt;r[month]) &#123; day=1; month++; &#125; &#125; else &#123; if(day&gt;p[month]) &#123; day=1; month++; &#125; &#125; if(month&gt;12) &#123; month=1; year++; &#125; &#125; &#125;&#125; 试题 D: 平面分割本题总分：10 分 问题：20 个圆和 20 条直线最多能把平面分成多少个部分？ 思路： 数学题…不会啊，放一个知乎大佬的回答 答案： 1391大佬在这 点我去看大佬 试题 E: 七段码本题总分：15 分 问题：小蓝要用七段码数码管来表示一种特殊的文字。上图给出了七段码数码管的一个图示，数码管中一共有 7 段可以发光的二极管，分别标记为 a, b, c, d, e, f, g。小蓝要选择一部分二极管（至少要有一个）发光来表达字符。在设计字符的表达时，要求所有发光的二极管是连成一片的。 例如：b 发光，其他二极管不发光可以用来表达一种字符。例如：c 发光，其他二极管不发光可以用来表达一种字符。这种方案与上一行的方案可以用来表示不同的字符，尽管看上去比较相似。 例如：a, b, c, d, e 发光，f, g 不发光可以用来表达一种字符。例如：b, f 发光，其他二极管不发光则不能用来表达一种字符，因为发光的二极管没有连成一片。请问，小蓝可以用七段码数码管表达多少种不同的字符？ 思路： dfs出所有情况，然后用并查集判断是否属于同一子集 答案： 80 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105import java.util.ArrayList;import java.util.Collection;public class test &#123; static int ans = 0; static int[] jl = new int[10]; static int[][] map = new int[10][10]; static int[] father = new int[10]; public static void main(String[] args) &#123; //储存关系 a~g对应1~7 map[1][2] = map[2][1] = 1;//a b map[1][6] = map[6][1] = 1;//a f map[2][7] = map[7][2] = 1;//b g map[2][3] = map[3][2] = 1;//b c map[3][4] = map[4][3] = 1;//c d map[3][7] = map[7][3] = 1;//c g map[4][5] = map[5][4] = 1;//d e map[5][6] = map[6][5] = 1;//e f map[5][7] = map[7][5] = 1;//e g map[6][7] = map[7][6] = 1;//f g //dfs遍历所有情况 dfs(0); // System.out.print(ans); &#125; public static void dfs(int n) &#123; //当7个灯都有状态时 进行判定 if(n==7) &#123; //把亮着的灯统计下来 ArrayList&lt;Integer&gt; a = new ArrayList&lt;&gt;(); for(int i=1;i&lt;=7;i++) &#123; if(jl[i]==1) &#123; a.add(new Integer(i)); &#125; &#125; //判断 if(a.size()!=0) &#123; if(judge(a)==1) &#123; ans++; &#125; &#125; a.clear(); return; &#125; //否则dfs灯情况 jl[n+1] = 1; dfs(n+1); jl[n+1] = 0; dfs(n+1); &#125; public static int judge(ArrayList&lt;Integer&gt; a) &#123; //System.out.println(++js); //并查集父集重置 for(int i=0;i&lt;10;i++) &#123; father[i] = i; &#125; //并集 for(int i=0;i&lt;a.size();i++) &#123; for(int ii=0;ii&lt;a.size();ii++) &#123; //如果两边相连的话 进行并集操作 if(map[a.get(i).intValue()][a.get(ii).intValue()]==1) &#123; int fx = find(a.get(i).intValue()); int fy = find(a.get(ii).intValue()); if(fx!=fy) &#123; father[fx] = fy; &#125; &#125; &#125; &#125; //查看是否都属于一个集合 int temp = find(a.get(0).intValue()); for(int i=1;i&lt;a.size();i++) &#123; if(find(a.get(i).intValue())!=temp) &#123; return 0; &#125; &#125; return 1; &#125; //查集 public static int find(int x) &#123; return father[x]==x ? x : (father[x] = find(father[x])); &#125; &#125; 以下题目部分能通过AcWing和蓝桥杯竞赛的数据测试（有的题没有被录入，无法测试） 试题 F: 成绩统计时间限制: 1.0s 内存限制: 512.0MB本题总分：15 分 问题：小蓝给学生们组织了一场考试，卷面总分为 100 分，每个学生的得分都是一个 0 到 100 的整数。如果得分至少是 60 分，则称为及格。如果得分至少为 85 分，则称为优秀。请计算及格率和优秀率，用百分数表示，百分号前的部分四舍五入保留整数。 输入：输入的第一行包含一个整数 n，表示考试人数。接下来 n 行，每行包含一个 0 至 100 的整数，表示一个学生的得分。 输出：输出两行，每行一个百分数，分别表示及格率和优秀率。百分号前的部分四舍五入保留整数。 样例输入： 123456778092567488100 样例输出： 1271%43% 评测用例规模与约定：对于 50% 的评测用例，1 ≤ n ≤ 100。对于所有评测用例，1 ≤ n ≤ 10000。 思路： 送分题，记得四舍五入保留整数 AC代码： OJ链接 1234567891011121314151617181920212223242526import java.util.Scanner;public class Main&#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); double n = sc.nextDouble(); double a = 0; double b = 0; for(int now=0;now&lt;n;now++) &#123; int temp = sc.nextInt(); if(temp&gt;=60) &#123; a++; &#125; if(temp&gt;=85) &#123; b++; &#125; &#125; System.out.println((int)(a/n*100+0.5)+&quot;%&quot;); System.out.println((int)(b/n*100+0.5)+&quot;%&quot;); &#125;&#125; 试题 G: 单词分析时间限制: 1.0s 内存限制: 512.0MB本题总分：20 分 问题：小蓝正在学习一门神奇的语言，这门语言中的单词都是由小写英文字母组成，有些单词很长，远远超过正常英文单词的长度。小蓝学了很长时间也记不住一些单词，他准备不再完全记忆这些单词，而是根据单词中哪个字母出现得最多来分辨单词。现在，请你帮助小蓝，给了一个单词后，帮助他找到出现最多的字母和这个字母出现的次数。 输入：输入一行包含一个单词，单词只由小写英文字母组成。 问题：输出两行，第一行包含一个英文字母，表示单词中出现得最多的字母是哪个。如果有多个字母出现的次数相等，输出字典序最小的那个。第二行包含一个整数，表示出现得最多的那个字母在单词中出现的次数。 样例输入： 1lanqiao 样例输出： 12a2 样例输入： 1longlonglongistoolong 样例输出： 12o6 评测用例规模与约定：对于所有的评测用例，输入的单词长度不超过 1000。 思路： 暴力统计即可 代码： OJ链接 12345678910111213141516171819202122232425import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); String s = sc.nextLine(); int[] ans = new int[30]; for(int now=0;now&lt;s.length();now++) &#123; ans[(int)(s.charAt(now)-&#x27;a&#x27;)+1]++; &#125; int end = 1; for(int now=1;now&lt;=26;now++) &#123; if(ans[end]&lt;ans[now]) &#123; end = now; &#125; &#125; System.out.println((char)(&#x27;a&#x27;+end-1)); System.out.println(ans[end]); &#125;&#125; 试题 H: 数字三角形时间限制: 1.0s 内存限制: 512.0MB本题总分：20 分问题：上图给出了一个数字三角形。从三角形的顶部到底部有很多条不同的路径。对于每条路径，把路径上面的数加起来可以得到一个和，你的任务就是找到最大的和。路径上的每一步只能从一个数走到下一层和它最近的左边的那个数或者右边的那个数。此外，向左下走的次数与向右下走的次数相差不能超过 1。 输入：输入的第一行包含一个整数 N (1 &lt; N ≤ 100)，表示三角形的行数。下面的N 行给出数字三角形。数字三角形上的数都是 0 至 100 之间的整数。 输出：输出一个整数，表示答案。 样例输入： 123456573 88 1 02 7 4 44 5 2 6 5 样例输出： 127 思路： C组这题是简化过的，数据量少了，也多了条件，所以直接dfs暴力就好。当左右差减一大于剩下行数时，说明走到末尾时必定相差超过1，可以进行剪枝。 AC代码：OJ链接1 链接里是本题版本，用DFS写OJ链接2 链接里是未简化的版本，用DP写 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.Scanner;public class test &#123; static int ans = 0; static int num = 0; static int[][] map = new int[510][510]; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); num = sc.nextInt(); for(int i=1;i&lt;=num;i++) &#123; for(int ii=1;ii&lt;=i;ii++) &#123; map[i][ii]=sc.nextInt(); &#125; &#125; dfs(1,1,0+map[1][1],0); System.out.print(ans); &#125; public static void dfs(int y,int x,int he,int cha)//y x 和 左右差 &#123; if(x&lt;=0||x&gt;y)//剪枝 越界 &#123; return; &#125; if(Math.abs(cha)-1&gt;(num-y))//剪枝 左右差大于剩下行数 &#123; return; &#125; if(y==num)//到达最底层 &#123; if(he&gt;ans&amp;&amp;Math.abs(cha)&lt;=1) &#123; ans = he; &#125; return; &#125; dfs(y+1,x,he+map[y+1][x],cha-1);//左下 dfs(y+1,x+1,he+map[y+1][x+1],cha+1);//右下 &#125;&#125; 试题 I: 作物杂交时间限制: 1.0s 内存限制: 512.0MB本题总分：25 分 问题：作物杂交是作物栽培中重要的一步。已知有 N 种作物 (编号 1 至 N )，第i 种作物从播种到成熟的时间为 Ti。作物之间两两可以进行杂交，杂交时间取两种中时间较长的一方。如作物 A 种植时间为 5 天，作物 B 种植时间为 7 天，则 AB 杂交花费的时间为 7 天。作物杂交会产生固定的作物，新产生的作物仍然属于 N 种作物中的一种。初始时，拥有其中 M 种作物的种子 (数量无限，可以支持多次杂交)。同时可以进行多个杂交过程。求问对于给定的目标种子，最少需要多少天能够得到。如存在 4 种作物 ABCD，各自的成熟时间为 5 天、7 天、3 天、8 天。初始拥有 AB 两种作物的种子，目标种子为 D，已知杂交情况为 A × B → C，A × C → D。则最短的杂交过程为： 第 1 天到第 7 天 (作物 B 的时间)，A × B → C。第 8 天到第 12 天 (作物 A 的时间)，A × C → D。花费 12 天得到作物 D 的种子。 输入：输入的第 1 行包含 4 个整数 N, M, K, T，N 表示作物种类总数 (编号 1 至N)，M 表示初始拥有的作物种子类型数量，K 表示可以杂交的方案数，T 表示目标种子的编号。第 2 行包含 N 个整数，其中第 i 个整数表示第 i 种作物的种植时间Ti(1 ≤ Ti ≤ 100)。第 3 行包含 M 个整数，分别表示已拥有的种子类型 Kj(1 ≤ Kj ≤ M)，Kj两两不同。第 4 至 K + 3 行，每行包含 3 个整数 A, B,C，表示第 A 类作物和第 B 类作物杂交可以获得第 C 类作物的种子。 输出：输出一个整数，表示得到目标种子的最短杂交时间。 样例输入： 12345676 2 4 65 3 4 6 4 91 21 2 31 3 42 3 54 5 6 样例输出： 116 样例说明：第 1 天至第 5 天，将编号 1 与编号 2 的作物杂交，得到编号 3 的作物种子。第 6 天至第 10 天，将编号 1 与编号 3 的作物杂交，得到编号 4 的作物种子。第 6 天至第 9 天，将编号 2 与编号 3 的作物杂交，得到编号 5 的作物种子。第 11 天至第 16 天，将编号 4 与编号 5 的作物杂交，得到编号 6 的作物种子。总共花费 16 天。 评测用例规模与约定：对于所有评测用例，1 ≤ N ≤ 2000, 2 ≤ M ≤ N, 1 ≤ K ≤ 100000, 1 ≤ T ≤ N,保证目标种子一定可以通过杂交得到。 思路： 暴力…感觉应该是过不了全部样例，但是网上也没有判题数据… 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import java.util.Scanner;public class Main &#123; public static boolean f(int arr[],int i,int j) &#123; int count = 0; for (int k = 0; k &lt; arr.length; k++) &#123; if (i==arr[k]||j==arr[k]) &#123; count++; &#125; &#125; return count&gt;=2; &#125; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int N = scanner.nextInt(); int M = scanner.nextInt(); int K = scanner.nextInt(); int T = scanner.nextInt(); int time[]=new int[N]; int Ztime= 0; int s = M; int start[]=new int[N]; int ZJtime[][]=new int[K][3]; for (int i = 0; i &lt;N; i++) &#123; time[i]=scanner.nextInt(); &#125; for (int i = 0; i &lt; M; i++) &#123; start[i]=scanner.nextInt(); &#125; for (int i = 0; i &lt; K; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; ZJtime[i][j]=scanner.nextInt(); &#125; &#125; for (int i = 0; i &lt;K; i++) &#123; if(f(start, ZJtime[i][0],ZJtime[i][1])) &#123; start[s]=ZJtime[i][2]; s++; if (time[ZJtime[i][0]-1]&gt;time[ZJtime[i][1]-1]) &#123; Ztime+=time[ZJtime[i][0]-1]; &#125; else &#123; Ztime+=time[ZJtime[i][1]-1]; &#125; &#125; for (int j = 0; j &lt; start.length; j++) &#123; if (ZJtime[i][2]==T) &#123; break; &#125; &#125; &#125; System.out.println(Ztime); &#125;&#125; 试题 J: 子串分值时间限制: 1.0s 内存限制: 512.0MB本题总分：25 分 问题：对于一个字符串 S，我们定义 S 的分值 f(S ) 为 S 中恰好出现一次的字符个数。例如 f(”aba”) &#x3D; 1，f(”abc”) &#x3D; 3, f(”aaa”) &#x3D; 0。现在给定一个字符串 S [0…n - 1]（长度为 n），请你计算对于所有 S 的非空子串 S [i… j] (0 ≤ i ≤ j &lt; n)，f(S [i… j]) 的和是多少。 输入：输入一行包含一个由小写字母组成的字符串 S。 输出：输出一个整数表示答案。 样例输入： 1ababc 样例输出： 121 样例说明： 子串 f值a 1ab 2aba 1abab 0ababc 1b 1ba 2bab 1babc 2a 1ab 2abc 3b 1bc 2c 1 评测用例规模与约定：对于 20% 的评测用例，1 ≤ n ≤ 10；对于 40% 的评测用例，1 ≤ n ≤ 100；对于 50% 的评测用例，1 ≤ n ≤ 1000；对于 60% 的评测用例，1 ≤ n ≤ 10000；对于所有评测用例，1 ≤ n ≤ 100000。 思路： 这题还是有点难度的。根据题意，我们可以发现每一个字母所提供的f值(权值)，为与上一个相同字母之间的差值乘以与后一个相同字母之间的差值。例如样例中的ababc: 1234567891011121314151617ababc字母a : 无前一个相同字母，前差值为1 与下一个字母a之间的差值为2，后差值为2 总权值为：1*2 = 2字母b : 无前一个相同字母，前差值为2 与下一个字母b之间的差值为2，后差值为2 总权值为：2*2 = 4字母a : 与前一个字母a之间的差值为2，前差值为2 无下一个相同字母，后差值为3 总权值为：2*3 = 6字母b : 与前一个字母b之间的差值为2，前差值为2 无下一个相同字母，后差值为2 总权值为：2*2 = 4字母c : 无前一个相同字母，前差值为5 无下一个相同字母，后差值为1 总权值为：5*1 = 5则答案(权值和)为：2+4+6+4+5 = 21 根据这个思路即可较为容易的解出本题，记得最后要用long类型转换，要不会爆int… 代码： OJ链接 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.util.Scanner;public class Main&#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); String s = sc.nextLine(); //前数组 int[] piror = new int[s.length()+10]; //后数组 int[] next = new int[s.length()+10]; //答案值 long ans = 0; //中间值数组 用来储存每个字母的前后值位置 int[] temp = new int[26]; //初始化 for(int i=0;i&lt;s.length()+10;i++) &#123; piror[i] = 1; next[i] = s.length()+1; &#125; //找每个位置字符的上一位 for(int i=1;i&lt;=s.length();i++) &#123; int t = s.charAt(i-1)-&#x27;a&#x27;;//计算出数组位置 piror[i] = i-temp[t];//计算出与上一位相同字母位置的差值 temp[t] = i; &#125; //初始化中间值数组 for(int i=0;i&lt;26;i++) &#123; temp[i] = 0; &#125; //找每个位置字符的下一位 for(int i=1;i&lt;=s.length();i++) &#123; int t = s.charAt(i-1)-&#x27;a&#x27;;//计算出数组位置 if(temp[t]==0)//说明是第一次碰到 &#123; temp[t] = i;//标记 &#125; else//不是第一次碰到 说明上一个的下一位找到了 &#123; next[temp[t]] = i; temp[t] = i;//标记 &#125; &#125; //计算答案 前差值*后差值等于当前字符的权值 累加即可 for(int i=1;i&lt;=s.length();i++) &#123; ans += (long)piror[i] * (long)(next[i]-i); &#125; System.out.println(ans); &#125;&#125; 试题 B: 寻找 2020 附件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300002000000220202000222000202200222220202202020002220002020022202200220220202002002220020200000000220022200202222022220222000022220220020020222020022220022220220000022022002020220002200220020020022200020222020200200000020220020022002202000202222020220020020022020000202022220222200022220000000020020020000020002002200002022222200222002020000200020220000022020002020200000222000000202202220222000222202200202202200200222222220202022020022002220200022020200222002220202202022202222002000220202200202202022000000222220222200200022220202200200020202222202222220022202220020002000000200022222202020020222220220002002202200022020020202000220002000020220202222020000020022222002000002222220022022020002022200020022020202020022200022200202202220200000202020220022200222020020222020020022200222220222000020202000020022220222022202222002002002000002020202200220200222202002002202002020202222220020002020220200000022200022002022002220002002222022020220002222200002002222002222222022200002022002002200220020002220002020002222222022020220020200000022022022220220222002222220000022200002002020000000022220202020020222202222200200220200220222220020202020002022002222022022022222002200220202202002022000022200020220000202222202222222000000022222022202022220000222002002000022202022002220220220022002002200000222200222002222002220000220022002202220222220222002002220200222200020222000202200022022020002222020022202002000200000222200020222020002020022222222222220202002200200200220020002020200000020022000202002000022000020200222020020222002020000022220022020220002220220220200222222000222222002202002200002000220022220020002200020020220002000020002002200200200000200200220202002020022202002002222222222200222020020000020220002222020202202222220202220200202002202220020220200000022020222002222020200200022202202202200002020222000220220200222000000202020022200022002020222220220200202000200200202222020020200220002200000020000002022000020020002220202002222220222000220220222222000002000000000002220022000220022202202202020222202202200002220200022222002000020020220200002200202220022220020002220020002222220220220200022000022002200222022222020022202000002222200002022002020220000220200000002002022000000022000022202022200002000000020200000020002202200020200002200000202002222002220020220200020222002000022002022020000020200000202020200020222200020022222222000222202020200200222000202020020000200022020202202222002020200002202020200000020002020022202222022220002222022222022200200002002220020220220222202000220022002220020022000202022022222200220020022202020202202222002202222000202200020020222222200202200220002222200220002202202220222022222200002220022002222000220002020220000220220022000020200220200022000202020220200222220002222000220022000222020020202220220002000002200222220002000020000000000202202002222022202220220200020202202200220202202022022222020220202202020002222200002020220202022200002222222200020022022202220000020002022020222020022022222022202220222002020000002022000020220020220222200200002202002220222002200222022022022200200220202202200200220222220022022000022000022022020200222020220000220220020020000020222022222002020220020220222000202200222222200020022002220222222002222200020002000202022202220222202020000020022202022002200020220002022022002002000022020202002020022000000220202200022022200020022220002002202022020200022222220022000022202220002202200000220000020220000020022200200020020222000000200022000202002022200222200222000000000202222200222022020202200020020202220022200200022200222022202202002202020222022002022002222222020202022220202020202002222222022220220002220022022002220022202002222002220022002222002220222000220000002200220020022000220022222220202200020022000222022202220220022202222020002020200202202002222022222020220200020000020022020022200000000000022202022022200220222022220222020000020222000200022202202220202002002222000220202220200220000220202022000202222020222000200000000000002220020002202202002220022220222002220002200022200002222002200020200202000000222222220022222200202220002222220000000220220022200002200022202022020200200002202000022202200002220220020220020022220022200000000220200200020022020222200202002200220222222202220202220002022020022020020200002022200222222020002200202020202220200020220220002002022022020022200202000220202220220222200002000020222022000002220020002002022022200002200000222222200022002222000200000220220220022022020022000200220022220002002200002022020200220000020000002002002020222202000202022220000220200200200020002002200220202000220002222002200200202222000020022220222022022002222220200002022222000020002222220200020220222220022220222220220000202022020222022220202000002222000200220202002202200022020220002220020022002202022022000000222020220002222222002020222000022222220200020000000200020200020220220222220020000222000220222222222200222202000200202020220002002020022020022020000202220202022222220020202220220202022220200002000222200000200200220002222202022200022020222022202002000022002200222222000222000202002022222020220202200020022220222022000002020022002000220220022202220202002200202000200222002000202200202222220222222002202200002220020220002002020000002002220020022022020220022022202202220202222222200020020020222222022020000000220222000220020202022202002020200002002202200200222022022020022000020002000222022000200000020000020002022020020200202200222222022222022000002002220220002202022020222000202002222000022022000000200020022022002002002002022220000022220020022222220002200222002200020202000202222002020020222020002200020002002202022220002022020000020022222200002202000020222220020000022000020220002220000202000220020202002220022000022002202000000220020202002202200202220220022002002202222222020220222222020020000222000000002022000202222220222222002202200200200220002022022000002200020202002020200002002202000220000222002020022020002000022020222000000202220220002022220022222220222002200220222220002020202202022002222202222202222002222200020000220020222002000022002222202220020222202202200202000000002200200222020022220220220202022200200022222020002022002000222000020002002222020002002222222020200022020002022220000200000002000020202002020220200020020002200020222000202200202222220020200020202222220200220200222202222002202200200202002222002002200022200022002200222002002000022022022002220002002002202022002222220020220022000022020020200200000000222202222220222020202202220200220022222202002200022022220002002200000202002002020000000220200222222020022220002000200022220202000002022220200002000000222220200020200002202002200200022220002220002220022202002202020220220200002222002020202020220220202000200020222200200222222000222020022200200200000002220002202002022202202220000222202222220220022002022220022002000022002202202000202002220200002002002000000220202200220202220002200002020000222220222020020202000222200202202020200000022002000022220000200020000202222200222200222022020200220200222200222202022202020222020020020200020222000022022222220222222220222000202200022022002000200022022220002020222222202222020200220200222202220002200002000200202022022022020222020200202020000000020000000220000002002200202200202022020200020000220000200000222002002000022220022220022200202202020002022200202220020222020222002222220020202000202222000022202020202002000222002222222200002220222202222022020200000200202002002202022220000202202020200222022220000202022020020022002220222022020000000020022222022020020200220022220020202202022002220202202202222222200002222020000022022220022200022200002202020022200200020202222000002022200000002222002022000200020020220002020022020020202022022200200020000200222202222000000002000200020222000020002020000202202202000000220202002222200202200222202002220222202002020222000202022022022020000022202200220220222000220020220000020000200200222220000222020002222020220020202020022002202002002022022020200220002000000000020200020200020020002202022020220022202002020022002020020020000202020022022200202202200000202220022222000002020020220202002022002222200200000222022022202000020000220000200200000220220200202200222220220202000200020200020200200202020020002000022000200220222020222022002000022202202222222200220020222200222020220220000202200000002020200202002202020200022002222022022000202022200202200020020202020020222200222200000220002200200000202220020202200222000222202000200020202022222000200022020200202220000220000222202202022020022200022002202020022200200000220002220200002222220200000220202222220020222000202222202000020222222220000022000222022020200000020222020220222222220202002222002200020022002200020002020000220000220200002202202200220220202002020222222000220020202200222002020002020222220222202002020202202200200002202202200022220222002222222000020222022000002022222000022200002000000220200200002000002020200202220222202020222220200222000002202022002200202202200220000222000202022002002200200000200202000200000220200020222222202202002222220000020222202222220002002222002222202222020000220222000200200220020020002022222002000002020220022000022220000022220222222000020000020220022002222202220022202022022000200200000002022222200022220222022220000222202002020222200220020020000220002202022022002222200002002020202220022222000200222002200000002222202202000022000000000222022000020200020200000200000020020002200222220202022222000020022202200202000000220000200200022220200222002000202220002000002020020002002022200002022002202002020220002020202222202220022022020202202200002200220022220202022202000220002002200020222222220020200222020200222020020022220200002022202022200200020002020200222200000020222202020000202022220222222222220200020202000202222220000202222220000200000202222222000222220220200220022202000202200220020002222000002200220222022200000202202220202220022220002002022202022222220002002002002000202002020200202202002022202222020202020000020020220000202202202222200000002022200222220000020000022200202022002202022002020200002020022202022222202020000220022220202002200022202000202000200220202222200022020220002222020000222002022022000020220000220200222022000202000002222200020222202022222000000202020002202202002000200222220002020222220020002200000220222222000222002022222002020200022002000222202220202020202020022200020222002200002222002202222000200020222222002222202000020200022022220020222220202020020000222000022220200022200002220200000220000200002002202022202222022020220000220202000020222022222222000020220020200002222002200202002200000020200202020222020020020002222200022002220200200022002022220022222222002220220000222022020222202000200000000220002002000200022022200002202002002220000022002022220022220220200020220020202022022220000020202002222000222222022002222200220020002222020020020220002200220202222222000202222220022002222220222022002222020222200000022002000220200220222000002022002020222202000020020200022000002200200222202202000020220220202220002222020000020200220200020200020022022002202022220000202020220002020002200220222002002220222000022022200000020020022002020000220202202002000002020020222000022000220000200002020202020022022200020022022202022000020020022000200222222020000220202222200022000200202002020022002000202002202220022020022022220020220220200002202022222022002002200200200020000002200222002202200020200202002220000022200200002020220222200000022200022002000000000002222222202220220220202022000002002222222020220202002222020200020020002220000022020022202002002202220020200222202222002200020222222202220200020202020002002202020002220220002000200200020020022000202202020000022220222222220000200222202220220020222202220000200020200020220202200222200220020200200020202020222202220202020000200220220220000002000200222002002002000022202022202222222002020020220000000220002220022202220002000002002000202220000220000222020200020220020000200020222020002222220200200200022202000202222222222002202202200200200002022020000202000200200002222002200020202020220020222200000000020000222222222202000002020002000020020000000000022000220220000200202202000200020002000202020022020200220202222202000020002002020002220222000202000022200000222222022020200222220002020202220202000020022000020022002020000002220000000002220200000000000002020022200220020002220220022002020200220020000222020020020222200000222002022202020020222020020202202202220200222020022200222000220202202202000222200200220000222200200200022022000022022000202000222222022022220002020202202022202002000220200202022020022000000002002002220220222002200000002000002002000222202220022222020202202200220002022002002202222002202200200220022022200020020022020020000220220002220002220022022222220200200022222020000020000000022002002020002220000220202000222200200000202002220020202002220200222002000220000000022220002222200002200002222222002000202020002022022200022002200220202020002220000002000202020200002002020000002002020002220020222002020200000020000022000022022222002202020020202022222220022000022200222022002000220000220202202002000202200222200220222202002220222220200022222002220200202002020002022020020222000220202222022202000220220020200000220202200222022222202000220202022220220000020202222222022202200202220002022002002202220200002000202022020002202222202220222022022222202222002220002020022022022022000022000202220022220220222202022222002202220022222020222002202200022002220022022020022002202000002220222222022002220000200022200020202220222022202022002022202200000000000202000022202200020002022200000222020000222002002002002200220202002000000202222002000200220222202220020020002220222000002202200022220022020202002220222002200222022220002022000222222000000000000000202220000222000200022202000202200222022000220202202002222002000022200202022222220202020000020000022022022200020220202200002220000222000200002202222220220002222022020222020200020020000020222020202022200020002200222002022200002220202022220022022020200020202020000020022200020000002222200022220022000222022020020020222222220222002202020020202222020002022220202202022002000220022020200220220220020002202222202220222002202200222200020022022200020222202202202200200222000202000002222220202020000202002220200200222020002200022000200020202200220002202222020002000020002000002202202220202220002022222222020220000000022200202002022000202002202200022022002202020020020022020000022202022200000200200022000220020022002022002200220002200200000222200202002000022202200022020022020200222220222200002000200200222000200200222022020022222222200002202200222022000000002000022000002220202020202002222020202000020020002022000200002002000200202222020222202200000222222220022220002202000200002022222022222002022222220020202222222020022220220002222022022022200202000000202002000020202200202200000022022200200220002220020020002200022022220000200002202002002200200222002000220020200200022002202020000202020002002222002220200200200200222022000002002022220002202002002002220000022222220002202020220002002200002020022220000220200222002022202220202202200222202220200222202202202022222020022200200220000022220000000220020022222222002022202022200202222020200022202220222200020022202222222020202200022002222000220002202022020000200222022220022200202002200020202222202000000000222200022002002002020000020022000222202202200220000220220000022200020220200200022000000022022000222022022200020202220002002200200220202200002022220200020222020200202022022002220202000220000202222200020002202022022200222222222020200022222002222200022002222222000202020222022200220002000020000022020000202202002200222202002222220222220220020000020022200220022220222202222202200220222220022222222020222000002202022200200222000000222220002002002222020200022220020020002002202200022222220000222200200202000202200202222202202202222200022200200020020220022202220000202020000020000000000220200020220000000002202000020022022020020020020020202020220202022022200002022022002200002202220202002022002002202200000200202200220222220020200220222000022202222022022020202200222000020020220220202222000220002200000000202202002002022200222200022220002022020002000202000000002002022002020220022020000022200200000000000000202202020000000022022000202020000020022222222002202202202000002000222020022002022020020222220202002000022200202222002000200222002220020202000022000002002202000002002002000222022200000202220020202222000220020000222200200222022000200200222222022220002020000202220222220202220002222022020002022220000022200202220002220022002000220222000002200222202220200200020022222000220020200002022222202002220022000022200220202000220000020020020000220002220202220002002002220020002020000200022020002022220202020220022202022200000220222220002200222022000020020020020200200022200220222222220022002200000220000220000022022020222002002002022000000200022220222020202022202022220000200022022220022222000200022000220020202200202222222020002000220222202002000020222220022020002020020222200020002002020022022200002200020020202202220202022020202020202022222202000202022002022002002022200202022000020202000022022022002222200220200222220200202020020022222020220000000000220222220220202220222000220020220022002222200000200020020202202020002022000000002202200222022020002000202000222022202000020002020220222200200202022202222020022002202022022200020002220222002000220220202220022222002200200000222202202222020000222202220222220202222022222200020200020022200020002202002000002220000202220200002202022200000200202220202200220022022020002200022000002202200000022222022222002022022220202022200220220200020022202202020000002022020000202200200000222020020220002000222200220200220000220220200020202000220020222022220020202000222020022000020220020000002220022222020022200022200020022202000020000200202202220200020002000220000000000220020020002202002222022020200022022000020002220022020020222020002220000222200000020022022020022220220200202022202020200022022020220202000020020220020022220202200000220220002000020000200222020220000222020022220022220200022022200000002020002022222000020220020020200022000020022002220200222202002022020002020202002002202020222002202202002020200020202022200220020200222002222222022200022022200222222220020000002220222000002002022200022020002000202222200200002202202000020200202000020002220002222200022020022202200200020220000002022022200222002220020202222220002002222222022000220220200020220220222202220200202222220000000000202022000020000220220202202200022222200000220200222000200222020220202022200020022000000002200220000220222202000002022222022002020222202202220022220022200022222220022202022202000202022202002020020220022202202022220220222220220000202200202002020000022202222020000002002000200002002000022200200220020022002020200202200200020022020202220202202220200002020200002220002000022200000000220220220022202000002000022202220202202202020002220000002202202220022202020022002200202000022022222002000202222202200222022222202022022222000022020222020020022020022202000020002202220200020200220202022222020202222220022220200202022022200022022002222222002220200222222202200222020202002002222022202222000222222202020200022000222000222200202200000020202020200222220000002002002200002020220220220002022202000020000020220020200220222000200002002002202022220220220222200000022200202222000022002202200000000002200022220000202000000002222200222000020200020000020202022220022002000000002022000002002200022000222220220220202220022022222200002222022222000020200022000000020002020202000222002022220020222002202220200020000022200220202002222000222002000200000002222020202222222220020000202000000220202200202020220020020200022002222220222200222020222222202020220220220202022000020020022220000002220200200002000020220002002000222200220222002222200222000220002020022000220200200200222020220220022222020222220200022002022200022020220002002200222222020222200020202222222200220222202022200222000020020022000000200020200000222002022000200000020022002202222002022020202002020000000022222222222202002222020202002020222000202222222020022220002000200220020202022022202202200020020000222220002202002002000222002200002020022222022202002002222022200222020202220002000020000020202200000022022200000220020202202200202200022200000202200200022202222220220020202020000000202222022222020020000022202022020020222020220020022202000022220020002002202200000220222202022200200220222200220220000020202220202200222000022002020002022200202222022002222220220022220022222000020220022222022220222000002022000222020202200200002022022200202000002000020200002002000000202002202222022200202022002202200222022202002222202022202020202020200222000220022220022000020020200200202200020222000200220020020020020220222022020222000002002220202220020222200020000202222002020022202220022020000022220022222002000022220202220000200022022020002200002222222000022020020222002202200220220022000002002000220200002020000020220020220200020200202200000200220002020020202202020222022022002220020022202202000222222202022022020022202222002020002022022200022200222022022020222020222002202222020020200220202002000000222002000002000202020022222000022002020002222020020020200222000022000220022000022220020002022002220002000002002002202202020222020202202022000202222220022220220222000002000002222200220222222200020020002222000000002002022202020020200220002022202200202220220220020202202002022200202222220202022222002200022002200200222202000202222000020000200000202002022220220220000200022002020220000200022020020222020202220220222220000200002022222002202020222202002020000000200002022222202220022222220200222000202000202222222002202022002202202220020002202220002202222002022220020000002220200022200200220202220022220022022222002220220002020000000002222020222200002022222220220220222222000200002022220200022220220200000002200202220222002002200002220222000020002002220022022202222200000220200000000202220002022202222000222200222020000222000002000222022202022220202022220002020220002222000220002002000222022222020022220022220222002000222000022200020020002020222222020202002200020002202200022022200022200200200200222202200220002200020002220022220222220020220200222222000222220220020000220022222202202022020020022200000022200022022002020220000000000020200200202220022002200020000222200000022002222000220200002000220220000002022202202200022200202000022202000002000002002000022002222000220200022222220202002202000202200002022200202000202000200220000000020200222000002200000020022202022000020020202020222202200022020022002002202220200202200220202202020222220222000000002002000022222200222002202020222220020002000222022200202020022200220200020022202022222202022222022002022220222000202222200220202000220220222222000220022002202022020202000222222222200002020002202020002002002020022220200220020202020220222202222202222222020220020002200000020002222200222200002000220000002200000222020022022220220000002222022002220022222200020222220202202020020220022220200020000200002220220222220000000022000002202022202022002022222022220220000002020200022000220020022200220000202002202020222220022202222000222202022220000220220020222220222222202202020220202220200002200000222020022220200000200022020000020200002220002000202000202202222222022022000000220202202222000020000022022222020222020022020002000200220202200202202202200000200000000200000202202002022220222200002202220222222200200222022020222220222220020222000202020200020022020000222020202002002000202020202200220022202220222000000022000022220222220020002222200222020202000222202222020220000022200000020200202220220200020002002000220222220222020222222202220020222222020002000020020220002220222200002220002020220220200220200020002200220202200220200200000002202020022022222220200222220000220022222222222000222002220020202020002002000020020020200222020220000002002022022222200000202200000222220202020220020220222202022202000002202022220200000220200222200000220222220000220202002220202000020222202200020000200222200200020220002022202020002202222220200000022022222222222002202002202020200202202200220000222020000002200222222002220000220220000202220222220202002200002020022200002022222222202000020202220200200000222200000222002202222222200000220000000022220020222022020020202002022000000002202200220222202200222222200200020000220002222222222202002002022000200200222220222020022000022222002002202222022202000020220020020002022000222202000000002200222020002022200000020222200202202022000022002002200020000022202002022002000202202200002022022000200220000222220222002200020202220220000220202022002200020200222002202220222200202022202002222000022222200220220202002220200002000200000000202002200000222000220000022020220002022202000000022000202222200022020022202000002002002202000200000002222002202022200202202002222002220200222220020222000222020020002222000200002220000002000202000002000222200200020002220202220222200020222220220202200200200020202000202200022020200220222222002202000002000200220222020000200002000200020000222202220202222202002022022202000000022222200220200022000202000222000022202000020222000000002022220202002222222002220220222020020222222222002202002000000202020202220200200022022000200222022220002000000202200020000022002022220020200200222200020022022000000000002002022202022020002202020202202000000220002220200222202022200200002002002200220000200202222220002202220002002220202222002002000020022020022220200220022000022002222220002020222000002022000200020022200022022222000222222220220200002000022222222022200000000220220202200002202002202022202220200020002222220020222022000002020220222002200222220202002202002222000200220200002222020202200022000202202002222220202022202020200020220200222022220022020022202002202002220200020200002222000222002200202202220020022000020000002220220200202202222020002220220200002202222020000020222000222022020000002220200002020000200000222022200000202222002002220020002022002220022000202000220000222002202000000002222202202200000002000000222222000222200222200000022022020202002202220000002020000022000202000200020022002022020200222002022222200202200002022200020202000222202222002002222222202200220220202200020000022222002000200202020002002000222222202002002200202020000022220200000220222000000200000002202222220222022220202020022222002000020220222000002220000200222022202222200220020000202220202222020222000000022220022020000002002020220002222022200000202222002022222200200202200002202002002020200222002202000002000022022200022022220002200200022002220222000022000022202200222022220200220020002200202002220000200202220022222222200222022020222000200002220000020220220222000222200022220202002002002020020200020200220222200002200200222020000000222202202000200220220200202220202222000000022022220022222200000222002022222200202002000200220000222000202000022222002220000202222002000002002020200220002002022020220222000202020020000022000022002020200202022000022000000202002220220202002022222002202000022220020202022022000220202222202000200000002002200022202022002020000222022022002002202000200000000220220002002220202202222000020000200200002220002002020020020202202002202202020222000022000020002220220220000022020220220020220022202020202220020020200222200020020002020222000200202000020200020000000202220020200222220022022020222022002002222020000220220002000222202022020200002202020002020002220022022002222200220002202000220022220020002220022020220220200200222222022220220000222220002000020002020220000202222020002200022202220200000000202002000022200022200220020020220000200020002022220002220002002222022222220222222022020222200202022200000220220002020200002022200002002020002022200222222200000200220200200020020200022020000022220020020222222202002000220222000202002020202220020220022222000220022220220020020220022202000022020200220220220200222200020222220000200022002000200220020002002002220000022202020202022020220202002022200220202202002222220020022200222202002222002200202200222000022200022000000022022020222002220002202202022202020022022202222202022222200002200202022002000200002200202022220200200020200020220202000000222020220222002222222002020002202020220220000002022200200202020200202002022020002022220222002020022222002222202000202002202020200220002220000000222002200020220020202000020002200200022022020002200000000200220222222020222202002022002200022000200002220022022200020220200022002020202220000202002202022020000000000200220222022000002202220000002200020022020000022022220000222022020002222022000202020220202200220200002022020002000022202202022202002000200220002220020222020220222202002020200022000200220002002020022222220220020002200222000200022000020022200222022222220022022222202020220222200200020202020220200020000022220000020202022200000202222222220200202202000020200002202220220000002220020200020020002020200000022202022002020000202022022002002020202200200002222022002020000000002020220002022002220002020002222002020222000202020220000002022202000000022222002200220220002200200000002200222222000000002020002002022202220020202020222222022000000022200020000220220200200200000220020222000202000020000220220220220222220202222000002022020022020000020020222220000000000002202022022002200220220200222202000200020002022222202200200002020202220002222020022022200000220220002022222020020000202022200020000000222222200200020002022020222000022202002020220000220222000000200220000202022022222202222022022200220022222202022000002222000220200222020200002020022202220020200000022202022202222200200222002020222000020020202022220202222202220200002220200022202222202000002202000022220020000020020022020202200000000020022200222200000202022202022000020020202000200002022202200020200200020000200222222000000202020220000022222002000222002220222220000002002220202022020020220020000222220222020000222200002022022222202020220002022002020220002220020020202002202022200220020020002220022200020220002000002020020020020200200002222000020202220002222000000022202002200220222002202022202000202202220000222020202002022022000020002020022220200202202220000000022020222020000000200200002022022200000200222002220202220222002020200020022202002020002222002222020022022000200022000002000222020002202020202200020002000000000000020220220022220000220200002002222200000020222000000020000022202200220022020022220200000020020020022000020022222202022002202200000200022000002022220202020202000022200200002000000000200022002202002022220222000002220000020002022022000200222200020000020000022200222220200000002222200022202202220002002220202000202200220020222000222000020200022202022222222220220020202200200022200020202222202002202020202000022222002222202222000002200202022222000022022020220000000022222200002220000020022202202000022222202020000000220202220020200020002220202202020220222000002020202022202200220020000200000200222200000200022020200002200222022022002000022020202222002202200002202000200220200220220220000222022222200020220022200200220022022200202222202022002222202202202020202020002000002200200222000220022220220202000220222002200000022000000022022200202000002202000220020020000200022002020020200220020222002002202022002000220200000020020000222200200020202200002002022222020200222222020220222200022020022222022222202020222002000200020000220000222022222222220020220220220200202002202002000200220200020022002220222022202020200020020200202002220020000202220020002020222020200220022020202222202220202222020020200002200022002202020000222200022222000222200202022020202002002202002202022222200200022020002020022002222202202022202002222220020222000000000022222222020022000002002002202222002222002222222022220000222002020222022002222020000202202020020222220022020000220220022200002002222222002222002222202222220022202000222222022002200022020020022202000222002000220222000222000200022000202002220022222222200020022202222002000022200000222202202020002222222202200020220222020022202000002222202002222000200002222002022220202022220202000200200020202222220022022220022000020020002022002202202222220000200202002222200220020022000002222020200000200220202200020002200222022222220202222020220222002200000222002220200220000022002202020020200200220202222020202000222020022222020220222020220002220200200022002000022020200020020222222222022200022220000002202220200020202020002022022000002202222002202200222020222202220022200200000002202022222200220200200200220222000202020220202202200002002020000200202202202202022020222020202022000202000022000002202022002220000002202020220200220222022200002002002220200200020200002202020202000022002020000000222022220220022002222000222200222002220020000222222020220220222202220202000022000002202002220022000202022020202000000020022202202020220200222020222000222022200020200200020200022020202002002200200200020222000002220200200220200200002202222020020002002020020022220020222002202220222202002022000202020202020222200002220222002022022222222202022000222000020222000022222202220002220202220020220202002022002022220000200200200202220220002002202000000002222202020022000002220002220000022220200202200022022022020002002220002220200202002002220222020220000000220202222002002020202220000022020220222000000020002222000020002222222022022202222020002002022022002002202202000002022020200222022222020020200022220200222002002022022020202220020000022200200220020002200022020222222020022000220202000200202202020220000000002200220000200202020020202202200020222002202000202200002222022020002220002002002202002202202202202202022000222220200002022020220220000222222222222022222020222022020202002202202020202202002200020200222222000022200022222022220022002202220202022220000200022022222002002002020002000000002000220222222202022222202220200002222202202222202022002222022000022020222022222022222200020222220202002020022022202220202202000020000020020200202002222000020022220220020020002220220200220020022220002202002002020202222200220022002200020200220002200002020000222200200222220020222000220200200000022220000002000020000000222002222022220022202200020022022022222220000222200000222002220200022200220222202002020200220020000220002000222220202200020000020202022000200020200202202000020020020002002002220202200222020222202220222222222002020200220202000202020200202202200200222000222220222222202220000000200022202000020202222202020220200222220222222200002200000220000020200200222200202002022220000220022220222200002222020220222202220220002000000202202200202002222022022002020200202202000222200020200200000222020022002000220002002200002000200202022020222222022020220200022022022002022222022202202200002020022202022220002200020220020222020222222002222002202002000002022200022200022020020002020020002202220202022202000220022002222002020022002022200222202200220002200202222002220200222000222222022002020202022022000220202002000000200000202000220022222222220002200002200022000220222020222200000220220022222000220000022022202220222200020002202220020000022000220200020222220222202022000202220222200202000002220200202220022000200002202200200020000202000222020220222002200202202200200220222022220002202000200220000222022220202200220022200020002200002202000222200022200022220202000020000200202022020220000220200022022020022000222200200200200002000022002000000000222002020002000000220002002022200020022202020022022220002202000020020000202000200002222202002200200002020020002200200020220222000002002000202200202020202002020002220020200000220200200202200220022002222200002022000200020000020020200022002000022000000222202200020200200022022220222200022222220202022200200022000222200000022000222202200020202200222002002002220222002222222222000002002020222020222202202220202000202002020220002000002200222202000000022002200000200000000200020020202020220020202222200000020020222022022220220000022020220022000220002022020000002000220020202002202002200020020000020222220020020220000202200202022222222202022222020200020002220002222222022220000000200002022202222202022222020222220220220002200000022220200020022022020000220202002002002022222022000202020020022020020222220002020000220222220200200200020020002020002200022002020202022022020000200200020220202220200222222200222220000002022200000022002222000220020200020202000022002220220220022020220000002222022220022202000022220020200000220000020202020022200202202222022200000022220200002222200222222020222202020000222000002022200220222220202002022220202222000002222202020200000222000220002220000002022220220022200222000220200020202022002002022002202002200002220022002220222020002002200000200020000202220000000002222002000002000220202000000022222022202022020022000022022022200000022000022002222020000022020220020200220222000202020002200022200000222222220200000220222020022000200220200200000002220220020222022022200200202200220022000022002020022222002202022222220220222002200202220000200002202200222200202000200020220002222022002020000220022002000000022222000002020222020002202000000220200022200000000202000020000200000002202220022222222200202020020000220000022200002000022020020222222020002200200002222000022002020220200202000022220000200222000022022220000022020222000202202020020220022000200000200002202000220020202220022022020022200202002000202000202220022202220022202022002022202002202020220202220222220220000002220222020002220022202000200222002202200200000000202202200022222022202222222222002022202200222200222200200220200200000000022002200022220200002200002202202002022022000222200220000200000022222202000020220000022020200202222202022020020020222002220022200020020222200200202202222220202020020200222220002002000222222020022022020000200220000022002202222220202220002200002202222222020220000020002022202000202000220002220222022022022202002022200020200000222022202000222022222202200200000002202200222022022222220022200020022222000200220202000220022020222200000000022020022020200000220020220020222220002202022020022202220000202200022000220000202020022002020022200000222020002022222002000220202022202220002000020202020020220020022002002202022000002022222200220020020000022020002002222022200020200220002222220022222020200222202000202000002200200200202022000222200000020020220200020222020022022002222222002002200200202000000002000200002200002002200020002220202200020200002020220022202220020002222200020222200000202002000200202200020220220222020222202020220020222022220200202020220002222202202020220200202200020202202222022022000200000022000020022020202000202220022020020202022000222200020002202020202220002222202022200202222022000200202000000202020000000020002002000022020020202000022202020020022200202220200200002202020202200002020022200022200020200000002202000002220002000020000002200022222000020202000202002000002022222002202202200222022220022020020002220220222202200000022222222000202220200002202000020022000200220222020020002202002220222022202002020200000020022020200222020220220222202022202220002002000220222022200020222000002202220200022022022200222000002200020202022222200222002000020002022202002002000200220022000220000202020200202202000022200002202020200202222220202202020002020020220200220220020200202202202022200002000000200022220020200222222202220222002202020000000020002202222202022202220002222220202222022220002002022020022020222002202022020222202020200000002020202002002202220202022022200200222222222022202200220220000000020222222202200220000000020022222020222000000200220000200020200020202022002022222222202020200002002222200000222000000020000020200222220202020222222222022002222220200222002200000222000220222020000222200000222022220022020220020020000220220222202220020202222222002002022002000220200002002000220022002222200002002200000002202200022202202202022202000202200220000000220202220022220022202022222202202020202020022202200200000200220220020200202220020202202002220220220220200220020020200200202222002220220020022000022222200020002022002222002020020200222020202202020222022002020022020220222202220222220222000000202000000002220220000002020222022222220000200002000000000200020020020220002022022022202002020222020202000200002222202000202220000202220002000022020222202020222220202022222200020202002202000220020000020220222202220202020220222222200020022022002222202202022202022020000020222002202022202000000022022020202020002202022022022000000202202020022220222202020220202220020002222020202020002220202022020202022200000002222220202002200002222220002222002220222002000222000022202222000222022002002200200000222222202020020020022020202220220220222020022222200200000000020200022022000000200202200022222000202022000222200020222020002000222222222220200000200202020202220020000202002022000022020222022020220220020002202222220200000002202200000202022002000200002220002002222002200022202222020200220020220200220220200222202222022220020020020202222200022020002000222020020220002202000022020220000002202202202002002202222020222022220000002020002220022000202200002002200020020002020220020022202220200020222200000022222000020202020022200220202022200020202020002200020222220020202222222002200000220222222020200222222000220022202002020020222200220002020220002002220020220220200022020222200220222220202222200202002020002202220202200022200002222002002022200020222020200022000202222202220220222222000020000022000202202022002220020022222002002200000022020022200200000002220222200000220000202020002220000002202022022002000222020222220022020020200222222200202222020000200002222200202002202022000022022222020200220002202022000002200020202202022022000022200002000200020020202000202202002000020000222002000002000022020202020022020002022020000002022222200020202022020220202020002222202200002202000000200222222222002200202022220002000002000220000200020222220020200200020202200020200020200022202020200002000200222020020202022022020202222002020022222200002022000202222222000002002020200000020222022000022020222200200000200202200002000020200222222000220220002200200222200202000222022002022222020000020222000020220200022200220002020002020000200200202202220000202022220022022002200222002000222002200222220002200220022222000022202202220020020002222220220002200020002202220220020222200200200202202020000222220222200222202202200220220020220200002002002020202200000200220200222200222002020202022220200020020022222022222022200222020002200022020200222222022002002220200020202000200000020002202002202020202200202020000020002222202222220222202200002200202202002020002220222020022020222002222220220220000200220022202222222202200222202000022000200220020220002220020222200020002202000202200222202020222202022000220020022200022202222222022200222220000220222022020220222000020020022020200002222220220222020200020220220220220202022220200022220202022002020020200002202002000222220200222002020200200020220202222002022200200002020200002002222000000220022002222022200220000220200220220222002022002222020202222022202220022222220200020200200002202202000002220002220202202022220200202022222202022220202202002020020202002202020020222000202200000220222220002200200200200202220202202202200220000202202020202020220222202202202002002002220200200202022202020002002220022020222220220222202200222020000220002020220022022220000222000000202002022000002000200000220020020002000220220020002020222202020222000220222020202020002202200222220220020202020220022020222020002002022220220220000020220200002220002202202200020020000202000202222220002200002020002202020222200220222022020222222022200222002222002220222220002002000220000222222000200202000002022022200220220000002220220202222022022202002002222002020020200002020002202222202202020002022200222000000020222202222002222020220022000000220000220200000222002200000222202022020022202220202002202200222200002222222002022000220200000202022220222202200202000022022002200022200202020022002222020002202220020200020202020022200002202202220222022200022022222222200000002202002002022002222020222022022000002000002200022022022022202200002022002020222200022220002020200220220202020220020202200020020222002020022002220220220002220000222002002000020022002022222200002200200000020020222020002222220002202220022022200222022020020200022200222020022222002200002020222200020002222200220000220000002202000220022022202200220020200002020222202002202022022022002200020200020222022002200020220000020000202000202020002020202200002022000020200002002200020000200202220002022022222202022020022000200202222220000222222200002202202202020220022200220000200002222020000002000002202222220202002200200202202020202020022200000000200202002000000020000220002200220020222020022222222002220222002220020002220000020200200000200000222222002202022202002222000002222220022202202200200002202002202222222220220000200000220202000200220002222020200020220000202202022200200000200000200022020022000022020220002202000222202222000222022022022222220002020000200200002022020020200020020022220220000202202000200022000000000202222022222202022022002202222220000002200000222222220022220222002202202202222022222020022022022022220202020022000220222002020222000002000220002000200020200000222202200000220200220020020002000200002022002222200222202002000002200000220000020002000020202220020202222220202200200202022000020200222200020200002000222022222022200200002222000020000002202000022002022002200020222202000222202202002000002200002000220202220020020000002220022020222000200022000200220022000022000200220200022022200222202002022200202022020222020002222220222000000022022202022020000202000020202222020020202002200022020222020220222022202222000202202200002000222000202020022222200002220020000220222000202022222222220220020000220222222222220202220220220002020020020000002220020000002002000000000202020200200022000220200022220020002200002222200002200222022000000022222220220000200000002222222220200002220202000202222202202220000202220202000220002202002222022200202220002220000020002020220222202000022202020000022022202002002222000002002000220222020220002022020002022200002000202022000222020002000020222022202220200022022000002222202000222200020222222022222002000220222022020202020000222220200000200000022222020020000002022222002202000202220020000020222200202022222220202000020200200202200222222002000202220020200022022222220200202000222020200002022202220220220200222222222020000220220202000000222202222022200022220200222002202220002222022200022000200222020202222200200222200222000002002022220200022220002200022000020022022002002000022022002020220202000000200200022202200222002022000220220002020202222202220000022222022220002020002002000220002020222000202222022220020020220020002202200200022222222002222222022000022202000200200000002200202200202200022002202222220220220020200220220020200002220020220022002202022000002022020202022220022222202002220000222000020002202000020020000020002202020222202020022202020202200202222002200202000022220020220020020000022222220002200002022202202202200000020202200222022200020002022000000222220220200200022000020222000220202020022220220200020200220220202202222220220202220222022002202222022200020022000202200202002000020020022220000000220022202002000200020202202020002022002002022200000222020200220022222002200200202000002000020020000000000022222022200200200220002220022202200220202002022022202002222020200020022002202222220220200020022220222020220200000202200202200000220202020222000222022022022220222202220022022222200202022022202202202002020020222002222002022000022022020222022020000222002002022020200202220202202202222002222000000020022022022200202222220000002020220222202202220022200220002202020200000220200200000220222200200022200200202220200202222020002002022022202022220222002202002200022002022020202222022020022000002020222200002202222022222200200022002002222220202202220222222202202002002200222222000202022220220002020020220022022000200200222200200020202222022200000222220000002202002200002202222022220220200202000000022200020020000220020222200202222000200000000220202000020220200200002200202002200002220220020202002200022220022220222220202020022020002220200022020022220000000222200200222202202020220200222222020200002202020020022202002020022202220202222222002202220200202002022002200000200202020002020020202000020200200200222000220222202220222222220002220000020020202022000202222002220200200022202022222020220220202220002000020002022020222200222002002000202222202202200022202020002020020200020022000000220222222202020002022220002000020000002220022202200002222020220000002202202022000200020020220220002220200222022000022200000002202002020222002002222200022020200222020022002020000022000000200022220202022000020022000022002002020220222022222220002000202002220202222022222020020222220000220020200220220020020022200220022002202022022002202200202200022202202020000222002020020022002000022222202200022202020022220222000022202020200220000000222000200220000000002020022002202022020202002022202220022000200220222222002022200202022222220220222200222002000020220200020002000222022000220200222022020000202022002002200000222200020220202222022220202222202000220002202022020222220220022200200000002022000202020022222022000222000200000000022022000000002222220002000002222202020220000022200002222220222202202002000000022200020022222200202002220022220000220020222020002002220002202222000200002222202002000202020022022002020220220020222220020020020220200020020220022000002020000220002000202000000000022002022222200000022002020020222220220222022020200022222200200220200202220220222022222002020200000000022222200202000202200202022000220000002220002220002202022000202222220000222220022020202222220020002202222002222202202000002000222202020022202202022002200222000020220020200000202002220020200202220000020000022222000002222002222222020022020222002002222202000220220002220020202000022200000020020220200200202200000022202002020000020202022002202222200220020020020000220202022020000022220002220222002202022020000200200002202202202002020202200020222000200022222202200002220202220002200202022002222202220000202020022000022022200220020202022200222222222022220200202222022202220022222002002222220202220220000202222022200000002202200200200220002200000020022220000022020220020022222022220202222000200202002200220002200000222022202022000002000220202022020000202222002200002000200000222020222220222020220002200022222022000002222000200220202202022020022020222220022002200222202220022200020200222000222002000000020202000002020020202020220000202000200022020022200222002002202000202000220200222200222022222220202200002020000022222200202002002222200022002222020202022222220000220222022220002000002202202220000220220202022002200002200220000222220220002202220200002220020000020220020020000202002022022202220200202222222220002202020022022200020220020022220020002002220200022020022020202200022022020000202020000202200020202202220000000220000202002202220200002020220220220200000000020220222222220000220220020200022202222020220220002000002022202220202020220200000202000002200022000222200020000220022220000222202022002222020222022022222222200200002020002222200020022022222202200202220002022022020220200222220002222202000200202022200202202000022020002022002202220202220002200020002020222002220200002222200202022022222220000002222000222002022222220000020202220222002000022200000200222222222000222022020000202000200022002202000222200000202002202200022000002002000000020020220002020002020002222020000002202200020202020222020220002000200002002000020220020002020002222020002022200220022022020202200020002220020220202200202202002002220002000202222002000022020220202202022000222000000002020022022202022222202220002202022200200020220220222000202022202220220000020222002200020200200220000202002020002220222000022220002222020022020220200222202200220222022022022000002222020002002000002220200022000022200222002220022222020000220222000022000000020222000000222022222200200202202222000202022222022020000022020202002222022020022200020222022000222200220222000222002022222002022000022222020020222002220002002222000002222020022200000020002020002202202000022200200222222002020020200000200200200000020002200202022020002202020002220022202220202222220002220020222222020220022222000022002002220220200202202020002000020200022220002202220200220202022000200200000222022000220020220000002002200202222022002002000002002002220022202002202200002020220002220020202002202020002002000022202020222220200002202222000022200000002020000202020020220002020200220222200020020202200000222002202020000220202000020220022220222200202222000200022220020002002002222000020002222222002202200002222022002000000220222020022002000202220020200002202222220220002022000200022000022202002000202002020222220002200020220000022220022020022222220222020200200222020020022020022000000002000002202000202202002200202222222200022000020220200200222022020022022022022202222202022202222000000000222000202222020200002202222222002020220000202202020000000202022002202022002200020002200000202022202220000002222002000200202200202220000002022020000222020220020200000220222022020220200000000222220220000202220020002000220220000020022222220200222002000020022022020200220022222000000022202000000002002202002202202222200200200020022002000002222222002222000022202020020222020002020020020020200020222202020022020220022200222000220202020022020022220000202200220200000220222202202000020022022202222022020200220200222222220222022202002200200200202222020002020002022022020000200020000202202222202000220020202222000222220002002000022200222022000002200220022202022002222202002002200020202020002020222202000020220222022022222202200222002002202222000000202002022202202020220202020220022002022022002000222222220002002222222022020002000022022222222202220022202222002200202222222200020220000002020202220200022200002020222022202002020020020222022000002202000200022020020220002200022000202220022000000202000022222000202202220222020202020022220200000202202200022022022022000000022220220020222202220020022020222022222222220022022220020002022222202020020200202020020022000220200022202202200222000200020220200200002000202222200000220022002020202220200220220222002222200200220200220022022022000202200222020022002000002202202020022202000202022220000200020222020000222200000000000000022200002200220020022022022220020022000222022020222222222202000200202202222000002020222000222202022222002200022202200022022222022022200000220020222000202002022202020002220220000220000000002000022000200002220002022222020220202002000200222222200022002002020022200220022000200020222002022002002022000202002002202200202220200200022200220002222002022220022020022220202222200002222220222020220022200200220000020222222202220200202002020220222202202022002202002022222022222002202200000202022220222200220002200002020200222020200202002200000200022222220200222200020202002202022020022020222222222220000220220202200222020222200022002022022200222200022000002002020000220020002002022022020222200202020020020202220202222020202202222222200200022202222020022022202200020022220200000222002222200002002022200200022220020000002222022222220200022020000220022220220000002022222222000020202220020022020020222020000002020002022200202202200220020202222200000002200020200000022022222200200200220002222022222022200022020200220222000000020202022200220002002000002222220202220200020002000220200222220202200022202020020020022000020022022220220202000202022222020002002200020020020002220200202022020202202200222222220022200000002020200200002220020002022020200022222020202000220020202022220020222022222000022220002000020202220202202220222022020200000202022200022222002022020020002002202020002000220002000020202022022200202002220000000200222022000202220220202200000002022022002002020000000200220002220022220220200002222200202000000220200202002022020220222022220020222222200200220200202200002220202200020022220022200022200200022222022022022222022000200022202222220202020200022202200000202202200020200000202222220200202202220002022200222220200002220020202020222222220000022222200002200200002200202000200200200020220002000220202202022200200002020022000200020002002000020220220000000222020222022222022222020022022020222020222020020022202022220220020202222202022222002020202000000020202002220000002200002202200220002002020020222202002020020020222022002202022002202202022220002002222202000200202220202000220000000222020200222220022002202002020002200202000202200000000022200000222022022222002222020222000220022222200222200020200002202022200220000022000200200002200200002222202020000002220220022000002002002200222000000220202022020220022200220000000022022222022002022202220220000200222222200220002202220020222020202200002000022020020002020020000202020020002002220200002000202020020222002002022022000000022200002202200200200220220220202022022002002202202002220200000202022000000022022000002220222200002222220020220220002222202002022000020200200220200000200002000222202020020022222002222022200000200220020222020222222022220022220220002200200222022222000002022002220020020000020200222222202200002222202200022020222022222002202020022000000022000202020020000022222222020020220220000022220222220002022000022020222002002000220202020202020220200022000200220200200222202200222200220000020022000202222200002220022222022022002022002220200002222002002002222220022202220020222020202220020022000220000220020002002222222020022000002000022020202200220020220220200220020222220202000020020200200202222202200022222002020020202202200220002200000222002222200002002000200200020202000020200200222220200022202222202200202202020000002202020002202222220002222000200200020000222020202000220202220000222220020002022000000020020020022222200222020202202222022020202000020000022220020222200022222002002200202200020020002222002020200022220200202020222002022022222202222000220002220220200220002000022222220020022222202222022202202002002200202222002022000020222222200002002022022222020020022002200022022220222222222002000020202002002220222002022000022002022020222022202200022220200002222222020000022022000000220020002022220000020020002202202002002022222220222000022000202020220000022002002020200202202000022222020222200022220022220022022020200000200202202022222002020022000202200200022200022022220002000200022020020020000002202200020220200222020202022202000020222000022020022222020000202022022220222200020202022002200022200202200202020222022020200022200222022000200222020000000000002200002220222220000020020022020222002022002222002200020202020200022200020220222200000220002000022200200222002002000000000000022002222022020220002002222220220220200202200222000022020002020220222020000220022200000020022022020000000200222200202000000202022002022020000200200220022002020200022002202202200000000020222002222000220202002022220200200220222000000220202220222002022022022220202202020220202220000022222202200020002000000222020222202022222202022020002022222022000220002222022222000202020002202222220200020200020020200002020020200020200222202200022020202020222022002222022222022000020200002202200002002222222222000222022200222222200222222022200220202020022222202022202020002022000202200222200002222002222202000200222020200220202200002202220220022222202220002222002020220202220022002020002200200220202022202002200202020020002022222200220002220222022200000200200020002200202222200202002022222200020200202202022002222202002220202020002200200220220202200220002022200202022000220200222020022222000020200202002222000200202020000202222220000220222000202220022000222002222022022202000200200020222222002222002022002220002022220002002000200020200002200020200020020200000202022022220022000022022000200000020220000202220022222222200220200200222200002222200000222200220222002000022222022200200222002222000020200022000222000002000022002222222022022022200222222000020222220022000000020000020202222200222220202222000020200220222202202222222222020202202202022002020200220020220202002202220222022000220022002220022222202222200000000002002200220222222202220022002020200020000000000200222220220202220002200220002222022220000202222202000022000202002020000002000200222222202202220220200002002222022222222000002020222022000202200000202220220202000022002202000020020022002200020202222002222200200202222220000020222000200000022020022000022202020222020022022020202202020000220220222202022020000020220020022202022022022222022000000200002000020202202022202000022022202220220022200202200200202000020000220220022202200220202220200022020022002000220022020202000000222202202002022000022200000000200000022022020000002000002002200220222020202220000002200002020200220020222020022020200202020202000200222000222020002022022022022220200220202200022222022220000000022002000222220002002000002200220022022202020200020220220000020000222002220020202222200220200020002220220202202020020022200200202002000000022000000200000020222200202002220202202000200000020020200220020022020200000000202202222022200220200222020200002202202022020200222022200200020002202200222202002020220022022222222220220000222002200200220022202220022020200020020222000002000220202020022000022200200202222020202222002220222220200022220022002000022220020222020020222222020200020022200000000020220022000020222202222202220000022222000002222202222200020200220220022020002002222222220020000220202202220020020220202022220222020220022002202200000202202002002220002020200022200022000022220202220000200200020022020200002002000202020022220222022220022202202020202202200222000202002002022002222002002222200002002222202020220000220020202020220020020202000202022000002202222020220002000202022222220202222000022200200200222022202002000002200022202002002222020222200220222000022202020020200022222020220202222000222220200020022022202020220020000222222002220200020222022022022220000200022220000220022200000002002200222202002222002222222022020020000020020202022202022020202200002220202222200220020000220220202202000002000202220222222000222022202200200000220202022022202200200000020022202200200202202222222202220202200202220020000020022200002222220222202220220222020022000222002200022002200220202200202220002022220002200202022000022000020220202020220222022200200022202022000002022022222020222220220022022200002000000222222220222002200022222002220220022222020200202002000020022022002200220222222002002020002200220000002222002022020022002220222000220020222002200000020222020002002002020220200220022022202002022000222202200200222022222020002000220202222000222202002020020202220222222020020020022202000022222022220202200020000000022202200222202200202220002002022202022222220002002022220220000020020200222022022022222002000002000220202200002202222000020020200002220222222202002020020020022220200022202222000000220202202022220220222020022022220222020002000220202000220000002020202222020002200200222022022202022000222002002200000000022002022000202020222022200020200200202220000020002220202020000022022222022022222220000022202200202022020200200222002222000022000000200022002020000002220220220022022222000020200200220022202222202020200000220222000000222020220022002022222220000000202022002002202202200202222200000002220202220020220222020002200020022222000222200022202022022002002220020222000020220000000002020022202220002222220022002200222220202222200002222202202220022200002020020202202200220022002000220220200002020022020202220222200222000202020022202022002222022222002020020202022022002220000200200000220202222200000000200000200002220022220200220222020022222200022202220202200220002002022200020000000020000022222022200002022020002220020200020202202020020020002002000002000020020002000022002000200200222020202222202002000222002220220220202202002220020220202022200220002222202020200220222222202220002200200202202000200200020020000222000002222000222200202202020220022222220202200202200202220200202000222000000200002000200220222020222222002222220022022222022222020222002000202022020222022202222020202020200002220200222000020020220200202202222222202020002202022222222000222200000202220022002020020000000002002002002220020002222220200220002000022002220000002020200002222000220220220020220200020200222000002200220200022000020000222202000020220000200202222020220200002220220000200200220000020200222220222022200200002022000222200200000220202002000202022222000222020022002222202222002022220202200000202222220220002002220002200200220000202002002220222220020202222222200202200020200220000200000200220020022202200220202020220220220002200020200002000020222020000222222220022000220022200222220220202220002002202202022022000202200020222022200220222222002222200002020202000200022202002220022200000220220220020222000222022200022222220002000222222022020220002200200020200020220220200200200020000202022000202020222000200020022200202022002220000002222222000220202200020202200000022222200200222200000002000022220202002020000202220000220202020022000000220000022222200200000022200220220220000020202202202020022200000200222020200022020000022020002022002022200220222220200022022000002220220002000200200220222022200222200222002222022220222002202002200202022022020020002022000000020000202222220000022022202220200000020000202220022202200002022002000200022220002200002202000222220202020202220222200000202002222020202200222222002200020002022202022222020202022022000200020220222002020202220000002220222020222220222022000022002020022200222200200220000222022002002222002020002020022220220022202000222020222022202202200222222202202002222020020020222200002022200220200000022020002002020220222222002202220220022200000220000202222220222022222000000002220022222202202200202222020222222022000002220020020220020020202002020022020220020002022002200222202200222200020022202002200002220020000202202220220200200202222222020200022020222000002020202200000222020222202002000000222002022000000022000202020200022002020002020000200022220200220020002200222020200022002220200002022020020220000220002022202222020220022022020220222220002000222200220022202020000002202002222000200200002000020020202020020220202202222200202220222200002200220222220202002222220022200202220222220020202022200200200000022220000220022000022220022200000022200222000002000020022020020020200000022200200222002202000220200000000220020202220200000200220000220202202020220222202220202222222022022202220000202022000222220002220220200220222020200002220022000000202000222202020222000020002020200020020200020002220002222220222020202000022020002202200020002002000220022222002022200022200222222022000022002222200222022222222000000202200000222022000020002202022020000220020200220202020020022222002202222200222202000022220022220000200000000222022220022202220020220202222022000002000022000200222020220020022002202022220202222022022202000000000200000020222020202222202020200020022022022022200022000020202202000220222002200202222022202222022222200202022200022202002200000202002020222000222020220002002200200202022022000220202222222200220002202000020000200022220000200220220200020220000220000200222220020022020200222002200220220220002220200020202202222220200220220022002022202000020200220220220020222202020000200002220000222222220220220222220222022002222020000002200022020222202220200222220020222020202222200022222202002000200022200002002202002002202200000000202020020220022000202220020202200022000202002020002000022022200202002202002020022222200000200002202220000202002202220202000002000000220002000220222022222202220000002020220200000200222022002002220020220202022200222022220200202000020222220220000022022222000000220020020222020002220220020202020220002220002202002000202222202020200220002200020220200020220220002200000200022220202022220220000200020002000022022022022222020202002200202200002022022002022020202000000220222020200202222220002220022020022000222022000020020200222000002222022000022000000020002222020022022002200220222000222020222000000020020200220202222220020020000200200022000000222220002222022020222222220000202020220200002000002202200202200200000220202020222020022000020020020000022002200202002022020022220002220200222202000002000000022222220000020002020000222200022022022220002020022000200200220022022002222200002200022000022000222200220022002000200000200022022000202200002220200022202002220020020222000020220002022022202222200002220200020222020220000000000000202022002202202200220222020202222220220022202022022220022220202200020220200022020222220000220020200222000200200202200000022200000022002022002222022200220000220222002220220200222022220222022002202202222202202200202022020220002022022000000000002200020220222220200222000020202002000000202000202202022002000220200202222220020200022000020202202220002002002002222020200022200200202200022222202020220002220022020200000200202202022202202202000020220202200222002222220222222020022220220222000202022000000200022200200200000022222022222222222000220022200220002002002020200002002002222000202220000022022220220200202222002202000220000220222000220222000000200200202220022220022002200020000020220002022222000002222020022020200222200202222222022020022222220022220002020002222022222220202222220222002002220202222002222202022000022000220200202220200022022220022020020222220202222202020202220200002220220000000022200002020202202200022202020220222202220020202002000022020202222002020202222220222020220002000020000222000020000020002202222022000220200200200002022200220022000220220022202020020000002200220220002020202002000022002000022202002220220200000002202002200222000002200222002002000200020000002222000220022000022200222020200222200200220022220202200202220022202020200202200000222000022200220022200020220202000200222022222002200000222022220222222222202002022000020002000200202220202002002200202002020020000020200202002020222000002222020200202020002222000000002220220020002000222220222020020200020220020000020002000200022020222222020022220200220200200002202222002022000200022002200020020020002202200202002002202200200000220020022220022220020020202200020200222200200220220222220200020000022020200220200200022202002200000002220220022000200000022000002220222022202020002000200002020222220220002020022002220200222020020022022022220020202022020220022222200202002220020002220220000222022002020020202220000000220022220002000222002002222200222220200222220220002202220220200022222202220022202022020002200002200022222222202000002200020020202002220220202000220002202220002200020002002022002020200020022020022000000020202020000202020202022000000020000200222000220020022000220002022000022000220022000022000200022200222222002200220220022200220000000202002220220022200020002000200220002000020222020202202002022000020000020200202220222220220020220002222222222220002020020002200200020000200020222220200022202220002002000202022022000022200202000202200222200202020022202000020200022202222222222222000220222002002022000220000200022000222002220002222000022002220202202022222200000000220000002202000222000000222222200200220002222002220002020020202202222002022220002002222000200220200220220000220002222222200202202220220020200002202022002200200000002000202000222020020220020220202222020002200000020222002202020202000202220200200222022020020020220002202022200202000200200002222022220200020022222000220222022020020002222002222200000002220022000022202222200200200220020020220022202200220000222022002222020020202200222220222222022022020200002022202020000222200202202202220222022002200202022200222000022002202202000022220220000200020020022000000202222020000022220222000000202220200200000220000200000200222202020020200020000202022222000022202200202022002002220020200222000220220022002020020022222200020200222000000022020200022220000000202220222222202220202220200200200000220222200022200200000000002200002022202202020200222022020220020220020222202000202020000000220202000200202020000202222022200002222202202200222000002020002220020200020002022022220022002200000022200022202022020000020200202002220220000200020022222020220022022200200220002000202022002202022202200022022202002202000000200000022002002222000220200222022020222222022000220220020020200220020002002000202000000002220220220200000020020222222200200022200220202020002022020202222022002002202200020020020220022220222022200020022202222220222220222020020220202202002200000020000020022222022000200222002020020200022202022000022220020022222202220220020022022022022020000222220000220220000000222002200022002220202022202000022020220200020222002220222022002020000222020020222220220000002222002022220200000220222220022220200222000222202022200220202022000220022220022002022222200220202022002002202000200220022022002000000020200200000020220222200022222222020022202000000200000022002002202202200222020020022222002220202022020202222022002022200222200022020220020222022220020200022222202000200222020000220000000200022002200200000222020202002020022000002000002000022000002220222200220200022022220022000002000220200002002002202022222222002202200020220000200200202020002202220000020222020022022200022220222022000020222022000000020202220020222020000222202222222022220202022020200202220220222002220200022202002202000000220202220202000000202200202200002000022002002202202022000022022002220002220022002200022022022220020020022000222022022002020022000000220200220022220020220202202222222200002000000200020202002000202200220000002022002220020000222022002222202022022020222222200202200000020220000222022202220000202022222020000202222022222200000202220202222002022002202220000222000222000220002022002020200200202222000022020202020200200202022202220200002202200000022200020220002202202222222000222002022020002002000222200002000000200220022020000220022022220022002002022202022000202222022022022222200202002200202000222002222020222200000200020220202022200002202002020202222220022022220000222202220222202000002200002200020020202200202200002200002020002020200020220220202220200022220020000000200000000200022202002220020022022202220020000222020200000002000020202200202200002000222002222022202202020020020020200020202202020222222220222222200222222022002202002202020020202220222200222202222200022022022220000220000220002202002020222020002202000220200020200022000000220202022202000022220002020202022022200022000000002222000200002000020020202222202202022022002020000222202002020202200020000222202020020220220022000200020020222222220220000020020220202200220000220202002020022000202002002000000002222000020222220020000220002220002222002020220002202220202000022222020002222222000022020022202220220200222020220020220202020020002202220222202200002000022222222022202220200022220222020222202002002022222200202022000002202002200002022000200002022020200022202020020020020222220002002200200200022200220200222220222202202200000222200020222000020200220202020220022002022022020020020202200222022222222220202220202220220222002020020200220002022020220022020220220222202020220020002202002002222202000220000022222020220200202022020022000002202222200020020002022220222200222202202222200200202202002200000200202022202220202220202202202020220222022220022202200200020200020022022220002002000000002200220200002200020200200222202002222222020202202022002020202220022000020020022202020002202002220220202020220200002200002222200222002202222202000220202002200022200002022202220202020000022202220020202202000222200222200002002020020220002220022002020220002202222200222000202222000000202222200202000000220200022202000002022220200000000222220022200020020202222220200020200200000000202022000022002220220022002220222020222200222200202222002002002200200202022020200000022200220202002200022020222020200000200002022020202002002202222002002002220000200022000000022220200020022222020000022220002222022222200202202222022222020202202000200002020200000202200022222002020022002202002002200222200022202020022022002202222202202022202222200202220200000002002022000000222220200002000000222022000022000002000020222200200022202202200220220222020000022022222020200220022220000222220000200000022220222220200220022000002000220002020020022202202222222020000002220000200020000222200002022020200002200220220222200222002020020022000002222022020202000220000022202200022002222222000002002022220022222222200020022220202220202222202222220220222002200000202020000022220220002002202022222200222202202220000202200022022202000222022222020220222022020002222020022002022020200222020202000002000220020020202002002222002200220000202020002022200222022002220200000000220202200020202200020220220000202222020002020002202220222020202200002222220200002020222202020000200000000000202220202022202000000222202000000222202222202000000022200000200202200220002022202002200220222000022222002200200020002222202002000202000220000222022020002020000000222022022022022202022020202202002022020002000020202020222220220200222202002002000002222222020002200000222220222220002202020022002020022020202222020220002020000002020222200220000202022002220002022202022202200202000002220020200222000020222200022020020022220200222200202200020022202022222000002220200002020000022222202020222002002022022202200000222020200000220222002222200200000022200022020000022020202220022022200002000202020202020220002220200022002222000022002000022202220200000022000002022220202220020000220200000202020220222200022220000202220002222000202222200222202222022002020002000020020200222200202022220200020000000022220200220202222000022002202022002222220202202020200020220220222000002220022000202202220022020000220000000022000200222200020020200002022202222222200222022022202220020002222002022022000222220022020000220000200202220200220202020020000222220202022000022200000020022000002200220222000020220220200222002200202000000022202000000220022000000200020022000020200002222220022022200202200200022222020022020200002022220220202220022222002202200002002022220200200202000222000020222220202200202220202220220020022002020000222202020200222020222002200200022022000200022220020002222220220220022020222200202002022022222020220200022220022200222202222020202020220020002220220020002020022220220220022202200000020222200202000002220022202202022020220022022202022002000220020220020000220200200202222002020000020022022002202202220222222002200022002002220202202022000222220002202222020200200002222220002220022022222222222000000002000200200202020022222022000000020200202022000020202220220222000222220020220002022022002000220202200002000022002220200000002000202220202020222022002020222000200222022202202220220220022202002020222220000200000000222202200002000200220200002000222202220202220200202002200002200220202202220202020200002000202020222202200200200222222022202200022022022022220002020002000000022020220200222222200222000220002000222022222022022202000222200222200020202220200220222202220200020222000000202202202220002022202000000000022002002002202202222020020222202022202202222000022002220202020200220200002222222220222200000000002022222020222022220220222222222220022200200222202202002022202220222022202020220020202200202000002022220222022020222000200022202022220002222200000020020202200000222020202000202022220220022220220022020222222000222222222000202222222222222020220002200220222000200220022020202200220222200020220220200002222200022020002020220200020220202002002000202200020220002200022200202002002022200002202200222200002202202220020022220020022202022200000020020000222020202002020002022022200202202020020220022222222022022000200200022002222222022222022022200002000220000020202002002200222020022022002000022002002202200220020002220220220020220222200200222000222000220020000000202202220000020222220222222220022022020222000222200202022200002202222202022000220202022000202200022022200222222220000222000002222002222000000022022202020222020020002220022002200202020222000222222022202020202222022020222222022020222000220200022020202222220222220022220020000022002020220202020000000220022220002200020022022200222200202002022022202002200002200200002022000200000202220000022000202202022020222020020220200022200202000020002022200200220202222200202002200020000002022200202020000200222220202000000020002002202000222020022022002000202222022202020020222002000002000200020020000002000022000222020220020020020022220022202000220000200200002020000022002000220000020200022002002220022000220020020220022002022222000200000020022000222202220002220202000200020002020022020002002222222222202022220002002220222020002222200020222200022022022022002200202022022222202000022022202200200002000220220222000200022222002002220000220020202022000200022002200020000222020022200000022222222222222202000222200022202220002022202002200020022200202002022000022022220002202020000000202020222220222220020020002220200202002222000222200022202222002000000200222000020020200020202220220222220200020202020002220222002200022020002222000202020000220020020202220202020222220220002220222222000002220000220022200020020220220200000000200022002020220202000020222020000202002020022022200220020202200200200220222002000002000200022002002200002220220020002220200002002002002202200022202022222000000202020222202022000202202200020222002220022202220202002200222002000020222022220222022222002002000202000222020000000020200222222220002202022020022202022002002220020022002020220220220020222220002020002222202202220022200220220022020022002200222002202222200002202022022220002002220020220020202200000200002222022202202200022202202200020020220000000002222002002200020022222222022220022222000202020202022000020202022220220222020022202222022022202202000020200002002222200000000220000222002022202222020000020000022020000000220202000000020220000200222000020020020002202022222202022022220202002202002222220020002202200222000220220222002220020000222202222002022022002202200022022200220202202220022002020222202020222022000022000202202202202200020022222022020000222002022022022000222220000000222002020200222022002222020220000222200202200022020002000202002002200002000202200002002002020000020220002202200222220000222222200220220000000022020002020002202000020202220002000200002220220002000000020202002220022000022200222002020020222202200020000220002202022002220202000002022222222200002220022022022020222220220022200002002002200222200200222220002220200202202220022222220020022200020020002220202000222022002202200202002222020000202220200020202202020020022000202022200222202000002220222002020020002200000000020202220000022000002220022000000022202020200020002200222022220222220020222202002022002200002022000000200000200220222220220002200220000200002000002002200200000220000000020200022222002020002202200022222200000222022022000020202220000220220222022002002220000000222200002202202022202002202000002002002000002220002202220220200220002000222202020222220222222222200202220200222222222002022220220020020220220220220202020200202020020002222020020022002222002000202022020022022002002222202202002200200000220202200200022220002000020020020202002200022220220200200202000022200222002222222202002022022020002200002220000222020020222022202022222222022020022020200220020222220002202222222222222202002020222222220020022202020222220220000000022002002002022222022200020220022020020220200000202022022220002202000022022202200022000220202022220022222022002022222022022022200020002222202000220202000022200220222200002202200020022202202200000020000222020222202000200000202000222000020020222020000222220002202000222000220022022200200022222002200002000202202220220000022200220202222020000002022000220022220002200202022200222220220220222200222000202000222022022000220222020222202220020222020000202020200220002020002222200200000222002200020022220220220220202202220002200200000000220022002222200222200222220020020200022022022020022222202220000200020202020002020000222202220020000220000022202220022200220202002202000000020222022200200002022022220200000220020222020220200002220222022020220020002222002220220202002000202020020202020202020000002022202020022020022022020002202020022220202022220020020022000002200202200000202202020220220000020200222222222200200000200202000200022200220200220022000002222202220220202002020222020022222222002002200020020222022202022200020002022220222020200200002202202020002000020220022002020020002220222000200022022200200202000220000022002202222200002002000020222200002000200000202000020000002220202220220002220222002022022222000222202000202222002020002222202202000202002200220020020222002220022222002002222220000020000022020020000202020002200200202220220002002020222222020020222202002202222200020220200222022200002200202200222200200202220202022200220200020000220202022200020220022220200220222222000220000020220002220002220220002022220222202202002000202220222022200222222222200220220222002022000020020202220020022220222000220020220200020222000222200002222220220020020220000200202202020002020202220020020200202022220220200220220000202002222200200222022220222202200020200222200020220000220000202220020002222222020222020000022220200220220202220022220220022000202200002022020020222020202022022002020200022002002022020202220202020002200220202200022000000020002220020002200000000220222222000200022222022020002220020222022202000002202222002002022220202202022220222000222000002220020220002002202220200222222020020002200022000220202000000222022000000020022200200202220200200200002000202202000000222222222202020022220222200200202002002220000002222200202200022202200020200202020002220220022222222002200222200200002022222020000020022020200002002000220000220002220000000220002020002022202020002022020220200220002002020000200200000200222202002202022020222220002000020222222022022202222022022220002202200220220022020202202002202220220020202000202002000202222020202222000222022220002222222200200200220002022222022220002000202002002020222000222222002002000220002020220022002202022220020000022022202000002002200020000002020020000022220020200020220220020220002022220222002000202220202200202020000020202000000220000202202020020002220020022000000022000202200000002002200020202022022000020002000022200000002020202220022200022200002202002222220202020202200000222222022022002222020200200200222020002022220222220200220202200200022202222022022002020000200200200002222220002202000022220022002002222222222002220000222202022222222000002200022220202220222220202020000220022022222222020022222022002220022200000200200202000220020000002222000020000022220202220022222220222020202022200022020000220200022002000202220222220002200202022000022200022022202222222000020202000000000220222202022222200202002202020200220220202220022000000200002200020200000002020200200200202020022220220220000222222000202202222022220200222022022200002200200022000002200022200222020220022200202202202200020200200220000020200000202220022020002220020200222022002200000020200002220202000000002200200002020002200022220220220022222202220202222200022020022202222220220022002000022020020202022020222222220000000000002022000020202022020200022202000000020220000222022202200220202020020002002002220220222200000222002022022022200022002222020220000020002022022000020002200020202000222022220222220202002222220020002222200220202002002202002220002222202002202220002000000200220202020222222202000020000020220222220002020020220200020200220220002022220000220222022002002222200200002020002202200200002200200222220202000202002200022220022020222020002202000020022000000200220000220000022220200220000020000200022222020022200020202002202222020020002202022222022220202222022022222202022002000020002202020022002002200020002022000002020002020202020202200022200220000220022220220202202202002220200022202200220220220220200200020020200022222022000202000220200002220222202000022020220002000220020222220000220000022022220000202000222202220020020222002222000000022220020220200022002002200200220022222022022200202222020222220200220200202220202202002222202200222020220202002020200020020022000220220002002022200000002020020020220002000022020222020020002220002200020020020200020200022002000020220202200202022022222200022022222022202020220000022220022020222000020220220202200022220022200220022220000220222020022000222022222022022002002020200020202002020022202000000220000200200022222022222000002200200000002220220222000022222222022020002020220202200222020002002202000200200220202002022020002202000000202020000022002220022002202200002022202000022220222202222202022020000200200222202220022020200222202220020220200020202000200200000222202222020000022002020200002022020222222202222020000002000220000000202200022202022202000000022002020022002002000220222002000222002000022020000220222222000202220002202200202000220000220020000022000200222020222222222000020200002222020000000200200200000022202222020000202220000200202222222002202000200022022002222000200022220222022000220020002000002222200202222222202000222020002000022200002200020222200022222022200020002020000202020000222020200222000022200222022022200020000020220000220000200022022200022220002220220222020200000020202022002220222002002220020002220002202202202200002002200222002220222000220000200000220200202200000022200000200220222200220000002002020020220220002222220002220020022020200222222222220202202202000220022002220222200002222220022000022200202222022200200222222020002002002220002202022220002022222022222022022220022000022200202220000000202022002022202002222020002202022202022202200222222220202200022222002222220220002020022220220202020200002002220020220022022002000202202002200202002020200000200022222222022022220000002200022002020200000220222022200020002202020220002200202220220002020000002020000020022020000200022202000002200202022200200200000022200220022002020020202022200000000002222020222002020222022022020220000202200220202020200200002000002000000020200220222002222220222000002200002222022200222222002222200020220020000200222222000020022000220000002220200000202002020220200220000202220222202222000200200000222222220022222002020002020022020000020000200222222020202220022200220220002200222202022002020200000220002000022200002020000222200200220200000200000002002020200202000202222002222200020220000202222202220020222220202222000222022202022202002000000020020022222200202002000022220222220020000020200020220020222022202200202002202002002002222202222222202222202002022020000200002222002000200000002202200020020200000200000220200022202020202220220020222200020202022022022202020202002200220002000200022222220022220000200000220222000002200020202022200002000020200222220002222220202202000200202220222022022200200000200020200000002000220200000020222022220220200222000200002222000222020200200202200202220222002200202002200202202222222002020220020000000202200000222200220000000000022200022000220202020222022022220220220202200020200222222022020020000002222202002222200000202020200220200200002020002022222002020000202222200202200002222200200000222200202022000202022220200002002220222202200002202220200222020002020222002000000202222220020000000000022002022002020202202002002200222200020222222002200000022000222200200222202000200000202022002222020220002222020000000002022220202000202202222200002222200022002000000002222200222222220000220200020020220202022020022222222002002200200002002200000002202220222200222000000000002022022020022202202200000200020220022220000022022002000020002022220200220220222020022200002022222222002200020222020002222220200002202002020022220022022002220222220002022020022022202002002222020020022202200222200000200022002220202000200222200202020022002220202200022002000200002202020002022000022220000002200200202022000202222022202222222202022002222200022200222220020200222020002022222220022202000002220020220002022222022022002022202222222000022002020002202002022000022000202200000220200022200020220222000022202222000222222022202022222022200002202220222000202000200002220200000200202002202202","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://zgg2001.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}]},{"title":"C++学习记录：内存池设计与实现 及其详细代码","slug":"20210301_C++学习记录：内存池设计与实现 及其详细代码","date":"2021-02-28T16:00:30.000Z","updated":"2021-02-28T16:00:30.000Z","comments":true,"path":"2021/03/01/20210301_C++学习记录：内存池设计与实现 及其详细代码/","permalink":"https://zgg2001.github.io/2021/03/01/20210301_C++%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E5%86%85%E5%AD%98%E6%B1%A0%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20%E5%8F%8A%E5%85%B6%E8%AF%A6%E7%BB%86%E4%BB%A3%E7%A0%81/","excerpt":"&emsp;&emsp;这是我在VS2019上写的第一个项目，使用VS2019的目的是想在更为规范的IDE上写出更加规范的代码。&emsp;&emsp;使用内存池可以减少程序运行中产生的内存碎片，且可以提高程序内存分配效率从而提升程序效率。在这篇笔记中，我将记录下自己关于这个内存池项目的思路与详细代码。同时，在我的C++网络编程学习相关内容的下一步改进中，我将引入这个内存池提高服务端的运行效率。","text":"&emsp;&emsp;这是我在VS2019上写的第一个项目，使用VS2019的目的是想在更为规范的IDE上写出更加规范的代码。&emsp;&emsp;使用内存池可以减少程序运行中产生的内存碎片，且可以提高程序内存分配效率从而提升程序效率。在这篇笔记中，我将记录下自己关于这个内存池项目的思路与详细代码。同时，在我的C++网络编程学习相关内容的下一步改进中，我将引入这个内存池提高服务端的运行效率。 一、内存池设计思路&emsp;&emsp;首先，为什么要使用内存池？&emsp;&emsp;我是这样理解的：不断的使用new/malloc从堆中申请内存，会在内存中留下一些“缝隙”。例如我们申请三份8个字节大小的内存A、B、C，由于内存地址是连续的，则ABC的地址值每个相差8(正常情况)。此时我们delete/free掉B内存，A与C内存之间此时就有了8个字节的空白。假如我们今后申请的内存都比8个字节大，则A与C之间这块内存就会一直为空白，这就是内存碎片。&emsp;&emsp;过多的内存碎片会影响程序的内存分配效率，为了降低内存碎片的影响，我们可以引入内存池来尝试解决它。 &emsp;&emsp;我们可以在程序启动时(或是其他合适的时机)，预先申请足够的、大小相同的内存，把这些内存放在一个容器内。在需要申请内存时，直接从容器中取出一块内存使用；而释放内存时，把这块内存放回容器中即可。这个容器就被称为内存池。而这样操作也可以大大减少内存碎片出现的可能性，提高内存申请&#x2F;释放的效率。 这个项目中内存池的思路图如下：我们需要新建三个类： 首先是底层的内存块类，其中包含了该内存块的信息：内存块编号、引用情况、所属内存池、下一块的位置等。 其次是内存池类，它对成组的内存块进行管理，可以实现把内存块从内存池中取出以及把内存块放回内存池。 最后是内存管理工具类，其中包含一个或多个内存池，所以它要根据用户申请的内存大小找到合适的内存池，调用内存池类的方法申请&#x2F;释放内存。 还需要进行的操作： 对new/delete进行重载，使其直接调用内存管理工具类申请&#x2F;释放内存。 &emsp;&emsp;上面的工作完成后，我们仍是以new/delete来申请&#x2F;释放内存，但是已经是通过内存池来实现的了，这个内存池项目也就暂时结束。下面我将详细记录实现的过程与思路。 二、内存块类MemoryBlock 设计与实现先扔出来思路图：&emsp;&emsp;首先，在内存池中每一块内存是由一个内存头以及其可用内存组成的，其中内存头里储存了这块内存的相关信息，可用内存即为数据域，类似链表中节点的结构。而一块块内存之间正是一种类似链表的结构，即通过内存头中的一个指针进行连接。内存头中包含的信息大概如下： 1、内存块编号 2、引用情况 3、所属内存池 4、下一块位置 5、是否在内存池内 则我们可以通过上面的思路新建内存块类MemoryBlock： 1234567891011121314151617181920212223由于内存头中要标记所属内存池，所以我们先预声明内存池类，在之后再进行实现。建立完成后，内存池内一块内存的大小为：sizeof(MemoryBlock) + 可用内存的大小//预声明内存池类class MemoryAlloc;//内存块类class MemoryBlock&#123;public: //内存块编号 int _nID; //引用情况 int _nRef; //所属内存池 MemoryAlloc* _pAlloc; //下一块位置 MemoryBlock* _pNext; //是否在内存池内 bool _bPool;private:&#125;; 三、内存池类MemoryAlloc 设计与实现还是先扔出来内存池申请&#x2F;释放内存的思路图：&emsp;&emsp;由图可知，整个内存池的管理基本为链表结构，内存池对象一直指向头部内存单元。在申请内存时移除头部单元，类似链表头结点的移除；在释放内存时，类似链表的头插法，把回收回来的内存单元放在内存池链表的头部。 内存池类中大概包含这些东西： 1、方法 1.成员变量初始化 —— 对内存单元可用内存大小以及内存单元数量进行设定 2.初始化 —— 依据内存单元的大小与数量，对内存池内的内存进行malloc申请，完善每一个内存单元的信息 3.申请内存 —— 从内存池链表中取出一块可用内存 4.释放内存 —— 将一块内存放回内存池链表中 2、成员变量 1.内存池地址 —— 指向内存池内的总内存 2.头部内存单元 —— 指向头部内存单元 3.内存块大小 —— 内存单元的可用内存大小 4.内存块数量 —— 内存单元的数量 则我们可以通过上面的思路新建内存块类MemoryAlloc： 1234567891011121314151617181920212223242526272829//导入内存块头文件#include&quot;MemoryBlock.h&quot;class MemoryAlloc&#123;public: MemoryAlloc(); virtual ~MemoryAlloc(); //设置初始化 void setInit(size_t nSize,size_t nBlockSize);//传入的为内存块可用内存大小和内存块数量 //初始化 void initMemory(); //申请内存 void* allocMem(size_t nSize);//传入的为申请可用内存的大小 //释放内存 void freeMem(void* p);protected: //内存池地址 char* _pBuf; //头部内存单元 MemoryBlock* _pHeader; //内存块大小 size_t _nSize; //内存块数量 size_t _nBlockSize; //多线程锁 std::mutex _mutex;//锁上申请内存方法和释放内存方法即可实现多线程操作&#125;; 四、内存管理工具类MemoryMgr 设计与实现仍然是先放思路图：&emsp;&emsp;首先，内存管理工具类用的是单例对象模式，从而能简易的对内存池进行管理。在这次的实现里，我使用的是饿汉式单例对象。其次，为了更简单的判断出申请内存时所需要调用的内存池，我建立了一个数组映射内存池。在工具类构造函数内，首先是对内存池进行初始化，随后便是将其映射到数组上。 1234映射：假如申请一个64字节内存池，申请一个128字节内存池我们新建一个指针数组test，使下标0~64指向64字节内存池，下标65~128指向128字节内存池则我们通过 test[要申请的内存大小] 即可确定合适的内存池 &emsp;&emsp;在随后的申请过程中，我们首先判断申请内存大小是否超过内存池最大可用内存，若没超过，则通过映射数组指向的内存池进行内存申请；若超过了，则直接使用malloc申请，记得多申请一个内存头大小的内存。随后完善内存头内的资料。&emsp;&emsp;在随后的释放过程中，我们通过内存头判断这块内存是否使属于内存池的内存，如果是，则通过其所属内存池进行内存回收；若不是，则直接进行free释放。 内存管理工具类中大概包含这些东西： 1、方法 饿汉式单例模式 —— 调用返回单例对象 申请内存 —— 调用获取一块内存 释放内存 —— 调用释放一块内存 内存初始化 —— 将内存池映射到数组上 2、成员变量 映射数组 —— 映射内存池 内存池1 内存池2 内存池… 则我们可以通过上面的思路新建内存管理工具类MemoryMgr： 12345678910111213141516171819202122232425262728293031//内存池最大申请#define MAX_MEMORY_SIZE 128//导入内存池模板类#include&quot;MemoryAlloc.h&quot;class MemoryMgr&#123;public: //饿汉式单例模式 static MemoryMgr* Instance(); //申请内存 void* allocMem(size_t nSize); //释放内存 void freeMem(void* p); private: MemoryMgr(); virtual ~MemoryMgr(); //内存映射初始化 void init_szAlloc(int begin,int end,MemoryAlloc* pMem);private: //映射数组 MemoryAlloc* _szAlloc[MAX_MEMORY_SIZE + 1]; //64字节内存池 MemoryAlloc _mem64; //128字节内存池 MemoryAlloc _mem128; //内存池...&#125;; 五、重载new/delete重载new/delete就不多说了，直接放代码： 123456void* operator new(size_t size);void operator delete(void* p);void* operator new[](size_t size);void operator delete[](void* p);void* mem_alloc(size_t size);//mallocvoid mem_free(void* p);//free 六、项目代码及其注释1.项目图片) 2.重载new/delete2.1 Alloctor.h1234567891011#ifndef _Alloctor_h_#define _Alloctor_h_void* operator new(size_t size);void operator delete(void* p);void* operator new[](size_t size);void operator delete[](void* p);void* mem_alloc(size_t size);void mem_free(void* p);#endif 2.2 Alloctor.cpp1234567891011121314151617181920212223242526272829303132#include&quot;Alloctor.h&quot;#include&quot;MemoryMgr.h&quot;//内存管理工具void* operator new(size_t size)&#123; return MemoryMgr::Instance()-&gt;allocMem(size);&#125;void operator delete(void* p)&#123; MemoryMgr::Instance()-&gt;freeMem(p);&#125;void* operator new[](size_t size)&#123; return MemoryMgr::Instance()-&gt;allocMem(size);&#125;void operator delete[](void* p)&#123; MemoryMgr::Instance()-&gt;freeMem(p);&#125;void* mem_alloc(size_t size)&#123; return MemoryMgr::Instance()-&gt;allocMem(size);&#125;void mem_free(void* p)&#123; MemoryMgr::Instance()-&gt;freeMem(p);&#125; 3.内存池类MemoryAlloc3.1 MemoryAlloc.h12345678910111213141516171819202122232425262728293031323334353637383940/*内存池类对内存块进行管理2021/2/26*/#ifndef Memory_Alloc_h#define Memory_Alloc_h//导入内存块头文件#include&quot;MemoryBlock.h&quot;class MemoryAlloc&#123;public: MemoryAlloc(); virtual ~MemoryAlloc(); //设置初始化 void setInit(size_t nSize,size_t nBlockSize); //初始化 void initMemory(); //申请内存 void* allocMem(size_t nSize); //释放内存 void freeMem(void* p);protected: //内存池地址 char* _pBuf; //头部内存单元 MemoryBlock* _pHeader; //内存块大小 size_t _nSize; //内存块数量 size_t _nBlockSize; //多线程锁 std::mutex _mutex;&#125;;#endif 3.2 MemoryAlloc.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include&quot;MemoryAlloc.h&quot;MemoryAlloc::MemoryAlloc()&#123; _pBuf = nullptr; _pHeader = nullptr; _nSize = 0; _nBlockSize = 0;&#125;MemoryAlloc::~MemoryAlloc()&#123; if (_pBuf) &#123; free(_pBuf); //现在有一个问题就是内存池外申请的内存不会被主动释放 &#125;&#125;void MemoryAlloc::setInit(size_t nSize, size_t nBlockSize)&#123; /*补全nSize const size_t n = sizeof(void*) _nSize = (nSize/n) * n + (nSize % n ? n : 0); */ _pBuf = nullptr; _pHeader = nullptr; _nSize = nSize; _nBlockSize = nBlockSize; initMemory();&#125;void MemoryAlloc::initMemory()&#123; //断言 assert(nullptr == _pBuf); //若已申请则返回 if (nullptr != _pBuf) &#123; return; &#125; //计算内存池的大小 (块大小+块头) * 块数量 size_t temp_size = _nSize + sizeof(MemoryBlock);//需要偏移的真正大小 size_t bufSize = temp_size * _nBlockSize; //向系统申请池内存 _pBuf = (char*)malloc(bufSize); //初始化内存池 _pHeader = (MemoryBlock*)_pBuf; if (nullptr != _pHeader) &#123; _pHeader-&gt;_bPool = true;//在池中 _pHeader-&gt;_nID = 0;//第0块 _pHeader-&gt;_nRef = 0;//引用次数为0 _pHeader-&gt;_pAlloc = this;//属于当前内存池 _pHeader-&gt;_pNext = nullptr;//下一块 MemoryBlock* pTemp1 = _pHeader; //遍历内存块进行初始化 for (size_t n = 1; n &lt; _nBlockSize; n++) &#123; MemoryBlock* pTemp2 = (MemoryBlock*)(_pBuf + (n * temp_size));//指针偏移到下一块 pTemp2-&gt;_bPool = true;//在池中 pTemp2-&gt;_nID = n;//第n块 pTemp2-&gt;_nRef = 0; pTemp2-&gt;_pAlloc = this; pTemp2-&gt;_pNext = nullptr; pTemp1-&gt;_pNext = pTemp2; pTemp1 = pTemp2; &#125; &#125;&#125;void* MemoryAlloc::allocMem(size_t nSize)&#123; //自解锁 std::lock_guard&lt;std::mutex&gt; lock(_mutex); //若内存池不存在则初始化 if (nullptr == _pBuf) &#123; initMemory(); &#125; MemoryBlock* pReturn = nullptr; if (nullptr == _pHeader)//如内存池已满 重新申请 &#123; pReturn = (MemoryBlock*)malloc(nSize+sizeof(MemoryBlock)); if (nullptr != pReturn) &#123; pReturn-&gt;_bPool = false;//不在池中 pReturn-&gt;_nID = -1; pReturn-&gt;_nRef = 1; pReturn-&gt;_pAlloc = this; pReturn-&gt;_pNext = nullptr; &#125; &#125; else//否则直接使用内存池 &#123; pReturn = _pHeader; _pHeader = _pHeader-&gt;_pNext; assert(0 == pReturn-&gt;_nRef); pReturn-&gt;_nRef = 1; &#125; //debug打印 if (nullptr != pReturn) &#123; xPrintf(&quot;NEW - allocMem:%p,id=%d,size=%d\\n&quot;, pReturn, pReturn-&gt;_nID, nSize); &#125; return ((char*)pReturn + sizeof(MemoryBlock));&#125;void MemoryAlloc::freeMem(void* p)&#123; //传进来的是消息区 需要加上信息头 MemoryBlock* pBlock = (MemoryBlock*)((char*)p - sizeof(MemoryBlock)); assert(1 == pBlock-&gt;_nRef); //判断是否被多次引用 if (--pBlock-&gt;_nRef != 0) &#123; return; &#125; //判断是否在内存池中 if (pBlock-&gt;_bPool) &#123; //自解锁 std::lock_guard&lt;std::mutex&gt; lock(_mutex); //把内存块放入内存池首位 pBlock-&gt;_pNext = _pHeader; _pHeader = pBlock; &#125; else &#123; free(pBlock); &#125;&#125; 4.内存块类MemoryBlock4.1 MemoryBlock.h123456789101112131415161718192021222324252627282930313233343536373839404142/*内存块类内存管理的最小单位2021/2/26*/#ifndef Memory_Block_h#define Memory_Block_h//声明内存池类class MemoryAlloc;//最底层导入内存头文件/断言头文件/锁头文件#include&lt;stdlib.h&gt;#include&lt;assert.h&gt;#include&lt;mutex&gt;//如果为debug模式则加入调试信息#ifdef _DEBUG #include&lt;stdio.h&gt; #define xPrintf(...) printf(__VA_ARGS__)#else #define xPrintf(...)#endif class MemoryBlock&#123;public: //内存块编号 int _nID; //引用情况 int _nRef; //所属内存池 MemoryAlloc* _pAlloc; //下一块位置 MemoryBlock* _pNext; //是否在内存池内 bool _bPool;private:&#125;;#endif 4.2 MemoryBlock.cpp1#include&quot;MemoryBlock.h&quot; 5.内存管理工具类MemoryMgr5.1 MemoryMgr.h123456789101112131415161718192021222324252627282930313233343536373839404142/*内存管理工具类对内存池进行管理2021/2/26*/#ifndef Memory_Mgr_h#define Memory_Mgr_h//内存池最大申请#define MAX_MEMORY_SIZE 128//导入内存池模板类#include&quot;MemoryAlloc.h&quot;class MemoryMgr&#123;public: //饿汉式单例模式 static MemoryMgr* Instance(); //申请内存 void* allocMem(size_t nSize); //释放内存 void freeMem(void* p); //增加内存块引用次数 void addRef(void* p);private: MemoryMgr(); virtual ~MemoryMgr(); //内存映射初始化 void init_szAlloc(int begin,int end,MemoryAlloc* pMem);private: //映射数组 MemoryAlloc* _szAlloc[MAX_MEMORY_SIZE + 1]; //64字节内存池 MemoryAlloc _mem64; //128字节内存池 MemoryAlloc _mem128;&#125;;#endif 5.2 MemoryMgr.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&quot;MemoryMgr.h&quot;MemoryMgr::MemoryMgr()&#123; _mem64.setInit(64, 10); init_szAlloc(0, 64, &amp;_mem64); _mem128.setInit(128, 10); init_szAlloc(65, 128, &amp;_mem128);&#125;MemoryMgr::~MemoryMgr()&#123;&#125;//初始化void MemoryMgr::init_szAlloc(int begin, int end, MemoryAlloc* pMem)&#123; //begin到end大小的内存申请都映射到相关的内存池上 for (int i = begin; i &lt;= end; i++) &#123; _szAlloc[i] = pMem; &#125;&#125;//饿汉式单例模式MemoryMgr* MemoryMgr::Instance()&#123; static MemoryMgr myMemoryMgr; //单例对象 return &amp;myMemoryMgr;&#125;//申请内存void* MemoryMgr::allocMem(size_t nSize)&#123; //若申请的内存大小正常，则直接申请 if (nSize &lt;= MAX_MEMORY_SIZE) &#123; return _szAlloc[nSize]-&gt;allocMem(nSize); &#125; else//否则用malloc申请一个 &#123; MemoryBlock* pReturn = (MemoryBlock*)malloc(nSize + sizeof(MemoryBlock)); if (nullptr != pReturn) &#123; pReturn-&gt;_bPool = false;//不在池中 pReturn-&gt;_nID = -1; pReturn-&gt;_nRef = 1; pReturn-&gt;_pAlloc = nullptr; pReturn-&gt;_pNext = nullptr; //debug打印 xPrintf(&quot;NEW - allocMem:%p,id=%d,size=%d\\n&quot;,pReturn,pReturn-&gt;_nID,nSize); &#125; return ((char*)pReturn + sizeof(MemoryBlock)); &#125;&#125;//释放内存void MemoryMgr::freeMem(void* p)&#123; //传进来的是消息区 需要加上信息头 MemoryBlock* pBlock = (MemoryBlock*)((char*)p - sizeof(MemoryBlock)); //debug打印 xPrintf(&quot;DELETE - allocMem:%p,id=%d\\n&quot;, pBlock, pBlock-&gt;_nID); //内存池内的内存块/内存池外的内存块 不同的处理方式 if (pBlock-&gt;_bPool == true) &#123; pBlock-&gt;_pAlloc-&gt;freeMem(p); &#125; else &#123; if (--pBlock-&gt;_nRef == 0) &#123; free(pBlock); &#125; &#125;&#125;//增加内存块引用次数void MemoryMgr::addRef(void* p)&#123; MemoryBlock* pBlock = (MemoryBlock*)((char*)p - sizeof(MemoryBlock)); ++pBlock-&gt;_nRef;&#125; 6.main文件6.1 main.cpp12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&quot;Alloctor.h&quot;#ifdef _DEBUG#endifint main()&#123; char* data2 = new char; delete data2; char* data1 = new char[129]; delete[] data1; char* data3 = new char[65]; delete[] data3; printf(&quot;--------------------------\\n&quot;); char* data[15]; for (size_t i = 0; i &lt; 12; i++) &#123; data[i] = new char[64]; delete[] data[i]; &#125; return 0;&#125; 七、小结 在申请与释放内存时，返回给用户和用户传进来的都是可用内存的地址，并不是内存头的地址。我们需要对地址进行偏移，从而返回&#x2F;接收正确的地址。具体为可用内存地址向前偏移一个内存头大小即为内存头地址；内存头地址向后偏移一个内存头大小即为可用内存地址。 内存池初始化时，申请总地址大小为：(可用地址大小+内存头大小) * 内存单元数量 内存池外申请的内存，不会在内存池析构函数内被释放，需要手动释放。（不过一般触发析构函数的时候，也不用手动释放了） 在这次的项目中，我对地址、内存等有了更深刻的理解，同时也能熟练使用VS的调试功能。希望未来能有更大的发展。","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"}]},{"title":"C++网络编程学习：消息接收与发送分离","slug":"20210221_C++网络编程学习：消息接收与发送分离","date":"2021-02-21T06:24:33.000Z","updated":"2021-02-21T06:24:33.000Z","comments":true,"path":"2021/02/21/20210221_C++网络编程学习：消息接收与发送分离/","permalink":"https://zgg2001.github.io/2021/02/21/20210221_C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%B6%88%E6%81%AF%E6%8E%A5%E6%94%B6%E4%B8%8E%E5%8F%91%E9%80%81%E5%88%86%E7%A6%BB/","excerpt":"使用的语言为C&#x2F;C++ 源码支持的平台为：Windows &#x2F; Linux 一、思路与准备&emsp;&emsp;在之前的 C++网络编程学习：服务端多线程分离业务处理高负载 笔记中，我将业务处理相关内容从主线程中分离，大大提高了服务端的效率。随着服务端的进一步完善，我会把各个模块进行分离，从而使代码的结构更加便于修改与完善，同时也可以提高代码的运行效率。&emsp;&emsp;本篇笔记中，我会记录自己如何把消息发送的相关内容从业务处理线程中分离出来。","text":"使用的语言为C&#x2F;C++ 源码支持的平台为：Windows &#x2F; Linux 一、思路与准备&emsp;&emsp;在之前的 C++网络编程学习：服务端多线程分离业务处理高负载 笔记中，我将业务处理相关内容从主线程中分离，大大提高了服务端的效率。随着服务端的进一步完善，我会把各个模块进行分离，从而使代码的结构更加便于修改与完善，同时也可以提高代码的运行效率。&emsp;&emsp;本篇笔记中，我会记录自己如何把消息发送的相关内容从业务处理线程中分离出来。 首先下面是我的思路图。 大致思路如下：处理事件线程 &gt;&gt; 发送线程缓冲区 &gt;&gt; 发送线程 &emsp;&emsp;我会在新建业务子线程时创建一条发送子线程。其中由主线程创建子线程对象，子线程对象中包含两条子线程，一条为业务子线程，一条为发送子线程。这样两条线程可以在一个对象中进行相关操作，便于实现。同时，主线程只需声明一个对象即可，封装性良好且低耦合。&emsp;&emsp;在业务线程需要发送消息时，首先创建一个消息发送对象，其中包含发送的目标和内容。随后把该对象加入缓冲区。在发送线程中，首先把缓冲区内的对象提取到正式发送队列中，随后把正式发送队列中的待发送事件挨个进行处理即可。 二、代码实现1.发送线程类文件相关&emsp;&emsp;首先，我们得新建两个类，一个是发送任务基类，一个是发送线程类。&emsp;&emsp;发送任务基类中，含有一个虚方法DoTask用来执行发送任务。该方法在服务端源码中被重载。&emsp;&emsp;发送线程类中，含有一条发送线程，同时有一个Start方法用来启动该线程。含有两条链表，一条为缓冲区链表，一条为正式消息链表，同时有一个addTask方法用来把消息任务加入缓冲区。线程执行OnRun方法把缓冲区中的任务加入正式队列并执行该任务的DoTask方法。 发送线程类文件 celltask.hpp 大致代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#ifndef _CELL_Task_hpp_#define _CELL_Task_hpp_#include&lt;thread&gt;#include&lt;mutex&gt;#include&lt;list&gt;//任务基类class CellTask&#123;public: //执行任务 virtual void DoTask() = 0; &#125;;//发送线程类class CellTaskServer&#123;public: CellTaskServer() &#123; &#125; virtual ~CellTaskServer() &#123; &#125; //添加任务 void addTask(CellTask* ptask) &#123; std::lock_guard&lt;std::mutex&gt;lock(_mutex); _tasksBuf.push_back(ptask); &#125; //启动服务 void Start() &#123; //线程 std::thread t(std::mem_fn(&amp;CellTaskServer::OnRun),this); t.detach(); &#125; protected: //工作函数 void OnRun() &#123; while(1) &#123; //将缓冲区内数据加入 if(!_tasksBuf.empty())//不为空 &#123; std::lock_guard&lt;std::mutex&gt;lock(_mutex); for(auto pTask : _tasksBuf) &#123; _tasks.push_back(pTask); &#125; _tasksBuf.clear(); &#125; //如果无任务 if(_tasks.empty()) &#123; //休息一毫秒 std::chrono::milliseconds t(1); std::this_thread::sleep_for(t); continue; &#125; //处理任务 for(auto pTask:_tasks) &#123; pTask-&gt;DoTask(); delete pTask; &#125; //清空任务 _tasks.clear(); &#125; &#125; private: //任务数据 std::list&lt;CellTask*&gt;_tasks; //任务数据缓冲区 std::list&lt;CellTask*&gt;_tasksBuf; //锁 锁数据缓冲区 std::mutex _mutex; &#125;;#endif 其中的缓冲区加入操作涉及到临界操作，所以加个自解锁。 因为缓冲区以及正式队列涉及到频繁进出，所以用的是链表list。 当没有发送任务时，会进行一毫秒的休息，防止消耗太多的内存。 2.主文件相关&emsp;&emsp;在导入上述celltask.hpp头文件后，我们需要重载DoTask方法，从而实现把主文件内的相关类型数据进行发送。&emsp;&emsp;我们可以创建一个新类，使他继承CellTask任务基类。其中导入主文件内的相关类型。例如下面的例子中就导入了ClientSocket客户端类与DataHeader报文结构体。同时重写了DoTask方法，使其调用ClientSocket客户端类的SendData方法发送报文。 12345678910111213141516171819202122//网络消息发送任务class CellSendMsgTask : public CellTask&#123;public: CellSendMsgTask(ClientSocket* pClient,DataHeader* pHead) &#123; _pClient = pClient; _pHeader = pHead; &#125; //执行任务 virtual void DoTask() &#123; _pClient-&gt;SendData(_pHeader); delete _pHeader; &#125; private: ClientSocket* _pClient; DataHeader* _pHeader; &#125;; &emsp;&emsp;而当我们想要发送报文时，只需要新建上述CellSendMsgTask对象，并调用CellTaskServer任务线程类的addTask方法添加至发送队列即可。 123456//向 pClient 客户端发送 pHead 报文void AddSendTask(ClientSocket* pClient,DataHeader* pHead)&#123; CellSendMsgTask* ptask = new CellSendMsgTask(pClient,pHead); _taskServer.addTask(ptask);&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"网络编程","slug":"网络编程","permalink":"https://zgg2001.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"C++网络编程学习：对socket select网络模型的优化","slug":"20210220_C++网络编程学习：对socket select网络模型的优化","date":"2021-02-20T14:00:28.000Z","updated":"2021-02-20T14:00:28.000Z","comments":true,"path":"2021/02/20/20210220_C++网络编程学习：对socket select网络模型的优化/","permalink":"https://zgg2001.github.io/2021/02/20/20210220_C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%AF%B9socket%20select%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BC%98%E5%8C%96/","excerpt":"使用的语言为C&#x2F;C++ 源码支持的平台为：Windows &#x2F; Linux 东西不多，简单记录一下，今后可能会补充 零、思路与流程select网络模型的大概流程如下：1.获取一个至三个fd_set集合，获取一个timeval2.select函数对fd_set集合进行选择筛选3.FD_ISSET函数依据fd_set集合遍历查找待处理事件","text":"使用的语言为C&#x2F;C++ 源码支持的平台为：Windows &#x2F; Linux 东西不多，简单记录一下，今后可能会补充 零、思路与流程select网络模型的大概流程如下：1.获取一个至三个fd_set集合，获取一个timeval2.select函数对fd_set集合进行选择筛选3.FD_ISSET函数依据fd_set集合遍历查找待处理事件 select相关详细内容点我 12345678WINSOCK_API_LINKAGE int WSAAPI select( int nfds,//是指待监听集合里的范围 即待监听数量最大值+1 fd_set *readfds,//待监听的可读文件集合 fd_set *writefds,//待监听的可写文件集合 fd_set *exceptfds,//待监听的异常文件集合 const PTIMEVAL timeout);//超时设置 传入NULL为阻塞模式 传入timeval结构体为非阻塞模式 返回值为满足条件的待监听socket数量和，如果出错返回-1，如果超时返回0。 一、对fd_set的优化&emsp;&emsp;首先，我们可以对fd_set的相关操作进行优化。&emsp;&emsp;之前，我们每进行一次select操作，都要使用循环把所有的已连接socket放到fd_set集合中，随后进行选择操作。但是当连接数很大、select操作频繁时，不断的新建fd_set并用循环放入socket，很明显会大大增大系统的消耗。&emsp;&emsp;由于fd_set集合中一定存放的是当前所有的socket，由此，我们可以建立两个fd_set集合与一个bool变量。bool变量用来表示socket的组成是否发生了变化，当有客户端加入或断开时，该变量为true，否则为false。&emsp;&emsp;我们使用一个fd_set集合储存”老的”socket集合，当socket集合没有发生变化时，我们另一个新fd_set集合直接使用memcpy函数复制老集合中的内容，从而避免从头循环放入。当socket集合发生变化时，新集合直接循环从头录入，随后老集合使用memcpy函数把新集合内的内容复制过去，方便下一次使用。&emsp;&emsp;这样，我们即可大大减少关于fd_set集合初始化的消耗。 二、对select函数的优化&emsp;&emsp;当前我的代码只对read可读集合进行操作，并没有write可写集合与except异常集合的操作，所以我的select目前第三、第四个参数都传了空。这样可以增加一点select的效率。 1select(_sock+1,&amp;fdRead,0,0,&amp;s_t); &emsp;&emsp;其余因为select函数被封装了，目前就我的水平来言应该没法做进一步的优化，可能以后会有吧。 三、对FD_ISSET的优化&emsp;&emsp;这是select架构里吃资源的大头，当socket连接数很大时，显而易见的是这种O(N^2)的查询方法会极大的消耗资源。对此我们可以引入map加快查找操作。 1std::map&lt;socket,Client&gt; _clients; &emsp;&emsp;socket当键，客户端对象当值。根据select处理后的fd_set集合内的socket进行查找。效率提高为O(lgN)。","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"网络编程","slug":"网络编程","permalink":"https://zgg2001.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"C++网络编程学习：服务端多线程分离业务处理高负载","slug":"20210207_C++网络编程学习：服务端多线程分离业务处理高负载","date":"2021-02-07T06:05:55.000Z","updated":"2021-02-07T06:05:55.000Z","comments":true,"path":"2021/02/07/20210207_C++网络编程学习：服务端多线程分离业务处理高负载/","permalink":"https://zgg2001.github.io/2021/02/07/20210207_C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%86%E7%A6%BB%E4%B8%9A%E5%8A%A1%E5%A4%84%E7%90%86%E9%AB%98%E8%B4%9F%E8%BD%BD/","excerpt":"使用的语言为C&#x2F;C++ 源码支持的平台为：Windows &#x2F; Linux 一、思路与准备之前的服务端思路大概是如下的： 123456789101.建立socket2.绑定端口IP3.监听端口while(true)&#123; 4.使用select函数获取存在待监听事件的socket 5.如果有新的连接则与新的客户端连接 6.如果有待监听事件，则对其进行处理(接受与发送)&#125;7.关闭socket &emsp;&emsp;但是，这样的架构在select处理事件较多时，很容易效率低下。对于这类问题，我们可以引入生产者与消费者模式，来处理此类并发问题。","text":"使用的语言为C&#x2F;C++ 源码支持的平台为：Windows &#x2F; Linux 一、思路与准备之前的服务端思路大概是如下的： 123456789101.建立socket2.绑定端口IP3.监听端口while(true)&#123; 4.使用select函数获取存在待监听事件的socket 5.如果有新的连接则与新的客户端连接 6.如果有待监听事件，则对其进行处理(接受与发送)&#125;7.关闭socket &emsp;&emsp;但是，这样的架构在select处理事件较多时，很容易效率低下。对于这类问题，我们可以引入生产者与消费者模式，来处理此类并发问题。 &emsp;&emsp;主线程为生产者线程，用来处理新客户端加入事件，把新客户端分配至消费者线程中。消费者线程便是我们建立的新线程，专门用来处理客户端发送的报文。这样就实现了事件处理的分离，从而使服务端处理效率更高。当过多客户端同时涌入时，可以更快的建立连接(因为有专门的线程用来处理这一事件)；而当客户端发送报文频率很快时，多线程处理报文也会大大提高效率。 大致改进思路如下，红色的为此次需要加入的核心，黑色为原本架构 &emsp;&emsp;所以我们首先需要新建一个线程类，用来封装关于消费者线程的内容，从而建立多线程架构。随后，在本次的改进中，我决定加入计时器用来统计数据以及显示数据，主要需要统计的数据为：当前客户端连接数量、数据包的每秒接收数量。同时，我也对报文类型进行了分离，把报文类型放在单独的头文件里，这样既方便更改也方便引用。 1.计时器相关请点这里 &emsp;&emsp; 2.多线程相关请点这里 二、代码的改进1.新建子线程类 首先是新建线程类CellServer，其中包含的基础方法以及相关变量如下： 123456789101112131415161718192021222324252627282930313233343536373839404142//线程类class CellServer&#123;public: //构造 CellServer(SOCKET sock = INVALID_SOCKET); //析构 ~CellServer(); //关闭socket void CloseSocket(); //判断是否工作中 bool IsRun(); //查询是否有待处理消息 bool OnRun(); //接收数据 int RecvData(ClientSocket *t_client); //响应数据 void NetMsg(DataHeader *head,SOCKET temp_socket); //增加客户端 void addClient(ClientSocket* client); //启动线程 void Start(); //获取该线程内客户端数量 int GetClientCount() private: //缓冲区相关 char *_Recv_buf;//接收缓冲区 //socket相关 SOCKET _sock; //正式客户队列 std::vector&lt;ClientSocket*&gt; _clients;//储存客户端 //客户缓冲区队列 std::vector&lt;ClientSocket*&gt; _clientsBuf; std::mutex _mutex;//锁 //线程 std::thread* _pThread;public: std::atomic_int _recvCount;//接收包的数量 &#125;; 大致处理思路如下：12345678910111213141516171819线程外：Start() 首先调用该方法启动线程新客户端加入：GetClientCount() 首先主线程使用这个方法获取各个线程内客户端数量//这个添加客户端的方法内涉及到临界区，需要上锁addClient(ClientSocket* client) 主线程找到客户端数量最少的线程，使用该线程添加客户端至缓冲队列线程内：OnRun()//运行线程&#123; while(IsRun())//判断是否工作中 &#123; 1.将缓冲队列中的客户数据加入正式队列 2.正式客户队列为空的话，continue本次循环 3.select选择出待处理事件，错误的话就关闭所有连接CloseSocket() 4.对待处理事件进行接收RecvData()，接收包的数量加一，随后处理NetMsg() &#125;&#125; 2.客户端主线程类的更改&emsp;&emsp;由于我们处理事件都改为在子线程中，所以首先主线程中是不需要处理报文消息了，所以类中接收消息和处理消息的方法都可以删除了。同时我们加入Start方法用来启动子线程，加入time4msg方法用来显示子线程中的客户端数量、每秒收包数等数据。 主线程类TcpServer，更改后如下： 12345678910111213141516171819202122232425262728293031323334353637class TcpServer : INetEvent&#123;public: //构造 TcpServer(); //析构 ~TcpServer(); //初始化socket 返回1为正常 int InitSocket(); //绑定IP/端口 int Bind(const char* ip,unsigned short port); //监听端口 int Listen(int n); //接受连接 int Accept(); //添加客户端至服务端 void AddClientToServer(ClientSocket* pClient); //线程启动 void Start(); //关闭socket void CloseSocket(); //判断是否工作中 bool IsRun(); //查询是否有待处理消息 bool OnRun(); //显示各线程数据信息 void time4msg(); private: //socket相关 SOCKET _sock; std::vector&lt;ClientSocket*&gt; _clients;//储存客户端 std::vector&lt;CellServer*&gt; _cellServers;//子线程们 //计时器 mytimer _time; &#125;; 大致处理思路如下：计时器相关请点这里12345678910111213141516171819202122232425262728调用TcpServer封装类建立服务端的流程：1.InitSocket() 建立一个socket2.Bind(const char* ip,unsigned short port) 绑定端口和IP3.Listen(int n) 监听4.Start() 线程启动while(5.IsRun()) 主线程循环 &#123; 6.OnRun() 开始select选择处理事件&#125;7.CloseSocket() 关闭socket主线程内：OnRun()&#123; time4msg()显示数据 select选择出新客户端加入事件 如果有新客户端加入，调用Accept()接受连接 Accept()连接成功后，调用AddClientToServer(ClientSocket* pClient)分配客户端到子线程中&#125;AddClientToServer()内：首先调用子线程的GetClientCount()方法获取各条子线程中的客户端数量随后调用子线程的addClient(ClientSocket* client)方法，把新客户端添加至客户端最少的线程中time4msg()内：首先GetSecond()获取计时器的计时如果大于一秒，就统计客户端的情况：子线程内_recvCount为收包数，主线程内_clients.size()获取客户端数量显示后UpDate()重置计时器，并且重置收包数，从而达到统计每秒收包数的作用 3.引入接口，实现子线程向主线程通信&emsp;&emsp;通过前两步的实现，多线程服务端已经初步完成，接下来需要进行一些完善。&emsp;&emsp;我们很容易可以发现，子线程对象是在主线程Start()方法被创建的，随后被加入容器_cellServers储存。这就导致主线程中可以调用子线程类中的方法与成员变量，但是子线程中却无法调用主线程的方法与成员变量。从而导致当子线程中有客户端退出时，主线程无法了解。&emsp;&emsp;对于这种情况，我们可以创建一个接口，让主线程类继承这个接口，子线程即可通过这个接口调用主线程中的特定方法。 接口类INetEvent如下：1234567class INetEvent&#123;public: //有客户端退出 virtual void OnLeave(ClientSocket* pClient) = 0;private: &#125;; 主线程类与子线程类中的相关实现： 1234567891011121314151617181920212223242526272829303132333435363738391.首先是主线程类继承该接口：class TcpServer : INetEvent2.随后实现接口中的虚方法：//客户端退出void OnLeave(ClientSocket* pClient)&#123; //找到退出的客户端 for(int n=0; n&lt;_clients.size(); n++) &#123; if(_clients[n] == pClient) &#123; auto iter = _clients.begin() + n; if(iter != _clients.end()) &#123; _clients.erase(iter);//移除 &#125; &#125; &#125; &#125; 即可实现调用该方法，移除客户端容器中指定客户端3.随后在子线程类中添加私有成员变量： private: INetEvent* _pNetEvent; 创建接口对象4.创建方法，让接口对象指向主线程类void setEventObj(INetEvent* event)&#123; _pNetEvent = event; &#125;event传进去主线程即可，接口对象即指向主线程5.主线程创建、启动子线程类时，调用该方法，传入自身this子线程对象-&gt;setEventObj(this);6.随后即可通过子线程调用主线程的OnLeave()方法删除客户端_pNetEvent-&gt;OnLeave(要删除的客户端); 三、详细代码实现1.计时器头文件 mytimer.hpp12345678910111213141516171819202122232425262728293031323334353637#ifndef MY_TIMER_H_#define MY_TIMER_H_#include&lt;chrono&gt;class mytimer&#123;private: std::chrono::steady_clock::time_point _begin;//起始时间 std::chrono::steady_clock::time_point _end;//终止时间public: mytimer() &#123; _begin = std::chrono::steady_clock::time_point(); _end = std::chrono::steady_clock::time_point(); &#125; virtual ~mytimer()&#123;&#125;; //调用update时，使起始时间等于当前时间 void UpDate() &#123; _begin = std::chrono::steady_clock::now(); &#125; //调用getsecond方法时，经过的时间为当前时间减去之前统计过的起始时间。 double GetSecond() &#123; _end = std::chrono::steady_clock::now(); //使用duration类型变量进行时间的储存 duration_cast是类型转换方法 std::chrono::duration&lt;double&gt; temp = std::chrono::duration_cast&lt;std::chrono::duration&lt;double&gt;&gt;(_end - _begin); return temp.count();//count() 获取当前时间的计数数量 &#125; &#125;;#endif 2.命令头文件 CMD.h12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//枚举类型记录命令 enum cmd &#123; CMD_LOGIN,//登录 CMD_LOGINRESULT,//登录结果 CMD_LOGOUT,//登出 CMD_LOGOUTRESULT,//登出结果 CMD_NEW_USER_JOIN,//新用户登入 CMD_ERROR//错误 &#125;;//定义数据包头 struct DataHeader &#123; short cmd;//命令 short date_length;//数据的长短 &#125;;//包1 登录 传输账号与密码struct Login : public DataHeader &#123; Login()//初始化包头 &#123; this-&gt;cmd = CMD_LOGIN; this-&gt;date_length = sizeof(Login); &#125; char UserName[32];//用户名 char PassWord[32];//密码 &#125;;//包2 登录结果 传输结果struct LoginResult : public DataHeader &#123; LoginResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGINRESULT; this-&gt;date_length = sizeof(LoginResult); &#125; int Result;&#125;;//包3 登出 传输用户名 struct Logout : public DataHeader &#123; Logout()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUT; this-&gt;date_length = sizeof(Logout); &#125; char UserName[32];//用户名 &#125;;//包4 登出结果 传输结果struct LogoutResult : public DataHeader &#123; LogoutResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUTRESULT; this-&gt;date_length = sizeof(LogoutResult); &#125; int Result;&#125;;//包5 新用户登入 传输通告 struct NewUserJoin : public DataHeader &#123; NewUserJoin()//初始化包头 &#123; this-&gt;cmd = CMD_NEW_USER_JOIN; this-&gt;date_length = sizeof(NewUserJoin); &#125; char UserName[32];//用户名 &#125;; 3.服务端头文件 TcpServer.hpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655#ifndef _TcpServer_hpp_#define _TcpServer_hpp_#ifdef _WIN32 #define FD_SETSIZE 10240 #define WIN32_LEAN_AND_MEAN #include&lt;winSock2.h&gt; #include&lt;windows.h&gt; #pragma comment(lib,&quot;ws2_32.lib&quot;)//链接此动态链接库 windows特有 #else #include&lt;arpa/inet.h&gt;//selcet #include&lt;unistd.h&gt;//uni std #include&lt;string.h&gt; #define SOCKET int #define INVALID_SOCKET (SOCKET)(~0) #define SOCKET_ERROR (-1)#endif#include&quot;CMD.h&quot;//命令 #include&quot;mytimer.hpp&quot;//计时器 #include&lt;stdio.h&gt;#include&lt;vector&gt;#include&lt;thread&gt; #include&lt;mutex&gt;#include&lt;atomic&gt;//缓冲区大小 #ifndef RECV_BUFFER_SIZE #define RECV_BUFFER_SIZE 4096#endif //线程数量 #define _THREAD_COUNT 4//客户端类 class ClientSocket&#123;public: //构造 ClientSocket(SOCKET sockfd = INVALID_SOCKET) &#123; _sockfd = sockfd; //缓冲区相关 _Msg_buf = new char[RECV_BUFFER_SIZE*10]; _Len_buf = 0; &#125; //析构 virtual ~ClientSocket() &#123; delete[] _Msg_buf; &#125; //获取socket SOCKET GetSockfd() &#123; return _sockfd; &#125; //获取缓冲区 char* MsgBuf() &#123; return _Msg_buf; &#125; //获取缓冲区尾部变量 int GetLen() &#123; return _Len_buf; &#125; //设置缓冲区尾巴变量 void SetLen(int len) &#123; _Len_buf = len; &#125; private: SOCKET _sockfd; //缓冲区相关 char *_Msg_buf;//消息缓冲区 int _Len_buf;//缓冲区数据尾部变量&#125;; //事件接口class INetEvent&#123;public: //有客户端退出 virtual void OnLeave(ClientSocket* pClient) = 0;private: &#125;;//线程类class CellServer&#123;public: //构造 CellServer(SOCKET sock = INVALID_SOCKET) &#123; _sock = sock; _pThread = nullptr; _pNetEvent = nullptr; _recvCount = 0; //缓冲区相关 _Recv_buf = new char[RECV_BUFFER_SIZE]; &#125; //析构 ~CellServer() &#123; delete[] _Recv_buf; //关闭socket CloseSocket(); _sock = INVALID_SOCKET; &#125; //处理事件 void setEventObj(INetEvent* event) &#123; _pNetEvent = event; &#125; //关闭socket void CloseSocket() &#123; if(INVALID_SOCKET != _sock) &#123;#ifdef _WIN32 //关闭客户端socket for(int n=0; n&lt;_clients.size(); ++n) &#123; closesocket(_clients[n]-&gt;GetSockfd()); delete _clients[n]; &#125; //关闭socket closesocket(_sock); //清除windows socket 环境 WSACleanup(); #else //关闭客户端socket for(int n=0; n&lt;_clients.size(); ++n) &#123; close(_clients[n]-&gt;GetSockfd()); delete _clients[n]; &#125; //关闭socket/LINUX close(_sock);#endif _sock = INVALID_SOCKET; _clients.clear(); &#125; &#125; //判断是否工作中 bool IsRun() &#123; return _sock != INVALID_SOCKET; &#125; //查询是否有待处理消息 bool OnRun() &#123; while(IsRun()) &#123; //将缓冲队列中的客户数据加入正式队列 if(_clientsBuf.size() &gt; 0) &#123; std::lock_guard&lt;std::mutex&gt; lock(_mutex);//上锁 for(auto client :_clientsBuf) &#123; _clients.push_back(client); &#125; _clientsBuf.clear(); &#125; //如果没有需要处理的客户端就跳过 if(_clients.empty()) &#123; std::chrono::milliseconds t(1);//休眠一毫秒 std::this_thread::sleep_for(t); continue; &#125; fd_set fdRead;//建立集合 FD_ZERO(&amp;fdRead);//清空集合 SOCKET maxSock = _clients[0]-&gt;GetSockfd();//最大socket //把连接的客户端 放入read集合 for(int n=_clients.size()-1; n&gt;=0; --n) &#123; FD_SET(_clients[n]-&gt;GetSockfd(),&amp;fdRead); if(maxSock &lt; _clients[n]-&gt;GetSockfd()) &#123; maxSock = _clients[n]-&gt;GetSockfd(); &#125; &#125; //select函数筛选select int ret = select(maxSock+1,&amp;fdRead,0,0,0); if(ret&lt;0) &#123; printf(&quot;select任务结束\\n&quot;); CloseSocket(); return false; &#125; //遍历所有socket 查看是否有待处理事件 for(int n=0; n&lt;_clients.size(); ++n) &#123; if(FD_ISSET(_clients[n]-&gt;GetSockfd(),&amp;fdRead)) &#123; if(-1 == RecvData(_clients[n]))//处理请求 客户端退出的话 &#123; std::vector&lt;ClientSocket*&gt;::iterator iter = _clients.begin()+n;//找到退出客户端的地址 if(iter != _clients.end())//如果是合理值 &#123; if(_pNetEvent)//主线程中删除客户端 &#123; _pNetEvent-&gt;OnLeave(_clients[n]); &#125; delete _clients[n]; _clients.erase(iter);//移除 &#125; &#125; &#125; &#125; //printf(&quot;空闲时间处理其他业务\\n&quot;); &#125; &#125; //接收数据 int RecvData(ClientSocket *t_client)//处理数据 &#123; _recvCount++;//收包数量加一 //接收客户端发送的数据 int buf_len = recv(t_client-&gt;GetSockfd(), _Recv_buf, RECV_BUFFER_SIZE, 0); if(buf_len&lt;=0) &#123; printf(&quot;客户端已退出\\n&quot;); return -1; &#125; //将接收缓冲区的数据拷贝到消息缓冲区 memcpy(t_client-&gt;MsgBuf() + t_client-&gt;GetLen(), _Recv_buf, buf_len); //消息缓冲区的数据末尾后移 t_client-&gt;SetLen(t_client-&gt;GetLen() + buf_len); //判断消息缓冲区的数据长度是否大于等于包头长度 while(t_client-&gt;GetLen() &gt;= sizeof(DataHeader))//处理粘包问题 &#123; //选出包头数据 DataHeader* header = (DataHeader*)t_client-&gt;MsgBuf(); //判断消息缓冲区内数据长度是否大于等于报文长度 避免少包问题 if(t_client-&gt;GetLen() &gt;= header-&gt;date_length) &#123; //计算出消息缓冲区内剩余未处理数据的长度 int size = t_client-&gt;GetLen() - header-&gt;date_length; //响应数据 NetMsg(header,t_client-&gt;GetSockfd()); //将消息缓冲区剩余未处理的数据前移 memcpy(t_client-&gt;MsgBuf(), t_client-&gt;MsgBuf() + header-&gt;date_length, size); //消息缓冲区的数据末尾前移 t_client-&gt;SetLen(size); &#125; else &#123; //消息缓冲区数据不足 break; &#125; &#125; return 0; &#125; //响应数据 void NetMsg(DataHeader *head,SOCKET temp_socket) &#123; //printf(&quot;接收到包头，命令：%d，数据长度：%d\\n&quot;,head-&gt;cmd,head-&gt;date_length); switch(head-&gt;cmd) &#123; case CMD_LOGIN://登录 接收登录包体 &#123; Login *login = (Login*)head; /* 进行判断操作 */ //printf(&quot;%s已登录\\n密码：%s\\n&quot;,login-&gt;UserName,login-&gt;PassWord); LoginResult *result = new LoginResult; result-&gt;Result = 1; //SendData(result,temp_socket); &#125; break; case CMD_LOGOUT://登出 接收登出包体 &#123; Logout *logout = (Logout*)head; /* 进行判断操作 */ //printf(&quot;%s已登出\\n&quot;,logout-&gt;UserName); LogoutResult *result = new LogoutResult(); result-&gt;Result = 1; //SendData(result,temp_socket); &#125; break; default://错误 &#123; head-&gt;cmd = CMD_ERROR; head-&gt;date_length = 0; //SendData(head,temp_socket); &#125; break; &#125; &#125; //增加客户端 void addClient(ClientSocket* client) &#123; std::lock_guard&lt;std::mutex&gt; lock(_mutex); //_mutex.lock(); _clientsBuf.push_back(client); //_mutex.unlock(); &#125; //启动线程 void Start() &#123; _pThread = new std::thread(std::mem_fun(&amp;CellServer::OnRun),this); &#125; //获取该线程内客户端数量 int GetClientCount() &#123; return _clients.size() + _clientsBuf.size(); &#125; private: //缓冲区相关 char *_Recv_buf;//接收缓冲区 //socket相关 SOCKET _sock; //正式客户队列 std::vector&lt;ClientSocket*&gt; _clients;//储存客户端 //客户缓冲区 std::vector&lt;ClientSocket*&gt; _clientsBuf; std::mutex _mutex;//锁 //线程 std::thread* _pThread; //退出事件接口 INetEvent* _pNetEvent; public: std::atomic_int _recvCount;//接收包的数量 &#125;;//服务端类 class TcpServer : INetEvent&#123;public: //构造 TcpServer() &#123; _sock = INVALID_SOCKET; &#125; //析构 virtual ~TcpServer() &#123; //关闭socket CloseSocket(); &#125; //初始化socket 返回1为正常 int InitSocket() &#123;#ifdef _WIN32 //启动windows socket 2,x环境 WORD ver = MAKEWORD(2,2); WSADATA dat; if(0 != WSAStartup(ver,&amp;dat)) &#123; return -1;//-1为环境错误 &#125;#endif //创建socket if(INVALID_SOCKET != _sock) &#123; printf(&quot;&lt;Socket=%d&gt;关闭连接\\n&quot;,_sock); CloseSocket();//如果之前有连接 就关闭连接 &#125; _sock = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP); if(INVALID_SOCKET == _sock) &#123; return 0;//0为socket创建错误 &#125; return 1; &#125; //绑定IP/端口 int Bind(const char* ip,unsigned short port) &#123; //如果为无效套接字 则初始化 if(INVALID_SOCKET == _sock) &#123; InitSocket(); &#125; //绑定网络端口和IP地址 sockaddr_in _myaddr = &#123;&#125;; _myaddr.sin_family = AF_INET;//IPV4 _myaddr.sin_port = htons(port);//端口#ifdef _WIN32 if(ip)//ip为空则监听所有网卡 &#123; _myaddr.sin_addr.S_un.S_addr = inet_addr(ip);//IP &#125; else &#123; _myaddr.sin_addr.S_un.S_addr = INADDR_ANY;//IP &#125;#else if(ip)//ip为空则监听所有网卡 &#123; _myaddr.sin_addr.s_addr = inet_addr(ip);//IP &#125; else &#123; _myaddr.sin_addr.s_addr = INADDR_ANY;//IP &#125;#endif if(SOCKET_ERROR == bind(_sock,(sockaddr*)&amp;_myaddr,sizeof(sockaddr_in)))//socket (强制转换)sockaddr结构体 结构体大小 &#123; printf(&quot;绑定失败\\n&quot;); return 0; &#125; else &#123; printf(&quot;绑定成功\\n绑定端口为%d\\n&quot;,port); return 1; &#125; &#125; //监听端口 int Listen(int n) &#123; //如果为无效套接字 则提示 if(INVALID_SOCKET == _sock) &#123; printf(&quot;请先初始化套接字并绑定IP端口\\n&quot;); return 0; &#125; //监听网络端口 if(SOCKET_ERROR == listen(_sock,n))//最大连接队列 &#123; printf(&quot;监听失败\\n&quot;); return 0; &#125; else &#123; printf(&quot;监听成功\\n&quot;); return 1; &#125; &#125; //接受连接 int Accept() &#123; //等待接收客户端连接 sockaddr_in clientAddr = &#123;&#125;;//新建sockadd结构体接收客户端数据 int addr_len = sizeof(sockaddr_in);//获取sockadd结构体长度 SOCKET temp_socket = INVALID_SOCKET;//声明客户端套接字 #ifdef _WIN32 temp_socket = accept(_sock,(sockaddr*)&amp;clientAddr,&amp;addr_len);//自身套接字 客户端结构体 结构体大小 #else temp_socket = accept(_sock,(sockaddr*)&amp;clientAddr,(socklen_t*)&amp;addr_len);//自身套接字 客户端结构体 结构体大小 #endif if(INVALID_SOCKET == temp_socket)//接收失败 &#123; printf(&quot;&lt;Socket=%d&gt;错误,接受到无效客户端SOCKET\\n&quot;,temp_socket); return 0; &#125; else &#123; //printf(&quot;新客户端加入 count: %d\\nIP地址为：%s \\n&quot;, _clients.size(), inet_ntoa(clientAddr.sin_addr)); //群发所有客户端 通知新用户登录 //NewUserJoin *user_join = new NewUserJoin(); //strcpy(user_join-&gt;UserName,inet_ntoa(clientAddr.sin_addr)); //SendDataToAll(user_join); //将新的客户端加入动态数组 AddClientToServer(new ClientSocket(temp_socket)); return 1; &#125; &#125; //添加客户端至服务端 void AddClientToServer(ClientSocket* pClient) &#123; _clients.push_back(pClient); //找出客户端最少的线程 然后加入 auto pMinServer = _cellServers[0]; for(auto pCellServer : _cellServers) &#123; if(pMinServer-&gt;GetClientCount() &gt; pCellServer-&gt;GetClientCount()) &#123; pMinServer = pCellServer; &#125; &#125; pMinServer-&gt;addClient(pClient); &#125; //线程启动 void Start() &#123; for(int n=0; n&lt;_THREAD_COUNT; n++) &#123; //线程加入容器 auto ser = new CellServer(_sock); _cellServers.push_back(ser); ser-&gt;setEventObj(this); ser-&gt;Start(); &#125; &#125; //关闭socket void CloseSocket() &#123; if(INVALID_SOCKET != _sock) &#123;#ifdef _WIN32 //关闭客户端socket for(int n=0; n&lt;_clients.size(); ++n) &#123; closesocket(_clients[n]-&gt;GetSockfd()); delete _clients[n]; &#125; //关闭socket closesocket(_sock); //清除windows socket 环境 WSACleanup(); #else //关闭客户端socket for(int n=0; n&lt;_clients.size(); ++n) &#123; close(_clients[n]-&gt;GetSockfd()); delete _clients[n]; &#125; //关闭socket/LINUX close(_sock);#endif _sock = INVALID_SOCKET; _clients.clear(); &#125; &#125; //判断是否工作中 bool IsRun() &#123; return _sock != INVALID_SOCKET; &#125; //查询是否有待处理消息 bool OnRun() &#123; if(IsRun()) &#123; time4msg();//查看各线程数据信息 fd_set fdRead;//建立集合 //fd_set fdWrite; //fd_set fdExcept; FD_ZERO(&amp;fdRead);//清空集合 //FD_ZERO(&amp;fdWrite); //FD_ZERO(&amp;fdExcept); FD_SET(_sock,&amp;fdRead);//放入集合 //FD_SET(_sock,&amp;fdWrite); //FD_SET(_sock,&amp;fdExcept); timeval s_t = &#123;0,0&#125;;//select最大响应时间 //select函数筛选select int ret = select(_sock+1,&amp;fdRead,0,0,&amp;s_t); if(ret&lt;0) &#123; printf(&quot;select任务结束\\n&quot;); CloseSocket(); return false; &#125; if(FD_ISSET(_sock,&amp;fdRead))//获取是否有新socket连接 &#123; FD_CLR(_sock,&amp;fdRead);//清理 Accept();//连接 &#125; return true; &#125; return false; &#125; //显示各线程数据信息 void time4msg() &#123; auto t1 = _time.GetSecond(); if(1.0 &lt;= t1) &#123; int recvCount = 0; for(auto ser: _cellServers) &#123; recvCount += ser-&gt;_recvCount; ser-&gt;_recvCount = 0; &#125; //时间间隔 本机socket连接序号 客户端数量 每秒收包数 printf(&quot;time&lt;%lf&gt;,socket&lt;%d&gt;,clients&lt;%d&gt;,recvCount&lt;%d&gt;\\n&quot;, t1, _sock, _clients.size(),(int)(recvCount/t1)); _time.UpDate(); &#125; &#125; //发送数据 int SendData(DataHeader *head,SOCKET temp_socket) &#123; if(IsRun() &amp;&amp; head) &#123; send(temp_socket,(const char*)head,head-&gt;date_length,0); return 1; &#125; return 0; &#125; //向所有人发送数据 void SendDataToAll(DataHeader *head) &#123; for(int n=0;n&lt;_clients.size();++n) &#123; SendData(head, _clients[n]-&gt;GetSockfd()); &#125; &#125; //客户端退出 void OnLeave(ClientSocket* pClient) &#123; //找到退出的客户端 for(int n=0; n&lt;_clients.size(); n++) &#123; if(_clients[n] == pClient) &#123; auto iter = _clients.begin() + n; if(iter != _clients.end()) &#123; _clients.erase(iter);//移除 &#125; &#125; &#125; &#125; private: //socket相关 SOCKET _sock; std::vector&lt;ClientSocket*&gt; _clients;//储存客户端 std::vector&lt;CellServer*&gt; _cellServers;//线程处理 //计时器 mytimer _time; &#125;;#endif 4.服务端样例代码 server.cpp1234567891011121314151617181920212223242526272829#include&quot;TcpServer.hpp&quot; int main() &#123; printf(&quot;Welcome\\n&quot;); //建立tcp对象 TcpServer *tcp1 = new TcpServer(); //建立一个socket tcp1-&gt;InitSocket(); //绑定端口和IP tcp1-&gt;Bind(NULL,8888); //监听 tcp1-&gt;Listen(5); //线程启动 tcp1-&gt;Start(); //循环 while(tcp1-&gt;IsRun()) &#123; tcp1-&gt;OnRun(); &#125; //关闭 tcp1-&gt;CloseSocket(); printf(&quot;任务结束，程序已退出&quot;); getchar(); return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"网络编程","slug":"网络编程","permalink":"https://zgg2001.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"C++学习记录：基于chrono库的高精度计时器","slug":"20210205_C++学习记录：基于chrono库的高精度计时器","date":"2021-02-05T11:25:08.000Z","updated":"2021-02-05T11:25:08.000Z","comments":true,"path":"2021/02/05/20210205_C++学习记录：基于chrono库的高精度计时器/","permalink":"https://zgg2001.github.io/2021/02/05/20210205_C++%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E5%9F%BA%E4%BA%8Echrono%E5%BA%93%E7%9A%84%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%AE%A1%E6%97%B6%E5%99%A8/","excerpt":"&emsp;&emsp;C++11中新引入了std::chrono库，由此可以较为容易的实现一个计时器。同时，休眠操作也可以通过这个库来实现，从而使代码有良好的跨平台性，避免使用Windows&#x2F;Linux的系统休眠函数。&emsp;&emsp;在接下来的网络编程学习中，将引入该计时器，实现对每秒收包、连接等数据的计数显示。&emsp;&emsp;本篇学习记录使用的语言为C++，调用的库为C++11里的std::chrono库。","text":"&emsp;&emsp;C++11中新引入了std::chrono库，由此可以较为容易的实现一个计时器。同时，休眠操作也可以通过这个库来实现，从而使代码有良好的跨平台性，避免使用Windows&#x2F;Linux的系统休眠函数。&emsp;&emsp;在接下来的网络编程学习中，将引入该计时器，实现对每秒收包、连接等数据的计数显示。&emsp;&emsp;本篇学习记录使用的语言为C++，调用的库为C++11里的std::chrono库。 一、简易的计时器类mytimer.hpp代码如下： 123456789101112131415161718192021222324252627282930313233343536#ifndef MY_TIMER_H_#define MY_TIMER_H_#include&lt;chrono&gt;class mytimer&#123;private: std::chrono::steady_clock::time_point _begin;//起始时间 std::chrono::steady_clock::time_point _end;//终止时间public: mytimer() &#123; _begin = std::chrono::steady_clock::time_point(); _end = std::chrono::steady_clock::time_point(); &#125; virtual ~mytimer()&#123;&#125;; //调用update时，使起始时间等于当前时间 void UpDate() &#123; _begin = std::chrono::steady_clock::now(); &#125; //调用getsecond方法时，经过的时间为当前时间减去之前统计过的起始时间。 double GetSecond() &#123; _end = std::chrono::steady_clock::now(); //使用duration类型变量进行时间的储存 duration_cast是类型转换方法 std::chrono::duration&lt;double&gt; temp = std::chrono::duration_cast&lt;std::chrono::duration&lt;double&gt;&gt;(_end - _begin); return temp.count();//count() 获取当前时间的计数数量 &#125;&#125;;#endif 测试该计时器的代码示例 main.cpp 代码如下： 1234567891011121314#include&quot;mytimer.hpp&quot;#include&lt;iostream&gt;int main()&#123; mytimer _time; _time.UpDate(); for(int n=0;n&lt;100000000;n++) &#123; &#125; std::cout&lt;&lt;_time.GetSecond(); return 0;&#125; 二、基于chrono库的休眠使用方法如下： 12std::chrono::milliseconds t(1);//休眠一毫秒 std::this_thread::sleep_for(t);","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"C++标准库学习","slug":"C-标准库学习","permalink":"https://zgg2001.github.io/tags/C-%E6%A0%87%E5%87%86%E5%BA%93%E5%AD%A6%E4%B9%A0/"}]},{"title":"C++学习记录：多线程相关","slug":"20210131_C++学习记录：多线程相关","date":"2021-01-31T06:08:47.000Z","updated":"2021-01-31T06:08:47.000Z","comments":true,"path":"2021/01/31/20210131_C++学习记录：多线程相关/","permalink":"https://zgg2001.github.io/2021/01/31/20210131_C++%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/","excerpt":"&emsp;&emsp;之前学过一点C语言多线程方面的内容(pthread.h)，但是仅仅是会用，对多线程的实现原理什么的基本上算是不了解。接下来，我的网络编程学习要进一步对代码进行优化，其中肯定少不了对多线程的运用，所以在进行下一步之前，先系统的学习一下多线程。&emsp;&emsp;本篇学习记录使用的语言为C++，调用的线程库为C++11里的std::thread库。","text":"&emsp;&emsp;之前学过一点C语言多线程方面的内容(pthread.h)，但是仅仅是会用，对多线程的实现原理什么的基本上算是不了解。接下来，我的网络编程学习要进一步对代码进行优化，其中肯定少不了对多线程的运用，所以在进行下一步之前，先系统的学习一下多线程。&emsp;&emsp;本篇学习记录使用的语言为C++，调用的线程库为C++11里的std::thread库。 零、基本概念&emsp;&emsp;一个进程可以有多个线程，而一个线程只能属于一个进程。 &emsp;&emsp;单核CPU的多线程执行为每条线程代码执行一段时间后进行切换，实际还是为同时进行一条线程，因为切换的速度很快，给人一种同时进行的错觉；而多核CPU的多线程执行为同时进行多条线程，当线程数量大于核数量时，也会进行线程的切换，保证线程的进行。 &emsp;&emsp;多线程的执行是抢占式的，即多条线程下，没有运行顺序的规律， 一、基本线程创建 thread如下所示，新建一个thread对象，构造函数传参第一个为线程执行函数，随后为执行函数的传参。 123456789101112#include&lt;thread&gt;using namespace std;thread *t1 = new thread(work,1111); void work(int a)&#123; for(int n=0;n&lt;a;n++) &#123; printf(&quot;%d\\n&quot;,a); &#125; &#125; 如下所示，新建一个thread数组，构造函数传参第一个为线程执行函数，随后为执行函数的传参。 12345678910111213141516#include&lt;thread&gt;using namespace std;thread *t[4];for(int n=0;n&lt;4;n++)&#123; t[n] = new thread(work,n);&#125;void work(int a)&#123; for(int n=0;n&lt;a;n++) &#123; printf(&quot;%d\\n&quot;,a); &#125; &#125; 二、等待&#x2F;分离 join/detach&emsp;&emsp;join是在main函数中等待线程执行完才继续执行main函数，detach则是把该线程分离出来，不管这个线程执行得怎样，往下继续执行main函数。 join操作会等待线程执行完毕，然后回收该线程资源；detach操作则不会等待线程完成，线程资源的回收由init进程完成。 12345678910#include&lt;thread&gt;using namespace std;thread *t[4];for(int n=0;n&lt;4;n++)&#123; t[n] = new thread(work,n); t[n]-&gt;detach();//线程分离 t[n]-&gt;join();//线程不分离&#125; 三、锁 lock/unlock&emsp;&emsp;由于线程的执行是抢占式的，且变量资源等是共享的，对于多条线程同时执行的情况下，可能对同一段内容同时执行，其中涉及到的变量操作等就会产生错误。类似同时对一个变量进行运算操作，由于赋值前的值不同，结果也就不同，导致数据出现问题。此时就可以使用锁的操作防止此类错误发生。 上锁的区域同时只能被一条线程执行，由此来解决同时执行造成错误的问题。123456789101112131415#include&lt;mutex&gt;//锁的头文件#include&lt;thread&gt;using namespace std;mutex m;//锁的变量void work(int a)&#123; for(int n=0;n&lt;4;n++) &#123; m.lock();//临界区域 开始 锁掉相关区域 避免同时调用printf操作导致打印混乱 printf(&quot;%d\\n&quot;,a); m.unlock();//临界区域 结束 解锁 &#125;&#125; &emsp;&emsp;但是不停的上锁和解锁很容易忘记解锁，就会出现该段代码无法被执行，导致程序出现问题，且不会报错。为了避免这种情况，我们可以使用自解锁。自解锁会自动对所处区间的代码进行上锁和解锁操作，从而防止忘解锁的情况发生。 自解锁的大致原理其实就是构造器进行上锁，析构器进行解锁…1234567891011121314#include&lt;mutex&gt;//锁的头文件#include&lt;thread&gt;using namespace std;mutex m;//锁的变量void work(int a)&#123; for(int n=0;n&lt;4;n++) &#123; lock_guard&lt;mutex&gt;lock1(m); //自解锁 printf(&quot;%d\\n&quot;,a); &#125;&#125; 四、原子操作 atomic&emsp;&emsp;频繁的上锁解锁操作会非常耗时，如果上锁区域执行的代码很少的话会非常不划算。如果我们在多线程中需要对变量操作的话，频繁的给变量操作区域上下锁性价比很低，此时我们可以使用原子变量。 原子变量同时只能被一条线程操作，相比读写锁，速度快了不止一个量级。123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;thread&gt;#include&lt;atomic&gt;//原子操作using namespace std;atomic_int count(0); //原子变量void work(int a)&#123; for(int n=0;n&lt;2;n++) &#123; printf(&quot;other thread:%d\\n&quot;,a); count++; &#125;&#125;int main()&#123; thread *t[4]; for(int n=0;n&lt;4;n++) &#123; t[n] = new thread(work,n); t[n]-&gt;join(); &#125; for(int n=0;n&lt;2;n++) &#123; printf(&quot;main thread\\n&quot;); count++; &#125; while(1) &#123; cout&lt;&lt;count; getchar(); &#125; return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"C++标准库学习","slug":"C-标准库学习","permalink":"https://zgg2001.github.io/tags/C-%E6%A0%87%E5%87%86%E5%BA%93%E5%AD%A6%E4%B9%A0/"}]},{"title":"KeepAlive小项目 基于Qt/C++实现后台自动提醒休息","slug":"20210129_KeepAlive小项目基于Qt-C++实现后台自动提醒休息","date":"2021-01-29T14:29:05.000Z","updated":"2021-01-29T14:29:05.000Z","comments":true,"path":"2021/01/29/20210129_KeepAlive小项目基于Qt-C++实现后台自动提醒休息/","permalink":"https://zgg2001.github.io/2021/01/29/20210129_KeepAlive%E5%B0%8F%E9%A1%B9%E7%9B%AE%E5%9F%BA%E4%BA%8EQt-C++%E5%AE%9E%E7%8E%B0%E5%90%8E%E5%8F%B0%E8%87%AA%E5%8A%A8%E6%8F%90%E9%86%92%E4%BC%91%E6%81%AF/","excerpt":"&emsp;&emsp;前两天在blink上发的思路，花了一天时间给实现了 。不得不说，好久没写Qt程序，手生了不少，要不应该可以更有效率的。 一、功能主要实现以下功能： 显示当前系统时间 给定一个定期提醒时间间隔，显示离提醒还有多久 显示程序运行以来经过的时间 可最小化到托盘，实现后台运行 当达到提醒时间间隔后，弹窗提醒","text":"&emsp;&emsp;前两天在blink上发的思路，花了一天时间给实现了 。不得不说，好久没写Qt程序，手生了不少，要不应该可以更有效率的。 一、功能主要实现以下功能： 显示当前系统时间 给定一个定期提醒时间间隔，显示离提醒还有多久 显示程序运行以来经过的时间 可最小化到托盘，实现后台运行 当达到提醒时间间隔后，弹窗提醒 辅助功能： 可手动输入，调整时间间隔 可自动创建桌面快捷方式 关于 二、详细介绍程序主界面（下图），可见有三个菜单按钮 在点击程序右上角退出键后，程序会进入托盘最小化，在后台运行。（如下图）同时会弹出通知。 此时左键单击托盘图标，弹出提示提醒时间。 左键双击，即可显示主窗口。 鼠标右键单击，显示菜单，可令程序退出。 第一个菜单点开后分别为：创建快捷方式、设置相关参数、退出。 创建快捷方式 点击后弹窗，点击确定后随即在桌面建立快捷方式。（如下图） 设置相关参数 点击后弹窗，可以修改时间间隔参数，范围为1~86400秒。（如下图）输入不正确值后会进行提醒。（如下图）当输入正确值后，计时会重置。 退出，点击退出后，程序彻底退出，不会进入托盘最小化。 第三个菜单内容为显示切换，点击后即可进行切换操作 当前系统时间 提醒时间倒计时 系统(软件)开启时间 当倒计时为0时，显示窗口进行提醒。 三、源码下载点我下载 四、可执行文件下载点我下载 密码：6eo1","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"QT","slug":"QT","permalink":"https://zgg2001.github.io/tags/QT/"}]},{"title":"C++网络编程学习：缓冲区溢出与粘包分包","slug":"20210128_C++网络编程学习：缓冲区溢出与粘包分包","date":"2021-01-28T03:53:13.000Z","updated":"2021-01-28T03:53:13.000Z","comments":true,"path":"2021/01/28/20210128_C++网络编程学习：缓冲区溢出与粘包分包/","permalink":"https://zgg2001.github.io/2021/01/28/20210128_C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E4%B8%8E%E7%B2%98%E5%8C%85%E5%88%86%E5%8C%85/","excerpt":"使用的语言为C&#x2F;C++ 源码支持的平台为：Windows &#x2F; Linux 一、关于缓冲区溢出1.缓冲区溢出的原因&emsp;&emsp;之前我们所编写的服务端与客户端的数据量都是很小的，且操作也不频繁，需要键入指令发送报文。 &emsp;&emsp;我们可以尝试在之前客户端代码的循环里，不断发送一种数据包，且把数据包的大小加大到1000字节，会发现很快服务端和客户端就会出现问题——要么是数据接收出现问题，要么是服务端或者客户端程序直接卡掉。这里出现问题的原因就是socket内核缓冲区溢出。","text":"使用的语言为C&#x2F;C++ 源码支持的平台为：Windows &#x2F; Linux 一、关于缓冲区溢出1.缓冲区溢出的原因&emsp;&emsp;之前我们所编写的服务端与客户端的数据量都是很小的，且操作也不频繁，需要键入指令发送报文。 &emsp;&emsp;我们可以尝试在之前客户端代码的循环里，不断发送一种数据包，且把数据包的大小加大到1000字节，会发现很快服务端和客户端就会出现问题——要么是数据接收出现问题，要么是服务端或者客户端程序直接卡掉。这里出现问题的原因就是socket内核缓冲区溢出。 &emsp;&emsp;首先，send和recv函数并不是直接通过网卡操作。在使用send函数时，send函数首先把数据写入到发送缓冲区，随后通过网卡发出；在使用recv函数时，网卡首先把接收到的消息写入接收缓冲区，recv函数再从中copy数据。注意，上文中的两个缓冲区是存在于内核中的，并不是程序中自定义的缓冲区。 &emsp;&emsp;我们在之前的源码中，recv的逻辑是先接收包头，随后根据包头接收包体。而当网卡接收数据太多时，我们接收一个包头的时间，网卡可能就新接收了两个完整的数据包，这就导致内核接收缓冲区里的数据量是在不断增加的，最终导致接收缓冲区溢出，造成无法正常发送以及程序阻塞的问题。 &emsp;&emsp;举个例子，缓冲区就像一个浴缸，而我们是一个拿盆子舀水的人。我们之前先接收一个包头就相当于舀出一个包头那么多的水，随后再舀出包体那么多的水。舀了两次仅仅舀出一个报文那么多的水。如果浴缸放水的速度比较大的话，我们很容易就会处理不过来。最终造成浴缸溢出(缓冲区溢出)。 2.缓冲区溢出的处理方法&emsp;&emsp;接着看上文的例子，我们怎么能阻止浴缸(缓冲区)溢出呢？首先我们不大可能改变浴缸的大小，因为太过麻烦以及治标不治本，只要浴缸放水的时间够长，总会溢出。接着，舀水的速度我们也不好改变，因为一时半会是改不了的。那我们就只能改变舀水的次数和数量了。 &emsp;&emsp;如何改变舀水的数量和次数？我们可以一次舀出足够多的水，随后再从舀出的水中分出想要数量的水，这样浴缸溢出的可能性就大大减少了。 &emsp;&emsp;从代码层面来看上面的思路，只要我们程序内新建一个足够大的缓冲区，一次从内核缓冲区上recv足够的数据，就可以避免内核缓冲区溢出了。 大概思路如下：123456789101112131415char _Recv_buf[4096];int DataRecv&#123; //接收客户端发送的数据 int recv_len = recv(socket, _Recv_buf, 4096, 0); if(recv_len &lt;= 0) &#123; return -1; &#125; while(_Recv_buf内不为空) &#123; 处理_Recv_buf内的数据 &#125; return 0;&#125; &emsp;&emsp;但是这样会出现新的问题，即粘包与分包问题，请看下文。 二、粘包与分包1.粘包与分包的原因&emsp;&emsp;上文中处理缓冲区溢出的思路是没有问题的，但是上文中的源码写法会存在问题。 &emsp;&emsp;我们一次接收那么多数据，其中数据的界限是没有限定的，比如上文中是想要一次接收4096个字节。假如缓冲区内有5个1000字节大小的数据包，我们这次接收4096字节，等于说接收的数据中有4.096个数据包，其中就包含了新的问题。 &emsp;&emsp;首先是粘包问题。即一次接收中含有多个数据包，这就导致数据包界限不清，粘在了一起。像上文中的4.096个包，接收端是不清楚的，接收端只知道有4096字节的数据，但是它不知道一个包是多大。所以我们可以通过包头来获取一个数据包的大小，由此来处理相应大小的数据以解决粘包问题。 &emsp;&emsp;接着是分包问题。即一次接收中含有不完整的包。例如上文中的4096个字节，其中包含了4个完整的包，和一个包的前96个字节。对此，我们只能处理前4个完整的数据包。那么问题来了，对于上文中的缓冲区，由于recv函数每次都会覆盖这个缓冲区，这就导致缓冲区内无法存放未处理的消息。对于这个问题，我们可以新建一个缓冲区，来存放未处理的消息，实现双缓冲，即可处理分包问题。 TCP是面向数据流的协议，所以会出现粘包分包问题；UDP是面向消息的协议，每一个数据段都是一条消息，所以不会出现粘包分包问题。 2.粘包与分包的处理方法2.1客户端升级思路&emsp;&emsp;首先是新建两个缓冲区，一个用来存放recv到的数据，一个用来存放所有待处理数据。首先第一个缓冲区recv到数据，随后把第一个缓冲区内的数据copy到第二个缓冲区内，即可实现数据的存放。随后处理数据之类的还是先获取包头，随后根据包头处理包体数据。 大致思路如下： 123456789101112131415161718192021222324//接收数据char 接收缓冲区[4096]char 消息缓冲区[40960];int RecvData(SOCKET temp_socket)//处理数据 &#123; //接收客户端发送的数据 int recv_len = recv(temp_socket, 接收缓冲区, 4096, 0); if(recv_len &lt;= 0) &#123; printf(&quot;与服务器断开连接,任务结束\\n&quot;); return -1; &#125; 1.将接收缓冲区的数据拷贝到消息缓冲区 while(2.判断消息缓冲区的数据长度是否大于等于包头长度) &#123; 3.选出包头数据 //解决粘包问题 if(4.判断消息缓冲区内数据长度是否大于等于报文长度) //解决少包问题 &#123; 5.响应数据 6.将处理过的消息移出消息缓冲区 &#125; &#125; return 0; &#125; 2.2服务端升级思路&emsp;&emsp;与客户端整头思路相似，但是需要注意，服务端有多个连接，如果多个连接共用一个缓冲区会存在错误，所以每一个客户端连接都需要有自己的缓冲区。对此，我们可以新建一个客户端连接类，来存放每一个客户端的socket以及它的缓冲区。 大致思路如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class 客户端连接&#123;public: 1.获取socket() 2.获取缓冲区() 3.获取缓冲区长度() 4.设置缓冲区长度()private: 1.socket 2.缓冲区&#125;; std::vector&lt;客户端连接*&gt; _clients;//储存客户端socketchar 接收缓冲区[4096];0.此时前面OnRun函数里的判断过程也需要改变//遍历所有socket 查看是否有待处理事件 for(int n=0; n&lt;_clients.size(); ++n)&#123; if(FD_ISSET(_clients[n]-&gt;获取socket(),&amp;fdRead)) &#123; if(-1 == RecvData(_clients[n]))//处理请求 客户端退出的话 &#123; std::vector&lt;客户端连接*&gt;::iterator iter = _clients.begin()+n;//找到退出客户端的地址 if(iter != _clients.end())//如果是合理值 &#123; delete _clients[n]; _clients.erase(iter);//移除 &#125; &#125; &#125;&#125;int RecvData(客户端连接* client)//处理数据 &#123; //接收客户端发送的数据 int recv_len = recv(client-&gt;获取socket(), 接收缓冲区, 4096, 0); if(recv_len &lt;= 0) &#123; printf(&quot;与服务器断开连接,任务结束\\n&quot;); return -1; &#125; 1.将接收缓冲区的数据拷贝到传入对象的消息缓冲区 client-&gt;获取缓冲区(); while(2.判断消息缓冲区的数据长度是否大于等于包头长度) client-&gt;获取缓冲区长度(); &#123; 3.选出包头数据 //解决粘包问题 if(4.判断消息缓冲区内数据长度是否大于等于报文长度) //解决少包问题 &#123; 5.响应数据 6.将处理过的消息移出消息缓冲区 client-&gt;设置缓冲区长度(); &#125; &#125; return 0; &#125; 三、升级后的源码及其详细注释1.客户端源码 TcpClient.hpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321#ifndef _TcpClient_hpp_#define _TcpClient_hpp_#ifdef _WIN32 #define WIN32_LEAN_AND_MEAN #include&lt;winSock2.h&gt; #include&lt;windows.h&gt; #pragma comment(lib,&quot;ws2_32.lib&quot;) #else #include&lt;arpa/inet.h&gt; #include&lt;unistd.h&gt; #include&lt;string.h&gt; #define SOCKET int #define INVALID_SOCKET (SOCKET)(~0) #define SOCKET_ERROR (-1)#endif//枚举类型记录命令 enum cmd &#123; CMD_LOGIN,//登录 CMD_LOGINRESULT,//登录结果 CMD_LOGOUT,//登出 CMD_LOGOUTRESULT,//登出结果 CMD_NEW_USER_JOIN,//新用户登入 CMD_ERROR//错误 &#125;;//定义数据包头 struct DataHeader &#123; short cmd;//命令 short date_length;//数据的长短 &#125;;//包1 登录 传输账号与密码struct Login : public DataHeader &#123; Login()//初始化包头 &#123; this-&gt;cmd = CMD_LOGIN; this-&gt;date_length = sizeof(Login); &#125; char UserName[32];//用户名 char PassWord[32];//密码 char data[932];&#125;;//包2 登录结果 传输结果struct LoginResult : public DataHeader &#123; LoginResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGINRESULT; this-&gt;date_length = sizeof(LoginResult); &#125; int Result; char Data[992];//无意义数据 &#125;;//包3 登出 传输用户名 struct Logout : public DataHeader &#123; Logout()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUT; this-&gt;date_length = sizeof(Logout); &#125; char UserName[32];//用户名 char data[964];&#125;;//包4 登出结果 传输结果struct LogoutResult : public DataHeader &#123; LogoutResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUTRESULT; this-&gt;date_length = sizeof(LogoutResult); &#125; int Result; char data[992];&#125;;//包5 新用户登入 传输通告 struct NewUserJoin : public DataHeader &#123; NewUserJoin()//初始化包头 &#123; this-&gt;cmd = CMD_NEW_USER_JOIN; this-&gt;date_length = sizeof(NewUserJoin); &#125; char UserName[32];//用户名 &#125;;#include&lt;bits/stdc++.h&gt;#define RECV_BUFFER_SIZE 4096class TcpClient&#123;public: //构造 TcpClient() &#123; _sock = INVALID_SOCKET; //缓冲区相关 _Recv_buf = new char[RECV_BUFFER_SIZE]; _Msg_buf = new char[RECV_BUFFER_SIZE*10]; _Len_buf = 0; &#125; //析构 virtual ~TcpClient() &#123; delete[] _Recv_buf; delete[] _Msg_buf; //关闭socket CloseSocket(); &#125; //初始化socket 返回1为正常 int InitSocket() &#123;#ifdef _WIN32 //启动windows socket 2,x环境 WORD ver = MAKEWORD(2,2); WSADATA dat; if(0 != WSAStartup(ver,&amp;dat)) &#123; return -1;//-1为环境错误 &#125;#endif //创建socket if(INVALID_SOCKET != _sock) &#123; printf(&quot;&lt;Socket=%d&gt;关闭连接\\n&quot;,_sock); CloseSocket();//如果之前有连接 就关闭连接 &#125; _sock = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP); if(INVALID_SOCKET == _sock) &#123; return 0;//0为socket创建错误 &#125; return 1; &#125; //连接服务器 返回1为成功 int Connect(const char *ip,unsigned short port) &#123; //如果为无效套接字 则初始化 if(INVALID_SOCKET == _sock) &#123; InitSocket(); &#125; //连接服务器 sockaddr_in _sin = &#123;&#125;; _sin.sin_family = AF_INET;//IPV4 _sin.sin_port = htons(port);//端口号 #ifdef _WIN32 _sin.sin_addr.S_un.S_addr = inet_addr(ip);//IP #else _sin.sin_addr.s_addr = inet_addr(ip);//IP #endif if(SOCKET_ERROR == connect(_sock,(sockaddr*)&amp;_sin,sizeof(sockaddr_in))) &#123; return 0;//连接失败 &#125; else &#123; return 1;//连接成功 &#125; &#125; //关闭socket void CloseSocket() &#123; if(INVALID_SOCKET != _sock) &#123;#ifdef _WIN32 //关闭socket closesocket(_sock); //清除windows socket 环境 WSACleanup(); #else //关闭socket/LINUX close(_sock);#endif _sock = INVALID_SOCKET; &#125; &#125; //查询是否有待处理消息 bool OnRun() &#123; if(IsRun())//如果有连接则监听事件 &#123; fd_set _fdRead;//建立集合 FD_ZERO(&amp;_fdRead);//清空集合 FD_SET(_sock,&amp;_fdRead);//放入集合 timeval _t = &#123;1,0&#125;;//select最大响应时间 //新建seclect int _ret = select(_sock+1,&amp;_fdRead,NULL,NULL,&amp;_t); if(_ret&lt;0) &#123; printf(&quot;seclect任务结束\\n&quot;); return false; &#125; if(FD_ISSET(_sock,&amp;_fdRead))//获取是否有可读socket &#123; FD_CLR(_sock,&amp;_fdRead);//清理计数器 if(-1 == RecvData(_sock)) &#123; CloseSocket(); return false; &#125; &#125; return true; &#125; return false; &#125; //判断是否工作中 bool IsRun() &#123; return _sock != INVALID_SOCKET; &#125; //发送数据 int SendData(DataHeader *_head) &#123; if(IsRun() &amp;&amp; _head) &#123; send(_sock,(const char*)_head,_head-&gt;date_length,0); return 1; &#125; return 0; &#125; //接收数据 int RecvData(SOCKET temp_socket)//处理数据 &#123; //接收客户端发送的数据 int recv_len = recv(temp_socket, _Recv_buf, RECV_BUFFER_SIZE, 0); if(recv_len &lt;= 0) &#123; printf(&quot;与服务器断开连接,任务结束\\n&quot;); return -1; &#125; //将接收缓冲区的数据拷贝到消息缓冲区 memcpy(_Msg_buf+_Len_buf, _Recv_buf, recv_len); //消息缓冲区的数据末尾后移 _Len_buf += recv_len; //判断消息缓冲区的数据长度是否大于等于包头长度 while(_Len_buf &gt;= sizeof(DataHeader))//处理粘包问题 &#123; //选出包头数据 DataHeader* header = (DataHeader*)_Msg_buf; //判断消息缓冲区内数据长度是否大于等于报文长度 避免少包问题 if(_Len_buf &gt;= header-&gt;date_length) &#123; //计算出消息缓冲区内剩余未处理数据的长度 int size = _Len_buf - header-&gt;date_length; //响应数据 NetMsg(header); //将消息缓冲区剩余未处理的数据前移 memcpy(_Msg_buf, _Msg_buf + header-&gt;date_length, size); //消息缓冲区的数据末尾前移 _Len_buf = size; &#125; else &#123; //消息缓冲区数据不足 break; &#125; &#125; return 0; &#125; //响应数据 virtual void NetMsg(DataHeader *_head) &#123; printf(&quot;接收到包头，命令：%d，数据长度：%d\\n&quot;,_head-&gt;cmd,_head-&gt;date_length); switch(_head-&gt;cmd) &#123; case CMD_LOGINRESULT://登录结果 接收登录包体 &#123; LoginResult *_result = (LoginResult*)_head; printf(&quot;登录结果:%d\\n&quot;,_result-&gt;Result); &#125; break; case CMD_LOGOUTRESULT://登出结果 接收登出包体 &#123; LogoutResult *_result = (LogoutResult*)_head; printf(&quot;登录结果:%d\\n&quot;,_result-&gt;Result); &#125; break; case CMD_NEW_USER_JOIN://新用户登录通知 &#123; NewUserJoin *_result = (NewUserJoin*)_head; printf(&quot;用户:%s已登录\\n&quot;,_result-&gt;UserName); &#125; break; case CMD_ERROR://错误 &#123; printf(&quot;错误数据\\n&quot;); getchar(); &#125; break; default: &#123; printf(&quot;未知数据\\n&quot;); getchar(); &#125; break; &#125; &#125; private: SOCKET _sock; //缓冲区相关 char *_Recv_buf;//接收缓冲区 char *_Msg_buf;//消息缓冲区 int _Len_buf;//缓冲区数据尾部变量 &#125;;#endif 2.服务端源码 TcpServer.hpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487#ifndef _TcpServer_hpp_#define _TcpServer_hpp_#ifdef _WIN32 #define WIN32_LEAN_AND_MEAN #include&lt;winSock2.h&gt; #include&lt;windows.h&gt; #pragma comment(lib,&quot;ws2_32.lib&quot;)//链接此动态链接库 windows特有 #else #include&lt;arpa/inet.h&gt;//selcet #include&lt;unistd.h&gt;//uni std #include&lt;string.h&gt; #define SOCKET int #define INVALID_SOCKET (SOCKET)(~0) #define SOCKET_ERROR (-1)#endif//枚举类型记录命令 enum cmd &#123; CMD_LOGIN,//登录 CMD_LOGINRESULT,//登录结果 CMD_LOGOUT,//登出 CMD_LOGOUTRESULT,//登出结果 CMD_NEW_USER_JOIN,//新用户登入 CMD_ERROR//错误 &#125;;//定义数据包头 struct DataHeader &#123; short cmd;//命令 short date_length;//数据的长短 &#125;;//包1 登录 传输账号与密码struct Login : public DataHeader &#123; Login()//初始化包头 &#123; this-&gt;cmd = CMD_LOGIN; this-&gt;date_length = sizeof(Login); &#125; char UserName[32];//用户名 char PassWord[32];//密码 char data[932];&#125;;//包2 登录结果 传输结果struct LoginResult : public DataHeader &#123; LoginResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGINRESULT; this-&gt;date_length = sizeof(LoginResult); &#125; int Result; char Data[992];//无意义数据 &#125;;//包3 登出 传输用户名 struct Logout : public DataHeader &#123; Logout()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUT; this-&gt;date_length = sizeof(Logout); &#125; char UserName[32];//用户名 char data[964];&#125;;//包4 登出结果 传输结果struct LogoutResult : public DataHeader &#123; LogoutResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUTRESULT; this-&gt;date_length = sizeof(LogoutResult); &#125; int Result; char data[992];&#125;;//包5 新用户登入 传输通告 struct NewUserJoin : public DataHeader &#123; NewUserJoin()//初始化包头 &#123; this-&gt;cmd = CMD_NEW_USER_JOIN; this-&gt;date_length = sizeof(NewUserJoin); &#125; char UserName[32];//用户名 &#125;;#include&lt;bits/stdc++.h&gt;#define RECV_BUFFER_SIZE 4096class ClientSocket&#123;public: //构造 ClientSocket(SOCKET sockfd = INVALID_SOCKET) &#123; _sockfd = sockfd; //缓冲区相关 _Msg_buf = new char[RECV_BUFFER_SIZE*10]; _Len_buf = 0; &#125; //析构 virtual ~ClientSocket() &#123; delete[] _Msg_buf; &#125; //获取socket SOCKET GetSockfd() &#123; return _sockfd; &#125; //获取缓冲区 char* MsgBuf() &#123; return _Msg_buf; &#125; //获取缓冲区尾部变量 int GetLen() &#123; return _Len_buf; &#125; //设置缓冲区尾巴变量 void SetLen(int len) &#123; _Len_buf = len; &#125; private: SOCKET _sockfd; //缓冲区相关 char *_Msg_buf;//消息缓冲区 int _Len_buf;//缓冲区数据尾部变量&#125;; class TcpServer&#123;public: //构造 TcpServer() &#123; _sock = INVALID_SOCKET; //缓冲区相关 _Recv_buf = new char[RECV_BUFFER_SIZE]; &#125; //析构 virtual ~TcpServer() &#123; delete[] _Recv_buf; //关闭socket CloseSocket(); &#125; //初始化socket 返回1为正常 int InitSocket() &#123;#ifdef _WIN32 //启动windows socket 2,x环境 WORD ver = MAKEWORD(2,2); WSADATA dat; if(0 != WSAStartup(ver,&amp;dat)) &#123; return -1;//-1为环境错误 &#125;#endif //创建socket if(INVALID_SOCKET != _sock) &#123; printf(&quot;&lt;Socket=%d&gt;关闭连接\\n&quot;,_sock); CloseSocket();//如果之前有连接 就关闭连接 &#125; _sock = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP); if(INVALID_SOCKET == _sock) &#123; return 0;//0为socket创建错误 &#125; return 1; &#125; //绑定IP/端口 int Bind(const char* ip,unsigned short port) &#123; //如果为无效套接字 则初始化 if(INVALID_SOCKET == _sock) &#123; InitSocket(); &#125; //绑定网络端口和IP地址 sockaddr_in _myaddr = &#123;&#125;; _myaddr.sin_family = AF_INET;//IPV4 _myaddr.sin_port = htons(port);//端口#ifdef _WIN32 if(ip)//ip为空则监听所有网卡 &#123; _myaddr.sin_addr.S_un.S_addr = inet_addr(ip);//IP &#125; else &#123; _myaddr.sin_addr.S_un.S_addr = INADDR_ANY;//IP &#125;#else if(ip)//ip为空则监听所有网卡 &#123; _myaddr.sin_addr.s_addr = inet_addr(ip);//IP &#125; else &#123; _myaddr.sin_addr.s_addr = INADDR_ANY;//IP &#125;#endif if(SOCKET_ERROR == bind(_sock,(sockaddr*)&amp;_myaddr,sizeof(sockaddr_in)))//socket (强制转换)sockaddr结构体 结构体大小 &#123; printf(&quot;绑定失败\\n&quot;); return 0; &#125; else &#123; printf(&quot;绑定成功\\n绑定端口为%d\\n&quot;,port); return 1; &#125; &#125; //监听端口 int Listen(int n) &#123; //如果为无效套接字 则提示 if(INVALID_SOCKET == _sock) &#123; printf(&quot;请先初始化套接字并绑定IP端口\\n&quot;); return 0; &#125; //监听网络端口 if(SOCKET_ERROR == listen(_sock,n))//最大连接队列 &#123; printf(&quot;监听失败\\n&quot;); return 0; &#125; else &#123; printf(&quot;监听成功\\n&quot;); return 1; &#125; &#125; //接受连接 int Accept() &#123; //等待接收客户端连接 sockaddr_in clientAddr = &#123;&#125;;//新建sockadd结构体接收客户端数据 int addr_len = sizeof(sockaddr_in);//获取sockadd结构体长度 SOCKET temp_socket = INVALID_SOCKET;//声明客户端套接字 #ifdef _WIN32 temp_socket = accept(_sock,(sockaddr*)&amp;clientAddr,&amp;addr_len);//自身套接字 客户端结构体 结构体大小 #else temp_socket = accept(_sock,(sockaddr*)&amp;clientAddr,(socklen_t*)&amp;addr_len);//自身套接字 客户端结构体 结构体大小 #endif if(INVALID_SOCKET == temp_socket)//接收失败 &#123; printf(&quot;&lt;Socket=%d&gt;错误,接受到无效客户端SOCKET\\n&quot;,temp_socket); return 0; &#125; else &#123; printf(&quot;新客户端加入\\nIP地址为：%s \\n&quot;, inet_ntoa(clientAddr.sin_addr)); //群发所有客户端 通知新用户登录 NewUserJoin *user_join = new NewUserJoin(); strcpy(user_join-&gt;UserName,inet_ntoa(clientAddr.sin_addr)); SendDataToAll(user_join); //将新的客户端加入动态数组 _clients.push_back(new ClientSocket(temp_socket)); return 1; &#125; &#125; //关闭socket void CloseSocket() &#123; if(INVALID_SOCKET != _sock) &#123;#ifdef _WIN32 //关闭客户端socket for(int n=0; n&lt;_clients.size(); ++n) &#123; closesocket(_clients[n]-&gt;GetSockfd()); delete _clients[n]; &#125; //关闭socket closesocket(_sock); //清除windows socket 环境 WSACleanup(); #else //关闭客户端socket for(int n=0; n&lt;_clients.size(); ++n) &#123; close(_clients[n]-&gt;GetSockfd()); delete _clients[n]; &#125; //关闭socket/LINUX close(_sock);#endif _sock = INVALID_SOCKET; _clients.clear(); &#125; &#125; //查询是否有待处理消息 bool OnRun() &#123; if(IsRun()) &#123; fd_set fdRead;//建立集合 fd_set fdWrite; fd_set fdExcept; FD_ZERO(&amp;fdRead);//清空集合 FD_ZERO(&amp;fdWrite); FD_ZERO(&amp;fdExcept); FD_SET(_sock,&amp;fdRead);//放入集合 FD_SET(_sock,&amp;fdWrite); FD_SET(_sock,&amp;fdExcept); timeval s_t = &#123;2,0&#125;;//select最大响应时间 SOCKET maxSock = _sock;//最大socket //把连接的客户端 放入read集合 for(int n=_clients.size()-1; n&gt;=0; --n) &#123; FD_SET(_clients[n]-&gt;GetSockfd(),&amp;fdRead); if(maxSock &lt; _clients[n]-&gt;GetSockfd()) &#123; maxSock = _clients[n]-&gt;GetSockfd(); &#125; &#125; //select函数筛选select int ret = select(maxSock+1,&amp;fdRead,&amp;fdWrite,&amp;fdExcept,&amp;s_t); if(ret&lt;0) &#123; printf(&quot;select任务结束\\n&quot;); CloseSocket(); return false; &#125; if(FD_ISSET(_sock,&amp;fdRead))//获取是否有新socket连接 &#123; FD_CLR(_sock,&amp;fdRead);//清理 Accept();//连接 &#125; //遍历所有socket 查看是否有待处理事件 for(int n=0; n&lt;_clients.size(); ++n) &#123; if(FD_ISSET(_clients[n]-&gt;GetSockfd(),&amp;fdRead)) &#123; if(-1 == RecvData(_clients[n]))//处理请求 客户端退出的话 &#123; std::vector&lt;ClientSocket*&gt;::iterator iter = _clients.begin()+n;//找到退出客户端的地址 if(iter != _clients.end())//如果是合理值 &#123; delete _clients[n]; _clients.erase(iter);//移除 &#125; &#125; &#125; &#125; //printf(&quot;空闲时间处理其他业务\\n&quot;); return true; &#125; return false; &#125; //判断是否工作中 bool IsRun() &#123; return _sock != INVALID_SOCKET; &#125; //发送数据 int SendData(DataHeader *head,SOCKET temp_socket) &#123; if(IsRun() &amp;&amp; head) &#123; send(temp_socket,(const char*)head,head-&gt;date_length,0); return 1; &#125; return 0; &#125; //向所有人发送数据 void SendDataToAll(DataHeader *head) &#123; for(int n=0;n&lt;_clients.size();++n) &#123; SendData(head, _clients[n]-&gt;GetSockfd()); &#125; &#125; //接收数据 int RecvData(ClientSocket *t_client)//处理数据 &#123; //接收客户端发送的数据 int buf_len = recv(t_client-&gt;GetSockfd(), _Recv_buf, RECV_BUFFER_SIZE, 0); if(buf_len&lt;=0) &#123; printf(&quot;客户端已退出\\n&quot;); return -1; &#125; //将接收缓冲区的数据拷贝到消息缓冲区 memcpy(t_client-&gt;MsgBuf() + t_client-&gt;GetLen(), _Recv_buf, buf_len); //消息缓冲区的数据末尾后移 t_client-&gt;SetLen(t_client-&gt;GetLen() + buf_len); //判断消息缓冲区的数据长度是否大于等于包头长度 while(t_client-&gt;GetLen() &gt;= sizeof(DataHeader))//处理粘包问题 &#123; //选出包头数据 DataHeader* header = (DataHeader*)t_client-&gt;MsgBuf(); //判断消息缓冲区内数据长度是否大于等于报文长度 避免少包问题 if(t_client-&gt;GetLen() &gt;= header-&gt;date_length) &#123; //计算出消息缓冲区内剩余未处理数据的长度 int size = t_client-&gt;GetLen() - header-&gt;date_length; //响应数据 NetMsg(header,t_client-&gt;GetSockfd()); //将消息缓冲区剩余未处理的数据前移 memcpy(t_client-&gt;MsgBuf(), t_client-&gt;MsgBuf() + header-&gt;date_length, size); //消息缓冲区的数据末尾前移 t_client-&gt;SetLen(size); &#125; else &#123; //消息缓冲区数据不足 break; &#125; &#125; return 0; &#125; //响应数据 void NetMsg(DataHeader *head,SOCKET temp_socket) &#123; printf(&quot;接收到包头，命令：%d，数据长度：%d\\n&quot;,head-&gt;cmd,head-&gt;date_length); switch(head-&gt;cmd) &#123; case CMD_LOGIN://登录 接收登录包体 &#123; Login *login = (Login*)head; /* 进行判断操作 */ //printf(&quot;%s已登录\\n密码：%s\\n&quot;,login-&gt;UserName,login-&gt;PassWord); LoginResult *result = new LoginResult; result-&gt;Result = 1; SendData(result,temp_socket); &#125; break; case CMD_LOGOUT://登出 接收登出包体 &#123; Logout *logout = (Logout*)head; /* 进行判断操作 */ //printf(&quot;%s已登出\\n&quot;,logout-&gt;UserName); LogoutResult *result = new LogoutResult(); result-&gt;Result = 1; SendData(result,temp_socket); &#125; break; default://错误 &#123; head-&gt;cmd = CMD_ERROR; head-&gt;date_length = 0; SendData(head,temp_socket); &#125; break; &#125; &#125; private: SOCKET _sock; std::vector&lt;ClientSocket*&gt; _clients;//储存客户端 //缓冲区相关 char *_Recv_buf;//接收缓冲区 &#125;;#endif","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"网络编程","slug":"网络编程","permalink":"https://zgg2001.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"C++网络编程学习：源码的封装","slug":"20210126_C++网络编程学习：源码的封装","date":"2021-01-26T13:42:02.000Z","updated":"2021-01-26T13:42:02.000Z","comments":true,"path":"2021/01/26/20210126_C++网络编程学习：源码的封装/","permalink":"https://zgg2001.github.io/2021/01/26/20210126_C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%BA%90%E7%A0%81%E7%9A%84%E5%B0%81%E8%A3%85/","excerpt":"使用的语言为C&#x2F;C++ 源码支持的平台为：Windows &#x2F; Linux 一、为何要进行封装操作&emsp;&emsp;C++为面向对象编程语言，我们要以面向对象的思路进行源码的编写。&emsp;&emsp;在对主要源码进行封装后，客户端与服务端的代码编写更加清晰明了，逻辑性更强，便于开发维护。且在今后的服务端高并发测试中，便于新建多个连接进行测试。&emsp;&emsp;在本篇笔记中，我会基于笔记四的源码进行封装，并将记录我对客户端与服务端源码进行封装时的思路与步骤。最终源码为客户端封装类文件TcpClient.hpp与服务端封装类文件TcpServer.hpp，以及客户端源码client_test.cpp与服务端源码server_test.cpp。","text":"使用的语言为C&#x2F;C++ 源码支持的平台为：Windows &#x2F; Linux 一、为何要进行封装操作&emsp;&emsp;C++为面向对象编程语言，我们要以面向对象的思路进行源码的编写。&emsp;&emsp;在对主要源码进行封装后，客户端与服务端的代码编写更加清晰明了，逻辑性更强，便于开发维护。且在今后的服务端高并发测试中，便于新建多个连接进行测试。&emsp;&emsp;在本篇笔记中，我会基于笔记四的源码进行封装，并将记录我对客户端与服务端源码进行封装时的思路与步骤。最终源码为客户端封装类文件TcpClient.hpp与服务端封装类文件TcpServer.hpp，以及客户端源码client_test.cpp与服务端源码server_test.cpp。 二、封装的思路与相关1.封装的头文件选择&emsp;&emsp;封装类首先要在头文件中以体现封装性。在本次的封装中，为了能更方便的储存，我选择了hpp头文件。即类声明与类定义都在此文件中。 2.客户端类的封装&emsp;&emsp;首先，客户端的大致流程如下： 123456789101112131415161.建立socket2.连接服务器3.建立新线程 用于发送命令while(true)&#123; 4.使用select函数获取服务器端是否有待处理事件 5.如果有，就处理它(接收/发送)&#125;6.关闭socket新线程：while(1)&#123; 1.键入数据 2.发送数据&#125; &emsp;&emsp;所以，我们需要封装的方法如下： 12345678910111213141516//初始化socketint InitSocket();//连接服务器 int Connect(const char *ip,unsigned short port);//关闭socketvoid CloseSocket();//查询是否有待处理消息 bool OnRun();//判断是否工作中 bool IsRun();//发送数据 int SendData(DataHeader *_head);//接收数据int RecvData(SOCKET _temp_socket);//响应数据virtual void NetMsg(DataHeader *_head); &emsp;&emsp;按照此思路，客户端的源码思路为： 1234567891011121314151.InitSocket();//建立socket2.Connect(const char *ip,unsigned short port);//连接服务器 传入IP与端口3.建立新线程 用于发送命令while(4.IsRun())//检测是否工作中&#123; 5.OnRun();//查询是否有待处理消息&#125;6.CloseSocket();//关闭socket新线程：while(1.IsRun())//检测是否工作中&#123; 2.键入数据 3.SendData(DataHeader *_head);&#125; &emsp;&emsp;其中，OnRun() 方法中使用的是select网络结构，在select筛选出待处理事件后，使用RecvData() 方法进行包头与包体的接收，随后调用NetMsg() 方法，依据包头的报文类型对包体数据进行处理。NetMsg() 方法为虚方法，在之后调用此封装类时，可以进行继承重载操作，便于对数据响应的操作进行变更。 相关源码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//查询是否有待处理消息 bool OnRun()&#123; if(IsRun())//如果有连接则监听事件 &#123; fd_set _fdRead;//建立集合 FD_ZERO(&amp;_fdRead);//清空集合 FD_SET(_sock,&amp;_fdRead);//放入集合 timeval _t = &#123;1,0&#125;;//select最大响应时间 //新建seclect int _ret = select(_sock+1,&amp;_fdRead,NULL,NULL,&amp;_t); if(_ret&lt;0) &#123; printf(&quot;seclect任务结束\\n&quot;); return false; &#125; if(FD_ISSET(_sock,&amp;_fdRead))//获取是否有可读socket &#123; FD_CLR(_sock,&amp;_fdRead);//清理计数器 if(-1 == RecvData(_sock)) &#123; CloseSocket(); return false; &#125; &#125; return true; &#125; return false;&#125; //接收数据int RecvData(SOCKET _temp_socket)//处理数据 &#123; //缓冲区 char buffer[4096] = &#123;&#125;; //接收客户端发送的数据 int _buf_len = recv(_temp_socket,buffer,sizeof(DataHeader),0); DataHeader *_head = (DataHeader*)buffer; if(_buf_len&lt;=0) &#123; printf(&quot;与服务器断开连接,任务结束\\n&quot;); return -1; &#125; recv(_temp_socket,buffer+sizeof(DataHeader),_head-&gt;date_length-sizeof(DataHeader),0); //响应数据 NetMsg(_head); return 0; &#125;//响应数据virtual void NetMsg(DataHeader *_head)&#123; printf(&quot;接收到包头，命令：%d，数据长度：%d\\n&quot;,_head-&gt;cmd,_head-&gt;date_length); switch(_head-&gt;cmd) &#123; case CMD_LOGINRESULT://登录结果 接收登录包体 &#123; LoginResult *_result = (LoginResult*)_head; printf(&quot;登录结果:%d\\n&quot;,_result-&gt;Result); &#125; break; case CMD_LOGOUTRESULT://登出结果 接收登出包体 &#123; LogoutResult *_result = (LogoutResult*)_head; printf(&quot;登录结果:%d\\n&quot;,_result-&gt;Result); &#125; break; case CMD_NEW_USER_JOIN://新用户登录通知 &#123; NewUserJoin *_result = (NewUserJoin*)_head; printf(&quot;用户:%s已登录\\n&quot;,_result-&gt;UserName); &#125; &#125;&#125; &emsp;&emsp;另外，由于已经被封装，所以在调用方法时，可能会出现步骤错误的情况。例如还没进行新建套接字就进行connect连接操作或是关闭套接字操作、传入数据有误等等，此时就会出现问题。&emsp;&emsp;我解决此类问题的方法是多加判定。例如判定套接字是否已经被建立，或是传入数据是否有误等等，随后根据情况进行处理。详细源码请看下文。 3.服务端类的封装&emsp;&emsp;首先，客户端的大致流程如下： 123456789101.建立socket2.绑定端口IP3.监听端口while(true)&#123; 4.使用select函数获取存在待监听事件的socket 5.如果有新的连接则与新的客户端连接 6.如果有待监听事件，则对其进行处理(接受与发送)&#125;7.关闭socket &emsp;&emsp;所以，我们需要封装的方法如下： 1234567891011121314151617181920//初始化socket int InitSocket();//绑定IP/端口int Bind(const char* ip,unsigned short port);//监听端口int Listen(int n);//接受连接int Accept();//关闭socket void CloseSocket();//查询是否有待处理消息 bool OnRun();//判断是否工作中 bool IsRun();//发送数据 int SendData(DataHeader *_head,SOCKET _temp_socket);//接收数据int RecvData(SOCKET _temp_socket);//响应数据void NetMsg(DataHeader *_head,SOCKET _temp_socket); &emsp;&emsp;按照此思路，客户端的源码思路为： 123456781.InitSocket();//建立socket2.Bind(const char* ip,unsigned short port);//绑定端口IP3.Listen(int n);//监听端口while(4.IsRun())//是否工作中&#123; 5.OnRun();//查看是否有待处理消息&#125;6.CloseSocket();//关闭socket &emsp;&emsp;其中，OnRun() 方法中使用的是select网络结构。在select筛选出待处理事件后，如果为新连接，则使用Accept() 方法进行新客户端连接操作；如果为已连接客户端的待接受事件，则使用RecvData() 方法进行包头与包体的接收，随后调用NetMsg() 方法，依据包头的报文类型对包体数据进行处理。NetMsg() 方法为虚方法，在之后调用此封装类时，可以进行继承重载操作，便于对数据响应的操作进行变更。 相关源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115//查询是否有待处理消息 bool OnRun()&#123; if(IsRun()) &#123; fd_set _fdRead;//建立集合 fd_set _fdWrite; fd_set _fdExcept; FD_ZERO(&amp;_fdRead);//清空集合 FD_ZERO(&amp;_fdWrite); FD_ZERO(&amp;_fdExcept); FD_SET(_sock,&amp;_fdRead);//放入集合 FD_SET(_sock,&amp;_fdWrite); FD_SET(_sock,&amp;_fdExcept); timeval _t = &#123;2,0&#125;;//select最大响应时间 SOCKET _maxSock = _sock;//最大socket //把连接的客户端 放入read集合 for(int n=_clients.size()-1; n&gt;=0; --n) &#123; FD_SET(_clients[n],&amp;_fdRead); if(_maxSock &lt; _clients[n]) &#123; _maxSock = _clients[n]; &#125; &#125; //select函数筛选select int _ret = select(_maxSock+1,&amp;_fdRead,&amp;_fdWrite,&amp;_fdExcept,&amp;_t); if(_ret&lt;0) &#123; printf(&quot;select任务结束\\n&quot;); CloseSocket(); return false; &#125; if(FD_ISSET(_sock,&amp;_fdRead))//获取是否有新socket连接 &#123; FD_CLR(_sock,&amp;_fdRead);//清理 Accept();//连接 &#125; //遍历所有socket 查看是否有待处理事件 for(int n=0; n&lt;_clients.size(); ++n) &#123; if(FD_ISSET(_clients[n],&amp;_fdRead)) &#123; if(-1 == RecvData(_clients[n]))//处理请求 客户端退出的话 &#123; std::vector&lt;SOCKET&gt;::iterator iter = _clients.begin()+n;//找到退出客户端的地址 if(iter != _clients.end())//如果是合理值 &#123; _clients.erase(iter);//移除 &#125; &#125; &#125; &#125; //printf(&quot;空闲时间处理其他业务\\n&quot;); return true; &#125; return false;&#125; //接收数据int RecvData(SOCKET _temp_socket)//处理数据 &#123; //缓冲区 char buffer[4096] = &#123;&#125;; //接收客户端发送的数据 int _buf_len = recv(_temp_socket,buffer,sizeof(DataHeader),0); DataHeader *_head = (DataHeader*)buffer; if(_buf_len&lt;=0) &#123; printf(&quot;客户端已退出\\n&quot;); return -1; &#125; recv(_temp_socket,buffer+sizeof(DataHeader),_head-&gt;date_length-sizeof(DataHeader),0); //响应数据 NetMsg(_head,_temp_socket); return 0;&#125;//响应数据void NetMsg(DataHeader *_head,SOCKET _temp_socket)&#123; printf(&quot;接收到包头，命令：%d，数据长度：%d\\n&quot;,_head-&gt;cmd,_head-&gt;date_length); switch(_head-&gt;cmd) &#123; case CMD_LOGIN://登录 接收登录包体 &#123; Login *_login = (Login*)_head; /* 进行判断操作 */ printf(&quot;%s已登录\\n密码：%s\\n&quot;,_login-&gt;UserName,_login-&gt;PassWord); LoginResult *_result = new LoginResult; _result-&gt;Result = 1; SendData(_result,_temp_socket); &#125; break; case CMD_LOGOUT://登出 接收登出包体 &#123; Logout *_logout = (Logout*)_head; /* 进行判断操作 */ printf(&quot;%s已登出\\n&quot;,_logout-&gt;UserName); LogoutResult *_result = new LogoutResult(); _result-&gt;Result = 1; SendData(_result,_temp_socket); &#125; break; default://错误 &#123; _head-&gt;cmd = CMD_ERROR; _head-&gt;date_length = 0; SendData(_head,_temp_socket); &#125; break; &#125;&#125; &emsp;&emsp;另外，由于已经被封装，所以在调用方法时，可能会出现步骤错误的情况。例如还没进行新建套接字就进行bind绑定端口IP或是关闭套接字操作、传入数据有误等等，此时就会出现问题。&emsp;&emsp;我解决此类问题的方法是多加判定。例如判定套接字是否已经被建立，或是传入数据是否有误等等，随后根据情况进行处理。详细源码请看下文。 三、封装后的详细源码及其注释1.客户端TcpClient.hpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272#ifndef _TcpClient_hpp_#define _TcpClient_hpp_#ifdef _WIN32 #define WIN32_LEAN_AND_MEAN #include&lt;winSock2.h&gt; #include&lt;windows.h&gt; #pragma comment(lib,&quot;ws2_32.lib&quot;) #else #include&lt;arpa/inet.h&gt; #include&lt;unistd.h&gt; #include&lt;string.h&gt; #define SOCKET int #define INVALID_SOCKET (SOCKET)(~0) #define SOCKET_ERROR (-1)#endif//枚举类型记录命令 enum cmd &#123; CMD_LOGIN,//登录 CMD_LOGINRESULT,//登录结果 CMD_LOGOUT,//登出 CMD_LOGOUTRESULT,//登出结果 CMD_NEW_USER_JOIN,//新用户登入 CMD_ERROR//错误 &#125;;//定义数据包头 struct DataHeader &#123; short cmd;//命令 short date_length;//数据的长短 &#125;;//包1 登录 传输账号与密码struct Login : public DataHeader &#123; Login()//初始化包头 &#123; this-&gt;cmd = CMD_LOGIN; this-&gt;date_length = sizeof(Login); &#125; char UserName[32];//用户名 char PassWord[32];//密码 &#125;;//包2 登录结果 传输结果struct LoginResult : public DataHeader &#123; LoginResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGINRESULT; this-&gt;date_length = sizeof(LoginResult); &#125; int Result;&#125;;//包3 登出 传输用户名 struct Logout : public DataHeader &#123; Logout()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUT; this-&gt;date_length = sizeof(Logout); &#125; char UserName[32];//用户名 &#125;;//包4 登出结果 传输结果struct LogoutResult : public DataHeader &#123; LogoutResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUTRESULT; this-&gt;date_length = sizeof(LogoutResult); &#125; int Result;&#125;;//包5 新用户登入 传输通告 struct NewUserJoin : public DataHeader &#123; NewUserJoin()//初始化包头 &#123; this-&gt;cmd = CMD_NEW_USER_JOIN; this-&gt;date_length = sizeof(NewUserJoin); &#125; char UserName[32];//用户名 &#125;;#include&lt;bits/stdc++.h&gt;class TcpClient&#123;public: //构造 TcpClient() &#123; _sock = INVALID_SOCKET; &#125; //析构 virtual ~TcpClient() &#123; //关闭socket CloseSocket(); &#125; //初始化socket 返回1为正常 int InitSocket() &#123;#ifdef _WIN32 //启动windows socket 2,x环境 WORD ver = MAKEWORD(2,2); WSADATA dat; if(0 != WSAStartup(ver,&amp;dat)) &#123; return -1;//-1为环境错误 &#125;#endif //创建socket if(INVALID_SOCKET != _sock) &#123; printf(&quot;&lt;Socket=%d&gt;关闭连接\\n&quot;,_sock); CloseSocket();//如果之前有连接 就关闭连接 &#125; _sock = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP); if(INVALID_SOCKET == _sock) &#123; return 0;//0为socket创建错误 &#125; return 1; &#125; //连接服务器 返回1为成功 int Connect(const char *ip,unsigned short port) &#123; //如果为无效套接字 则初始化 if(INVALID_SOCKET == _sock) &#123; InitSocket(); &#125; //连接服务器 sockaddr_in _sin = &#123;&#125;; _sin.sin_family = AF_INET;//IPV4 _sin.sin_port = htons(port);//端口号 #ifdef _WIN32 _sin.sin_addr.S_un.S_addr = inet_addr(ip);//IP #else _sin.sin_addr.s_addr = inet_addr(ip);//IP #endif if(SOCKET_ERROR == connect(_sock,(sockaddr*)&amp;_sin,sizeof(sockaddr_in))) &#123; return 0;//连接失败 &#125; else &#123; return 1;//连接成功 &#125; &#125; //关闭socket void CloseSocket() &#123; if(INVALID_SOCKET != _sock) &#123;#ifdef _WIN32 //关闭socket closesocket(_sock); //清除windows socket 环境 WSACleanup(); #else //关闭socket/LINUX close(_sock);#endif _sock = INVALID_SOCKET; &#125; &#125; //查询是否有待处理消息 bool OnRun() &#123; if(IsRun())//如果有连接则监听事件 &#123; fd_set _fdRead;//建立集合 FD_ZERO(&amp;_fdRead);//清空集合 FD_SET(_sock,&amp;_fdRead);//放入集合 timeval _t = &#123;1,0&#125;;//select最大响应时间 //新建seclect int _ret = select(_sock+1,&amp;_fdRead,NULL,NULL,&amp;_t); if(_ret&lt;0) &#123; printf(&quot;seclect任务结束\\n&quot;); return false; &#125; if(FD_ISSET(_sock,&amp;_fdRead))//获取是否有可读socket &#123; FD_CLR(_sock,&amp;_fdRead);//清理计数器 if(-1 == RecvData(_sock)) &#123; CloseSocket(); return false; &#125; &#125; return true; &#125; return false; &#125; //判断是否工作中 bool IsRun() &#123; return _sock != INVALID_SOCKET; &#125; //发送数据 int SendData(DataHeader *_head) &#123; if(IsRun() &amp;&amp; _head) &#123; send(_sock,(const char*)_head,_head-&gt;date_length,0); return 1; &#125; return 0; &#125; //接收数据 int RecvData(SOCKET _temp_socket)//处理数据 &#123; //缓冲区 char buffer[4096] = &#123;&#125;; //接收客户端发送的数据 int _buf_len = recv(_temp_socket,buffer,sizeof(DataHeader),0); DataHeader *_head = (DataHeader*)buffer; if(_buf_len&lt;=0) &#123; printf(&quot;与服务器断开连接,任务结束\\n&quot;); return -1; &#125; recv(_temp_socket,buffer+sizeof(DataHeader),_head-&gt;date_length-sizeof(DataHeader),0); //响应数据 NetMsg(_head); return 0; &#125; //响应数据 virtual void NetMsg(DataHeader *_head) &#123; printf(&quot;接收到包头，命令：%d，数据长度：%d\\n&quot;,_head-&gt;cmd,_head-&gt;date_length); switch(_head-&gt;cmd) &#123; case CMD_LOGINRESULT://登录结果 接收登录包体 &#123; LoginResult *_result = (LoginResult*)_head; printf(&quot;登录结果:%d\\n&quot;,_result-&gt;Result); &#125; break; case CMD_LOGOUTRESULT://登出结果 接收登出包体 &#123; LogoutResult *_result = (LogoutResult*)_head; printf(&quot;登录结果:%d\\n&quot;,_result-&gt;Result); &#125; break; case CMD_NEW_USER_JOIN://新用户登录通知 &#123; NewUserJoin *_result = (NewUserJoin*)_head; printf(&quot;用户:%s已登录\\n&quot;,_result-&gt;UserName); &#125; &#125; &#125; private: SOCKET _sock;&#125;;#endif client_test.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&quot;TcpClient.hpp&quot;#include&lt;thread&gt;void _cmdThread(TcpClient* tcp)//命令线程 &#123; while(tcp-&gt;IsRun()) &#123; //输入请求 char _msg[256] = &#123;&#125;; scanf(&quot;%s&quot;,_msg); //处理请求 if(0 == strcmp(_msg,&quot;exit&quot;)) &#123; tcp-&gt;CloseSocket(); printf(&quot;程序退出\\n&quot;); break; &#125; else if(0 == strcmp(_msg,&quot;login&quot;)) &#123; //发送 Login _login; strcpy(_login.UserName,&quot;hbxxy&quot;); strcpy(_login.PassWord,&quot;123456&quot;); tcp-&gt;SendData(&amp;_login); &#125; else if(0 == strcmp(_msg,&quot;logout&quot;)) &#123; //发送 Logout _logout; strcpy(_logout.UserName,&quot;hbxxy&quot;); tcp-&gt;SendData(&amp;_logout); &#125; else &#123; printf(&quot;不存在的命令\\n&quot;); &#125; &#125;&#125;int main()&#123; printf(&quot;Welcome\\n&quot;); //建立tcp对象 TcpClient *tcp1 = new TcpClient(); //建立一个socket tcp1-&gt;InitSocket(); //连接服务器 tcp1-&gt;Connect(&quot;127.0.0.1&quot;,8888); //创建UI线程 std::thread t1(_cmdThread,tcp1); t1.detach();//线程分离 //循环 while(tcp1-&gt;IsRun()) &#123; tcp1-&gt;OnRun(); &#125; //关闭 tcp1-&gt;CloseSocket(); return 0;&#125; 2.服务端TcpServer.hpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396#ifndef _TcpServer_hpp_#define _TcpServer_hpp_#ifdef _WIN32 #define WIN32_LEAN_AND_MEAN #include&lt;winSock2.h&gt; #include&lt;windows.h&gt; #pragma comment(lib,&quot;ws2_32.lib&quot;)//链接此动态链接库 windows特有 #else #include&lt;arpa/inet.h&gt;//selcet #include&lt;unistd.h&gt;//uni std #include&lt;string.h&gt; #define SOCKET int #define INVALID_SOCKET (SOCKET)(~0) #define SOCKET_ERROR (-1)#endif//枚举类型记录命令 enum cmd &#123; CMD_LOGIN,//登录 CMD_LOGINRESULT,//登录结果 CMD_LOGOUT,//登出 CMD_LOGOUTRESULT,//登出结果 CMD_NEW_USER_JOIN,//新用户登入 CMD_ERROR//错误 &#125;;//定义数据包头 struct DataHeader &#123; short cmd;//命令 short date_length;//数据的长短 &#125;;//包1 登录 传输账号与密码struct Login : public DataHeader &#123; Login()//初始化包头 &#123; this-&gt;cmd = CMD_LOGIN; this-&gt;date_length = sizeof(Login); &#125; char UserName[32];//用户名 char PassWord[32];//密码 &#125;;//包2 登录结果 传输结果struct LoginResult : public DataHeader &#123; LoginResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGINRESULT; this-&gt;date_length = sizeof(LoginResult); &#125; int Result;&#125;;//包3 登出 传输用户名 struct Logout : public DataHeader &#123; Logout()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUT; this-&gt;date_length = sizeof(Logout); &#125; char UserName[32];//用户名 &#125;;//包4 登出结果 传输结果struct LogoutResult : public DataHeader &#123; LogoutResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUTRESULT; this-&gt;date_length = sizeof(LogoutResult); &#125; int Result;&#125;;//包5 新用户登入 传输通告 struct NewUserJoin : public DataHeader &#123; NewUserJoin()//初始化包头 &#123; this-&gt;cmd = CMD_NEW_USER_JOIN; this-&gt;date_length = sizeof(NewUserJoin); &#125; char UserName[32];//用户名 &#125;;#include&lt;bits/stdc++.h&gt;class TcpServer&#123;public: //构造 TcpServer() &#123; _sock = INVALID_SOCKET; &#125; //析构 virtual ~TcpServer() &#123; //关闭socket CloseSocket(); &#125; //初始化socket 返回1为正常 int InitSocket() &#123;#ifdef _WIN32 //启动windows socket 2,x环境 WORD ver = MAKEWORD(2,2); WSADATA dat; if(0 != WSAStartup(ver,&amp;dat)) &#123; return -1;//-1为环境错误 &#125;#endif //创建socket if(INVALID_SOCKET != _sock) &#123; printf(&quot;&lt;Socket=%d&gt;关闭连接\\n&quot;,_sock); CloseSocket();//如果之前有连接 就关闭连接 &#125; _sock = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP); if(INVALID_SOCKET == _sock) &#123; return 0;//0为socket创建错误 &#125; return 1; &#125; //绑定IP/端口 int Bind(const char* ip,unsigned short port) &#123; //如果为无效套接字 则初始化 if(INVALID_SOCKET == _sock) &#123; InitSocket(); &#125; //绑定网络端口和IP地址 sockaddr_in _myaddr = &#123;&#125;; _myaddr.sin_family = AF_INET;//IPV4 _myaddr.sin_port = htons(port);//端口#ifdef _WIN32 if(ip)//ip为空则监听所有网卡 &#123; _myaddr.sin_addr.S_un.S_addr = inet_addr(ip);//IP &#125; else &#123; _myaddr.sin_addr.S_un.S_addr = INADDR_ANY;//IP &#125;#else if(ip)//ip为空则监听所有网卡 &#123; _myaddr.sin_addr.s_addr = inet_addr(ip);//IP &#125; else &#123; _myaddr.sin_addr.s_addr = INADDR_ANY;//IP &#125;#endif if(SOCKET_ERROR == bind(_sock,(sockaddr*)&amp;_myaddr,sizeof(sockaddr_in)))//socket (强制转换)sockaddr结构体 结构体大小 &#123; printf(&quot;绑定失败\\n&quot;); return 0; &#125; else &#123; printf(&quot;绑定成功\\n绑定端口为%d\\n&quot;,port); return 1; &#125; &#125; //监听端口 int Listen(int n) &#123; //如果为无效套接字 则提示 if(INVALID_SOCKET == _sock) &#123; printf(&quot;请先初始化套接字并绑定IP端口\\n&quot;); return 0; &#125; //监听网络端口 if(SOCKET_ERROR == listen(_sock,n))//最大连接队列 &#123; printf(&quot;监听失败\\n&quot;); return 0; &#125; else &#123; printf(&quot;监听成功\\n&quot;); return 1; &#125; &#125; //接受连接 int Accept() &#123; //等待接收客户端连接 sockaddr_in _clientAddr = &#123;&#125;;//新建sockadd结构体接收客户端数据 int _addr_len = sizeof(sockaddr_in);//获取sockadd结构体长度 SOCKET _temp_socket = INVALID_SOCKET;//声明客户端套接字 #ifdef _WIN32 _temp_socket = accept(_sock,(sockaddr*)&amp;_clientAddr,&amp;_addr_len);//自身套接字 客户端结构体 结构体大小 #else _temp_socket = accept(_sock,(sockaddr*)&amp;_clientAddr,(socklen_t*)&amp;_addr_len);//自身套接字 客户端结构体 结构体大小 #endif if(INVALID_SOCKET == _temp_socket)//接收失败 &#123; printf(&quot;&lt;Socket=%d&gt;错误,接受到无效客户端SOCKET\\n&quot;,_temp_socket); return 0; &#125; else &#123; printf(&quot;新客户端加入\\nIP地址为：%s \\n&quot;, inet_ntoa(_clientAddr.sin_addr)); //群发所有客户端 通知新用户登录 NewUserJoin _user_join; strcpy(_user_join.UserName,inet_ntoa(_clientAddr.sin_addr)); for(int n=0;n&lt;_clients.size();++n) &#123; send(_clients[n],(const char*)&amp;_user_join,sizeof(NewUserJoin),0); &#125; //将新的客户端加入动态数组 _clients.push_back(_temp_socket); return 1; &#125; &#125; //关闭socket void CloseSocket() &#123; if(INVALID_SOCKET != _sock) &#123;#ifdef _WIN32 //关闭客户端socket for(int n=0; n&lt;_clients.size(); ++n) &#123; closesocket(_clients[n]); &#125; //关闭socket closesocket(_sock); //清除windows socket 环境 WSACleanup(); #else //关闭客户端socket for(int n=0; n&lt;_clients.size(); ++n) &#123; close(_clients[n]); &#125; //关闭socket/LINUX close(_sock);#endif _sock = INVALID_SOCKET; &#125; &#125; //查询是否有待处理消息 bool OnRun() &#123; if(IsRun()) &#123; fd_set _fdRead;//建立集合 fd_set _fdWrite; fd_set _fdExcept; FD_ZERO(&amp;_fdRead);//清空集合 FD_ZERO(&amp;_fdWrite); FD_ZERO(&amp;_fdExcept); FD_SET(_sock,&amp;_fdRead);//放入集合 FD_SET(_sock,&amp;_fdWrite); FD_SET(_sock,&amp;_fdExcept); timeval _t = &#123;2,0&#125;;//select最大响应时间 SOCKET _maxSock = _sock;//最大socket //把连接的客户端 放入read集合 for(int n=_clients.size()-1; n&gt;=0; --n) &#123; FD_SET(_clients[n],&amp;_fdRead); if(_maxSock &lt; _clients[n]) &#123; _maxSock = _clients[n]; &#125; &#125; //select函数筛选select int _ret = select(_maxSock+1,&amp;_fdRead,&amp;_fdWrite,&amp;_fdExcept,&amp;_t); if(_ret&lt;0) &#123; printf(&quot;select任务结束\\n&quot;); CloseSocket(); return false; &#125; if(FD_ISSET(_sock,&amp;_fdRead))//获取是否有新socket连接 &#123; FD_CLR(_sock,&amp;_fdRead);//清理 Accept();//连接 &#125; //遍历所有socket 查看是否有待处理事件 for(int n=0; n&lt;_clients.size(); ++n) &#123; if(FD_ISSET(_clients[n],&amp;_fdRead)) &#123; if(-1 == RecvData(_clients[n]))//处理请求 客户端退出的话 &#123; std::vector&lt;SOCKET&gt;::iterator iter = _clients.begin()+n;//找到退出客户端的地址 if(iter != _clients.end())//如果是合理值 &#123; _clients.erase(iter);//移除 &#125; &#125; &#125; &#125; //printf(&quot;空闲时间处理其他业务\\n&quot;); return true; &#125; return false; &#125; //判断是否工作中 bool IsRun() &#123; return _sock != INVALID_SOCKET; &#125; //发送数据 int SendData(DataHeader *_head,SOCKET _temp_socket) &#123; if(IsRun() &amp;&amp; _head) &#123; send(_temp_socket,(const char*)_head,_head-&gt;date_length,0); return 1; &#125; return 0; &#125; //接收数据 int RecvData(SOCKET _temp_socket)//处理数据 &#123; //缓冲区 char buffer[4096] = &#123;&#125;; //接收客户端发送的数据 int _buf_len = recv(_temp_socket,buffer,sizeof(DataHeader),0); DataHeader *_head = (DataHeader*)buffer; if(_buf_len&lt;=0) &#123; printf(&quot;客户端已退出\\n&quot;); return -1; &#125; recv(_temp_socket,buffer+sizeof(DataHeader),_head-&gt;date_length-sizeof(DataHeader),0); //响应数据 NetMsg(_head,_temp_socket); return 0; &#125; //响应数据 void NetMsg(DataHeader *_head,SOCKET _temp_socket) &#123; printf(&quot;接收到包头，命令：%d，数据长度：%d\\n&quot;,_head-&gt;cmd,_head-&gt;date_length); switch(_head-&gt;cmd) &#123; case CMD_LOGIN://登录 接收登录包体 &#123; Login *_login = (Login*)_head; /* 进行判断操作 */ printf(&quot;%s已登录\\n密码：%s\\n&quot;,_login-&gt;UserName,_login-&gt;PassWord); LoginResult *_result = new LoginResult; _result-&gt;Result = 1; SendData(_result,_temp_socket); &#125; break; case CMD_LOGOUT://登出 接收登出包体 &#123; Logout *_logout = (Logout*)_head; /* 进行判断操作 */ printf(&quot;%s已登出\\n&quot;,_logout-&gt;UserName); LogoutResult *_result = new LogoutResult(); _result-&gt;Result = 1; SendData(_result,_temp_socket); &#125; break; default://错误 &#123; _head-&gt;cmd = CMD_ERROR; _head-&gt;date_length = 0; SendData(_head,_temp_socket); &#125; break; &#125; &#125; private: SOCKET _sock; std::vector&lt;SOCKET&gt; _clients;//储存客户端socket&#125;;#endif server_test.cpp123456789101112131415161718192021222324252627#include&quot;TcpServer.hpp&quot; int main() &#123; printf(&quot;Welcome\\n&quot;); //建立tcp对象 TcpServer *tcp1 = new TcpServer(); //建立一个socket tcp1-&gt;InitSocket(); //绑定端口和IP tcp1-&gt;Bind(NULL,8888); //监听 tcp1-&gt;Listen(5); //循环 while(tcp1-&gt;IsRun()) &#123; tcp1-&gt;OnRun(); &#125; //关闭 tcp1-&gt;CloseSocket(); printf(&quot;任务结束，程序已退出&quot;); getchar(); return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"网络编程","slug":"网络编程","permalink":"https://zgg2001.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"C++网络编程学习：跨平台支持Windows、Linux系统","slug":"20210124_C++网络编程学习：跨平台支持Windows、Linux系统","date":"2021-01-24T12:09:34.000Z","updated":"2021-01-24T12:09:34.000Z","comments":true,"path":"2021/01/24/20210124_C++网络编程学习：跨平台支持Windows、Linux系统/","permalink":"https://zgg2001.github.io/2021/01/24/20210124_C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%94%AF%E6%8C%81Windows%E3%80%81Linux%E7%B3%BB%E7%BB%9F/","excerpt":"使用的语言为C&#x2F;C++ 源码支持的平台为：Windows &#x2F; Linux 一、为何要进行跨平台操作&emsp;&emsp;首先，我是想在网络编程学习渐入佳境后，自己尝试做一个网络方面的项目，其中就必须用到服务器。Linux服务器相比Windows服务器更加稳定且高效，所以对于我来说，学会如何编写出可以在Linux系统下运行的网络程序是必不可少的。&emsp;&emsp;其次，就目前来说，企业中的高性能网络编程都是基于Linux的，学会跨平台的网络编程技能，可以在未来就业方面等有很大的好处。&emsp;&emsp;由此，我决定在网络编程学习的第四小阶段，学习如何进行跨平台的网络编程。","text":"使用的语言为C&#x2F;C++ 源码支持的平台为：Windows &#x2F; Linux 一、为何要进行跨平台操作&emsp;&emsp;首先，我是想在网络编程学习渐入佳境后，自己尝试做一个网络方面的项目，其中就必须用到服务器。Linux服务器相比Windows服务器更加稳定且高效，所以对于我来说，学会如何编写出可以在Linux系统下运行的网络程序是必不可少的。&emsp;&emsp;其次，就目前来说，企业中的高性能网络编程都是基于Linux的，学会跨平台的网络编程技能，可以在未来就业方面等有很大的好处。&emsp;&emsp;由此，我决定在网络编程学习的第四小阶段，学习如何进行跨平台的网络编程。 二、关于Win与Linux系统下网络编程的差异差异一 在Linux环境下，程序的头文件与定义与Win环境下存在差异。 1234567891011121314#ifdef _WIN32 #define WIN32_LEAN_AND_MEAN #include&lt;winSock2.h&gt; #include&lt;windows.h&gt; #pragma comment(lib,&quot;ws2_32.lib&quot;)//链接此动态链接库 windows特有 #else #include&lt;arpa/inet.h&gt;//selcet #include&lt;unistd.h&gt;//uni std #include&lt;string.h&gt; #define SOCKET int #define INVALID_SOCKET (SOCKET)(~0) #define SOCKET_ERROR (-1)#endif 这是更改后的程序部分。可以看出： Win环境下的特有头文件 &lt;windows.h&gt; 对应Linux环境下的特有头文件 **&lt;unistd.h&gt;**。 Win环境下的网络头文件 &lt;winSock2.h&gt; 对应Linux环境下的特有头文件 **&lt;arpa&#x2F;inet.h&gt;**。 SOCKET为Win环境下的特有数据类型，其原型为unsigned __int64，所以我们在Linux下，需要简单对SOCKET进行定义。 Linux中同样对INVALID_SOCKET与SOCKET_ERROR也没有定义，所以我们参考Win中的定义，在Linux系统下对其定义。 (此图为Win环境下_socket_types.h头文件中的相关定义) 差异二 在Linux环境下不需要使用WSAStartup与WSACleanup搭建网络环境，这是Win环境特有的。 所以我们只需要加上判断即可，当检测到系统环境为Win时执行即可： 1234567891011121314#ifdef _WIN32 //启动windows socket 2,x环境 windows特有 WORD ver = MAKEWORD(2,2);//WinSock库版本号 WSADATA dat;//网络结构体 储存WSAStartup函数调用后返回的Socket数据 if(0 != WSAStartup(ver,&amp;dat))//正确初始化后返回0 &#123; return 0; &#125;#endif#ifdef _WIN32 //清除windows socket 环境 WSACleanup(); #endif 差异三 Linux环境与Win环境下，网络通信相关结构体 sockaddr_in和sockaddr 存在差异。最明显的差异为存储IP的结构不太一样。 所以我们这样更改即可：12345#ifdef _WIN32 _sin.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);//想要连接的IP #else _sin.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);//想要连接的IP #endif 差异四 Linux环境与Win环境下，关闭套接字的函数存在差异。Win下为**closesocket()，Linux下则简单粗暴为close()**。 所以我们这样更改即可：1234567#ifdef _WIN32 //关闭socket closesocket(_mysocket); #else //关闭socket/LINUX close(_mysocket);#endif 差异五 Linux环境与Win环境下，服务器的accept连接函数参数存在差异。Win下的最后一个参数为int型地址，Linux下则为socklen_t型地址。进行一次强制转换即可。 所以我们这样更改即可：12345#ifdef _WIN32 _temp_socket = accept(_mysocket,(sockaddr*)&amp;_clientAddr,&amp;_addr_len);//自身套接字 客户端结构体 结构体大小 #else _temp_socket = accept(_mysocket,(sockaddr*)&amp;_clientAddr,(socklen_t*)&amp;_addr_len);//自身套接字 客户端结构体 结构体大小 #endif 差异六 Linux环境与Win环境下，fd_set结构体中的参数出现了变化，不再有储存socket数量的fd_count变量，所以我们需要对源码下select函数的第一个参数进行准确的数据传入。 select函数的第一个参数实际为 所有socket的最大值+1，所以我们新建一个变量，用于储存最大值。在每次对fdread集合进行导入时，找到socket的最大值，随后传入select函数即可。 所以我们这样更改即可：123456789101112SOCKET _maxSock = _mysocket;//最大socket for(int n=_clients.size()-1; n&gt;=0; --n)//把连接的客户端 放入read集合 &#123; FD_SET(_clients[n],&amp;_fdRead); if(_maxSock &lt; _clients[n]) &#123; _maxSock = _clients[n];//找最大 &#125;&#125;//select函数筛选select int _ret = select(_maxSock+1,&amp;_fdRead,&amp;_fdWrite,&amp;_fdExcept,&amp;_t); 差异七 Linux环境与Win环境下，fd_set结构体中的参数出现了变化，不再有储存socket数量的fd_count变量，所以我们需要对源码下面关于遍历socket的逻辑进行改变。 首先遍历 _clients 数组中的所有socket，随后使用FD_ISSET函数判定其是否存在待处理事件，如果有，即可按逻辑进行处理。 所以我们这样更改即可：1234567891011121314for(int n=0; n&lt;_clients.size(); ++n)//遍历所有socket&#123; if(FD_ISSET(_clients[n],&amp;_fdRead))//看一下是否在待处理事件列表中 &#123; if(-1 == _handle(_clients[n]))//处理请求 客户端退出的话 &#123; vector&lt;SOCKET&gt;::iterator iter = _clients.begin()+n;//找到退出客户端的地址 if(iter != _clients.end())//如果是合理值 &#123; _clients.erase(iter);//移除 &#125; &#125; &#125;&#125; 三、基于笔记三源码进行 跨平台化升级1.客户端源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250#ifdef _WIN32 #define WIN32_LEAN_AND_MEAN #include&lt;winSock2.h&gt; #include&lt;windows.h&gt; #pragma comment(lib,&quot;ws2_32.lib&quot;)//链接此动态链接库 windows特有 #else #include&lt;arpa/inet.h&gt;//selcet #include&lt;unistd.h&gt;//uni std #include&lt;string.h&gt; #define SOCKET int #define INVALID_SOCKET (SOCKET)(~0) #define SOCKET_ERROR (-1)#endif#include&lt;bits/stdc++.h&gt;#include&lt;thread&gt; using namespace std; //枚举类型记录命令 enum cmd &#123; CMD_LOGIN,//登录 CMD_LOGINRESULT,//登录结果 CMD_LOGOUT,//登出 CMD_LOGOUTRESULT,//登出结果 CMD_NEW_USER_JOIN,//新用户登入 CMD_ERROR//错误 &#125;;//定义数据包头 struct DateHeader &#123; short cmd;//命令 short date_length;//数据的长短 &#125;;//包1 登录 传输账号与密码struct Login : public DateHeader &#123; Login()//初始化包头 &#123; this-&gt;cmd = CMD_LOGIN; this-&gt;date_length = sizeof(Login); &#125; char UserName[32];//用户名 char PassWord[32];//密码 &#125;;//包2 登录结果 传输结果struct LoginResult : public DateHeader &#123; LoginResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGINRESULT; this-&gt;date_length = sizeof(LoginResult); &#125; int Result;&#125;;//包3 登出 传输用户名 struct Logout : public DateHeader &#123; Logout()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUT; this-&gt;date_length = sizeof(Logout); &#125; char UserName[32];//用户名 &#125;;//包4 登出结果 传输结果struct LogoutResult : public DateHeader &#123; LogoutResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUTRESULT; this-&gt;date_length = sizeof(LogoutResult); &#125; int Result;&#125;;//包5 新用户登入 传输通告 struct NewUserJoin : public DateHeader &#123; NewUserJoin()//初始化包头 &#123; this-&gt;cmd = CMD_NEW_USER_JOIN; this-&gt;date_length = sizeof(NewUserJoin); &#125; char UserName[32];//用户名 &#125;; int _handle(SOCKET _temp_socket)//处理数据 &#123; //接收客户端发送的数据 DateHeader _head = &#123;&#125;; int _buf_len = recv(_temp_socket,(char*)&amp;_head,sizeof(DateHeader),0); if(_buf_len&lt;=0) &#123; printf(&quot;与服务器断开连接,任务结束\\n&quot;); return -1; &#125; printf(&quot;接收到包头，命令：%d，数据长度：%d\\n&quot;,_head.cmd,_head.date_length); switch(_head.cmd) &#123; case CMD_LOGINRESULT://登录结果 接收登录包体 &#123; LoginResult _result; recv(_temp_socket,(char*)&amp;_result+sizeof(DateHeader),sizeof(LoginResult)-sizeof(DateHeader),0); printf(&quot;登录结果:%d\\n&quot;,_result.Result); &#125; break; case CMD_LOGOUTRESULT://登出结果 接收登出包体 &#123; LogoutResult _result; recv(_temp_socket,(char*)&amp;_result+sizeof(DateHeader),sizeof(LogoutResult)-sizeof(DateHeader),0); printf(&quot;登录结果:%d\\n&quot;,_result.Result); &#125; break; case CMD_NEW_USER_JOIN://新用户登录通知 &#123; NewUserJoin _result; recv(_temp_socket,(char*)&amp;_result+sizeof(DateHeader),sizeof(NewUserJoin)-sizeof(DateHeader),0); printf(&quot;用户:%s已登录\\n&quot;,_result.UserName); &#125; &#125; return 0; &#125;bool _run = true;//当前程序是否还在运行中 void _cmdThread(SOCKET _mysocket)//命令线程 &#123; while(_run) &#123; //输入请求 char _msg[256] = &#123;&#125;; scanf(&quot;%s&quot;,_msg); //处理请求 if(0 == strcmp(_msg,&quot;exit&quot;)) &#123; _run = false; printf(&quot;程序退出\\n&quot;); break; &#125; else if(0 == strcmp(_msg,&quot;login&quot;)) &#123; //发送 Login _login; strcpy(_login.UserName,&quot;hbxxy&quot;); strcpy(_login.PassWord,&quot;123456&quot;); send(_mysocket,(const char*)&amp;_login,sizeof(_login),0); &#125; else if(0 == strcmp(_msg,&quot;logout&quot;)) &#123; //发送 Logout _logout; strcpy(_logout.UserName,&quot;hbxxy&quot;); send(_mysocket,(const char*)&amp;_logout,sizeof(_logout),0); &#125; else &#123; printf(&quot;不存在的命令\\n&quot;); &#125; &#125;&#125;int main()&#123; printf(&quot;Welcome\\n&quot;); #ifdef _WIN32 //启动windows socket 2,x环境 windows特有 WORD ver = MAKEWORD(2,2);//WinSock库版本号 WSADATA dat;//网络结构体 储存WSAStartup函数调用后返回的Socket数据 if(0 != WSAStartup(ver,&amp;dat))//正确初始化后返回0 &#123; return 0; &#125; #endif //建立一个socket SOCKET _mysocket = socket(AF_INET,SOCK_STREAM,0);//IPV4 数据流类型 类型可以不用写 if(INVALID_SOCKET == _mysocket)//建立失败 &#123; printf(&quot;socket error&quot;); return 0; &#125; //连接服务器 sockaddr_in _sin = &#123;&#125;;//sockaddr结构体 _sin.sin_family = AF_INET;//IPV4 _sin.sin_port = htons(8888);//想要连接的端口号 #ifdef _WIN32 _sin.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);//想要连接的IP #else _sin.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);//想要连接的IP #endif if(SOCKET_ERROR == connect(_mysocket,(sockaddr*)&amp;_sin,sizeof(sockaddr_in))) &#123; cout&lt;&lt;&quot;连接失败&quot;&lt;&lt;endl; #ifdef _WIN32 //关闭socket closesocket(_mysocket); #else //关闭socket/LINUX close(_mysocket); #endif &#125; else &#123; cout&lt;&lt;&quot;连接成功&quot;&lt;&lt;endl; &#125; //创建新线程 thread t1(_cmdThread,_mysocket); t1.detach();//线程分离 while(_run) &#123; fd_set _fdRead;//建立集合 FD_ZERO(&amp;_fdRead);//清空集合 FD_SET(_mysocket,&amp;_fdRead);//放入集合 timeval _t = &#123;1,0&#125;;//select最大响应时间 //新建seclect int _ret = select(_mysocket+1,&amp;_fdRead,NULL,NULL,&amp;_t); if(_ret&lt;0) &#123; printf(&quot;seclect任务结束\\n&quot;); break; &#125; if(FD_ISSET(_mysocket,&amp;_fdRead))//获取是否有可读socket &#123; FD_CLR(_mysocket,&amp;_fdRead);//清理计数器 if(-1 == _handle(_mysocket)) &#123; printf(&quot;seclect任务结束\\n&quot;); break; &#125; &#125; &#125;#ifdef _WIN32 //关闭socket closesocket(_mysocket); //清除windows socket 环境 WSACleanup(); #else //关闭socket/LINUX close(_mysocket);#endif return 0;&#125; 2.服务端源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290#ifdef _WIN32 #define WIN32_LEAN_AND_MEAN #include&lt;winSock2.h&gt; #include&lt;windows.h&gt; #pragma comment(lib,&quot;ws2_32.lib&quot;)//链接此动态链接库 windows特有 #else #include&lt;arpa/inet.h&gt;//selcet #include&lt;unistd.h&gt;//uni std #include&lt;string.h&gt; #define SOCKET int #define INVALID_SOCKET (SOCKET)(~0) #define SOCKET_ERROR (-1)#endif#include&lt;bits/stdc++.h&gt;using namespace std; //枚举类型记录命令 enum cmd &#123; CMD_LOGIN,//登录 CMD_LOGINRESULT,//登录结果 CMD_LOGOUT,//登出 CMD_LOGOUTRESULT,//登出结果 CMD_NEW_USER_JOIN,//新用户登入 CMD_ERROR//错误 &#125;;//定义数据包头 struct DateHeader &#123; short cmd;//命令 short date_length;//数据的长短 &#125;;//包1 登录 传输账号与密码struct Login : public DateHeader &#123; Login()//初始化包头 &#123; this-&gt;cmd = CMD_LOGIN; this-&gt;date_length = sizeof(Login); &#125; char UserName[32];//用户名 char PassWord[32];//密码 &#125;;//包2 登录结果 传输结果struct LoginResult : public DateHeader &#123; LoginResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGINRESULT; this-&gt;date_length = sizeof(LoginResult); &#125; int Result;&#125;;//包3 登出 传输用户名 struct Logout : public DateHeader &#123; Logout()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUT; this-&gt;date_length = sizeof(Logout); &#125; char UserName[32];//用户名 &#125;;//包4 登出结果 传输结果struct LogoutResult : public DateHeader &#123; LogoutResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUTRESULT; this-&gt;date_length = sizeof(LogoutResult); &#125; int Result;&#125;;//包5 新用户登入 传输通告 struct NewUserJoin : public DateHeader &#123; NewUserJoin()//初始化包头 &#123; this-&gt;cmd = CMD_NEW_USER_JOIN; this-&gt;date_length = sizeof(NewUserJoin); &#125; char UserName[32];//用户名 &#125;; vector&lt;SOCKET&gt; _clients;//储存客户端socket int _handle(SOCKET _temp_socket)//处理数据 &#123; //接收客户端发送的数据 DateHeader _head = &#123;&#125;; int _buf_len = recv(_temp_socket,(char*)&amp;_head,sizeof(DateHeader),0); if(_buf_len&lt;=0) &#123; printf(&quot;客户端已退出\\n&quot;); return -1; &#125; printf(&quot;接收到包头，命令：%d，数据长度：%d\\n&quot;,_head.cmd,_head.date_length); switch(_head.cmd) &#123; case CMD_LOGIN://登录 接收登录包体 &#123; Login _login; recv(_temp_socket,(char*)&amp;_login+sizeof(DateHeader),sizeof(Login)-sizeof(DateHeader),0); /* 进行判断操作 */ printf(&quot;%s已登录\\n密码：%s\\n&quot;,_login.UserName,_login.PassWord); LoginResult _result; _result.Result = 1; send(_temp_socket,(char*)&amp;_result,sizeof(LoginResult),0);//发包体 &#125; break; case CMD_LOGOUT://登出 接收登出包体 &#123; Logout _logout; recv(_temp_socket,(char*)&amp;_logout+sizeof(DateHeader),sizeof(Logout)-sizeof(DateHeader),0); /* 进行判断操作 */ printf(&quot;%s已登出\\n&quot;,_logout.UserName); LogoutResult _result; _result.Result = 1; send(_temp_socket,(char*)&amp;_result,sizeof(LogoutResult),0);//发包体 &#125; break; default://错误 &#123; _head.cmd = CMD_ERROR; _head.date_length = 0; send(_temp_socket,(char*)&amp;_head,sizeof(DateHeader),0);//发包头 &#125; break; &#125; return 0; &#125; int main() &#123;#ifdef _WIN32 //启动windows socket 2,x环境 windows特有 WORD ver = MAKEWORD(2,2);//WinSock库版本号 WSADATA dat;//网络结构体 储存WSAStartup函数调用后返回的Socket数据 if(0 != WSAStartup(ver,&amp;dat))//正确初始化后返回0 &#123; return 0; &#125;#endif //建立一个socket SOCKET _mysocket = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);//IPV4 数据流类型 TCP类型 if(INVALID_SOCKET == _mysocket)//建立失败 &#123; return 0; &#125; //绑定网络端口和IP地址 sockaddr_in _myaddr = &#123;&#125;;//建立sockaddr结构体 sockaddr_in结构体方便填写 但是下面要进行类型转换 _myaddr.sin_family = AF_INET;//IPV4 _myaddr.sin_port = htons(8888);//端口 host to net unsigned short#ifdef _WIN32 _myaddr.sin_addr.S_un.S_addr = INADDR_ANY;//inet_addr(&quot;127.0.0.1&quot;);#else _myaddr.sin_addr.s_addr = INADDR_ANY;//想要监听的ip #endif if(SOCKET_ERROR == bind(_mysocket,(sockaddr*)&amp;_myaddr,sizeof(sockaddr_in)))//socket (强制转换)sockaddr结构体 结构体大小 &#123; cout&lt;&lt;&quot;绑定不成功&quot;&lt;&lt;endl; &#125; else &#123; //cout&lt;&lt;&quot;绑定成功&quot;&lt;&lt;endl; &#125; //监听网络端口 if(SOCKET_ERROR == listen(_mysocket,5))//套接字 最大多少人连接 &#123; cout&lt;&lt;&quot;监听失败&quot;&lt;&lt;endl; &#125; else &#123; //cout&lt;&lt;&quot;监听成功&quot;&lt;&lt;endl; &#125; while(true) &#123; fd_set _fdRead;//建立集合 fd_set _fdWrite; fd_set _fdExcept; FD_ZERO(&amp;_fdRead);//清空集合 FD_ZERO(&amp;_fdWrite); FD_ZERO(&amp;_fdExcept); FD_SET(_mysocket,&amp;_fdRead);//放入集合 FD_SET(_mysocket,&amp;_fdWrite); FD_SET(_mysocket,&amp;_fdExcept); timeval _t = &#123;2,0&#125;;//select最大响应时间 SOCKET _maxSock = _mysocket;//最大socket for(int n=_clients.size()-1; n&gt;=0; --n)//把连接的客户端 放入read集合 &#123; FD_SET(_clients[n],&amp;_fdRead); if(_maxSock &lt; _clients[n]) &#123; _maxSock = _clients[n];//找最大 &#125; &#125; //select函数筛选select int _ret = select(_maxSock+1,&amp;_fdRead,&amp;_fdWrite,&amp;_fdExcept,&amp;_t); if(_ret&lt;0) &#123; printf(&quot;select任务结束\\n&quot;); break; &#125; if(FD_ISSET(_mysocket,&amp;_fdRead))//获取是否有新socket连接 &#123; FD_CLR(_mysocket,&amp;_fdRead);//清理 //等待接收客户端连接 sockaddr_in _clientAddr = &#123;&#125;;//新建sockadd结构体接收客户端数据 int _addr_len = sizeof(sockaddr_in);//获取sockadd结构体长度 SOCKET _temp_socket = INVALID_SOCKET;//声明客户端套接字 #ifdef _WIN32 _temp_socket = accept(_mysocket,(sockaddr*)&amp;_clientAddr,&amp;_addr_len);//自身套接字 客户端结构体 结构体大小 #else _temp_socket = accept(_mysocket,(sockaddr*)&amp;_clientAddr,(socklen_t*)&amp;_addr_len);//自身套接字 客户端结构体 结构体大小 #endif if(INVALID_SOCKET == _temp_socket)//接收失败 &#123; cout&lt;&lt;&quot;接收到无效客户端Socket&quot;&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;&quot;新客户端加入&quot;&lt;&lt;endl; printf(&quot;IP地址为：%s \\n&quot;, inet_ntoa(_clientAddr.sin_addr)); //群发所有客户端 通知新用户登录 NewUserJoin _user_join; strcpy(_user_join.UserName,inet_ntoa(_clientAddr.sin_addr)); for(int n=0;n&lt;_clients.size();++n) &#123; send(_clients[n],(const char*)&amp;_user_join,sizeof(NewUserJoin),0); &#125; //将新的客户端加入动态数组 _clients.push_back(_temp_socket); &#125; &#125; for(int n=0; n&lt;_clients.size(); ++n)//遍历所有socket &#123; if(FD_ISSET(_clients[n],&amp;_fdRead))//看一下是否在待处理事件列表中 &#123; if(-1 == _handle(_clients[n]))//处理请求 客户端退出的话 &#123; vector&lt;SOCKET&gt;::iterator iter = _clients.begin()+n;//找到退出客户端的地址 if(iter != _clients.end())//如果是合理值 &#123; _clients.erase(iter);//移除 &#125; &#125; &#125; &#125; printf(&quot;空闲时间处理其他业务\\n&quot;); &#125;#ifdef _WIN32 //关闭客户端socket for(int n=0; n&lt;_clients.size(); ++n) &#123; closesocket(_clients[n]); &#125; //关闭socket closesocket(_mysocket); //清除windows socket 环境 WSACleanup(); #else //关闭客户端socket for(int n=0; n&lt;_clients.size(); ++n) &#123; close(_clients[n]); &#125; //关闭socket/LINUX close(_mysocket);#endif printf(&quot;任务结束，程序已退出&quot;); getchar(); return 0;&#125; 四、移植过程中遇到的一些小问题1.关于IP的问题&emsp;&emsp;如果服务端在本机Windows环境下运行，客户端在VM虚拟机Linux环境下运行，则在Windows命令行上输入ipconfig命令。下面这一块数据下的IPv4地址即为客户端需要连接的IP。 1234567以太网适配器 VMware Network Adapter VMnet8: 连接特定的 DNS 后缀 . . . . . . . : 本地链接 IPv6 地址. . . . . . . . : IPv4 地址 . . . . . . . . . . . . : 子网掩码 . . . . . . . . . . . . : 默认网关. . . . . . . . . . . . . : &emsp;&emsp;如果服务端在VM虚拟机Linux环境下运行，客户端在本机Windows环境下运行，则在Linux命令行上输入ifconfig命令。显示出来的数据中网卡的IP即为客户端需要连接的IP。 2.关于端口的问题&emsp;&emsp;如果你的服务端运行正常，客户端运行正常，本机双开客户端和服务端也运行正常，但本机与虚拟机各开一个却连接不上时，可能是服务端的端口未开放导致的。 Windows环境下会主动提示，点击允许即可，如果还是不行就去网上搜。 Linux环境下相关命令如下：12345678910111213141516171819systemctl status firewalld 查看防火墙状态systemctl start firewalld 开启防火墙 systemctl stop firewalld 关闭防火墙 service firewalld start 开启防火墙 查看对外开放的8888端口状态 yes/nofirewall-cmd --query-port=8888/tcp打开8888端口firewall-cmd --add-port=8888/tcp --permanent重载端口firewall-cmd --reload移除指定的8888端口：firewall-cmd --permanent --remove-port=8888/tcp","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"网络编程","slug":"网络编程","permalink":"https://zgg2001.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"C++网络编程学习：升级为select网络模型","slug":"20210123_C++网络编程学习：升级为select网络模型","date":"2021-01-23T14:36:50.000Z","updated":"2021-01-23T14:36:50.000Z","comments":true,"path":"2021/01/23/20210123_C++网络编程学习：升级为select网络模型/","permalink":"https://zgg2001.github.io/2021/01/23/20210123_C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%8D%87%E7%BA%A7%E4%B8%BAselect%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/","excerpt":"使用的语言为C&#x2F;C++ 源码支持的平台为：Windows 一、为何要使用select网络模型？&emsp;&emsp;通过前面的学习，已经实现了简单的网络报文收发。但是可以很明显的看出其中的缺点，那就是整个程序的运行是阻塞模式的。即服务端在与一个客户端进行socket连接时，只要连接不中断，那么就无法接收新的客户端的消息。而客户端在未输入命令时，是阻塞状态，也无法接收服务端发来的消息。&emsp;&emsp;在之前碰到这个问题时，我的想法是通过多线程来解决程序运行中的阻塞问题，但是在最近的学习中，我了解到可以使用select网络模型来方便快捷的解决小型网络程序运行中的阻塞问题。（I&#x2F;O多路复用模型相关内容）","text":"使用的语言为C&#x2F;C++ 源码支持的平台为：Windows 一、为何要使用select网络模型？&emsp;&emsp;通过前面的学习，已经实现了简单的网络报文收发。但是可以很明显的看出其中的缺点，那就是整个程序的运行是阻塞模式的。即服务端在与一个客户端进行socket连接时，只要连接不中断，那么就无法接收新的客户端的消息。而客户端在未输入命令时，是阻塞状态，也无法接收服务端发来的消息。&emsp;&emsp;在之前碰到这个问题时，我的想法是通过多线程来解决程序运行中的阻塞问题，但是在最近的学习中，我了解到可以使用select网络模型来方便快捷的解决小型网络程序运行中的阻塞问题。（I&#x2F;O多路复用模型相关内容） 二、select系统及其相关select函数如下： 12345678WINSOCK_API_LINKAGE int WSAAPI select( int nfds,//是指待监听集合里的范围 即待监听数量最大值+1 fd_set *readfds,//待监听的可读文件集合 fd_set *writefds,//待监听的可写文件集合 fd_set *exceptfds,//待监听的异常文件集合 const PTIMEVAL timeout);//超时设置 传入NULL为阻塞模式 传入timeval结构体为非阻塞模式返回值为满足条件的待监听socket数量和，如果出错返回-1，如果超时返回0。 通过上面select函数的参数可以发现存在两个特殊的结构体 fd_set 和 timeval，其相关内容如下： 1234567891011typedef struct fd_set//可以存放多个socket &#123; u_int fd_count;//记录放了多少个socket SOCKET fd_array[FD_SETSIZE];//socket数组&#125; fd_set;struct timeval//时间结构体 &#123; long tv_sec;//秒 long tv_usec;//毫秒&#125;; 接下来为select的相关函数 1234void FD_SET(int fd, fd_set *set);//将fd加入set集合void FD_ZERO(fd_set *set);//使set集合清零 不包含任何socketvoid FD_CLR(int fd, fd_set *set);//将fd从set集合中清除int FD_ISSET(int fd, fd_set *set);//测试fd是否在集合中 0是不在 1是在 ★ select相关使用总结与心得&emsp;&emsp;在一开始的select使用中，我以为向select函数中传入fd_set地址，select会把待处理事件的socket放在set集合中，但是发现并不是这样。&emsp;&emsp;经过网络上资料的查询以及我个人的测试，可以发现，用户首先需要把一份socket数组传入到此set中，select函数的作用是移除该set中没有待处理事件的socket，则剩下的socket都存在待处理事件(未决I&#x2F;O操作)。这个过程可以说是一种“选择”的过程，select函数“选择”出需要操作的socket，这或许就是select(选择)的意思吧。&emsp;&emsp;在接下来的源码中，对于需要存储所有已连接socket的服务端，我使用动态数组vector进行socket的储存。在进行select筛选前，先把vector中的socket导入到set中，随后set中筛选剩下的即为有待处理事件的socket。&emsp;&emsp;如果服务端自己的socket提示有待处理事件，则说明有新的客户端尝试进行连接，此时进行accept操作即可。&emsp;&emsp;对于客户端的多线程问题，需要注意使用detach()方法使主线程与新线程分类，否则可能会出现主线程先结束的情况，导致程序出错。&emsp;&emsp;在线程中，我们可以引入一个bool变量，用来记录客户端是否仍在连接中，当输入exit命令退出客户端时，通过此bool变量使主线程停止，跳出循环。 三、升级为select网络模型的思路1.服务端升级（select）在之前，我们的思路是： 123456789101.建立socket2.绑定端口IP3.监听端口4.与客户端连接while(true)&#123; 5.接收数据 6.发送数据&#125;7.关闭socket &emsp;&emsp;这就导致我们只能与一个客户端进行连接，随后便进入循环，只能接收这一个客户端的消息。且由于send与recv函数都是阻塞函数，所以程序也是阻塞模式的。 接下来，我们需要根据select网络模型，对服务端进行升级。思路大致如下： 123456789101.建立socket2.绑定端口IP3.监听端口while(true)&#123; 4.使用select函数获取存在待监听事件的socket 5.如果有新的连接则与新的客户端连接 6.如果有待监听事件，则对其进行处理(接受与发送)&#125;7.关闭socket &emsp;&emsp;按如上思路，即可将程序升级为select网络模型。实现非阻塞模式，可以实现多客户端信息接收。对于select相关的细节与总结，请看上文中的总结。相关代码在下文。 2.客户端升级（select+多线程）在之前，我们的思路是： 123456781.建立socket2.连接服务器while(true)&#123; 3.发送数据 4.接收数据&#125;5.关闭socket &emsp;&emsp;这就导致我们在与一个服务端连接后，无法被动的接收服务器端发来的消息。因为send与recv函数都是阻塞函数，程序也为阻塞模式。如果我们想要客户端能接收服务端发来的消息，那么就可以使用select模型。 接下来，我们需要根据select网络模型，对客户端进行升级。思路大致如下： 123456781.建立socket2.连接服务器while(true)&#123; 3.使用select函数获取服务器端是否有待处理事件 4.如果有，就处理它(接收/发送)&#125;5.关闭socket &emsp;&emsp;按如上思路，即可将程序升级为select网络模型。实现非阻塞模式，可以实现服务器端数据的被动接收。 但是，这样的程序结构也有很明显的缺点，因为scanf等数据接收函数也为阻塞函数，如果我们想要主动输入一些命令发送给服务端，就会阻塞程序运行。对此，我们可以引入多线程解决问题。思路大致如下： 123456789101112131415161.建立socket2.连接服务器3.建立新线程 用于发送命令while(true)&#123; 4.使用select函数获取服务器端是否有待处理事件 5.如果有，就处理它(接收/发送)&#125;5.关闭socket新线程：while(1)&#123; 1.键入数据 2.发送数据&#125; &emsp;&emsp;按如上思路，即可将程序变得更加完善。可以被动接受数据且可以主动向服务端发送键入命令。对于select相关的细节与总结以及线程方面的注意事项，请看上文中的总结。相关代码在下文。 四、代码及其详细注释1.服务端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276#define WIN32_LEAN_AND_MEAN#include&lt;winSock2.h&gt;#include&lt;windows.h&gt;#include&lt;bits/stdc++.h&gt;#pragma comment(lib,&quot;ws2_32.lib&quot;)//链接此动态链接库 windows特有 using namespace std; //枚举类型记录命令 enum cmd &#123; CMD_LOGIN,//登录 CMD_LOGINRESULT,//登录结果 CMD_LOGOUT,//登出 CMD_LOGOUTRESULT,//登出结果 CMD_NEW_USER_JOIN,//新用户登入 CMD_ERROR//错误 &#125;;//定义数据包头 struct DateHeader &#123; short cmd;//命令 short date_length;//数据的长短 &#125;;//包1 登录 传输账号与密码struct Login : public DateHeader &#123; Login()//初始化包头 &#123; this-&gt;cmd = CMD_LOGIN; this-&gt;date_length = sizeof(Login); &#125; char UserName[32];//用户名 char PassWord[32];//密码 &#125;;//包2 登录结果 传输结果struct LoginResult : public DateHeader &#123; LoginResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGINRESULT; this-&gt;date_length = sizeof(LoginResult); &#125; int Result;&#125;;//包3 登出 传输用户名 struct Logout : public DateHeader &#123; Logout()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUT; this-&gt;date_length = sizeof(Logout); &#125; char UserName[32];//用户名 &#125;;//包4 登出结果 传输结果struct LogoutResult : public DateHeader &#123; LogoutResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUTRESULT; this-&gt;date_length = sizeof(LogoutResult); &#125; int Result;&#125;;//包5 新用户登入 传输通告 struct NewUserJoin : public DateHeader &#123; NewUserJoin()//初始化包头 &#123; this-&gt;cmd = CMD_NEW_USER_JOIN; this-&gt;date_length = sizeof(NewUserJoin); &#125; char UserName[32];//用户名 &#125;; vector&lt;SOCKET&gt; _clients;//储存客户端socket int _handle(SOCKET _temp_socket)//处理数据 &#123; //接收客户端发送的数据 DateHeader _head = &#123;&#125;; int _buf_len = recv(_temp_socket,(char*)&amp;_head,sizeof(DateHeader),0); if(_buf_len&lt;=0) &#123; printf(&quot;客户端已退出\\n&quot;); return -1; &#125; printf(&quot;接收到包头，命令：%d，数据长度：%d\\n&quot;,_head.cmd,_head.date_length); switch(_head.cmd) &#123; case CMD_LOGIN://登录 接收登录包体 &#123; Login _login; recv(_temp_socket,(char*)&amp;_login+sizeof(DateHeader),sizeof(Login)-sizeof(DateHeader),0); /* 进行判断操作 */ printf(&quot;%s已登录\\n密码：%s\\n&quot;,_login.UserName,_login.PassWord); LoginResult _result; _result.Result = 1; send(_temp_socket,(char*)&amp;_result,sizeof(LoginResult),0);//发包体 &#125; break; case CMD_LOGOUT://登出 接收登出包体 &#123; Logout _logout; recv(_temp_socket,(char*)&amp;_logout+sizeof(DateHeader),sizeof(Logout)-sizeof(DateHeader),0); /* 进行判断操作 */ printf(&quot;%s已登出\\n&quot;,_logout.UserName); LogoutResult _result; _result.Result = 1; send(_temp_socket,(char*)&amp;_result,sizeof(LogoutResult),0);//发包体 &#125; break; default://错误 &#123; _head.cmd = CMD_ERROR; _head.date_length = 0; send(_temp_socket,(char*)&amp;_head,sizeof(DateHeader),0);//发包头 &#125; break; &#125; return 0; &#125; int main() &#123; //启动windows socket 2,x环境 windows特有 WORD ver = MAKEWORD(2,2);//WinSock库版本号 WSADATA dat;//网络结构体 储存WSAStartup函数调用后返回的Socket数据 if(0 != WSAStartup(ver,&amp;dat))//正确初始化后返回0 &#123; return 0; &#125; //建立一个socket SOCKET _mysocket = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);//IPV4 数据流类型 TCP类型 if(INVALID_SOCKET == _mysocket)//建立失败 &#123; return 0; &#125; //绑定网络端口和IP地址 sockaddr_in _myaddr = &#123;&#125;;//建立sockaddr结构体 sockaddr_in结构体方便填写 但是下面要进行类型转换 _myaddr.sin_family = AF_INET;//IPV4 _myaddr.sin_port = htons(8888);//端口 host to net unsigned short _myaddr.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);//网络地址 INADDR_ANY监听所有网卡的端口 if(SOCKET_ERROR == bind(_mysocket,(sockaddr*)&amp;_myaddr,sizeof(sockaddr_in)))//socket (强制转换)sockaddr结构体 结构体大小 &#123; cout&lt;&lt;&quot;绑定不成功&quot;&lt;&lt;endl; &#125; else &#123; //cout&lt;&lt;&quot;绑定成功&quot;&lt;&lt;endl; &#125; //监听网络端口 if(SOCKET_ERROR == listen(_mysocket,5))//套接字 最大多少人连接 &#123; cout&lt;&lt;&quot;监听失败&quot;&lt;&lt;endl; &#125; else &#123; //cout&lt;&lt;&quot;监听成功&quot;&lt;&lt;endl; &#125; while(true) &#123; //select相关 /* WINSOCK_API_LINKAGE int WSAAPI select( int nfds,//是指待监听集合里的范围 即待监听数量最大值+1 fd_set *readfds,//待监听的可读文件集合 fd_set *writefds,//待监听的可写文件集合 fd_set *exceptfds,//待监听的异常文件集合 const PTIMEVAL timeout);//超时设置 传入NULL为阻塞模式 传入timeval结构体为非阻塞模式 typedef struct fd_set//可以存放多个socket &#123; u_int fd_count;//记录放了多少个socket SOCKET fd_array[FD_SETSIZE];//socket数组 &#125; fd_set; struct timeval//时间结构体 &#123; long tv_sec;//秒 long tv_usec;//毫秒 &#125;; */ fd_set _fdRead;//建立集合 fd_set _fdWrite; fd_set _fdExcept; FD_ZERO(&amp;_fdRead);//清空集合 FD_ZERO(&amp;_fdWrite); FD_ZERO(&amp;_fdExcept); FD_SET(_mysocket,&amp;_fdRead);//放入集合 FD_SET(_mysocket,&amp;_fdWrite); FD_SET(_mysocket,&amp;_fdExcept); timeval _t = &#123;1,0&#125;;//select最大响应时间 for(int n=_clients.size()-1; n&gt;=0; --n)//把连接的客户端 放入read集合 &#123; FD_SET(_clients[n],&amp;_fdRead); &#125; //select函数筛选select int _ret = select(_mysocket+1,&amp;_fdRead,&amp;_fdWrite,&amp;_fdExcept,&amp;_t); if(_ret&lt;0) &#123; printf(&quot;select任务结束\\n&quot;); break; &#125; if(FD_ISSET(_mysocket,&amp;_fdRead))//获取是否有新socket连接 &#123; FD_CLR(_mysocket,&amp;_fdRead);//清理 //等待接收客户端连接 sockaddr_in _clientAddr = &#123;&#125;;//新建sockadd结构体接收客户端数据 int _addr_len = sizeof(sockaddr_in);//获取sockadd结构体长度 SOCKET _temp_socket = INVALID_SOCKET;//声明客户端套接字 _temp_socket = accept(_mysocket,(sockaddr*)&amp;_clientAddr,&amp;_addr_len);//自身套接字 客户端结构体 结构体大小 if(INVALID_SOCKET == _temp_socket)//接收失败 &#123; cout&lt;&lt;&quot;接收到无效客户端Socket&quot;&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;&quot;新客户端加入&quot;&lt;&lt;endl; printf(&quot;IP地址为：%s \\n&quot;, inet_ntoa(_clientAddr.sin_addr)); //群发所有客户端 通知新用户登录 NewUserJoin _user_join; strcpy(_user_join.UserName,inet_ntoa(_clientAddr.sin_addr)); for(int n=0;n&lt;_clients.size();n++) &#123; send(_clients[n],(const char*)&amp;_user_join,sizeof(NewUserJoin),0); &#125; //将新的客户端加入动态数组 _clients.push_back(_temp_socket); &#125; &#125; for(int n=0; n&lt;_fdRead.fd_count; ++n)//在read数组里挨个处理 &#123; if(-1 == _handle(_fdRead.fd_array[n]))//处理请求 客户端退出的话 &#123; vector&lt;SOCKET&gt;::iterator iter = find(_clients.begin(),_clients.end(),_fdRead.fd_array[n]); if(iter != _clients.end())//如果找到了的话 就在动态数组里删除掉 &#123; _clients.erase(iter); &#125; &#125; &#125; printf(&quot;空闲时间处理其他业务\\n&quot;); &#125; //关闭客户端socket for(int n=0; n&lt;_clients.size(); ++n) &#123; closesocket(_clients[n]); &#125; //关闭socket closesocket(_mysocket); //清除windows socket 环境 WSACleanup(); printf(&quot;任务结束，程序已退出&quot;); getchar(); return 0;&#125; 2.客户端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223#define WIN32_LEAN_AND_MEAN#include&lt;winSock2.h&gt;#include&lt;windows.h&gt;#include&lt;bits/stdc++.h&gt;#include&lt;thread&gt;#pragma comment(lib,&quot;ws2_32.lib&quot;)//链接此动态链接库 windows特有 using namespace std; //枚举类型记录命令 enum cmd &#123; CMD_LOGIN,//登录 CMD_LOGINRESULT,//登录结果 CMD_LOGOUT,//登出 CMD_LOGOUTRESULT,//登出结果 CMD_NEW_USER_JOIN,//新用户登入 CMD_ERROR//错误 &#125;;//定义数据包头 struct DateHeader &#123; short cmd;//命令 short date_length;//数据的长短 &#125;;//包1 登录 传输账号与密码struct Login : public DateHeader &#123; Login()//初始化包头 &#123; this-&gt;cmd = CMD_LOGIN; this-&gt;date_length = sizeof(Login); &#125; char UserName[32];//用户名 char PassWord[32];//密码 &#125;;//包2 登录结果 传输结果struct LoginResult : public DateHeader &#123; LoginResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGINRESULT; this-&gt;date_length = sizeof(LoginResult); &#125; int Result;&#125;;//包3 登出 传输用户名 struct Logout : public DateHeader &#123; Logout()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUT; this-&gt;date_length = sizeof(Logout); &#125; char UserName[32];//用户名 &#125;;//包4 登出结果 传输结果struct LogoutResult : public DateHeader &#123; LogoutResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUTRESULT; this-&gt;date_length = sizeof(LogoutResult); &#125; int Result;&#125;;//包5 新用户登入 传输通告 struct NewUserJoin : public DateHeader &#123; NewUserJoin()//初始化包头 &#123; this-&gt;cmd = CMD_NEW_USER_JOIN; this-&gt;date_length = sizeof(NewUserJoin); &#125; char UserName[32];//用户名 &#125;; int _handle(SOCKET _temp_socket)//处理数据 &#123; //接收客户端发送的数据 DateHeader _head = &#123;&#125;; int _buf_len = recv(_temp_socket,(char*)&amp;_head,sizeof(DateHeader),0); if(_buf_len&lt;=0) &#123; printf(&quot;与服务器断开连接,任务结束\\n&quot;); return -1; &#125; printf(&quot;接收到包头，命令：%d，数据长度：%d\\n&quot;,_head.cmd,_head.date_length); switch(_head.cmd) &#123; case CMD_LOGINRESULT://登录结果 接收登录包体 &#123; LoginResult _result; recv(_temp_socket,(char*)&amp;_result+sizeof(DateHeader),sizeof(LoginResult)-sizeof(DateHeader),0); printf(&quot;登录结果:%d\\n&quot;,_result.Result); &#125; break; case CMD_LOGOUTRESULT://登出结果 接收登出包体 &#123; LogoutResult _result; recv(_temp_socket,(char*)&amp;_result+sizeof(DateHeader),sizeof(LogoutResult)-sizeof(DateHeader),0); printf(&quot;登录结果:%d\\n&quot;,_result.Result); &#125; break; case CMD_NEW_USER_JOIN://新用户登录通知 &#123; NewUserJoin _result; recv(_temp_socket,(char*)&amp;_result+sizeof(DateHeader),sizeof(NewUserJoin)-sizeof(DateHeader),0); printf(&quot;用户:%s已登录\\n&quot;,_result.UserName); &#125; &#125; return 0; &#125;bool _run = true;//当前程序是否还在运行中 void _cmdThread(SOCKET _mysocket)//命令线程 &#123; while(true) &#123; //输入请求 char _msg[256] = &#123;&#125;; scanf(&quot;%s&quot;,_msg); //处理请求 if(0 == strcmp(_msg,&quot;exit&quot;)) &#123; _run = false; printf(&quot;程序退出\\n&quot;); break; &#125; else if(0 == strcmp(_msg,&quot;login&quot;)) &#123; //发送 Login _login; strcpy(_login.UserName,&quot;河边小咸鱼&quot;); strcpy(_login.PassWord,&quot;123456&quot;); send(_mysocket,(const char*)&amp;_login,sizeof(_login),0); //这里就不用接收了 由select用来检测接收 &#125; else if(0 == strcmp(_msg,&quot;logout&quot;)) &#123; //发送 Logout _logout; strcpy(_logout.UserName,&quot;河边小咸鱼&quot;); send(_mysocket,(const char*)&amp;_logout,sizeof(_logout),0); //这里就不用接收了 由select用来检测接收 &#125; else &#123; printf(&quot;不存在的命令\\n&quot;); &#125; &#125;&#125;int main()&#123; //启动windows socket 2,x环境 windows特有 WORD ver = MAKEWORD(2,2);//WinSock库版本号 WSADATA dat;//网络结构体 储存WSAStartup函数调用后返回的Socket数据 if(0 != WSAStartup(ver,&amp;dat))//正确初始化后返回0 &#123; return 0; &#125; //建立一个socket SOCKET _mysocket = socket(AF_INET,SOCK_STREAM,0);//IPV4 数据流类型 类型可以不用写 if(INVALID_SOCKET == _mysocket)//建立失败 &#123; return 0; &#125; //连接服务器 sockaddr_in _sin = &#123;&#125;;//sockaddr结构体 _sin.sin_family = AF_INET;//IPV4 _sin.sin_port = htons(8888);//想要连接的端口号 _sin.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);//想要连接的IP if(SOCKET_ERROR == connect(_mysocket,(sockaddr*)&amp;_sin,sizeof(sockaddr_in))) &#123; cout&lt;&lt;&quot;连接失败&quot;&lt;&lt;endl; closesocket(_mysocket); &#125; else &#123; cout&lt;&lt;&quot;连接成功&quot;&lt;&lt;endl; &#125; //创建新线程 thread t1(_cmdThread,_mysocket); t1.detach();//线程分离 while(_run) &#123; fd_set _fdRead;//建立集合 FD_ZERO(&amp;_fdRead);//清空集合 FD_SET(_mysocket,&amp;_fdRead);//放入集合 timeval _t = &#123;1,0&#125;;//select最大响应时间 //新建seclect int _ret = select(_mysocket+1,&amp;_fdRead,NULL,NULL,&amp;_t); if(_ret&lt;0) &#123; printf(&quot;seclect任务结束\\n&quot;); break; &#125; if(FD_ISSET(_mysocket,&amp;_fdRead))//获取是否有可读socket &#123; FD_CLR(_mysocket,&amp;_fdRead);//清理计数器 if(-1 == _handle(_mysocket)) &#123; printf(&quot;seclect任务结束\\n&quot;); break; &#125; &#125; &#125; //关闭socket closesocket(_mysocket); //清除windows socket 环境 WSACleanup(); return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"网络编程","slug":"网络编程","permalink":"https://zgg2001.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"C++网络编程学习：网络数据报文的收发","slug":"20210122_C++网络编程学习：网络数据报文的收发","date":"2021-01-22T04:25:43.000Z","updated":"2021-01-22T04:25:43.000Z","comments":true,"path":"2021/01/22/20210122_C++网络编程学习：网络数据报文的收发/","permalink":"https://zgg2001.github.io/2021/01/22/20210122_C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%96%87%E7%9A%84%E6%94%B6%E5%8F%91/","excerpt":"使用的语言为C&#x2F;C++ 源码支持的平台为：Windows 一、网络数据报文的格式定义 报文有两个部分，包头和包体，是网络消息的基本单元。 包头： 描述本次消息包的大小，描述包体数据的作用。 包体： 其中包含了需要传输的数据。","text":"使用的语言为C&#x2F;C++ 源码支持的平台为：Windows 一、网络数据报文的格式定义 报文有两个部分，包头和包体，是网络消息的基本单元。 包头： 描述本次消息包的大小，描述包体数据的作用。 包体： 其中包含了需要传输的数据。 &emsp;&emsp;根据此数据结构，我们可以根据包头的内容，来灵活的对包体的数据进行处理。 二、将包头与包体数据分开收发1.概括&emsp;&emsp;通过上文对网络数据报文的定义，我们可以很轻易的想到： 发送端进行两次send操作，第一次send发送包头，第二次send发送包体，即可实现网络数据报文的发送。 接收端进行两次recv操作，第一次recv接收包头，第二次recv接收包体并根据包头的内容进行数据处理，即可实现网络数据报文的接收。 &emsp;&emsp;按以上操作，即可实现网络数据报文的收发。 2.代码及其详细注释2.1 服务端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166#define WIN32_LEAN_AND_MEAN#include&lt;winSock2.h&gt;#include&lt;windows.h&gt;#include&lt;bits/stdc++.h&gt;#pragma comment(lib,&quot;ws2_32.lib&quot;)//链接此动态链接库 windows特有 using namespace std; //枚举类型记录命令 enum cmd &#123; CMD_LOGIN,//登录 CMD_LOGOUT,//登出 CMD_ERROR//错误 &#125;;//定义数据包头 struct DateHeader &#123; short cmd;//命令 short date_length;//数据的长短 &#125;;//包体1 登录 传输账号与密码struct Login&#123; char UserName[32];//用户名 char PassWord[32];//密码 &#125;;//包体2 登录结果 传输结果struct LoginResult &#123; int Result;&#125;;//包体3 登出 传输用户名 struct Logout&#123; char UserName[32];//用户名 &#125;;//包体4 登出结果 传输结果struct LogoutResult &#123; int Result;&#125;; int main() &#123; //启动windows socket 2,x环境 windows特有 WORD ver = MAKEWORD(2,2);//WinSock库版本号 WSADATA dat;//网络结构体 储存WSAStartup函数调用后返回的Socket数据 if(0 != WSAStartup(ver,&amp;dat))//正确初始化后返回0 &#123; return 0; &#125; //建立一个socket SOCKET _mysocket = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);//IPV4 数据流类型 TCP类型 if(INVALID_SOCKET == _mysocket)//建立失败 &#123; return 0; &#125; //绑定网络端口和IP地址 sockaddr_in _myaddr = &#123;&#125;;//建立sockaddr结构体 sockaddr_in结构体方便填写 但是下面要进行类型转换 _myaddr.sin_family = AF_INET;//IPV4 _myaddr.sin_port = htons(8888);//端口 host to net unsigned short _myaddr.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);//网络地址 INADDR_ANY监听所有网卡的端口 if(SOCKET_ERROR == bind(_mysocket,(sockaddr*)&amp;_myaddr,sizeof(sockaddr_in)))//socket (强制转换)sockaddr结构体 结构体大小 &#123; cout&lt;&lt;&quot;绑定不成功&quot;&lt;&lt;endl; &#125; else &#123; //cout&lt;&lt;&quot;绑定成功&quot;&lt;&lt;endl; &#125; //监听网络端口 if(SOCKET_ERROR == listen(_mysocket,5))//套接字 最大多少人连接 &#123; cout&lt;&lt;&quot;监听失败&quot;&lt;&lt;endl; &#125; else &#123; //cout&lt;&lt;&quot;监听成功&quot;&lt;&lt;endl; &#125; //等待接收客户端连接 sockaddr_in _clientAddr = &#123;&#125;;//新建sockadd结构体接收客户端数据 int _addr_len = sizeof(sockaddr_in);//获取sockadd结构体长度 SOCKET _temp_socket = INVALID_SOCKET;//声明客户端套接字 _temp_socket = accept(_mysocket,(sockaddr*)&amp;_clientAddr,&amp;_addr_len);//自身套接字 客户端结构体 结构体大小 if(INVALID_SOCKET == _temp_socket)//接收失败 &#123; cout&lt;&lt;&quot;接收到无效客户端Socket&quot;&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;&quot;新客户端加入&quot;&lt;&lt;endl; printf(&quot;IP地址为：%s \\n&quot;, inet_ntoa(_clientAddr.sin_addr)); &#125; while(true) &#123; //接收客户端发送的数据 DateHeader _head = &#123;&#125;; int _buf_len = recv(_temp_socket,(char*)&amp;_head,sizeof(DateHeader),0); if(_buf_len&lt;=0) &#123; printf(&quot;客户端已退出\\n&quot;); break; &#125; printf(&quot;接收到包头，命令：%d，数据长度：%d\\n&quot;,_head.cmd,_head.date_length); switch(_head.cmd) &#123; case CMD_LOGIN://登录 接收登录包体 &#123; Login _login = &#123;&#125;; recv(_temp_socket,(char*)&amp;_login,sizeof(Login),0); /* 进行判断操作 */ printf(&quot;%s已登录\\n&quot;,_login.UserName); send(_temp_socket,(char*)&amp;_head,sizeof(DateHeader),0);//发包头 LoginResult _result = &#123;1&#125;; send(_temp_socket,(char*)&amp;_result,sizeof(LoginResult),0);//发包体 &#125; break; case CMD_LOGOUT://登出 接收登出包体 &#123; Logout _logout = &#123;&#125;; recv(_temp_socket,(char*)&amp;_logout,sizeof(Logout),0); /* 进行判断操作 */ printf(&quot;%s已登出\\n&quot;,_logout.UserName); send(_temp_socket,(char*)&amp;_head,sizeof(DateHeader),0);//发包头 LogoutResult _result = &#123;1&#125;; send(_temp_socket,(char*)&amp;_result,sizeof(LogoutResult),0);//发包体 &#125; break; default://错误 &#123; _head.cmd = CMD_ERROR; _head.date_length = 0; send(_temp_socket,(char*)&amp;_head,sizeof(DateHeader),0);//发包头 &#125; break; &#125; &#125; //关闭客户端socket closesocket(_temp_socket); //关闭socket closesocket(_mysocket); //清除windows socket 环境 WSACleanup(); printf(&quot;任务结束，程序已退出&quot;); getchar(); return 0;&#125; 2.2 客户端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#define WIN32_LEAN_AND_MEAN#include&lt;winSock2.h&gt;#include&lt;windows.h&gt;#include&lt;bits/stdc++.h&gt;#pragma comment(lib,&quot;ws2_32.lib&quot;)//链接此动态链接库 windows特有 using namespace std; //枚举类型记录命令 enum cmd &#123; CMD_LOGIN,//登录 CMD_LOGOUT,//登出 CMD_ERROR//错误 &#125;;//定义数据包头 struct DateHeader &#123; short cmd;//命令 short date_length;//数据的长短 &#125;;//包体1 登录 传输账号与密码struct Login&#123; char UserName[32];//用户名 char PassWord[32];//密码 &#125;;//包体2 登录结果 传输结果struct LoginResult &#123; int Result;&#125;;//包体3 登出 传输用户名 struct Logout&#123; char UserName[32];//用户名 &#125;;//包体4 登出结果 传输结果struct LogoutResult &#123; int Result;&#125;; int main()&#123; //启动windows socket 2,x环境 windows特有 WORD ver = MAKEWORD(2,2);//WinSock库版本号 WSADATA dat;//网络结构体 储存WSAStartup函数调用后返回的Socket数据 if(0 != WSAStartup(ver,&amp;dat))//正确初始化后返回0 &#123; return 0; &#125; //建立一个socket SOCKET _mysocket = socket(AF_INET,SOCK_STREAM,0);//IPV4 数据流类型 类型可以不用写 if(INVALID_SOCKET == _mysocket)//建立失败 &#123; return 0; &#125; //连接服务器 sockaddr_in _sin = &#123;&#125;;//sockaddr结构体 _sin.sin_family = AF_INET;//IPV4 _sin.sin_port = htons(8888);//想要连接的端口号 _sin.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);//想要连接的IP if(SOCKET_ERROR == connect(_mysocket,(sockaddr*)&amp;_sin,sizeof(sockaddr_in))) &#123; cout&lt;&lt;&quot;连接失败&quot;&lt;&lt;endl; closesocket(_mysocket); &#125; else &#123; cout&lt;&lt;&quot;连接成功&quot;&lt;&lt;endl; &#125; while(true) &#123; //输入请求 char _msg[256] = &#123;&#125;; scanf(&quot;%s&quot;,_msg); //处理请求 if(0 == strcmp(_msg,&quot;exit&quot;)) &#123; break; &#125; else if(0 == strcmp(_msg,&quot;login&quot;)) &#123; //发送 Login _login = &#123;&quot;河边小咸鱼&quot;,&quot;123456&quot;&#125;; DateHeader _head = &#123;CMD_LOGIN,sizeof(_login)&#125;; send(_mysocket,(const char*)&amp;_head,sizeof(_head),0); send(_mysocket,(const char*)&amp;_login,sizeof(_login),0); //接收 DateHeader _head2 = &#123;&#125;; LoginResult _result= &#123;&#125;; recv(_mysocket,(char*)&amp;_head2,sizeof(DateHeader),0); recv(_mysocket,(char*)&amp;_result,sizeof(LoginResult),0); printf(&quot;result:%d\\n&quot;,_result.Result); &#125; else if(0 == strcmp(_msg,&quot;logout&quot;)) &#123; //发送 Logout _logout = &#123;&quot;河边小咸鱼&quot;&#125;; DateHeader _head = &#123;CMD_LOGOUT,sizeof(_logout)&#125;; send(_mysocket,(const char*)&amp;_head,sizeof(_head),0); send(_mysocket,(const char*)&amp;_logout,sizeof(_logout),0); //接收 DateHeader _head2 = &#123;&#125;; LogoutResult _result= &#123;&#125;; recv(_mysocket,(char*)&amp;_head2,sizeof(DateHeader),0); recv(_mysocket,(char*)&amp;_result,sizeof(LogoutResult),0); printf(&quot;result:%d\\n&quot;,_result.Result); &#125; else &#123; printf(&quot;不存在的命令\\n&quot;); &#125; &#125; //关闭socket closesocket(_mysocket); //清除windows socket 环境 WSACleanup(); return 0;&#125; 三、将分开收发报文数据改为一次收发1.思路&emsp;&emsp;由上文，我们可以知道，可以通过两次send和两次recv进行报文的收发，但是其中操作较为麻烦，需要多次声明DateHeader包头结构体，不仅消耗时间资源，也容易出错。&emsp;&emsp;因此，我们可以尝试将分开收发改为一次收发。大致思路为完善报文的结构体，使包体继承包头结构体，或者使包体结构体中包含一个包头结构体。由此完善报文的结构体，只进行一次send操作，即可发送所有报文数据。&emsp;&emsp;在进行数据接收时，我们先接收包头大小的数据，随后根据包头的内容，来确定接下来接收数据的大小，即接收 总数据大小 减去 包头数据大小 的数据。而在接下来使用recv接收剩下数据时，要使用指针偏移，跳过结构体包头的接收(因为接收过了)，直接接收到包体数据位置上。 12345/*因为包头已经接收过了 所以进行指针偏移：&amp;_login+sizeof(DateHeader)接收数据长短为：sizeof(Login)-sizeof(DateHeader) 减去包头的大小*/recv(_temp_socket,(char*)&amp;_login+sizeof(DateHeader),sizeof(Login)-sizeof(DateHeader),0); 2.代码及其详细注释2.1 服务端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#define WIN32_LEAN_AND_MEAN#include&lt;winSock2.h&gt;#include&lt;windows.h&gt;#include&lt;bits/stdc++.h&gt;#pragma comment(lib,&quot;ws2_32.lib&quot;)//链接此动态链接库 windows特有 using namespace std; //枚举类型记录命令 enum cmd &#123; CMD_LOGIN,//登录 CMD_LOGINRESULT,//登录结果 CMD_LOGOUT,//登出 CMD_LOGOUTRESULT,//登出结果 CMD_ERROR//错误 &#125;;//定义数据包头 struct DateHeader &#123; short cmd;//命令 short date_length;//数据的长短 &#125;;//包1 登录 传输账号与密码struct Login : public DateHeader &#123; Login()//初始化包头 &#123; this-&gt;cmd = CMD_LOGIN; this-&gt;date_length = sizeof(Login); &#125; char UserName[32];//用户名 char PassWord[32];//密码 &#125;;//包2 登录结果 传输结果struct LoginResult : public DateHeader &#123; LoginResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGINRESULT; this-&gt;date_length = sizeof(LoginResult); &#125; int Result;&#125;;//包3 登出 传输用户名 struct Logout : public DateHeader &#123; Logout()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUT; this-&gt;date_length = sizeof(Logout); &#125; char UserName[32];//用户名 &#125;;//包4 登出结果 传输结果struct LogoutResult : public DateHeader &#123; LogoutResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUTRESULT; this-&gt;date_length = sizeof(LogoutResult); &#125; int Result;&#125;; int main() &#123; //启动windows socket 2,x环境 windows特有 WORD ver = MAKEWORD(2,2);//WinSock库版本号 WSADATA dat;//网络结构体 储存WSAStartup函数调用后返回的Socket数据 if(0 != WSAStartup(ver,&amp;dat))//正确初始化后返回0 &#123; return 0; &#125; //建立一个socket SOCKET _mysocket = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);//IPV4 数据流类型 TCP类型 if(INVALID_SOCKET == _mysocket)//建立失败 &#123; return 0; &#125; //绑定网络端口和IP地址 sockaddr_in _myaddr = &#123;&#125;;//建立sockaddr结构体 sockaddr_in结构体方便填写 但是下面要进行类型转换 _myaddr.sin_family = AF_INET;//IPV4 _myaddr.sin_port = htons(8888);//端口 host to net unsigned short _myaddr.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);//网络地址 INADDR_ANY监听所有网卡的端口 if(SOCKET_ERROR == bind(_mysocket,(sockaddr*)&amp;_myaddr,sizeof(sockaddr_in)))//socket (强制转换)sockaddr结构体 结构体大小 &#123; cout&lt;&lt;&quot;绑定不成功&quot;&lt;&lt;endl; &#125; else &#123; //cout&lt;&lt;&quot;绑定成功&quot;&lt;&lt;endl; &#125; //监听网络端口 if(SOCKET_ERROR == listen(_mysocket,5))//套接字 最大多少人连接 &#123; cout&lt;&lt;&quot;监听失败&quot;&lt;&lt;endl; &#125; else &#123; //cout&lt;&lt;&quot;监听成功&quot;&lt;&lt;endl; &#125; //等待接收客户端连接 sockaddr_in _clientAddr = &#123;&#125;;//新建sockadd结构体接收客户端数据 int _addr_len = sizeof(sockaddr_in);//获取sockadd结构体长度 SOCKET _temp_socket = INVALID_SOCKET;//声明客户端套接字 _temp_socket = accept(_mysocket,(sockaddr*)&amp;_clientAddr,&amp;_addr_len);//自身套接字 客户端结构体 结构体大小 if(INVALID_SOCKET == _temp_socket)//接收失败 &#123; cout&lt;&lt;&quot;接收到无效客户端Socket&quot;&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;&quot;新客户端加入&quot;&lt;&lt;endl; printf(&quot;IP地址为：%s \\n&quot;, inet_ntoa(_clientAddr.sin_addr)); &#125; while(true) &#123; //接收客户端发送的数据 DateHeader _head = &#123;&#125;; int _buf_len = recv(_temp_socket,(char*)&amp;_head,sizeof(DateHeader),0); if(_buf_len&lt;=0) &#123; printf(&quot;客户端已退出\\n&quot;); break; &#125; printf(&quot;接收到包头，命令：%d，数据长度：%d\\n&quot;,_head.cmd,_head.date_length); switch(_head.cmd) &#123; case CMD_LOGIN://登录 接收登录包体 &#123; Login _login; recv(_temp_socket,(char*)&amp;_login+sizeof(DateHeader),sizeof(Login)-sizeof(DateHeader),0); /* 进行判断操作 */ printf(&quot;%s已登录\\n密码：%s\\n&quot;,_login.UserName,_login.PassWord); LoginResult _result; _result.Result = 1; send(_temp_socket,(char*)&amp;_result,sizeof(LoginResult),0);//发包体 &#125; break; case CMD_LOGOUT://登出 接收登出包体 &#123; Logout _logout; recv(_temp_socket,(char*)&amp;_logout+sizeof(DateHeader),sizeof(Logout)-sizeof(DateHeader),0); /* 进行判断操作 */ printf(&quot;%s已登出\\n&quot;,_logout.UserName); LogoutResult _result; _result.Result = 1; send(_temp_socket,(char*)&amp;_result,sizeof(LogoutResult),0);//发包体 &#125; break; default://错误 &#123; _head.cmd = CMD_ERROR; _head.date_length = 0; send(_temp_socket,(char*)&amp;_head,sizeof(DateHeader),0);//发包头 &#125; break; &#125; &#125; //关闭客户端socket closesocket(_temp_socket); //关闭socket closesocket(_mysocket); //清除windows socket 环境 WSACleanup(); printf(&quot;任务结束，程序已退出&quot;); getchar(); return 0;&#125; 2.2 客户端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#define WIN32_LEAN_AND_MEAN#include&lt;winSock2.h&gt;#include&lt;windows.h&gt;#include&lt;bits/stdc++.h&gt;#pragma comment(lib,&quot;ws2_32.lib&quot;)//链接此动态链接库 windows特有 using namespace std; //枚举类型记录命令 enum cmd &#123; CMD_LOGIN,//登录 CMD_LOGINRESULT,//登录结果 CMD_LOGOUT,//登出 CMD_LOGOUTRESULT,//登出结果 CMD_ERROR//错误 &#125;;//定义数据包头 struct DateHeader &#123; short cmd;//命令 short date_length;//数据的长短 &#125;;//包1 登录 传输账号与密码struct Login : public DateHeader &#123; Login()//初始化包头 &#123; this-&gt;cmd = CMD_LOGIN; this-&gt;date_length = sizeof(Login); &#125; char UserName[32];//用户名 char PassWord[32];//密码 &#125;;//包2 登录结果 传输结果struct LoginResult : public DateHeader &#123; LoginResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGINRESULT; this-&gt;date_length = sizeof(LoginResult); &#125; int Result;&#125;;//包3 登出 传输用户名 struct Logout : public DateHeader &#123; Logout()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUT; this-&gt;date_length = sizeof(Logout); &#125; char UserName[32];//用户名 &#125;;//包4 登出结果 传输结果struct LogoutResult : public DateHeader &#123; LogoutResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUTRESULT; this-&gt;date_length = sizeof(LogoutResult); &#125; int Result;&#125;; int main()&#123; //启动windows socket 2,x环境 windows特有 WORD ver = MAKEWORD(2,2);//WinSock库版本号 WSADATA dat;//网络结构体 储存WSAStartup函数调用后返回的Socket数据 if(0 != WSAStartup(ver,&amp;dat))//正确初始化后返回0 &#123; return 0; &#125; //建立一个socket SOCKET _mysocket = socket(AF_INET,SOCK_STREAM,0);//IPV4 数据流类型 类型可以不用写 if(INVALID_SOCKET == _mysocket)//建立失败 &#123; return 0; &#125; //连接服务器 sockaddr_in _sin = &#123;&#125;;//sockaddr结构体 _sin.sin_family = AF_INET;//IPV4 _sin.sin_port = htons(8888);//想要连接的端口号 _sin.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);//想要连接的IP if(SOCKET_ERROR == connect(_mysocket,(sockaddr*)&amp;_sin,sizeof(sockaddr_in))) &#123; cout&lt;&lt;&quot;连接失败&quot;&lt;&lt;endl; closesocket(_mysocket); &#125; else &#123; cout&lt;&lt;&quot;连接成功&quot;&lt;&lt;endl; &#125; while(true) &#123; //输入请求 char _msg[256] = &#123;&#125;; scanf(&quot;%s&quot;,_msg); //处理请求 if(0 == strcmp(_msg,&quot;exit&quot;)) &#123; break; &#125; else if(0 == strcmp(_msg,&quot;login&quot;)) &#123; //发送 Login _login; strcpy(_login.UserName,&quot;河边小咸鱼&quot;); strcpy(_login.PassWord,&quot;123456&quot;); send(_mysocket,(const char*)&amp;_login,sizeof(_login),0); //接收 LoginResult _result; recv(_mysocket,(char*)&amp;_result,sizeof(LoginResult),0); printf(&quot;result:%d\\n&quot;,_result.Result); &#125; else if(0 == strcmp(_msg,&quot;logout&quot;)) &#123; //发送 Logout _logout; strcpy(_logout.UserName,&quot;河边小咸鱼&quot;); send(_mysocket,(const char*)&amp;_logout,sizeof(_logout),0); //接收 LogoutResult _result; recv(_mysocket,(char*)&amp;_result,sizeof(LogoutResult),0); printf(&quot;result:%d\\n&quot;,_result.Result); &#125; else &#123; printf(&quot;不存在的命令\\n&quot;); &#125; &#125; //关闭socket closesocket(_mysocket); //清除windows socket 环境 WSACleanup(); return 0;&#125; 网络编程学习记录 使用的语言为C&#x2F;C++ 源码支持的平台为：Windows 笔记一：建立基础TCP服务端&#x2F;客户端 &emsp;点我跳转笔记二：网络数据报文的收发 &emsp;点我跳转笔记三：升级为select网络模型 &emsp;点我跳转笔记四：跨平台支持Windows、Linux系统 &emsp;点我跳转笔记五：源码的封装 &emsp;点我跳转笔记六：缓冲区溢出与粘包分包 &emsp;点我跳转笔记七：服务端多线程分离业务处理高负载 &emsp;点我跳转笔记八：对socket select网络模型的优化 &emsp;点我跳转笔记九：消息接收与发送分离 &emsp;点我跳转笔记十：项目化 (加入内存池静态库 &#x2F; 报文动态库) &emsp;更多笔记请点我 @TOC 一、网络数据报文的格式定义 报文有两个部分，包头和包体，是网络消息的基本单元。 包头： 描述本次消息包的大小，描述包体数据的作用。 包体： 其中包含了需要传输的数据。 &emsp;&emsp;根据此数据结构，我们可以根据包头的内容，来灵活的对包体的数据进行处理。 二、将包头与包体数据分开收发1.概括&emsp;&emsp;通过上文对网络数据报文的定义，我们可以很轻易的想到： 发送端进行两次send操作，第一次send发送包头，第二次send发送包体，即可实现网络数据报文的发送。 接收端进行两次recv操作，第一次recv接收包头，第二次recv接收包体并根据包头的内容进行数据处理，即可实现网络数据报文的接收。 &emsp;&emsp;按以上操作，即可实现网络数据报文的收发。 2.代码及其详细注释2.1 服务端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166#define WIN32_LEAN_AND_MEAN#include&lt;winSock2.h&gt;#include&lt;windows.h&gt;#include&lt;bits/stdc++.h&gt;#pragma comment(lib,&quot;ws2_32.lib&quot;)//链接此动态链接库 windows特有 using namespace std; //枚举类型记录命令 enum cmd &#123; CMD_LOGIN,//登录 CMD_LOGOUT,//登出 CMD_ERROR//错误 &#125;;//定义数据包头 struct DateHeader &#123; short cmd;//命令 short date_length;//数据的长短 &#125;;//包体1 登录 传输账号与密码struct Login&#123; char UserName[32];//用户名 char PassWord[32];//密码 &#125;;//包体2 登录结果 传输结果struct LoginResult &#123; int Result;&#125;;//包体3 登出 传输用户名 struct Logout&#123; char UserName[32];//用户名 &#125;;//包体4 登出结果 传输结果struct LogoutResult &#123; int Result;&#125;; int main() &#123; //启动windows socket 2,x环境 windows特有 WORD ver = MAKEWORD(2,2);//WinSock库版本号 WSADATA dat;//网络结构体 储存WSAStartup函数调用后返回的Socket数据 if(0 != WSAStartup(ver,&amp;dat))//正确初始化后返回0 &#123; return 0; &#125; //建立一个socket SOCKET _mysocket = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);//IPV4 数据流类型 TCP类型 if(INVALID_SOCKET == _mysocket)//建立失败 &#123; return 0; &#125; //绑定网络端口和IP地址 sockaddr_in _myaddr = &#123;&#125;;//建立sockaddr结构体 sockaddr_in结构体方便填写 但是下面要进行类型转换 _myaddr.sin_family = AF_INET;//IPV4 _myaddr.sin_port = htons(8888);//端口 host to net unsigned short _myaddr.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);//网络地址 INADDR_ANY监听所有网卡的端口 if(SOCKET_ERROR == bind(_mysocket,(sockaddr*)&amp;_myaddr,sizeof(sockaddr_in)))//socket (强制转换)sockaddr结构体 结构体大小 &#123; cout&lt;&lt;&quot;绑定不成功&quot;&lt;&lt;endl; &#125; else &#123; //cout&lt;&lt;&quot;绑定成功&quot;&lt;&lt;endl; &#125; //监听网络端口 if(SOCKET_ERROR == listen(_mysocket,5))//套接字 最大多少人连接 &#123; cout&lt;&lt;&quot;监听失败&quot;&lt;&lt;endl; &#125; else &#123; //cout&lt;&lt;&quot;监听成功&quot;&lt;&lt;endl; &#125; //等待接收客户端连接 sockaddr_in _clientAddr = &#123;&#125;;//新建sockadd结构体接收客户端数据 int _addr_len = sizeof(sockaddr_in);//获取sockadd结构体长度 SOCKET _temp_socket = INVALID_SOCKET;//声明客户端套接字 _temp_socket = accept(_mysocket,(sockaddr*)&amp;_clientAddr,&amp;_addr_len);//自身套接字 客户端结构体 结构体大小 if(INVALID_SOCKET == _temp_socket)//接收失败 &#123; cout&lt;&lt;&quot;接收到无效客户端Socket&quot;&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;&quot;新客户端加入&quot;&lt;&lt;endl; printf(&quot;IP地址为：%s \\n&quot;, inet_ntoa(_clientAddr.sin_addr)); &#125; while(true) &#123; //接收客户端发送的数据 DateHeader _head = &#123;&#125;; int _buf_len = recv(_temp_socket,(char*)&amp;_head,sizeof(DateHeader),0); if(_buf_len&lt;=0) &#123; printf(&quot;客户端已退出\\n&quot;); break; &#125; printf(&quot;接收到包头，命令：%d，数据长度：%d\\n&quot;,_head.cmd,_head.date_length); switch(_head.cmd) &#123; case CMD_LOGIN://登录 接收登录包体 &#123; Login _login = &#123;&#125;; recv(_temp_socket,(char*)&amp;_login,sizeof(Login),0); /* 进行判断操作 */ printf(&quot;%s已登录\\n&quot;,_login.UserName); send(_temp_socket,(char*)&amp;_head,sizeof(DateHeader),0);//发包头 LoginResult _result = &#123;1&#125;; send(_temp_socket,(char*)&amp;_result,sizeof(LoginResult),0);//发包体 &#125; break; case CMD_LOGOUT://登出 接收登出包体 &#123; Logout _logout = &#123;&#125;; recv(_temp_socket,(char*)&amp;_logout,sizeof(Logout),0); /* 进行判断操作 */ printf(&quot;%s已登出\\n&quot;,_logout.UserName); send(_temp_socket,(char*)&amp;_head,sizeof(DateHeader),0);//发包头 LogoutResult _result = &#123;1&#125;; send(_temp_socket,(char*)&amp;_result,sizeof(LogoutResult),0);//发包体 &#125; break; default://错误 &#123; _head.cmd = CMD_ERROR; _head.date_length = 0; send(_temp_socket,(char*)&amp;_head,sizeof(DateHeader),0);//发包头 &#125; break; &#125; &#125; //关闭客户端socket closesocket(_temp_socket); //关闭socket closesocket(_mysocket); //清除windows socket 环境 WSACleanup(); printf(&quot;任务结束，程序已退出&quot;); getchar(); return 0;&#125; 2.2 客户端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#define WIN32_LEAN_AND_MEAN#include&lt;winSock2.h&gt;#include&lt;windows.h&gt;#include&lt;bits/stdc++.h&gt;#pragma comment(lib,&quot;ws2_32.lib&quot;)//链接此动态链接库 windows特有 using namespace std; //枚举类型记录命令 enum cmd &#123; CMD_LOGIN,//登录 CMD_LOGOUT,//登出 CMD_ERROR//错误 &#125;;//定义数据包头 struct DateHeader &#123; short cmd;//命令 short date_length;//数据的长短 &#125;;//包体1 登录 传输账号与密码struct Login&#123; char UserName[32];//用户名 char PassWord[32];//密码 &#125;;//包体2 登录结果 传输结果struct LoginResult &#123; int Result;&#125;;//包体3 登出 传输用户名 struct Logout&#123; char UserName[32];//用户名 &#125;;//包体4 登出结果 传输结果struct LogoutResult &#123; int Result;&#125;; int main()&#123; //启动windows socket 2,x环境 windows特有 WORD ver = MAKEWORD(2,2);//WinSock库版本号 WSADATA dat;//网络结构体 储存WSAStartup函数调用后返回的Socket数据 if(0 != WSAStartup(ver,&amp;dat))//正确初始化后返回0 &#123; return 0; &#125; //建立一个socket SOCKET _mysocket = socket(AF_INET,SOCK_STREAM,0);//IPV4 数据流类型 类型可以不用写 if(INVALID_SOCKET == _mysocket)//建立失败 &#123; return 0; &#125; //连接服务器 sockaddr_in _sin = &#123;&#125;;//sockaddr结构体 _sin.sin_family = AF_INET;//IPV4 _sin.sin_port = htons(8888);//想要连接的端口号 _sin.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);//想要连接的IP if(SOCKET_ERROR == connect(_mysocket,(sockaddr*)&amp;_sin,sizeof(sockaddr_in))) &#123; cout&lt;&lt;&quot;连接失败&quot;&lt;&lt;endl; closesocket(_mysocket); &#125; else &#123; cout&lt;&lt;&quot;连接成功&quot;&lt;&lt;endl; &#125; while(true) &#123; //输入请求 char _msg[256] = &#123;&#125;; scanf(&quot;%s&quot;,_msg); //处理请求 if(0 == strcmp(_msg,&quot;exit&quot;)) &#123; break; &#125; else if(0 == strcmp(_msg,&quot;login&quot;)) &#123; //发送 Login _login = &#123;&quot;河边小咸鱼&quot;,&quot;123456&quot;&#125;; DateHeader _head = &#123;CMD_LOGIN,sizeof(_login)&#125;; send(_mysocket,(const char*)&amp;_head,sizeof(_head),0); send(_mysocket,(const char*)&amp;_login,sizeof(_login),0); //接收 DateHeader _head2 = &#123;&#125;; LoginResult _result= &#123;&#125;; recv(_mysocket,(char*)&amp;_head2,sizeof(DateHeader),0); recv(_mysocket,(char*)&amp;_result,sizeof(LoginResult),0); printf(&quot;result:%d\\n&quot;,_result.Result); &#125; else if(0 == strcmp(_msg,&quot;logout&quot;)) &#123; //发送 Logout _logout = &#123;&quot;河边小咸鱼&quot;&#125;; DateHeader _head = &#123;CMD_LOGOUT,sizeof(_logout)&#125;; send(_mysocket,(const char*)&amp;_head,sizeof(_head),0); send(_mysocket,(const char*)&amp;_logout,sizeof(_logout),0); //接收 DateHeader _head2 = &#123;&#125;; LogoutResult _result= &#123;&#125;; recv(_mysocket,(char*)&amp;_head2,sizeof(DateHeader),0); recv(_mysocket,(char*)&amp;_result,sizeof(LogoutResult),0); printf(&quot;result:%d\\n&quot;,_result.Result); &#125; else &#123; printf(&quot;不存在的命令\\n&quot;); &#125; &#125; //关闭socket closesocket(_mysocket); //清除windows socket 环境 WSACleanup(); return 0;&#125; 三、将分开收发报文数据改为一次收发1.思路&emsp;&emsp;由上文，我们可以知道，可以通过两次send和两次recv进行报文的收发，但是其中操作较为麻烦，需要多次声明DateHeader包头结构体，不仅消耗时间资源，也容易出错。&emsp;&emsp;因此，我们可以尝试将分开收发改为一次收发。大致思路为完善报文的结构体，使包体继承包头结构体，或者使包体结构体中包含一个包头结构体。由此完善报文的结构体，只进行一次send操作，即可发送所有报文数据。&emsp;&emsp;在进行数据接收时，我们先接收包头大小的数据，随后根据包头的内容，来确定接下来接收数据的大小，即接收 总数据大小 减去 包头数据大小 的数据。而在接下来使用recv接收剩下数据时，要使用指针偏移，跳过结构体包头的接收(因为接收过了)，直接接收到包体数据位置上。 12345/*因为包头已经接收过了 所以进行指针偏移：&amp;_login+sizeof(DateHeader)接收数据长短为：sizeof(Login)-sizeof(DateHeader) 减去包头的大小*/recv(_temp_socket,(char*)&amp;_login+sizeof(DateHeader),sizeof(Login)-sizeof(DateHeader),0); 2.代码及其详细注释2.1 服务端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#define WIN32_LEAN_AND_MEAN#include&lt;winSock2.h&gt;#include&lt;windows.h&gt;#include&lt;bits/stdc++.h&gt;#pragma comment(lib,&quot;ws2_32.lib&quot;)//链接此动态链接库 windows特有 using namespace std; //枚举类型记录命令 enum cmd &#123; CMD_LOGIN,//登录 CMD_LOGINRESULT,//登录结果 CMD_LOGOUT,//登出 CMD_LOGOUTRESULT,//登出结果 CMD_ERROR//错误 &#125;;//定义数据包头 struct DateHeader &#123; short cmd;//命令 short date_length;//数据的长短 &#125;;//包1 登录 传输账号与密码struct Login : public DateHeader &#123; Login()//初始化包头 &#123; this-&gt;cmd = CMD_LOGIN; this-&gt;date_length = sizeof(Login); &#125; char UserName[32];//用户名 char PassWord[32];//密码 &#125;;//包2 登录结果 传输结果struct LoginResult : public DateHeader &#123; LoginResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGINRESULT; this-&gt;date_length = sizeof(LoginResult); &#125; int Result;&#125;;//包3 登出 传输用户名 struct Logout : public DateHeader &#123; Logout()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUT; this-&gt;date_length = sizeof(Logout); &#125; char UserName[32];//用户名 &#125;;//包4 登出结果 传输结果struct LogoutResult : public DateHeader &#123; LogoutResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUTRESULT; this-&gt;date_length = sizeof(LogoutResult); &#125; int Result;&#125;; int main() &#123; //启动windows socket 2,x环境 windows特有 WORD ver = MAKEWORD(2,2);//WinSock库版本号 WSADATA dat;//网络结构体 储存WSAStartup函数调用后返回的Socket数据 if(0 != WSAStartup(ver,&amp;dat))//正确初始化后返回0 &#123; return 0; &#125; //建立一个socket SOCKET _mysocket = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);//IPV4 数据流类型 TCP类型 if(INVALID_SOCKET == _mysocket)//建立失败 &#123; return 0; &#125; //绑定网络端口和IP地址 sockaddr_in _myaddr = &#123;&#125;;//建立sockaddr结构体 sockaddr_in结构体方便填写 但是下面要进行类型转换 _myaddr.sin_family = AF_INET;//IPV4 _myaddr.sin_port = htons(8888);//端口 host to net unsigned short _myaddr.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);//网络地址 INADDR_ANY监听所有网卡的端口 if(SOCKET_ERROR == bind(_mysocket,(sockaddr*)&amp;_myaddr,sizeof(sockaddr_in)))//socket (强制转换)sockaddr结构体 结构体大小 &#123; cout&lt;&lt;&quot;绑定不成功&quot;&lt;&lt;endl; &#125; else &#123; //cout&lt;&lt;&quot;绑定成功&quot;&lt;&lt;endl; &#125; //监听网络端口 if(SOCKET_ERROR == listen(_mysocket,5))//套接字 最大多少人连接 &#123; cout&lt;&lt;&quot;监听失败&quot;&lt;&lt;endl; &#125; else &#123; //cout&lt;&lt;&quot;监听成功&quot;&lt;&lt;endl; &#125; //等待接收客户端连接 sockaddr_in _clientAddr = &#123;&#125;;//新建sockadd结构体接收客户端数据 int _addr_len = sizeof(sockaddr_in);//获取sockadd结构体长度 SOCKET _temp_socket = INVALID_SOCKET;//声明客户端套接字 _temp_socket = accept(_mysocket,(sockaddr*)&amp;_clientAddr,&amp;_addr_len);//自身套接字 客户端结构体 结构体大小 if(INVALID_SOCKET == _temp_socket)//接收失败 &#123; cout&lt;&lt;&quot;接收到无效客户端Socket&quot;&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;&quot;新客户端加入&quot;&lt;&lt;endl; printf(&quot;IP地址为：%s \\n&quot;, inet_ntoa(_clientAddr.sin_addr)); &#125; while(true) &#123; //接收客户端发送的数据 DateHeader _head = &#123;&#125;; int _buf_len = recv(_temp_socket,(char*)&amp;_head,sizeof(DateHeader),0); if(_buf_len&lt;=0) &#123; printf(&quot;客户端已退出\\n&quot;); break; &#125; printf(&quot;接收到包头，命令：%d，数据长度：%d\\n&quot;,_head.cmd,_head.date_length); switch(_head.cmd) &#123; case CMD_LOGIN://登录 接收登录包体 &#123; Login _login; recv(_temp_socket,(char*)&amp;_login+sizeof(DateHeader),sizeof(Login)-sizeof(DateHeader),0); /* 进行判断操作 */ printf(&quot;%s已登录\\n密码：%s\\n&quot;,_login.UserName,_login.PassWord); LoginResult _result; _result.Result = 1; send(_temp_socket,(char*)&amp;_result,sizeof(LoginResult),0);//发包体 &#125; break; case CMD_LOGOUT://登出 接收登出包体 &#123; Logout _logout; recv(_temp_socket,(char*)&amp;_logout+sizeof(DateHeader),sizeof(Logout)-sizeof(DateHeader),0); /* 进行判断操作 */ printf(&quot;%s已登出\\n&quot;,_logout.UserName); LogoutResult _result; _result.Result = 1; send(_temp_socket,(char*)&amp;_result,sizeof(LogoutResult),0);//发包体 &#125; break; default://错误 &#123; _head.cmd = CMD_ERROR; _head.date_length = 0; send(_temp_socket,(char*)&amp;_head,sizeof(DateHeader),0);//发包头 &#125; break; &#125; &#125; //关闭客户端socket closesocket(_temp_socket); //关闭socket closesocket(_mysocket); //清除windows socket 环境 WSACleanup(); printf(&quot;任务结束，程序已退出&quot;); getchar(); return 0;&#125; 2.2 客户端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#define WIN32_LEAN_AND_MEAN#include&lt;winSock2.h&gt;#include&lt;windows.h&gt;#include&lt;bits/stdc++.h&gt;#pragma comment(lib,&quot;ws2_32.lib&quot;)//链接此动态链接库 windows特有 using namespace std; //枚举类型记录命令 enum cmd &#123; CMD_LOGIN,//登录 CMD_LOGINRESULT,//登录结果 CMD_LOGOUT,//登出 CMD_LOGOUTRESULT,//登出结果 CMD_ERROR//错误 &#125;;//定义数据包头 struct DateHeader &#123; short cmd;//命令 short date_length;//数据的长短 &#125;;//包1 登录 传输账号与密码struct Login : public DateHeader &#123; Login()//初始化包头 &#123; this-&gt;cmd = CMD_LOGIN; this-&gt;date_length = sizeof(Login); &#125; char UserName[32];//用户名 char PassWord[32];//密码 &#125;;//包2 登录结果 传输结果struct LoginResult : public DateHeader &#123; LoginResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGINRESULT; this-&gt;date_length = sizeof(LoginResult); &#125; int Result;&#125;;//包3 登出 传输用户名 struct Logout : public DateHeader &#123; Logout()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUT; this-&gt;date_length = sizeof(Logout); &#125; char UserName[32];//用户名 &#125;;//包4 登出结果 传输结果struct LogoutResult : public DateHeader &#123; LogoutResult()//初始化包头 &#123; this-&gt;cmd = CMD_LOGOUTRESULT; this-&gt;date_length = sizeof(LogoutResult); &#125; int Result;&#125;; int main()&#123; //启动windows socket 2,x环境 windows特有 WORD ver = MAKEWORD(2,2);//WinSock库版本号 WSADATA dat;//网络结构体 储存WSAStartup函数调用后返回的Socket数据 if(0 != WSAStartup(ver,&amp;dat))//正确初始化后返回0 &#123; return 0; &#125; //建立一个socket SOCKET _mysocket = socket(AF_INET,SOCK_STREAM,0);//IPV4 数据流类型 类型可以不用写 if(INVALID_SOCKET == _mysocket)//建立失败 &#123; return 0; &#125; //连接服务器 sockaddr_in _sin = &#123;&#125;;//sockaddr结构体 _sin.sin_family = AF_INET;//IPV4 _sin.sin_port = htons(8888);//想要连接的端口号 _sin.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);//想要连接的IP if(SOCKET_ERROR == connect(_mysocket,(sockaddr*)&amp;_sin,sizeof(sockaddr_in))) &#123; cout&lt;&lt;&quot;连接失败&quot;&lt;&lt;endl; closesocket(_mysocket); &#125; else &#123; cout&lt;&lt;&quot;连接成功&quot;&lt;&lt;endl; &#125; while(true) &#123; //输入请求 char _msg[256] = &#123;&#125;; scanf(&quot;%s&quot;,_msg); //处理请求 if(0 == strcmp(_msg,&quot;exit&quot;)) &#123; break; &#125; else if(0 == strcmp(_msg,&quot;login&quot;)) &#123; //发送 Login _login; strcpy(_login.UserName,&quot;河边小咸鱼&quot;); strcpy(_login.PassWord,&quot;123456&quot;); send(_mysocket,(const char*)&amp;_login,sizeof(_login),0); //接收 LoginResult _result; recv(_mysocket,(char*)&amp;_result,sizeof(LoginResult),0); printf(&quot;result:%d\\n&quot;,_result.Result); &#125; else if(0 == strcmp(_msg,&quot;logout&quot;)) &#123; //发送 Logout _logout; strcpy(_logout.UserName,&quot;河边小咸鱼&quot;); send(_mysocket,(const char*)&amp;_logout,sizeof(_logout),0); //接收 LogoutResult _result; recv(_mysocket,(char*)&amp;_result,sizeof(LogoutResult),0); printf(&quot;result:%d\\n&quot;,_result.Result); &#125; else &#123; printf(&quot;不存在的命令\\n&quot;); &#125; &#125; //关闭socket closesocket(_mysocket); //清除windows socket 环境 WSACleanup(); return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"网络编程","slug":"网络编程","permalink":"https://zgg2001.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"C++网络编程学习：建立基础TCP服务端/客户端","slug":"20210121_C++网络编程学习：建立基础TCP服务端-客户端","date":"2021-01-21T09:49:20.000Z","updated":"2021-01-21T09:49:20.000Z","comments":true,"path":"2021/01/21/20210121_C++网络编程学习：建立基础TCP服务端-客户端/","permalink":"https://zgg2001.github.io/2021/01/21/20210121_C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%BB%BA%E7%AB%8B%E5%9F%BA%E7%A1%80TCP%E6%9C%8D%E5%8A%A1%E7%AB%AF-%E5%AE%A2%E6%88%B7%E7%AB%AF/","excerpt":"使用的语言为C&#x2F;C++ 源码支持的平台为：Windows 一、建立简易TCP服务端1.建立服务端大致流程 建立一个套接字 （socket） 绑定客户端连接的端口 （bind） 监听网络端口 （listen） 等待接受客户端连接 （accept） 接收客户端发送的数据 （recv） 向客户端发送数据 （send） 关闭套接字 （closesocket）","text":"使用的语言为C&#x2F;C++ 源码支持的平台为：Windows 一、建立简易TCP服务端1.建立服务端大致流程 建立一个套接字 （socket） 绑定客户端连接的端口 （bind） 监听网络端口 （listen） 等待接受客户端连接 （accept） 接收客户端发送的数据 （recv） 向客户端发送数据 （send） 关闭套接字 （closesocket） 2.代码实现以及详细注释123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#define WIN32_LEAN_AND_MEAN//消除下面两个头文件存在的冲突#include&lt;winSock2.h&gt;//此头文件应在windows.h头文件的上面，否则会有冲突#include&lt;windows.h&gt;#include&lt;bits/stdc++.h&gt;#pragma comment(lib,&quot;ws2_32.lib&quot;)//链接此动态链接库 windows特有 using namespace std; int main() &#123; //启动windows socket 2,x环境 windows特有 WORD ver = MAKEWORD(2,2);//WinSock库版本号 WSADATA dat;//网络结构体 储存WSAStartup函数调用后返回的Socket数据 if(0 != WSAStartup(ver,&amp;dat))//正确初始化后返回0 &#123; return 0; &#125; //建立一个socket SOCKET _mysocket = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);//IPV4 数据流类型 TCP类型 if(INVALID_SOCKET == _mysocket)//建立失败 &#123; return 0; &#125; //绑定网络端口和IP地址 sockaddr_in _myaddr = &#123;&#125;;//建立sockaddr结构体 sockaddr_in结构体方便填写 但是下面要进行类型转换 _myaddr.sin_family = AF_INET;//IPV4 _myaddr.sin_port = htons(8888);//端口 host to net unsigned short _myaddr.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);//网络地址 INADDR_ANY监听所有网卡的端口 if(SOCKET_ERROR == bind(_mysocket,(sockaddr*)&amp;_myaddr,sizeof(sockaddr_in)))//socket (强制转换)sockaddr结构体 结构体大小 &#123; cout&lt;&lt;&quot;绑定不成功&quot;&lt;&lt;endl; &#125; else &#123; //cout&lt;&lt;&quot;绑定成功&quot;&lt;&lt;endl; &#125; //监听网络端口 if(SOCKET_ERROR == listen(_mysocket,5))//套接字 最大多少人连接 &#123; cout&lt;&lt;&quot;监听失败&quot;&lt;&lt;endl; &#125; else &#123; //cout&lt;&lt;&quot;监听成功&quot;&lt;&lt;endl; &#125; //等待接收客户端连接 sockaddr_in _clientAddr = &#123;&#125;;//新建sockadd结构体接收客户端数据 int _addr_len = sizeof(sockaddr_in);//获取sockadd结构体长度 SOCKET _temp_socket = INVALID_SOCKET;//声明客户端套接字 char _buf[256] = &#123;&#125;;//接收客户端发送的消息 while(true) &#123; _temp_socket = accept(_mysocket,(sockaddr*)&amp;_clientAddr,&amp;_addr_len);//自身套接字 客户端结构体 结构体大小 if(INVALID_SOCKET == _temp_socket)//接收失败 &#123; cout&lt;&lt;&quot;接收到无效客户端Socket&quot;&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;&quot;新客户端加入&quot;&lt;&lt;endl; printf(&quot;IP地址为：%s \\n&quot;, inet_ntoa(_clientAddr.sin_addr)); &#125; //接收客户端发送的数据 char _buf[256] = &#123;&#125;; int _buf_len = recv(_temp_socket,_buf,256,0); if(_buf_len&gt;0) &#123; printf(&quot;%s\\n&quot;,_buf); &#125; //向客户端发送数据 char _msg[] = &quot;HelloWorld&quot;; send(_temp_socket,_msg,strlen(_msg)+1,0);//客户端套接字 数据 数据长短 flag //关闭客户端socket closesocket(_temp_socket); &#125; //关闭socket closesocket(_mysocket); //清除windows socket 环境 WSACleanup(); return 0;&#125; 二、建立简易TCP客户端1.建立客户端大致流程 建立一个套接字 （socket） 连接服务器 （connect） 向客户端发送数据 （send） 接收客户端发送的数据 （recv） 关闭套接字 （closesocket） 2.代码实现以及详细注释1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#define WIN32_LEAN_AND_MEAN#include&lt;winSock2.h&gt;#include&lt;windows.h&gt;#include&lt;bits/stdc++.h&gt;#pragma comment(lib,&quot;ws2_32.lib&quot;)//链接此动态链接库 windows特有 using namespace std; int main()&#123; //启动windows socket 2,x环境 windows特有 WORD ver = MAKEWORD(2,2);//WinSock库版本号 WSADATA dat;//网络结构体 储存WSAStartup函数调用后返回的Socket数据 if(0 != WSAStartup(ver,&amp;dat))//正确初始化后返回0 &#123; return 0; &#125; //建立一个socket SOCKET _mysocket = socket(AF_INET,SOCK_STREAM,0);//IPV4 数据流类型 类型可以不用写 if(INVALID_SOCKET == _mysocket)//建立失败 &#123; return 0; &#125; //连接服务器 sockaddr_in _sin = &#123;&#125;;//sockaddr结构体 _sin.sin_family = AF_INET;//IPV4 _sin.sin_port = htons(8888);//想要连接的端口号 _sin.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);//想要连接的IP if(SOCKET_ERROR == connect(_mysocket,(sockaddr*)&amp;_sin,sizeof(sockaddr_in))) &#123; cout&lt;&lt;&quot;连接失败&quot;&lt;&lt;endl; closesocket(_mysocket); &#125; else &#123; cout&lt;&lt;&quot;连接成功&quot;&lt;&lt;endl; &#125; //向客户端发送数据 char _msg[] = &quot;HelloServer&quot;; send(_mysocket,_msg,strlen(_msg)+1,0);//客户端套接字 数据 数据长短 flag //接收服务器信息 char _buf[256] = &#123;&#125;; int _buf_len = recv(_mysocket,_buf,256,0); if(_buf_len&gt;0) &#123; printf(&quot;%s\\n&quot;,_buf); &#125; //关闭socket closesocket(_mysocket); //清除windows socket 环境 WSACleanup(); return 0;&#125; 三、建立可持续处理请求的网络程序1.思路&emsp;&emsp;在进行socket连接后，即服务端进行accept操作、客户端进行connect操作后，使用循环，在此循环中进行send&#x2F;recv操作传输数据，即可实现持续处理请求。 2.代码实现以及详细注释2.1 服务端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#define WIN32_LEAN_AND_MEAN#include&lt;winSock2.h&gt;#include&lt;windows.h&gt;#include&lt;bits/stdc++.h&gt;#pragma comment(lib,&quot;ws2_32.lib&quot;)//链接此动态链接库 windows特有 using namespace std; int main() &#123; //启动windows socket 2,x环境 windows特有 WORD ver = MAKEWORD(2,2);//WinSock库版本号 WSADATA dat;//网络结构体 储存WSAStartup函数调用后返回的Socket数据 if(0 != WSAStartup(ver,&amp;dat))//正确初始化后返回0 &#123; return 0; &#125; //建立一个socket SOCKET _mysocket = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);//IPV4 数据流类型 TCP类型 if(INVALID_SOCKET == _mysocket)//建立失败 &#123; return 0; &#125; //绑定网络端口和IP地址 sockaddr_in _myaddr = &#123;&#125;;//建立sockaddr结构体 sockaddr_in结构体方便填写 但是下面要进行类型转换 _myaddr.sin_family = AF_INET;//IPV4 _myaddr.sin_port = htons(8888);//端口 host to net unsigned short _myaddr.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);//网络地址 INADDR_ANY监听所有网卡的端口 if(SOCKET_ERROR == bind(_mysocket,(sockaddr*)&amp;_myaddr,sizeof(sockaddr_in)))//socket (强制转换)sockaddr结构体 结构体大小 &#123; cout&lt;&lt;&quot;绑定不成功&quot;&lt;&lt;endl; &#125; else &#123; //cout&lt;&lt;&quot;绑定成功&quot;&lt;&lt;endl; &#125; //监听网络端口 if(SOCKET_ERROR == listen(_mysocket,5))//套接字 最大多少人连接 &#123; cout&lt;&lt;&quot;监听失败&quot;&lt;&lt;endl; &#125; else &#123; //cout&lt;&lt;&quot;监听成功&quot;&lt;&lt;endl; &#125; //等待接收客户端连接 sockaddr_in _clientAddr = &#123;&#125;;//新建sockadd结构体接收客户端数据 int _addr_len = sizeof(sockaddr_in);//获取sockadd结构体长度 SOCKET _temp_socket = INVALID_SOCKET;//声明客户端套接字 char _buf[256] = &#123;&#125;;//接收客户端发送的消息 _temp_socket = accept(_mysocket,(sockaddr*)&amp;_clientAddr,&amp;_addr_len);//自身套接字 客户端结构体 结构体大小 if(INVALID_SOCKET == _temp_socket)//接收失败 &#123; cout&lt;&lt;&quot;接收到无效客户端Socket&quot;&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;&quot;新客户端加入&quot;&lt;&lt;endl; printf(&quot;IP地址为：%s \\n&quot;, inet_ntoa(_clientAddr.sin_addr)); &#125; while(true)//循环 &#123; //接收客户端发送的数据 int _buf_len = recv(_temp_socket,_buf,256,0); if(_buf_len&lt;=0) &#123; printf(&quot;客户端已退出\\n&quot;); break; &#125; if(0 == strcmp(_buf,&quot;getname&quot;)) &#123; //向客户端发送数据 char _msg[] = &quot;My name is Mr.Zhao&quot;; send(_temp_socket,_msg,strlen(_msg)+1,0);//客户端套接字 数据 数据长短 flag &#125; else if(0 == strcmp(_buf,&quot;getage&quot;)) &#123; //向客户端发送数据 char _msg[] = &quot;My age is 19&quot;; send(_temp_socket,_msg,strlen(_msg)+1,0);//客户端套接字 数据 数据长短 flag &#125; else &#123; //向客户端发送数据 char _msg[] = &quot;???&quot;; send(_temp_socket,_msg,strlen(_msg)+1,0);//客户端套接字 数据 数据长短 flag &#125; &#125; //关闭客户端socket closesocket(_temp_socket); //关闭socket closesocket(_mysocket); //清除windows socket 环境 WSACleanup(); printf(&quot;任务结束，程序已退出&quot;); getchar(); return 0;&#125; 2.2 客户端代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#define WIN32_LEAN_AND_MEAN#include&lt;winSock2.h&gt;#include&lt;windows.h&gt;#include&lt;bits/stdc++.h&gt;#pragma comment(lib,&quot;ws2_32.lib&quot;)//链接此动态链接库 windows特有 using namespace std; int main()&#123; //启动windows socket 2,x环境 windows特有 WORD ver = MAKEWORD(2,2);//WinSock库版本号 WSADATA dat;//网络结构体 储存WSAStartup函数调用后返回的Socket数据 if(0 != WSAStartup(ver,&amp;dat))//正确初始化后返回0 &#123; return 0; &#125; //建立一个socket SOCKET _mysocket = socket(AF_INET,SOCK_STREAM,0);//IPV4 数据流类型 类型可以不用写 if(INVALID_SOCKET == _mysocket)//建立失败 &#123; return 0; &#125; //连接服务器 sockaddr_in _sin = &#123;&#125;;//sockaddr结构体 _sin.sin_family = AF_INET;//IPV4 _sin.sin_port = htons(8888);//想要连接的端口号 _sin.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);//想要连接的IP if(SOCKET_ERROR == connect(_mysocket,(sockaddr*)&amp;_sin,sizeof(sockaddr_in))) &#123; cout&lt;&lt;&quot;连接失败&quot;&lt;&lt;endl; closesocket(_mysocket); &#125; else &#123; cout&lt;&lt;&quot;连接成功&quot;&lt;&lt;endl; &#125; while(true)//循环 &#123; //输入请求 char _msg[256] = &#123;&#125;; scanf(&quot;%s&quot;,_msg); //处理请求 if(0 == strcmp(_msg,&quot;exit&quot;))//退出 &#123; break; &#125; else &#123; //向客户端发送数据 send(_mysocket,_msg,strlen(_msg)+1,0);//客户端套接字 数据 数据长短 flag &#125; //接收服务器信息 char _buf[256] = &#123;&#125;; int _buf_len = recv(_mysocket,_buf,256,0); if(_buf_len&gt;0) &#123; printf(&quot;%s\\n&quot;,_buf); &#125; &#125; //关闭socket closesocket(_mysocket); //清除windows socket 环境 WSACleanup(); return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"网络编程","slug":"网络编程","permalink":"https://zgg2001.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"Java容器及其相关学习记录","slug":"20210119_Java容器及其相关学习记录","date":"2021-01-19T02:54:28.000Z","updated":"2021-01-19T02:54:28.000Z","comments":true,"path":"2021/01/19/20210119_Java容器及其相关学习记录/","permalink":"https://zgg2001.github.io/2021/01/19/20210119_Java%E5%AE%B9%E5%99%A8%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","excerpt":"本文主要记录Java容器相关的内容。更多详细Java学习记录，请看我的另一篇文章：链接点我","text":"本文主要记录Java容器相关的内容。更多详细Java学习记录，请看我的另一篇文章：链接点我 1.容器关系图如图所示： 2.Iterator迭代器主要用于遍历Collection中的元素。由于Java没有指针，所以迭代器的使用相比C++更复杂一点。 2.1 常用方法 import java.util.Iterator; public E next() ：返回迭代的下一个元素。 public boolean hasNext() ：如果仍有元素可以迭代，返回true。 public void remove()： 删除当前指针所指向的元素，一般和next方法一起用，这时候的作用就是删除next方法返回的元素。 2.2 使用实例12345678910111213141516171819202122232425262728import java.util.Collection;import java.util.ArrayList;import java.util.Iterator;public class test &#123; public static void main(String[] args) &#123; Collection&lt;Integer&gt; t1 = new ArrayList&lt;&gt;(); t1.add(1); t1.add(2); t1.add(3); t1.add(4); t1.add(5); //while循环遍历 Iterator&lt;Integer&gt; iter1 = t1.iterator(); while(iter1.hasNext()) &#123; int temp = iter1.next(); System.out.println(temp); &#125; //for循环遍历 for(Iterator&lt;Integer&gt; iter2 = t1.iterator();iter2.hasNext();) &#123; int temp = iter2.next(); System.out.println(temp); &#125; &#125;&#125; 2.3 增强for循环增强for循环，用来遍历集合和数组。是JDK1.5之后出现的新特性，底层使用的也是迭代器，但是简化了使用方法。(不用导Iterator包) 格式： 1234for(集合/数组的数据类型 变量名 : 集合名/数组名)&#123; System.out.println(变量名);&#125; 实例： 12345678910111213141516171819import java.util.Collection;import java.util.ArrayList;public class test &#123; public static void main(String[] args) &#123; Collection&lt;Integer&gt; t1 = new ArrayList&lt;&gt;(); t1.add(1); t1.add(2); t1.add(3); t1.add(4); t1.add(5); //增强for循环 for(int i : t1) &#123; System.out.println(i); &#125; &#125;&#125; 3.Collection（单列集合）Collection是所有单列集合的父接口，其中定义了单列集合(List和Set)通用的一些方法，这些方法可以用于操作所有的单列集合。 import java.util.Collection; public boolean add(E e) ：把给定的对象添加到当前集合中。 public void clear() ：清空集合中的所有元素。 public boolean remove(E e) ：把给定的对象在当前集合中删除。 public boolean contains(E e) ：判断当前集合中是否包含给定的对象。 public boolean isEmpty() ：判断当前集合是否为空。 public int size() ：返回集合中元素的个数。 public Object[] toarray() ：把集合中的元素，储存到数组中。 public Iterator iterator() ： 获取集合所依赖的迭代器对象。 3.1 List（列表）List接口为有序的集合，并且存在索引，**包含了一些带索引的方法(特有)**。List接口中允许存储重复的元素。 import java.util.List; public void add(int index, E element) ：将指定的元素，添加到该集合指定的位置上。 public E get(int index) ：返回集合中指定位置的元素。 public E remove(int index) ：移除列表中指定的元素，返回的为被移除的元素。 public E set(int index, E element) ：用指定的元素替换集合中指定位置的元素，返回值为更新前的元素。 3.1.1 ArrayListArrayList储存结构为数组结构，通过List接口实现大小可变的数组。元素增删慢，查找快。ArrayList的实现是多线程的，也就是实现不是同步的，效率高，但是存在线程安全问题。 import java.util.ArrayList; 3.1.2 LinkedListLinkedList储存结构为链表结构，通过List接口实现双向链表。元素增删快，查找慢。LinkedList提供了大量首尾操作的特有方法，跟C++的STL队列方法思路都差不多。 import java.util.LinkedList; public void addFirst(E e) ：将指定元素添加到列表的开头。 public void addLast(E e) ：将指定元素添加到列表的结尾。 public E getFirst() ：返回此列表的第一个元素。 public E getLast() ：返回此列表的最后一个元素。 public E removeFirst() ：移除并返回列表的第一个元素。 public E removeLast() ：移除并返回列表的最后一个元素。 public E pop() ：从此列表的堆栈处弹出一个元素。此处等效于removeFirst(); public void push(E e) ：将元素推入列表的堆栈。此处等效于addFirst(); public boolean isEmpty() ：如果列表不包含元素，返回true。 3.1.3 VectorVector储存结构为数组结构，通过List接口实现大小可变的数组。元素增删慢，查找快。Vector的实现是单线程的，即实现是同步的，所以效率比ArrayList要低，但是不存在线程安全问题。 import java.util.Vector; 3.2 Set（集合）Set接口与Collection接口中的方法基本一致，没有对Collection进行功能上的扩充，但是比Collection接口更加严格。Set接口中元素无序，且都会以某种规则保证存入的元素不出现重复。也不能通过普通的for循环进行遍历。 (参考C++中的set即可) import java.util.Set; 3.2.1 HashSet底层为一个哈希表(数组加红黑树)，查询的速度非常快。且为一个无序的集合，存储和取出元素的顺序不一定一样。在进行数据add存储时，首先使用hashCode()方法获取哈希值进行比较，如果无重复则直接填入。如果存在哈希冲突，则使用equals()方法进行判重，如果不存在重复则填入。 import java.util.HashSet; 在HashSet存储自定义类型元素时，需重写对象的hashCode方法和equals方法，建立自己的比较方式，从而保证集合中对象唯一。 3.2.2 LinkedHashSet底层为一个哈希表+链表，多的这条链表用来记录元素的存储顺序，保证元素有序，即存储和取出元素的顺序一样。 import java.util.LinkedHashSet; 4.Map（双列集合&#x2F;图）Map为双列集合，一个元素里有两个值(key和value)。key不可重复，value可重复。 import java.util.Map; public V put(K key, V value) ：把指定的键与指定的值添加到Map集合中。 public V remove(Object key) ：把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。 public V get(Object key) ：根据指定的键，在Map集合中获取对应的值。 boolean containsKey(Object key) ：判断集合中是否包含指定的键。 public Set&lt;K&gt; keySet() ：获取Map集合中所有的键，存储到Set集合中。 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() ：获取到Map集合中所有的 键值对 对象的集合(Set集合)。 实例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.Set;import java.util.Map;import java.util.HashMap;public class test &#123; public static void main(String[] args) &#123; Integer temp; Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); //put添加元素 如果key不重复返回值为null;如果key重复,替换value,返回值是老value temp = map.put(&quot;张三&quot;, 18);//temp = null temp = map.put(&quot;张三&quot;, 19);//temp = 18 System.out.println(temp); //remove删除元素 key存在,返回value值;key不存在,返回null map.put(&quot;李四&quot;, 20); temp = map.remove(&quot;李四&quot;);//temp = 20 temp = map.remove(&quot;王五&quot;);//temp = null System.out.println(temp); //get获取元素 key存在,返回value值;key不存在,返回null temp = map.get(&quot;张三&quot;);//temp = 19 temp = map.get(&quot;赵六&quot;);//temp = null System.out.println(temp); //containsKey通过key判断集合中是否包含指定元素 存在返回true boolean bool = map.containsKey(&quot;张三&quot;);//true bool = map.containsKey(&quot;赵六&quot;);//false System.out.println(bool); //keySet 获取一个set,其中储存了map的所有key值 Set&lt;String&gt; set = map.keySet(); for(String i : set)//随后就可以根据set使用增强for或者迭代器进行遍历 &#123; temp = map.get(i); System.out.println(i+&quot; &quot;+temp); &#125; //entrySet 返回一个set,其中储存了map中的所有Entry对象 Set&lt;Map.Entry&lt;String,Integer&gt;&gt; set1 = map.entrySet(); for(Map.Entry&lt;String,Integer&gt; i : set1)//遍历set集合,获取每一个Entry对象 &#123; //通过Entry对象中的方法获取key和value String key = i.getKey(); Integer value = i.getValue(); System.out.println(key+&quot; &quot;+value); &#125; &#125;&#125; 4.1 HashMap底层为哈希表(数组+链表&#x2F;红黑树)，查询速度很快。且为一个无序的集合，存储和取出元素的顺序不一定一样。 import java.util.HashMap; 在HashMap存储自定义类型元素时，需重写key元素的hashCode方法和equals方法，从而保证key唯一。 4.2 LinkedHashMap底层为哈希表+链表，多的这条链表用来记录元素的存储顺序，保证元素有序，即存储和取出元素的顺序一样。 import java.util.LinkedHashMap; 4.3 Hashtable底层为哈希表，与HashMap基本一致。其与HashMap的关系，类似Vector与ArrayList的关系。 区别： HashMap键值可以为null，但是Hashtable的键值都不能为空。 Hashtable为单线程，线程安全但是速度慢。 import java.util.Hashtable; 5.Collections集合工具类 import java.util.Collections; public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T…elements) ：往集合中添加一些元素。 public static void shuffle(List&lt;?&gt; list) ：打乱集合顺序。 public static &lt;T&gt; void sort(List&lt;T&gt; list) ：将集合中元素按照默认规则排序。(默认为升序) public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; ) ：将集合中元素按照指定规则排序。 实例： 12345678910111213141516171819202122232425262728293031import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;public class test &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; t1 = new ArrayList&lt;&gt;(); //addAll 添加1，2，3，4，5 Collections.addAll(t1,1,2,3,4,5); //shuffle 打乱顺序 每次执行顺序都不一样 Collections.shuffle(t1); //sort默认排序 默认为升序 Collections.sort(t1); //sort自定义排序 降序 Collections.sort(t1,new Comparator&lt;Integer&gt;() &#123; @Override//重写compare方法 public int compare(Integer o1,Integer o2)/ &#123; //后减前为降序 前减后为升序 return o2-o1; &#125; &#125;); //增强for循环 for(int i : t1) &#123; System.out.println(i);//5 4 3 2 1 &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zgg2001.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zgg2001.github.io/tags/Java/"}]},{"title":"Java学习记录：基于C++的快速学习","slug":"20210108_Java学习记录：基于C++的快速学习","date":"2021-01-08T15:17:16.000Z","updated":"2021-01-08T15:17:16.000Z","comments":true,"path":"2021/01/08/20210108_Java学习记录：基于C++的快速学习/","permalink":"https://zgg2001.github.io/2021/01/08/20210108_Java%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E5%9F%BA%E4%BA%8EC++%E7%9A%84%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0/","excerpt":"HB小咸鱼学习记录 初中的时候曾经学过一点java，算是程序的敲门砖，但是没想到上了大学最先深入学习的是C语言和C++。21年初这个寒假决定在家系统学习Java和网络编程，发个帖子记录过程，方便今后查看。","text":"HB小咸鱼学习记录 初中的时候曾经学过一点java，算是程序的敲门砖，但是没想到上了大学最先深入学习的是C语言和C++。21年初这个寒假决定在家系统学习Java和网络编程，发个帖子记录过程，方便今后查看。 【前期准备】 Java JDK版本选择的是： “1.8.0_181” 编译器我选择的是： Eclipse 具体环境搭建方法由网络上查询得知，不多说了。 学习地址：（B站永远滴神）[video(video-zPI8bhtB-1610116863147)(type-bilibili)(url-https://player.bilibili.com/player.html?aid=797299458)(image-https://ss.csdn.net/p?http://i2.hdslb.com/bfs/archive/73b9c56133cf2defc06255ca50a219156917272e.png)(title-黑马程序员Java语言入门到精通-【基础+高级】-附全套资料(IDEA版))] 【笔记一】 1- 基本语法 C++里的include头文件和Java里的import包机制相似。 C++和Java代码执行的起点都是main函数。 变量关键字与C++基本一致。值得一提的是，由于Java里没有指针，所以Java中的字符串由字符串变量String储存。使用方法与C++&#x2F;STL里的string大同小异，记得Java里的String首字母要大写。 Java中申请数组时，分为动态分配和静态分配。动态分配为new申请内存后不设置各初始值，静态分配为new申请内存后直接设置各初始值。 int[] array1 = new int[3];//动态分配 int[] array2 = new int[]&#123;1,2,3&#125;;//静态分配 Java中的数组和字符串都自带类似C++&#x2F;STL里的方法，例如length()就是获取长度。 变量类型强制转换和C++一致都可以使用(int)double这样的格式进行转换。 字符类型与C++一致也是用的ASCII码。 if&#x2F;else条件判定语句与C++一致。 switch关键字的使用方法与C++一致。 for循环、while循环、do…while循环的使用方法与C++一致。 break和continue的使用方法与C++一致。 Java中类的思路与C++中基本一致。注意Java类中的公&#x2F;私有标识符不用加 ‘:’ 。 Java中类和方法的声明&#x2F;使用方法与C++基本一致。 对于只使用一次的对象，可以使用匿名对象，直接new就行。 final关键字代表最终的，不可改变的。 外部类名称.内部类名称 对象名 &#x3D; new 外部类名称().new 内部类名称(); 直接声明内部类。 现在的编译器支持自动装箱和自动拆箱。 包装类除了int–Integer，char–Character，其余都是首字母大写。 泛型省去了类型转换的麻烦，更加安全，但是只能储存一种数据。 native关键字，代表该方法调用的是本地操作系统的方法。 当方法的参数类型已经确定，但是参数个数不确定时，可以使用可变参数。修饰符 返回值类型 方法名(数据类型…变量名){} 底层为一个数组。 【笔记二】 115-118P Scanner接收类 Java接收输入的方式为调用Scanner类。需要导包：import java.util.Scanner; 接收数据的方法为:字符串-Scanner.next()&#x2F;Scanner.nextLine();其余类型-Scanner.next类型(); 如：int-Scanner.nextInt(); double-Scanner.nextDouble(); 【笔记三】 121-124P Random随机数类 Java生成随机数的方式为调用Random类。需要导包：import java.util.Random; Random类生成随机数的方法和Scanner的方法类似，如Random.nextInt(100); 范围左闭右开，即[0,100)，0~99。 【笔记四】 133-142P String字符串类 不需要导包。 字符串比较方法：str1.equals(str2); 相同返回true。**.equalsIgnoreCase()** 忽略大小写。 字符串长度：str1.length(); 返回字符串长度。 拼接字符串：str3 &#x3D; str1.concat(str2); 返回值为新的字符串地址。 获取字符串指定位置字符：char ch &#x3D; str1.charAt(1); 返回值为一个char。 查找子串在主串中第一次出现的位置：int a &#x3D; str1.indexOf(“abc”); 返回值为第一次出现的索引位置。没有的话返回-1。 字符串截取方法：str2 &#x3D; str1.substring(5);&#x2F;&#x2F;从第5号截取到末尾str2 &#x3D; str1.substring(4,7);&#x2F;&#x2F;从4号截取到6号，左闭右开[4,7) 字符串转为char数组：char[] chars &#x3D; “hello”.toCharArray(); 字符串转为byte数组：byte[] bytes &#x3D; “hello”.getBytes(); 替换字符串内指定内容：String str1 &#x3D; “how do you do?”.replace(“o”,”*”);&#x2F;&#x2F;h*w d* y*u d*? 分割字符串：String[] array1 &#x3D; “aaa.bbb.ccc”.split(“\\\\.”);&#x2F;&#x2F;切成aaa,bbb,ccc三个字符串 【笔记五】 143-147P static静态关键字 当使用static进行修饰后，被修饰的方法&#x2F;变量不再属于对象，而是属于类。 由于不再属于对象，所以带static的方法&#x2F;变量可以直接被调用。静态方法：类名称.静态方法();静态变量：类名称.静态变量; 静态不能直接访问非静态，例如静态方法访问非静态变量。 静态方法里也不能用this。 对于静态变量初始化，我们可以使用静态代码块。静态代码块只在类第一次被声明时，执行一次。 静态内容总是优先于非静态。 【笔记六】 148-149P Arrays数组工具类 需要导包：import java.util.Arrays; 将数组变为字符串：Arrays.toString();int[] a1 &#x3D; {10,20,30};String s1 &#x3D; Arrays.toString(a1);&#x2F;&#x2F;[10, 20, 30] 数组排序：Arrays.sort();int[] a1 &#x3D; {20,10,30};Arrays.sort(a1);&#x2F;&#x2F;10,20,30 默认为升序 【笔记七】 150-151P Math数学工具类 不需要导包。 取绝对值：Math.abs(); 与C++一致，但是浮点数类型也是abs()，不是fabs()。 取平方根：Math.sqrt(); 与C++一致。 求n次方：Math.pow(a,b); 求a的b次方，与C++一致。 比大小：Math.max(a,b) &#x2F; Math.min(a,b); a和b比大小，与C++一致。 向上取整：Math.ceil(); 向下取整：Math.floor(); 四舍五入：Math.round(); Math包里还有常见的数学值，比如Math.PI是圆周率，Math.E是e值。 【笔记八】 171-184P 接口相关 接口没有静态代码块和构造方法。 一个类的父类只有一个，但是一个类可以同时实现多个接口。当父类的方法与接口的默认方法冲突，优先父类。当实现多个接口时存在默认方法冲突，需要对默认方法进行重写。当实现多个接口时存在抽象方法冲突，只需要覆盖重写一次即可。 使用接口首先要定义接口类。定义接口类的格式如：public interface 接口名称 { 接口内容 } 使用接口需要创建接口实现类对接口进行实现。接口实现类的格式如：public class 实现类名称 implements 接口名称 { … } 接口中定义的变量均为常量。常量格式如：public static final 数据类型 常量名称 &#x3D; 数值; 前方三个关键词可省略。 接口中均为抽象方法，且实现类必须覆盖重写接口所有的抽象方法，除非实现类也是抽象类。(必须覆盖)抽象方法格式如：public abstract 返回值类型 方法名称(参数列表); Java8后，接口中可以定义默认方法。(可覆盖可不覆盖)默认方法格式如：public default 返回值类型 方法名称(参数列表) { 方法体 } Java8后，接口中可以定义静态方法。静态方法格式如：public static 返回值类型 方法名称(参数列表) { 方法体 } Java9后，接口中可以定义私有方法。(我的Java版本是1.8.0也就是Java8，所以不支持)普通私有方法格式如：private 返回值类型 方法名称(参数列表) { 方法体 }静态私有方法格式如：private static 返回值类型 方法名称(参数列表) { 方法体 } 【笔记九】 185-194P 继承与多态相关 C++继承用冒号，Java继承用关键字extends。 @Override检测是否重写，总体来说，Java的类继承与C++的类继承很相似。 Java不支持多重继承，所以有super关键字，用来找父类。 abstract为抽象关键字。抽象类&#x2F;抽象方法。 访问成员变量的规则：通过对象名称访问：看声明对象时对象的类型(等号左边)，没有就向上找。通过成员方法访问：看方法属于谁，就优先用谁的成员变量，没有就向上找。 实现多态性：父类引用指向子类对象。多态格式：父类名称 对象名 &#x3D; new 子类名称();接口名称 对象名 &#x3D; new 实现类名称(); 根据第6条和第7条可知，多态中成员方法优先用子类的成员方法；通过对象名称访问成员变量，优先用父类的成员变量。 “编译看左，运行看右”，即编译前把对象看为父类类型(左边)，运行时成员变量看左边，成员方法看右边。 个人感觉，多态的存在使代码更加有逻辑性。 向上转型：右侧new一个子类对象，把它当父类来看待。 (无法调用子类特有方法) 向下转型：将父类对象，还原成为本来的子类对象。格式：子类名称 对象名 &#x3D; (子类名称)父类对象；（有点像强制类型转换） 对象 instanceof 类名称 ：如果对象属于该类，则返回true。使用这个即可根据对象类型，来进行向下转型，使用子类特有方法。 【笔记十】 215-218P Object&#x2F;Objects根类 不需要导包。 **Object.toString()**：转换为字符串，默认转换对象的地址值，需重写。 **Object.equals(对象)**：比较对象是否相等，默认比较对象的地址值，需重写。 **Objects.equals(对象1,对象2)**：第二条的equals方法存在空指针异常可能，Objects的equals方法更加完善。 【笔记十一】 219-225P 日期时间类 Date类 需要导包：import java.util.Date; Date类的空参构造函数为获取当前日期。 Date类的带参构造函数为传入一个long类型的毫秒值，根据毫秒值计算日期。0L为1970年1月1日0点。(中国是东八区加8个小时) **Date.getTime()**：将日期转换为毫秒值，返回值为long类型。 DateFormat类 需要导包：import java.text.DateFormat; DateFomat类是一个抽象类，无法直接创建对象，可以使用其子类SimpleDateFormat(String pattern) SimpleDateFormat类需要导包：import java.text.SimpleDateFormat; SimpleDateFormat s1 &#x3D; new SimpleDateFormat(“yyyy年MM月dd日 HH时mm分ss秒”); 构造函数传参按这个格式即可，字母不能变，其余可变。 String str1 &#x3D; s1.format(Date对象); 将一个Date对象转换为SimpleDateFormat对象中指定格式的字符串。 Date date &#x3D; s1.parse(“2020年01月04日 20时00分00秒”); 按照SimpleDateFormat对象的格式，转换为一个Date格式对象。 Calendar类 需要导包：import java.util.Calendar; Calendar类为抽象类，无法直接创建对象。 Calendar c1 &#x3D; Calendar.getInstance(); 使用多态方法，获取一个Calendar的子类。等号右边方法为获取Calendar的子类。 **Calendar.get(字段)**：返回日历指定字段的数值。例：c1.get(Calendar.YEAR); **Calendar.set(字段,值)**：设置日历指定字段的数值。例：c1.set(Calendar.YEAR, 2020); **Calendar.add(字段,值)**：使指定字段增加给定值，可以为负数。例：c1.add(Calendar.YEAR, -2); **Calendar.getTime()**：将Calendar类转为Date类。例：Date date &#x3D; c1.getTime(); 【笔记十二】 226-226P System系统类 不需要导包。 System.currentTimeMillis()： 返回以毫秒为单位的当前时间，可以用来计算程序的运行时间。 System.arraycopy(参数1,参数2,参数3,参数4,参数5)： 将数组中指定的数据copy到另一个数组。参数1 &#x2F; 参数3：源数组 &#x2F; 目标数组。参数2 &#x2F; 参数4：源数组中的起始位置 &#x2F; 目标数组中的起始位置。参数5：要复制的数组元素的数量。 【笔记十三】 227-229P StringBuilder字符串缓冲区类 不需要导包。 字符串缓冲区，可以提高字符串的操作效率。 String底层为final修饰的数组，而StringBuilder底层是没有被final修饰的数组，可以改变长度。 StringBuilder()： 无参构造函数，默认建议一个空字符串。 StringBuilder(String str)： 带参构造函数，建立一个内容为str的字符串。 append(参数)： 向对象里添加指定参数内容。返回值为”this”，故不用接收返回值。 toString()： 将一个StringBuilder对象转为String对象，返回一个String对象，需要接收。 【笔记十四】 234-281P 容器及其相关* &emsp;详情请看我的另一篇文章：链接点我 &emsp;其中介绍了Java容器及其相关内容。","categories":[{"name":"Java","slug":"Java","permalink":"https://zgg2001.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zgg2001.github.io/tags/Java/"}]},{"title":"使用g++创建动态库和静态库及其相关探索","slug":"20201207_使用g++创建动态库和静态库及其相关探索","date":"2020-12-07T15:39:51.000Z","updated":"2020-12-07T15:39:51.000Z","comments":true,"path":"2020/12/07/20201207_使用g++创建动态库和静态库及其相关探索/","permalink":"https://zgg2001.github.io/2020/12/07/20201207_%E4%BD%BF%E7%94%A8g++%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81%E5%BA%93%E5%92%8C%E9%9D%99%E6%80%81%E5%BA%93%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E6%8E%A2%E7%B4%A2/","excerpt":"使用g++创建动态库和静态库及其相关探索","text":"使用g++创建动态库和静态库及其相关探索 0.前期准备 首先我们建立头文件 “hello.h” 内容如图： 随后我们建立源文件 “hello.cpp” 内容如图： 最后我们建立源文件 “main.cpp” 内容如图： 我们使用 g++ -c 编译出.o文件。无论是动态库还是静态库，都得由.o文件创建，所以我们先编译出.o文件。 结果如图：可以看到有 hello.o 文件 1.静态库创建及链接 使用 ar crv 命令创立静态库。 结果如图：建立出了静态库文件 libmyhello.a ，静态库文件后缀为.a 。 使用 g++ 命令链接静态库 1g++ main.cpp libmyhello.a -o main 结果如图：生成了可执行文件main，且可以正常运行。 删除静态库libmyhello.a，程序仍能运行，说明链接成功。 结果如图： 2.动态库创建及链接 使用 -shared -fPCI 命令创立动态库。 结果如图：建立出了动态库文件 libtest.so ，动态库文件后缀为.so 。 使用 g++ 命令链接动态库 1234g++ main.cpp -L. -ltest -o main/*-L代表so库目录，“-L.” 是当前目录， -I代表引用文件目录。main即为可执行文件*/ 结果如图： 生成可执行文件main 运行程序 直接运行会报错：缺少文件。我们将动态库移动到&#x2F;usr&#x2F;lib 中即可 1mv libtest.so /usr/lib 随后即可正常运行（如果移动后仍不能运行，请看下文） 3.相关问题移动动态库后仍不能运行1.首先进入 &#x2F;etc&#x2F;ld.so.conf 文件 1vim /etc/ld.so.conf 2.修改内容为如下 1include /etc/ld.so.conf.d/*.conf 3.进入目录，创建任意*.conf文件 12cd /etc/ld.so.conf.dvim mylib.conf 4.在其中添加so的路径即可 1/usr/lib 5.执行命令使其生效 1sudo ldconfig 随后程序即可正常运行","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"}]},{"title":"2019 蓝桥杯 C/C++实现 B组国赛","slug":"20201112_2019蓝桥杯C-C++实现B组国赛","date":"2020-11-12T15:23:34.000Z","updated":"2020-11-12T15:23:34.000Z","comments":true,"path":"2020/11/12/20201112_2019蓝桥杯C-C++实现B组国赛/","permalink":"https://zgg2001.github.io/2020/11/12/20201112_2019%E8%93%9D%E6%A1%A5%E6%9D%AFC-C++%E5%AE%9E%E7%8E%B0B%E7%BB%84%E5%9B%BD%E8%B5%9B/","excerpt":"2019 蓝桥杯 C&#x2F;C++实现 B组国赛 题目 &amp; 题解","text":"2019 蓝桥杯 C&#x2F;C++实现 B组国赛 题目 &amp; 题解 A：平方序列请找到两个正整数X和Y满足下列条件：1、2019&lt;X&lt;Y2、2019^2^、X^2^、Y^2^构成等差数列满足条件的X和Y可能有多种情况，请给出X+Y的值，并且令X+Y尽可能的小。 思路： 两层暴力循环。 答案： 7020 代码： 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int t=2019*2019; for(int x=2020;x&lt;10000;x++) &#123; for(int y=x+1;y&lt;10000;y++) &#123; //cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl; if(y*y-x*x==x*x-t) &#123; cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl; cout&lt;&lt;x+y; return 0; &#125; &#125; &#125; return 0;&#125; B：质数拆分2019可以被分解成若干个两两不同的素数，请问不同的分解方案有多少种？注意：分解方案不考虑顺序，如2+2017&#x3D;2019和2017+2&#x3D;2019属于同一种方案。 思路： 动态规划。dp[a][b]表示数字a拆成若干份，最大值为b的方法数。可知，状态转移方程为 dp[a][b] &#x3D; (dp[a-b][2]+dp[a-b][3]+dp[a-b][5]+…+dp[a-b][b下的最大素数]); 用双层循环对a和b进行遍历，其中b均为素数，最后对dp[2019]进行统计即可。 答案： 55965365465060 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;const int M = 2020;vector&lt;int&gt;ps;long long dp[M][M];void shai()&#123; bool kg=true; for(int now=2;now&lt;M;now++) &#123; kg=true; for(int t=2;t&lt;=sqrt(now);t++) &#123; if(now%t==0) &#123; kg=false; break; &#125; &#125; if(kg==true) &#123; ps.push_back(now); &#125; &#125;&#125;int main()&#123; shai(); memset(dp,0,sizeof(dp)); for(int now=0;now&lt;ps.size();now++) &#123; dp[ps[now]][ps[now]] = 1; &#125; for(int now=2;now&lt;M;now++) &#123; for(int count=0;ps[count]&lt;now;count++) &#123; for(int t=0;t&lt;count&amp;&amp;ps[t]&lt;=now-ps[count];t++) &#123; dp[now][ps[count]] += dp[now-ps[count]][ps[t]]; &#125; &#125; &#125; long long ans=0; for(int now=0;now&lt;ps.size();now++) &#123; printf(&quot;%lld &quot;,dp[M-1][ps[now]]); ans+=dp[M-1][ps[now]]; &#125; printf(&quot;\\n最终答案：%lld&quot;,ans); return 0;&#125; C：拼接小明要把一根木头切成两段，然后拼接成一个直角。 如下图所示，他把中间部分分成了 n × n 的小正方形，他标记了每个小正方形属于左边还是右边。 然后沿两边的分界线将木头切断，将右边旋转向上后拼接在一起。要求每个小正方形都正好属于左边或右边，而且同一边的必须是连通的。在拼接时，拼接的部位必须保持在原来大正方形里面。请问，对于 7 × 7 的小正方形，有多少种合法的划分小正方形的方式。 D：求值有一个7X7的方格。方格左上角顶点坐标为(0,0)，右下角坐标为(7,7)。求满足下列条件的路径条数：1、起点和终点都是(0,0)2、路径不自交3、路径长度不大于124、对于每一个顶点，有上下左右四个方向可以走，但是不能越界。例如，图中路线，左上角顶点（0，0），路线长度为10思路： dfs暴力搜索，为了防止路径重复，即(0,0) &gt; (0,1) &gt; (0,0)，(0,0) &gt; (1,0) &gt; (0,0)，我把初始点(0,0)进行标记，在坐标即将改变时进行判定。 答案： 206 代码： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;bool m[8][8];int fx[4][2] = &#123;&#123;-1,0&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;0,1&#125;&#125;;int ans=0;void dfs(int x,int y,int nnn)&#123; if(nnn&gt;=12) &#123; return; &#125; for(int now=0;now&lt;4;now++) &#123; int tx = x + fx[now][0]; int ty = y + fx[now][1]; if(tx&lt;0||ty&lt;0||tx&gt;7||ty&gt;7) continue; if(tx==0&amp;&amp;ty==0&amp;&amp;nnn!=1) &#123; ans++; return; &#125; if(m[tx][ty]==true) continue; m[tx][ty]=true; dfs(tx,ty,nnn+1); m[tx][ty]=false; &#125;&#125;int main()&#123; memset(m,false,sizeof(m)); m[0][0]=true; dfs(0,0,0); cout&lt;&lt;ans; return 0;&#125; E：路径计数有1个约数的最小数为1（1），有两个约数的最小数为2（1，2）……有n个约数的最小数为SnS1&#x3D;1 （1）S2&#x3D;2 （1 2）S3&#x3D;4 （1 2 4）S4&#x3D;6 （1 2 3 6）求S100 思路： 两层暴力循环。 答案： 45360 代码： 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int ans; for(int now=100;;now++) &#123; ans=1; for(int t=2;t&lt;=now;t++) &#123; if(now%t==0) &#123; ans++; &#125; &#125; if(ans==100) &#123; cout&lt;&lt;now; return 0; &#125; &#125; return 0;&#125; F：最优包含我们称一个字符串 S 包含字符串 T 是指 T 是 S 的一个子序列，即可以从字符串 S 中抽出若干个字符，它们按原来的顺序组合成一个新的字符串与 T 完全一样。 给定两个字符串 S 和 T，请问最少修改 S 中的多少个字符，能使 S 包含 T？ 输入格式：输入两行，每行一个字符串。第一行的字符串为 S，第二行的字符串为 T。两个字符串均非空而且只包含大写英文字母。 输出格式：输出一个整数，表示答案。 数据范围：1≤|T|≤|S|≤1000 输入样例：ABCDEABCDXAABZ 输出样例：3 OJ链接 AC代码： 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt; using namespace std;int dp[1001][1001];int main(void)&#123; memset(dp,0,sizeof(dp)); string s1,s2; cin&gt;&gt;s1&gt;&gt;s2; for(int x=1;x&lt;=s2.size();x++) &#123; for(int y=x;y&lt;=s1.size();y++) &#123; if(s1[y-1]!=s2[x-1]) &#123; if(y&gt;x) dp[x][y] = min(dp[x-1][y-1]+1,dp[x][y-1]); else dp[x][y] = dp[x-1][y-1]+1; &#125; else &#123; dp[x][y] = dp[x-1][y-1]; &#125; &#125; &#125; cout&lt;&lt;dp[s2.size()][s1.size()]; return 0;&#125; G：排列数在一个排列中，一个折点是指排列中的一个元素，它同时小于两边的元素，或者同时大于两边的元素。对于一个 1 ∼ n 的排列，如果可以将这个排列中包含 t 个折点，则它称为一个 t + 1 单调序列。例如，排列 (1, 4, 2, 3) 是一个 3 单调序列，其中 4 和 2 都是折点。 给定 n 和 k，请问 1 ∼ n 的所有排列中有多少个 k 单调队列？ 输入格式：输入一行包含两个整数 n, k。 输出格式：输出一个整数，表示答案。答案可能很大，你可需要输出满足条件的排列数量除以 123456 的余数即可。 样例输入：4 2 样例输出：12 数据范围：对于 20% 的评测用例，1 ≤ k ≤ n ≤ 10；对于 40% 的评测用例，1 ≤ k ≤ n ≤ 20；对于 60% 的评测用例，1 ≤ k ≤ n ≤ 100；对于所有评测用例，1 ≤ k ≤ n ≤ 500。 H：解谜游戏 小明正在玩一款解谜游戏，谜题由 24 根塑料棒组成， 其中黄色塑料棒 4 根，红色 8 根，绿色 12 根 (后面用 Y 表示黄色、R 表示红色、G 表示绿色)。 初始时这些塑料棒排成三圈，如上图所示，外圈 12 根，中圈 8 根，内圈 4 根。 小明可以进行三种操作： 将三圈塑料棒都顺时针旋转一个单位。例如当前外圈从 0 点位置开始，顺时针依次是 YRYGRYGRGGGG，中圈是 RGRGGRRY，内圈是 GGGR。那么顺时针旋转一次之后，外圈、中圈、内圈依次变为：GYRYGRYGRGGG、YRGRGGRR 和 RGGG。将三圈塑料棒都逆时针旋转一个单位。例如当前外圈从 0 点位置开始，顺时针依次是 YRYGRYGRGGGG，中圈是 RGRGGRRY，内圈是 GGGR。那么逆时针旋转一次之后，外圈、中圈、内圈依次变为：RYGRYGRGGGGY、GRGGRRYR 和 GGRG将三圈 0 点位置的塑料棒做一个轮换。具体来说：外圈 0 点塑料棒移动到内圈 0 点，内圈 0 点移动到中圈 0 点，中圈 0 点移动到外圈 0 点。例如当前外圈从 0 点位置开始顺时针依次是 YRYGRYGRGGGG，中圈是RGRGGRRY，内圈是 GGGR。那么轮换一次之后，外圈、中圈、内圈依次变为：RRYGRYGRGGGG、GGRGGRRY 和 YGGR。小明的目标是把所有绿色移动到外圈、所有红色移动中圈、所有黄色移动到内圈。给定初始状态，请你判断小明是否可以达成目标？ 输入格式：第一行包含一个整数 T，代表询问的组数。(1 ≤ T ≤ 100)。每组询问包含 3 行：第一行包含 12 个大写字母，代表外圈从 0 点位置开始顺时针每个塑料棒的颜色。第二行包含 8 个大写字母，代表中圈从 0 点位置开始顺时针每个塑料棒的颜色。第三行包含 4 个大写字母，代表内圈从 0 点位置开始顺时针每个塑料棒的颜色。 输出格式：对于每组询问，输出一行 YES 或者 NO，代表小明是否可以达成目标。 样例输入：2GYGGGGGGGGGGRGRRRRRRYRYYYGGGRRRRGGGYYGGGRRRRYGGG 样例输出：YESNO I：第八大奇迹在一条 R 河流域，繁衍着一个古老的名族 Z，他们世代沿河而居，也在河边发展出了璀璨的文明。 Z 族在 R 河沿岸修建了很多建筑，最近，他们热衷攀比起来，他们总是在比谁的建筑建得最奇特。 幸好 Z 族人对奇特的理解都差不多，他们很快给每栋建筑都打了分，这样评选谁最奇特就轻而易举了。 于是，根据分值，大家很快评出了最奇特的建筑，称为大奇迹。 后来他们又陆续评选了第二奇特、第二奇特、……、第七奇特的建筑，依次称为第二大奇迹、第三大奇迹、……、第七大奇迹。 最近，他们开始评选第八奇特的建筑，准备命名为第八大奇迹，在评选中，他们遇到了一些问题。 首先，Z 族一直在发展，有的建筑被拆除又建了新的建筑，新建筑的奇特值和原建筑不一样，这使得评选不那么容易了。 其次，Z 族的每个人所生活的范围可能不一样，他们见过的建筑并不是所有的建筑，他们坚持他们自己所看到的第八奇特的建筑就是第八大奇迹。 Z 族首领最近很头疼这个问题，他害怕因为意见不一致导致 Z 族发生分歧。他找到你，他想先了解一下，民众自己认为的奇迹是怎样的。 现在告诉在 R 河周边的建筑的变化情况，以及在变化过程中一些人的生活范围，请编程求出每个人认为的第八大奇迹的奇特值是多少。 输入格式：输入的第一行包含两个整数 L, N，分别表示河流的长度和要你处理的信息的数量。开始时河流沿岸没有建筑，或者说所有的奇特值为 0。接下来 N 行，每行一条你要处理的信息。如果信息为 C p x，表示流域中第 p 个位置 (1 ≤ p ≤ L) 建立了一个建筑，其奇特值为 x。如果这个位置原来有建筑，原来的建筑会被拆除。如果信息为 Q a b，表示有个人生活的范围是河流的第 a 到 b 个位置（包含 a 和 b，a ≤ b），这时你要算出这个区间的第八大奇迹的奇特值，并输出。如果找不到第八大奇迹，输出 0。 输出格式：对于每个为 Q 的信息，你需要输出一个整数，表示区间中第八大奇迹的奇特值。 样例输入：10 15C 1 10C 2 20C 3 30C 4 40C 5 50C 6 60C 7 70C 8 80C 9 90C 10 100Q 1 2Q 1 10Q 1 8C 10 1Q 1 10 样例输出：0301020 数据范围：对于 20% 的评测用例，1 ≤ L ≤ 1000, 1 ≤ N ≤ 1000。对于 40% 的评测用例，1 ≤ L ≤ 10000, 1 ≤ N ≤ 10000。对于 100% 的评测用例，1 ≤ L ≤ 100000，1 ≤ N ≤ 100000。所有奇特值为不超过 10^9^ 的非负整数。 J：燃烧权杖小 C 最近迷上了一款游戏。现在，在游戏中，小 C 有一个英雄，生命值为 x；敌人也有一个英雄，生命值为 y。 除此以外，还有 k 个士兵，生命值分别为a1 、a2 、……、ak，现在小 C 打算使用一个叫做“燃烧权杖”的技能。 “燃烧权杖”会每次等概率随机选择一个活着的角色（英雄或士兵），扣减其 10 点生命值， 然后如果该角色的生命值小于或等于 0，则该角色死亡，不会再被“燃烧权杖”选中。 “燃烧权杖”会重复做上述操作，直至任意一名英雄死亡。 小 C 想知道使用“燃烧权杖”后敌方英雄死亡（即，小 C 的英雄存活）的概率。 为了避免精度误差，你只需要输出答案模一个质数 p 的结果，具体见输出格式。 输入格式：输入包含多组数据。输入第一行包含一个正整数 T，表示数据组数。接下来 T 组，每组数据第一行包含四个非负整数 x, y, p, k，分别表示小C的英雄的生命值、敌方英雄的生命值，模数和士兵个数。第二行包含 k 个正整数 a1 、a2 、……、ak ，分别表示每个士兵的生命值。 输出格式：对于每组数据，输出一行一个非负整数，表示答案模质数 p 的余数。可以证明，答案一定为有理数。设答案为 a &#x2F; b（a 和 b 为互质的正整数），你输出的数为 x，则你需要保证 a 与 bx 模 p 同余；也即，x &#x3D; (a·b−1 ) mod p，其中 b−1 表示 b 模 p 的逆元， mod 为取模运算。 样例输入：61 10 101 0100 1 101 050 30 4903 21 1987 654 233 13211000000000 999999999 233 31 2 31000000000 999999999 3 31 2 3 样例输出：513710351181172 样例说明：对于第一组数据，所求概率即为“燃烧权杖”第一次就扣减敌方英雄 10 点生命值的概率，即 1&#x2F;2。2 × 51 模 101 余 1。对于第二组数据，答案为 1023&#x2F;1024，1024 × 37 与 1023 模 101 同余。对于第三组数据，答案为 99&#x2F;128。 数据范围：对于 10% 的评测用例，x, y, a1 ,··· , ak ≤ 10。对于 20% 的评测用例，x, y, a1,··· , ak ≤ 100。对于 50% 的评测用例，x, y, a1 ,··· , ak ≤ 1000。另有 10% 的评测用例，p &#x3D; 3。另有 20% 的评测用例，p ≤ 100。对于全部评测用例，1 ≤ x, y, a1 ,··· , ak ≤ 10^9^ ，3 ≤ p ≤ 10000 且 p 为质数，0 ≤ k ≤ 10。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://zgg2001.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}]},{"title":"动态规划学习记录：题型/思路汇总","slug":"20201105_动态规划学习记录：题型思路汇总","date":"2020-11-05T11:58:59.000Z","updated":"2020-11-05T11:58:59.000Z","comments":true,"path":"2020/11/05/20201105_动态规划学习记录：题型思路汇总/","permalink":"https://zgg2001.github.io/2020/11/05/20201105_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E9%A2%98%E5%9E%8B%E6%80%9D%E8%B7%AF%E6%B1%87%E6%80%BB/","excerpt":"动态规划学习记录 记录了常见的一维与二维动态规划题目 &amp; 题解。","text":"动态规划学习记录 记录了常见的一维与二维动态规划题目 &amp; 题解。 一维数组动态规划 一般来说这类题数据都是一维的。例如只受价格影响，如果像01背包问题那样的受价格和大小两个数据影响，就是二维的动态规划。一维动态规划的状态转移方程一般都是平级移动，受之前状态的影响，相对较简单。 1.爬楼梯假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？注意：给定 n 是一个正整数。 示例 1：输入： 2输出： 2解释： 有两种方法可以爬到楼顶。 1 阶 + 1 阶 2 阶 示例 2：输入： 3输出： 3解释： 有三种方法可以爬到楼顶。 1 阶 + 1 阶 + 1 阶 1 阶 + 2 阶 2 阶 + 1 阶 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/climbing-stairs OJ链接著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路：思路很简单，因为一次只能跳一格或者两格，所以当前阶数可前往的方法数等于前两阶的方法数之和。 状态转移方程为：dp[now] &#x3D; dp[now-1] + dp[now-2]; AC代码： 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;class Solution &#123;public: int climbStairs(int n) &#123; int *dp = new int[n+10],t; dp[1]=1; dp[2]=2; for(int now=3;now&lt;=n;now++) &#123; dp[now] = dp[now-1]+dp[now-2]; &#125; t = dp[n]; delete[] dp; return t; &#125;&#125;;int main()&#123; int n; cin&gt;&gt;n; Solution s; cout&lt;&lt;s.climbStairs(n); return 0;&#125; 2.数硬币给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。你可以认为每种硬币的数量是无限的。 示例 1：输入：coins &#x3D; [1, 2, 5], amount &#x3D; 11输出：3解释：11 &#x3D; 5 + 5 + 1 示例 2：输入：coins &#x3D; [2], amount &#x3D; 3输出：-1 示例 3：输入：coins &#x3D; [1], amount &#x3D; 0输出：0 示例 4：输入：coins &#x3D; [1], amount &#x3D; 1输出：1 示例 5：输入：coins &#x3D; [1], amount &#x3D; 2输出：2 提示：1 &lt;&#x3D; coins.length &lt;&#x3D; 121 &lt;&#x3D; coins[i] &lt;&#x3D; 231 - 10 &lt;&#x3D; amount &lt;&#x3D; 104 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/coin-change OJ链接著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路： 当前金额的最小需要硬币数，等于当前金额分别减去硬币面额的所需最小硬币数的最小值加一。例如求2,5,7面额硬币凑27块钱所需的最少硬币，就得求20块钱、22块钱、25块钱的最少硬币(27-7 27-5 27-2)，找到其中的最小值加一就是27块钱所需的最小硬币数。而20块钱，22块钱，25块钱的最少硬币数就按这个倒推，最终可以求出所有金额所需的最小硬币数。 状态转移方程为：dp[x] &#x3D; x金额的所需最少硬币数;dp[now] &#x3D; min( (now-coin[0])+1, (now-coin[1])+1, …… (now-coin[end])+1 );最终结果为: dp[amount]; AC代码： 12345678910111213141516171819202122232425262728class Solution &#123;public: int func(int *z,vector&lt;int&gt;&amp; coins,int d) &#123; int temp=9999999; for(int now=0;now&lt;coins.size();now++) &#123; if(d-coins[now]&gt;=0) &#123; temp=min(temp,z[d-coins[now]]); &#125; &#125; return temp+1; &#125; int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123; int *count=new int[amount+1]; count[0]=0; for(int now=1;now&lt;amount+1;now++) &#123; count[now]=func(count,coins,now); //printf(&quot;%d\\n&quot;,count[now]); &#125; return count[amount]==10000000 ? -1 : count[amount]; &#125;&#125;; 3.最大子序和给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例:输入: [-2,1,-3,4,-1,2,1,-5,4]输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/maximum-subarray OJ链接著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路：加一个max变量，储存最大值，dp数组储存当前连续的最大值。 状态转移方程为：dp[now] &#x3D; max(nums[now],dp[now-1]+nums[now]; AC代码： 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int *dp = new int[nums.size()+1],max_=0; dp[0]=nums[0]; max_=dp[0]; for(int now=1;now&lt;nums.size();now++) &#123; dp[now]=max(nums[now],dp[now-1]+nums[now]); max_=max(max_,dp[now]); &#125; return max_; &#125;&#125;;int main()&#123; int a[] = &#123;-2,1,-3,4,-1,2,1,-5,4&#125;; vector&lt;int&gt;n(a,a+9); Solution s; cout&lt;&lt;s.maxSubArray(n); return 0;&#125; 4.区域和检索 - 数组不可变给定一个整数数组 nums，求出数组从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点。实现 NumArray 类：NumArray(int[] nums) 使用数组 nums 初始化对象int sumRange(int i, int j) 返回数组 nums 从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点（也就是 sum(nums[i], nums[i + 1], … , nums[j])） 示例： 输入：[“NumArray”, “sumRange”, “sumRange”, “sumRange”][[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]] 输出：[null, 1, -1, -3] 解释：NumArray numArray &#x3D; new NumArray([-2, 0, 3, -5, 2, -1]);numArray.sumRange(0, 2); &#x2F;&#x2F; return 1 ((-2) + 0 + 3)numArray.sumRange(2, 5); &#x2F;&#x2F; return -1 (3 + (-5) + 2 + (-1))numArray.sumRange(0, 5); &#x2F;&#x2F; return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1)) 提示：0 &lt;&#x3D; nums.length &lt;&#x3D; 104-105 &lt;&#x3D; nums[i] &lt;&#x3D; 1050 &lt;&#x3D; i &lt;&#x3D; j &lt; nums.length最多调用 104 次 sumRange 方法 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/range-sum-query-immutable OJ链接著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路：用dp数组记录前x个数的和，求i ~ j区间的值的和即为dp[j+1] - dp[i]; 状态转移方程：dp[now]代表前now个数字的和；dp[now] &#x3D; dp[now-1] + nums[now-1]; AC代码： 123456789101112131415161718class NumArray &#123;public: NumArray(vector&lt;int&gt;&amp; nums) &#123; dp.resize(nums.size()+10,0); for(int i=1;i&lt;=nums.size();i++) &#123; dp[i]=dp[i-1]+nums[i-1]; &#125; &#125; int sumRange(int i, int j) &#123; return dp[j+1]-dp[i]; &#125;private: vector&lt;int&gt; dp;&#125;; 5.整数拆分定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。 示例 1:输入: 2输出: 1解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1。 示例 2:输入: 10输出: 36解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36。说明: 你可以假设 n 不小于 2 且不大于 58。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/integer-break OJ地址著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路： 遍历所有可能的分割结果。 状态转移方程为：dp[x] &#x3D; 整数为x时的最大组合乘积;初始dp[1]&#x3D;1;即1的整数最大乘积是1;dp[x] &#x3D; max( max( dp[x-1] * 1, (x-1) * 1 ), max( dp[x-2] * 2, (x-2) * 2 ), max( dp[x-3] * 3, (x-3) * 3 ), …… max( dp[1] * (x-1), 1 * (x-1) );最终结果为: dp[n]; AC代码： 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;class Solution &#123;public: int integerBreak(int n) &#123; int *count = new int[n+1],temp=0; count[1]=1; for(int now=2;now&lt;n+1;now++) &#123; temp=0; for(int t1=1;t1&lt;now;t1++) &#123; temp=max(temp,count[now-t1]*t1); temp=max(temp,(now-t1)*t1); &#125; count[now]=temp; //cout&lt;&lt;count[now]&lt;&lt;endl; &#125; return count[n]; &#125;&#125;;int main()&#123; int n; cin&gt;&gt;n; Solution s; cout&lt;&lt;s.integerBreak(n); return 0;&#125; 6.打家劫舍你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 示例 1：输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。 偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。 示例 2：输入：[2,7,9,3,1]输出：12解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。 偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。 提示：0 &lt;&#x3D; nums.length &lt;&#x3D; 1000 &lt;&#x3D; nums[i] &lt;&#x3D; 400 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/house-robber OJ链接著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路： 可简单看出最大值是在不偷前一个屋子加上偷当前屋子和不偷当前屋子和偷前一个屋子之间做选择。 状态转移方程为：dp[x] &#x3D; 偷到x号房子时的最大可偷最大价值;初始dp[0]&#x3D;0,dp[1]&#x3D;nums[0];即不偷的时候价值为0，只偷一个屋子时价值最大为第一个屋子;dp[x] &#x3D; max( dp[x-2]+nums[x], dp[x-1] );最终结果为: dp[nums.size()]; AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; int *dp = new int[nums.size()+1]; if(nums.size()&gt;=1) &#123; dp[0]=0,dp[1]=nums[0]; for(int now=2;now&lt;=nums.size();now++) &#123; dp[now] = max(dp[now-2]+nums[now-1],dp[now-1]); //cout&lt;&lt;dp[now]&lt;&lt;endl; &#125; return dp[nums.size()]; &#125; else &#123; return 0; &#125; &#125;&#125;;int main()&#123; vector&lt;int&gt;n; int t; while(scanf(&quot;%d&quot;,&amp;t)!=EOF) &#123; n.push_back(t); &#125; Solution s; cout&lt;&lt;s.rob(n); return 0;&#125; 7.打家劫舍II你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下 ，能够偷窃到的最高金额。 示例 1：输入：nums &#x3D; [2,3,2]输出：3解释：你不能先偷窃 1 号房屋（金额 &#x3D; 2），然后偷窃 3 号房屋（金额 &#x3D; 2）, 因为他们是相邻的。 示例 2：输入：nums &#x3D; [1,2,3,1]输出：4解释：你可以先偷窃 1 号房屋（金额 &#x3D; 1），然后偷窃 3 号房屋（金额 &#x3D; 3）。偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。 示例 3：输入：nums &#x3D; [0]输出：0 提示：1 &lt;&#x3D; nums.length &lt;&#x3D; 1000 &lt;&#x3D; nums[i] &lt;&#x3D; 1000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/house-robber-ii OJ链接著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路： 在上一题的基础上，增加了环的概念。大致就是有首不能有尾，有尾不能有首。我们可以先求{1，n-1}这个区间的最大值，再求{2，n}这个区间的最大值，然后取这两个值中的最大值，即为本题答案。 AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; int *dp = new int[nums.size()+1]; int *dp2 = new int[nums.size()+1]; if(nums.size()&gt;=1) &#123; dp[0]=0,dp[1]=nums[0];// 0 ~ n-1 for(int now=2;now&lt;=nums.size()-1;now++) &#123; dp[now] = max(dp[now-2]+nums[now-1],dp[now-1]); //cout&lt;&lt;dp[now]&lt;&lt;endl; &#125; dp2[0]=0,dp2[1]=0;// 1 ~ n for(int now=2;now&lt;=nums.size();now++) &#123; dp2[now] = max(dp2[now-2]+nums[now-1],dp2[now-1]); //cout&lt;&lt;dp[now]&lt;&lt;endl; &#125; if(nums.size()&gt;1) dp[nums.size()]=max(dp[nums.size()-1],dp2[nums.size()]); return dp[nums.size()]; &#125; else &#123; return 0; &#125; &#125;&#125;;int main()&#123; vector&lt;int&gt;n; int t; while(scanf(&quot;%d&quot;,&amp;t)!=EOF) &#123; n.push_back(t); &#125; Solution s; cout&lt;&lt;s.rob(n); return 0;&#125; 8.解码方法一条包含字母 A-Z 的消息通过以下方式进行了编码：‘A’ -&gt; 1‘B’ -&gt; 2…‘Z’ -&gt; 26给定一个只包含数字的非空字符串，请计算解码方法的总数。题目数据保证答案肯定是一个 32 位的整数。 示例 1：输入：”12”输出：2解释：它可以解码为 “AB”（1 2）或者 “L”（12）。 示例 2：输入：”226”输出：3解释：它可以解码为 “BZ” (2 26), “VF” (22 6), 或者 “BBF” (2 2 6) 。 示例 3：输入：s &#x3D; “0”输出：0 示例 4：输入：s &#x3D; “1”输出：1 示例 5：输入：s &#x3D; “2”输出：1 提示：1 &lt;&#x3D; s.length &lt;&#x3D; 100s 只包含数字，并且可以包含前导零。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/decode-ways OJ链接著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码： 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: int numDecodings(string s) &#123; int *dp = new int[s.size()+1]; memset(dp,0,sizeof(dp)); dp[0]=1; s[0]==&#x27;0&#x27; ? dp[1]=0 : dp[1]=1; for(int now=2;now&lt;=s.size();now++) &#123; if(s[now-1]!=&#x27;0&#x27;) &#123; if(s[now-2]==&#x27;1&#x27;||(s[now-2]==&#x27;2&#x27;&amp;&amp;s[now-1]&lt;=&#x27;6&#x27;)) &#123; dp[now]=dp[now-1]+dp[now-2]; &#125; else &#123; dp[now]=dp[now-1]; &#125; &#125; else &#123; if(s[now-2]==&#x27;2&#x27;||s[now-2]==&#x27;1&#x27;) &#123; dp[now]=dp[now-2]; &#125; else &#123; return 0; &#125; &#125; &#125; return dp[s.size()]; &#125;&#125;; 9.乘积最大字数组给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。 示例 1:输入: [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。 示例 2:输入: [-2,0,-1]输出: 0解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/maximum-product-subarray OJ链接著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码： 12345678910111213141516171819202122class Solution &#123;public: int maxProduct(vector&lt;int&gt;&amp; nums) &#123; int dp_max[nums.size()+10],dp_min[nums.size()+10]; dp_max[1]=nums[0]; dp_min[1]=nums[0]; for(int now=2;now&lt;=nums.size();now++) &#123; dp_max[now] = max(dp_min[now-1]*nums[now-1], dp_max[now-1]*nums[now-1]); dp_max[now] = max(dp_max[now], nums[now-1]); dp_min[now] = min(dp_max[now-1]*nums[now-1], dp_min[now-1]*nums[now-1]); dp_min[now] = min(dp_min[now], nums[now-1]); &#125; int max_ = INT_MIN; for(int now=1;now&lt;=nums.size();now++) &#123; max_ = max(max_,dp_max[now]); &#125; return max_; &#125;&#125;; 10.完全平方数给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 示例 1:输入: n &#x3D; 12输出: 3解释: 12 &#x3D; 4 + 4 + 4. 示例 2:输入: n &#x3D; 13输出: 2解释: 13 &#x3D; 4 + 9. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/perfect-squares OJ链接著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码： 12345678910111213141516171819class Solution &#123;public: int numSquares(int n) &#123; int dp[n+1],t=1; memset(dp,9999,sizeof(dp)); dp[0] = 0; for(int now=1;now&lt;=n;now++) &#123; t=1; while(t*t&lt;=now) &#123; dp[now] = min(dp[now],dp[now-t*t]+1); t++; &#125; &#125; return dp[n]; &#125;&#125;; 二维数组动态规划 这类的dp题有两个影响结果的数值，例如01背包问题里的价值和大小、空间问题里的x,y坐标等等都是二维的数据。这种题建立dp数组的时候，就需要构建二维的dp数组，并且状态转移方程的变化情况也更加多样，相对较难一点。 1.不同路径一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。问总共有多少条不同的路径？ 例如，上图是一个7 x 3 的网格。有多少可能的路径？ 示例 1: 输入: m &#x3D; 3, n &#x3D; 2 输出: 3解释:从左上角开始，总共有 3 条路径可以到达右下角。 向右 -&gt; 向右 -&gt; 向下 向右 -&gt; 向下 -&gt; 向右 向下 -&gt; 向右 -&gt; 向右 示例 2: 输入: m &#x3D; 7, n &#x3D; 3 输出: 28 提示：1 &lt;&#x3D; m, n &lt;&#x3D; 100题目数据保证答案小于等于 2 * 10 ^ 9 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/unique-paths OJ链接著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路： dp构建表格，dp[x][y]代表在x,y坐标时的可前往路程数。由于方格只能向下或者向右走，所以前往某一格的方案数，就是前往上一格和左一格的方案数之和。 状态转移方程：dp[x][y] &#x3D; dp[x-1][y]+dp[x][y-1];最终结果为: dp[X][Y]; AC代码： OJ链接 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;class Solution &#123;public: int uniquePaths(int m, int n) &#123; int dp[101][101]; memset(dp,0,sizeof(dp)); dp[1][1]=1; for(int now=1;now&lt;=m;now++) &#123; for(int now1=1;now1&lt;=n;now1++) &#123; if(now-1&gt;=1) &#123; dp[now][now1]+=dp[now-1][now1]; &#125; if(now1-1&gt;=1) &#123; dp[now][now1]+=dp[now][now1-1]; &#125; &#125; &#125; return dp[m][n]; &#125;&#125;;int main()&#123; Solution s; cout&lt;&lt;s.uniquePaths(7,3); return 0;&#125; 2.不同路径II一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 网格中的障碍物和空位置分别用 1 和 0 来表示。 示例 1： 输入：obstacleGrid &#x3D; [[0,0,0],[0,1,0],[0,0,0]] 输出：2解释：3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径： 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右 示例 2： 输入：obstacleGrid &#x3D; [[0,1],[0,0]] 输出：1 提示：m &#x3D;&#x3D; obstacleGrid.length n &#x3D;&#x3D; obstacleGrid[i].length1 &lt;&#x3D; m, n &lt;&#x3D; 100obstacleGrid[i][j] 为 0 或 1 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/unique-paths-ii OJ链接著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路：在上一题的基础上，增加一个判断即可，当遍历到障碍格时，直接跳过不计数即可。令障碍格的可到达方法为0。 状态转移方程：dp[x][y] &#x3D; dp[x-1][y]+dp[x][y-1];最终结果为: dp[X][Y]; AC代码： 12345678910111213141516171819202122232425262728293031class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int dp[101][101]; memset(dp,0,sizeof(dp)); dp[1][1]=1; for(int now=1;now&lt;=obstacleGrid.size();now++) &#123; for(int now1=1;now1&lt;=obstacleGrid[0].size();now1++) &#123; if(obstacleGrid[now-1][now1-1]==0) &#123; if(now-1&gt;=1) &#123; dp[now][now1]+=dp[now-1][now1]; &#125; if(now1-1&gt;=1) &#123; dp[now][now1]+=dp[now][now1-1]; &#125; &#125; else &#123; dp[now][now1]=0; &#125; &#125; &#125; return dp[obstacleGrid.size()][obstacleGrid[0].size()]; &#125;&#125;; 3.最小路径和给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。说明：每次只能向下或者向右移动一步。 示例 1： 输入：grid &#x3D; [[1,3,1],[1,5,1],[4,2,1]] 输出：7解释： 因为路径 1→3→1→1→1 的总和最小。 示例 2： 输入：grid &#x3D; [[1,2,3],[4,5,6]] 输出：12 提示：m &#x3D;&#x3D; grid.lengthn &#x3D;&#x3D; grid[i].length1 &lt;&#x3D; m, n &lt;&#x3D; 2000 &lt;&#x3D; grid[i][j] &lt;&#x3D; 100 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/minimum-path-sum OJ链接著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路：由于只能向下或者向右移动，所以前往一个格子的最小路径，就是其上一个格子和左一个格子的较小路径和加上这个格子的权值。 状态转移方程：dp[x][y] &#x3D; min(dp[x-1][y], dp[x][y-1]) + grid[x][y]; AC代码： 12345678910111213141516171819202122232425262728class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int dp[201][201]; memset(dp,0,sizeof(dp)); dp[0][0]=grid[0][0]; for(int now=0;now&lt;grid.size();now++) &#123; for(int now1=0;now1&lt;grid[now].size();now1++) &#123; if(now!=0&amp;&amp;now1!=0) &#123; dp[now][now1] = min(dp[now-1][now1],dp[now][now1-1]) + grid[now][now1]; &#125; else if(now==0&amp;&amp;now1!=0) &#123; dp[now][now1] = dp[now][now1-1] + grid[now][now1]; &#125; else if(now!=0&amp;&amp;now1==0) &#123; dp[now][now1] = dp[now-1][now1] + grid[now][now1]; &#125; &#125; &#125; return dp[grid.size()-1][grid[0].size()-1]; &#125;&#125;; 4.三角形最小路径和给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。 例如，给定三角形： 123456[ [2], [3,4], [6,5,7], [4,1,8,3]] 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 &#x3D; 11）。 说明：如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/triangle OJ链接著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路：建立二维数组，储存到达每一个坐标的最小路径值。最后遍历最后一行的最小值，即为最终答案。 状态转移方程：对于行首元素：dp[x][0] &#x3D; dp[x-1][0] + triangle[x][0];对于行尾元素：dp[x][x] &#x3D; dp[x-1][x-1] + triangle[x][x];对于行中元素：dp[x][y] &#x3D; min(dp[x-1][y-1], dp[x-1][y]) + triangle[x][y]; AC代码： 123456789101112131415161718192021222324class Solution &#123;public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123; int dp[triangle.size()][triangle.size()]; memset(dp,0,sizeof(dp)); dp[0][0]=triangle[0][0]; for(int now=1;now&lt;triangle.size();now++) &#123; dp[now][0]=dp[now-1][0]+triangle[now][0]; dp[now][now]=dp[now-1][now-1]+triangle[now][now]; for(int t=1;t&lt;=now-1;t++) &#123; dp[now][t] = min(dp[now-1][t-1],dp[now-1][t]) + triangle[now][t]; &#125; &#125; int min_=INT_MAX; for(int now=0;now&lt;triangle.size();now++) &#123; min_=min(dp[triangle.size()-1][now],min_); &#125; return min_; &#125;&#125;; 5.最大正方形在一个由 ‘0’ 和 ‘1’ 组成的二维矩阵内，找到只包含 ‘1’ 的最大正方形，并返回其面积。 示例： 1234567输入：matrix = [[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;], [&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]输出：4 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/maximal-square OJ链接著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码： 1234567891011121314151617181920212223242526272829class Solution &#123;public: int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; if(matrix.size()==0) return 0; int dp[matrix.size()+1][matrix[0].size()+1]; int max_=0,temp; memset(dp,0,sizeof(dp)); for(int x=1;x&lt;=matrix.size();x++) &#123; for(int y=1;y&lt;=matrix[0].size();y++) &#123; if(matrix[x-1][y-1]==&#x27;1&#x27;) &#123; temp = min(dp[x-1][y-1],dp[x-1][y]); temp = min(temp,dp[x][y-1]); dp[x][y] = temp+1; max_ = max(max_,dp[x][y]); &#125; else &#123; dp[x][y] = 0; &#125; &#125; &#125; return max_*max_; &#125;&#125;;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"C语言实现大整数加减 数组实现","slug":"20201013_C语言实现大整数加减数组实现","date":"2020-10-13T15:25:06.000Z","updated":"2020-10-13T15:25:06.000Z","comments":true,"path":"2020/10/13/20201013_C语言实现大整数加减数组实现/","permalink":"https://zgg2001.github.io/2020/10/13/20201013_C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0/","excerpt":"C语言通过数组实现大整数加减法","text":"C语言通过数组实现大整数加减法 思路导图 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include&lt;bits/stdc++.h&gt;void add(int* count_1,int *count_2,int *ans,int max)&#123; for(int now=0;now&lt;max;now++) &#123; ans[now]+=count_1[now]+count_2[now];//这一位的值加上第一个数组的该位值 再加上第二个数组的该位值 if(ans[now]&gt;=10)//大于10就进位 &#123; ans[now+1]+=1;//进一位 ans[now]%=10;//留下个位 &#125; &#125; &#125;void sub(int* count_1,int *count_2,int *ans,int max)&#123; for(int now=0;now&lt;max;now++) &#123; ans[now]+=count_1[now]-count_2[now];//这一位的值等于第一个数组的该位值 减去第二个数组的该位值 if(ans[now]&lt;0)//如果该位数字小于0 &#123; ans[now]+=10;//借一位 加10 ans[now+1]--;//前一位-1; &#125; &#125; &#125; void print(int *ans,int max)&#123; bool kg=false; for(int now=max-1;now&gt;=0;now--) &#123; if(ans[now]!=0||kg==true) &#123; printf(&quot;%d&quot;,ans[now]); kg=true; &#125; &#125; &#125;int main()&#123; char string0[1000],*front,*after,sign;//输入的字符串 切割后的第一个字符串front 第二个字符串after 符号 scanf(&quot;%s&quot;,string0); for(int now=0;;now++) &#123; if(string0[now]==&#x27;+&#x27;)//找到加号 &#123; sign=&#x27;+&#x27;; front=strtok_r(string0,&quot;+&quot;,&amp;after);//切割 break; &#125; else if(string0[now]==&#x27;-&#x27;)//找到减号 &#123; sign=&#x27;-&#x27;; front=strtok_r(string0,&quot;-&quot;,&amp;after);//切割 break; &#125; &#125; int n=strlen(front),m=strlen(after);//两个数的位数 用于下一行的最大位数的选择 int max;//最大位数 不超过两个数最大位数+1 if(n&gt;m)//n比m大 &#123; max=n+1; &#125; else &#123; max=m+1; &#125; int count_1[max], count_2[max], ans[max];//第一个数的数组 第二个数的数组 答案 memset(count_1,0,sizeof(count_1)); memset(count_2,0,sizeof(count_2)); memset(ans,0,sizeof(ans));//每一位都初始化为0 for(int now=0;now&lt;n;now++) &#123; count_1[now]=front[n-now-1]-&#x27;0&#x27;; &#125; for(int now=0;now&lt;m;now++) &#123; count_2[now]=after[m-now-1]-&#x27;0&#x27;; &#125; printf(&quot; = &quot;); if(sign==&#x27;+&#x27;) &#123; add(count_1,count_2,ans,max); &#125; else &#123; if(n&gt;m)// 1 比 2 长 &#123; sub(count_1,count_2,ans,max); &#125; else if(n==m)//一样长 &#123; bool state=false; for(int a=max-1;a&gt;=0&amp;&amp;state==false;a--) &#123; if(count_1[a]&gt;count_2[a]) &#123; sub(count_1,count_2,ans,max); state=true; &#125; else if(count_1[a]&lt;count_2[a]) &#123; printf(&quot;-&quot;); sub(count_2,count_1,ans,max); state=true; &#125; &#125; if(state==false) &#123; printf(&quot;0&quot;); &#125; &#125; else//1 比 2 短 &#123; printf(&quot;-&quot;); sub(count_2,count_1,ans,max); &#125; &#125; print(ans,max); return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"C语言","slug":"C语言","permalink":"https://zgg2001.github.io/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"C语言读取csv文件数据并分组","slug":"20200911_C语言读取csv文件数据并分组","date":"2020-09-11T14:34:12.000Z","updated":"2020-09-11T14:34:12.000Z","comments":true,"path":"2020/09/11/20200911_C语言读取csv文件数据并分组/","permalink":"https://zgg2001.github.io/2020/09/11/20200911_C%E8%AF%AD%E8%A8%80%E8%AF%BB%E5%8F%96csv%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%88%86%E7%BB%84/","excerpt":"核心就是.csv文件各组数据之间用‘,’逗号来分割，我们使用C语言的strtok函数对.csv文件的每一行数据进行分割即可。","text":"核心就是.csv文件各组数据之间用‘,’逗号来分割，我们使用C语言的strtok函数对.csv文件的每一行数据进行分割即可。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;void cut(char *line,int num)//读入这一行的数据 / 数据的组数-1（逗号的个数） &#123; char *temp; temp=strtok(line,&quot;,&quot;); if(temp) &#123; printf(&quot;第1组数据：%6s\\t&quot;,temp);//第一组数据 &#125; for(int now=0;now&lt;num-1;now++) &#123; temp = strtok(NULL,&quot;,&quot;); printf(&quot;第%d组数据：%6s\\t&quot;,now+2,temp);//中间的数据 &#125; temp = strtok(NULL,&quot;,&quot;); temp[strlen(temp)-1]=&#x27;\\0&#x27;;//把fgets读取的回车去掉 printf(&quot;第%d组数据：%6s\\n&quot;,num+1, temp);//最后一组数据 &#125;int main(int argc, char *argv[])&#123; /*if(argc!=3) &#123; return 0; &#125;*/ FILE *file = fopen(&quot;minute.csv&quot;,&quot;r&quot;);//读文件 if(!file) &#123; printf(&quot;file error&quot;); return 0; &#125; char line[1024]; int num=0; fgets(line,1024,file); for(int now=0;line[now]!=&#x27;\\n&#x27;;now++)//通过统计分割的逗号 来统计数据的组数 &#123; if(line[now]==&#x27;,&#x27;) &#123; num++; &#125; &#125; printf(&quot;一共有%d组数据\\n&quot;,num+1);//有num个逗号 就是有num+1组数据 cut(line,num);//分割输出第一行 while(fgets(line,1024,file)!=NULL)//对之后行进行分割 &#123; cut(line,num); &#125; return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"https://zgg2001.github.io/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"2020 第十一届 蓝桥杯 整数拼接","slug":"20200907_2020第十一届蓝桥杯整数拼接","date":"2020-09-07T03:41:04.000Z","updated":"2020-09-07T03:41:04.000Z","comments":true,"path":"2020/09/07/20200907_2020第十一届蓝桥杯整数拼接/","permalink":"https://zgg2001.github.io/2020/09/07/20200907_2020%E7%AC%AC%E5%8D%81%E4%B8%80%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%95%B4%E6%95%B0%E6%8B%BC%E6%8E%A5/","excerpt":"此题为2020年第十一届蓝桥杯省赛第一场B组第九题","text":"此题为2020年第十一届蓝桥杯省赛第一场B组第九题 时间限制: 1.0s 内存限制: 256.0MB 本题总分：25 分问题：给定义个长度为 n 的数组 A1, A2, · · · , An。你可以从中选出两个数 Ai (i 不等于 j)，然后将 Ai 和 Aj 一前一后拼成一个新的整数。例如 12 和 以拼成 12345 或 34512。注意交换 Ai 和 Aj 的顺序总是被视为 2 种拼法，是 Ai &#x3D; Aj 时。请你计算有多少种拼法满足拼出的整数是 K 的倍数。 输入：第一行包含 2 个整数 n 和 K。第二行包含 n 个整数 A1, A2, · · · , An。 输出：一个整数代表答案。 样例输入：4 21 2 3 4 样例输出：6 评测用例规模与约定：对于 30% 的评测用例，1 ≤ n ≤ 1000, 1 ≤ K ≤ 20, 1 ≤ Ai ≤ 10的四次方。对于所有评测用例，1 ≤ n ≤ 10的五次方，1 ≤ K ≤ 10的五次方，1 ≤ Ai ≤ 10的九次方。 思路： 直接暴力肯定超时。我们可以先进行一次操作，对所有数字进行遍历。求出对于每个数，后数为多少时满足题目要求。因为所有数都小于等于十的九次方，即最多为10位数，所以我们只需要求每个数在后数为1位数到10位数时对后数的余数要求即可。然后再遍历一次判定满足要求的后数，总答案加上对该后数的需求即可。数据接收数组选择long long，防止运算中数据超限。答案也选择long long，防止储存不下。 具体思路如下： 整式为 （数一*10^数二的位数^+数二）%k &#x3D;&#x3D; 0 即数一数二满足要求 我们遍历整个数组，按 （k - 数一*10^1-10^%k）%k 求出数一在1-10次方的情况下对后数余数的要求。这次遍历统计的是数一对于数二的需求。 用一个二维数组 mymap[位数][余数需求] 来储存对于 特定数二 的需求数量。 再次遍历整个数组，对数组元素的位数与余数进行计算，如果位数与余数满足需求，总答案则加上上一步中统计的需求数量。这次遍历是为了寻找数二。 在遍历中，我们需要进行去重判定。如果一个数跟自己组合也满足条件，说明上面多加了一次，总答案减去1。 AC代码： OJ链接 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;long long myarray[100001];//存数 int mymap[11][100001];//存不同幂情况下对余数的需求 mymap[幂][需求]=数量 long long ans=0;//答案 void func1(int n,int k)//将各个位数可组合数的需求进行统计 &#123; for(int now=0;now&lt;n;now++) &#123; for(int temp=1;temp&lt;=10;temp++) &#123; int times=(long long)pow(10,temp)%k; mymap[temp][(k-myarray[now]*times%k)%k]++;//在temp次幂的情况下 对后数余数为 k-array[now]*times%k 的需求加一 //即后数为temp位数 并且余数为 k-array[now]*times%k 即可成功组合 //因为 array[now]*times%k 可能等于0 所以k减它可能等于k 所以需要总体%k一下 &#125; &#125;&#125;void func2(int n,int k)//遍历所有数 答案加上需求数 顺便去重 &#123; for(int now=0;now&lt;n;now++) &#123; int times=(int)log10(myarray[now])+1;//当前数位数 ans+=mymap[times][myarray[now]%k];//加上所有可以组合的 if((myarray[now]*(int)pow(10,times)%k+myarray[now]%k)%k==0)//去重 &#123; ans--;//如果一个数跟自己组合也满足条件 说明上面多加了一次 减去它 &#125; &#125;&#125; int main() &#123; int n,k; memset(mymap,0,sizeof(mymap)); scanf(&quot;%d %d&quot;,&amp;n,&amp;k); for(int now=0;now&lt;n;now++) &#123; scanf(&quot;%lld&quot;,&amp;myarray[now]); &#125; func1(n,k); func2(n,k); printf(&quot;%lld&quot;,ans); return 0;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://zgg2001.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}]},{"title":"2020 蓝桥杯 C/C++实现 7月B组省赛","slug":"20200906_2020蓝桥杯C-C++实现7月B组省赛","date":"2020-09-06T09:52:31.000Z","updated":"2020-09-06T09:52:31.000Z","comments":true,"path":"2020/09/06/20200906_2020蓝桥杯C-C++实现7月B组省赛/","permalink":"https://zgg2001.github.io/2020/09/06/20200906_2020%E8%93%9D%E6%A1%A5%E6%9D%AFC-C++%E5%AE%9E%E7%8E%B07%E6%9C%88B%E7%BB%84%E7%9C%81%E8%B5%9B/","excerpt":"2020蓝桥杯 C&#x2F;C++ 7月B组省赛原题 &amp; 题解","text":"2020蓝桥杯 C&#x2F;C++ 7月B组省赛原题 &amp; 题解 @TOC 试题 A: 跑步训练本题总分：5 分问题：小明要做一个跑步训练。初始时，小明充满体力，体力值计为 10000。如果小明跑步，每分钟损耗600 的体力。如果小明休息，每分钟增加 300 的体力。体力的损耗和增加都是均匀变化的。小明打算跑一分钟、休息一分钟、再跑一分钟、再休息一分钟……如此循环。如果某个时刻小明的体力到达 0，他就停止锻炼。请问小明在多久后停止锻炼。为了使答案为整数，请以秒为单位输出答案。答案中只填写数，不填写单位。 思路： 简单循环即可。 答案： 3880 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int first=10000,ans=0; while(first) &#123; if(first&gt;=600) &#123; first-=600; ans+=60; first+=300; ans+=60; &#125; else &#123; ans+=first/10; first=0; &#125; &#125; cout&lt;&lt;ans; return 0;&#125; 试题 B: 纪念日本题总分：5 分问题：2020 年 7 月 1 日是中国某党成立 99 周年纪念日。中国某党成立于 1921 年 7 月 23 日。请问从 1921 年 7 月 23 日中午 12 时到 2020 年 7 月 1 日中午 12 时一共含多少分钟？ 思路： 先算多少天，再算多少时，再算多少分钟。 答案： 52038720 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int ans=0; for(int now=1922;now&lt;2020;now++)//1922到2019年共有多少天 &#123; if(now%100!=0&amp;&amp;now%4==0||now%400==0) &#123; ans+=366; &#125; else &#123; ans+=365; &#125; &#125; ans=ans+31+29+31+30+31+30;//2020年1到6月有多少天 ans=ans+31+30+31+30+31;//1921年8月到12月有多少天 ans+=9;//加上多余那几天 ans*=24;//换算成时 ans*=60;//换算成分 cout&lt;&lt;ans; return 0;&#125; 试题 C: 合并检测本题总分：10 分问题：新冠疫情由新冠病毒引起，最近在 A 国蔓延，为了尽快控制疫情，A 国准 备给大量民众进病毒核酸检测。然而，用于检测的试剂盒紧缺。 为了解决这一困难，科学家想了一个办法：合并检测。即将从多个人（k 个）采集的标本放到同一个试剂盒中进行检测。如果结果为阴性，则说明这 k 个人都是阴性，用一个试剂盒完成了 k 个人的检测。如果结果为阳性，则说明 至少有一个人为阳性，需要将这 k 个人的样本全部重新独立检测（从理论上看， 如果检测前 k−1 个人都是阴性可以推断出第 k 个人是阳性，但是在实际操作中 不会利用此推断，而是将 k 个人独立检测），加上最开始的合并检测，一共使用 了 k + 1 个试剂盒完成了 k 个人的检测。 A 国估计被测的民众的感染率大概是 **1%**，呈均匀分布。请问 k 取多少能 最节省试剂盒？ 思路： 假设有一共检测m个人，则第一批检测需要m&#x2F;k个试剂盒（向上取整）。由于感染率为1%，且均匀分布，则有0.01 * m个试剂盒会有阳性反应。这时进行第二批挨个检测，检测盒数量即为0.01 * m * k个。则总需求盒子数即为m&#x2F;k+0.01 * m * k个（m&#x2F;k向上取整）。 答案： 10 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int min_=999,min_k=0; int m=100;//假设初始人有100 for(int k=1;k&lt;=100;k++) &#123; int need=m/k+0.01*m*k; if(m%k!=0) need++; if(need&lt;min_) &#123; min_=need; min_k=k; &#125; &#125; cout&lt;&lt;min_k; return 0;&#125; 试题 D: REPEAT 程序本题总分：15 分问题：附件 prog.txt 中是一个用某种语言写的程序。prog.txt 附件下载地址其中 REPEAT k 表示一个次数为 k 的循环。循环控制的范围由缩进表达，从次行开始连续的缩进比该行多的（前面的空白更长的）为循环包含的内容。例如如下片段： A &#x3D; A + 4 所在的行到 A &#x3D; A + 8 所在的行都在第一行的循环两次中。REPEAT 6: 所在的行到 A &#x3D; A + 7 所在的行都在 REPEAT 5: 循环中。A &#x3D; A + 5 实际总共的循环次数是 2 × 5 × 6 &#x3D; 60 次。请问该程序执行完毕之后，A 的值是多少？ 思路： 可以建立一个栈来存放循环的信息，一个变量times存放当前行数被执行的次数。通过对文本的观察我们发现，可以通过每一行前面的空格数量来判断当前行数的“等级”，4个空格代表一个等级。如果当前行等级比上一层循环的等级低则说明退出了上一层循环，对栈和times进行改变即可。随后我们发现整个文本里面，所有数字都为单位数，所以我们直接用循环找到一个数字即可提取出该行的有效数字。 答案： 241830 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string string_; stack&lt;int&gt;stack_; freopen(&quot;prog.txt&quot;, &quot;rb&quot;, stdin); getline(cin, string_);//读第一行 A=0 int A=0,times=1,old_counts=0;//A=0,当前倍数，老的层数 while(getline(cin, string_)) &#123; int counts=0;//当前的层数， for(counts=0;counts&lt;string_.size();counts++) &#123; //记录空格数 4个空格是一层 if(string_[counts]!=&#x27; &#x27;) break; &#125; counts/=4;//这句话的层数 while(counts&lt;old_counts)//新层数低 则退出一层循环 pop &#123; times/=stack_.top(); stack_.pop(); old_counts--; &#125; if(string_[counts*4]==&#x27;R&#x27;)//R开头就是新增循环 &#123; for(int now=counts*4;now&lt;string_.size();now++)//找到数字 &#123; if(string_[now]&gt;=&#x27;0&#x27;&amp;&amp;string_[now]&lt;=&#x27;9&#x27;)//如果是数字 &#123; stack_.push(string_[now]-&#x27;0&#x27;); times*=string_[now]-&#x27;0&#x27;; old_counts++; break; &#125; &#125; &#125; else//否则就是执行计算操作 &#123; for(int now=counts*4;now&lt;string_.size();now++)//找到数字 &#123; if(string_[now]&gt;=&#x27;0&#x27;&amp;&amp;string_[now]&lt;=&#x27;9&#x27;)//如果是数字 &#123; A+=(string_[now]-&#x27;0&#x27;)*times; break; &#125; &#125; &#125; &#125; cout&lt;&lt;A; return 0;&#125; 试题 E: 矩阵本题总分：15 分问题：把 1 ∼ 2020 放在 2 × 1010 的矩阵里。要求同一行中右边的比左边大，列中下边的比上边的大。一共有多少种方案？答案很大，你只需要给出方案数除以 2020 的余数即可。 思路： 动态规划。 答案： 1340 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;int f[1020][1020];int main()&#123; f[0][0] = 1; // 两行一个数字都不放，也是一种方案 for (int i = 0; i &lt;= 1010; i ++) for (int j = 0; j &lt;= 1010; j ++) &#123; if(i - 1 &gt;= j) // 转移前的状态也要合法，即第一行的数量不小于第二行的数量 f[i][j] += f[i - 1][j] % 2020; if(j) f[i][j] += f[i][j - 1] % 2020; &#125; cout &lt;&lt; f[1010][1010] &lt;&lt; endl; return 0;&#125; 以下五题均能通过AcWing的数据测试 试题 F: 整除序列时间限制: 1.0s 内存限制: 256.0MB 本题总分：15问题：有一个序列，序列的第一个数是 n，后面的每个数是前一个数整除 2，出这个序列中值为正数的项。 输入:输入一行包含一个整数 n。 输出：输出一行，包含多个整数，相邻的整数之间用一个空格分隔，表示答案。 样例输入：20 样例输出：20 10 5 2 1 评测用例规模与约定：对于 80% 的评测用例，1 ≤ n ≤ 10的9次方。对于所有评测用例，1 ≤ n ≤ 10的18次方。 思路： 直接循环除就好。 AC代码： OJ链接 1234567891011121314#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; long long n=0; scanf(&quot;%lld&quot;,&amp;n); while(n) &#123; printf(&quot;%lld &quot;,n); n&gt;&gt;=1; &#125; return 0;&#125; 试题 G: 解码时间限制: 1.0s 内存限制: 256.0MB 本题总分：20 分问题：小明有一串很长的英文字母，可能包含大写和小写。在这串字母中，有很多连续的是重复的。小明想了一个办法将这串字达得更短：将连续的几个相同字母写成字母 + 出现次数的形式。例如，连续的 5 个 a，即 aaaaa，小明可以简写成 a5（也可能简写aa3a 等）。对于这个例子：HHHellllloo，小明可以简写成 H3el5o2。为了方便表达，小明不会将连续的超过 9 个相同的字符写成简写的形式。现在给出简写后的字符串，请帮助小明还原成原来的串。 输入：输入一行包含一个字符串。 输出：输出一个字符串，表示还原后的串。 样例输入：H3el5o2 样例输出：HHHellllloo 评测用例规模与约定：对于所有评测用例，字符串由大小写英文字母和数字组成，长度不100。请注意原来的串长度可能超过 100。 思路： 对字符串进行循环判断即可。 AC代码： OJ链接 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string string_; char old_letter;//老字母 getline(cin,string_); old_letter=string_[0];//指向第一个字母 for(int now=1;now&lt;string_.size();now++) &#123; if(string_[now]&gt;=&#x27;1&#x27;&amp;&amp;string_[now]&lt;=&#x27;9&#x27;)//数字就循环输出 &#123; for(int temp=0;temp&lt;string_[now]-&#x27;0&#x27;-1;temp++) &#123; printf(&quot;%c&quot;,old_letter); &#125; &#125; else//否则输出一次 换新字 &#123; printf(&quot;%c&quot;,old_letter); old_letter=string_[now]; &#125; &#125; printf(&quot;%c&quot;,old_letter); return 0;&#125; 试题 H: 走方格时间限制: 1.0s 内存限制: 256.0MB 本题总分：20 分问题：在平面上有一些二维的点阵。这些点的编号就像二维数组的编号一样，从上到下依次为第 1 至第 n 行，从左到右依次为第 1 至第 m 列，每一个点可以用行号和列号来表示。现在有个人站在第 1 行第 1 列，要走到第 n 行第 m 列。只能向右或者向下走。注意，如果行号和列数都是偶数，不能走入这一格中。问有多少种方案。 输入：输入一行包含两个整数 n, m。 输出：输出一个整数，表示答案。 样例输入1：3 4 样例输出1：2 样例输入2：6 6 样例输出2：0 评测用例规模与约定：对于所有评测用例，1 ≤ n ≤ 30, 1 ≤ m ≤ 30。 思路： dfs暴力搜索的话，当n&#x3D;29，m&#x3D;30的时候会超时。我们可以用dp把结果都记录下来然后直接输出。记得行号列号都是偶数的时候跳过，因为不能走入这种方格。 AC代码： OJ链接 1.dfs写法（超时）12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;int fx[2][2]=&#123;&#123;0,1&#125;,&#123;1,0&#125;&#125;,ans=0;//右/下 答案 int n,m,a1,b1;//n,m void dfs(int a,int b)&#123; if(a==n&amp;&amp;b==m) &#123; ans++; return; &#125; for(int now=0;now&lt;2;now++) &#123; a1=a+fx[now][0]; b1=b+fx[now][1]; if(a1&gt;n||b1&gt;m) continue; if(!(a1&amp;1)&amp;&amp;!(b1&amp;1)) continue; dfs(a1,b1); &#125;&#125; int main()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); if(!(n&amp;1)&amp;&amp;!(m&amp;1)) &#123; cout&lt;&lt;0; return 0; &#125; dfs(1,1); cout&lt;&lt;ans; return 0;&#125; 2.dp写法（可AC） 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int dp[31][31];//dp int n,m;//n,m scanf(&quot;%d %d&quot;,&amp;n,&amp;m); memset(dp,0,sizeof(dp)); dp[1][1]=1; for(int now=1;now&lt;=30;now++) &#123; for(int now1=1;now1&lt;=30;now1++) &#123; if(!(now&amp;1)&amp;&amp;!(now1&amp;1))//都是偶数就跳过 continue; if(now-1&gt;=1) &#123; dp[now][now1]+=dp[now-1][now1]; &#125; if(now1-1&gt;=1) &#123; dp[now][now1]+=dp[now][now1-1]; &#125; &#125; &#125; /*for(int now=1;now&lt;=30;now++) &#123; for(int now1=1;now1&lt;=30;now1++) &#123; printf(&quot;%d &quot;,dp[now][now1]); &#125; printf(&quot;\\n&quot;); &#125;*/ cout&lt;&lt;dp[n][m]; return 0;&#125; 试题 I: 整数拼接时间限制: 1.0s 内存限制: 256.0MB 本题总分：25 分问题：给定义个长度为 n 的数组 A1, A2, · · · , An。你可以从中选出两个数 Ai (i 不等于 j)，然后将 Ai 和 Aj 一前一后拼成一个新的整数。例如 12 和 以拼成 12345 或 34512。注意交换 Ai 和 Aj 的顺序总是被视为 2 种拼法，是 Ai &#x3D; Aj 时。请你计算有多少种拼法满足拼出的整数是 K 的倍数。 输入：第一行包含 2 个整数 n 和 K。第二行包含 n 个整数 A1, A2, · · · , An。 输出：一个整数代表答案。 样例输入：4 21 2 3 4 样例输出：6 评测用例规模与约定：对于 30% 的评测用例，1 ≤ n ≤ 1000, 1 ≤ K ≤ 20, 1 ≤ Ai ≤ 10的四次方。对于所有评测用例，1 ≤ n ≤ 10的五次方，1 ≤ K ≤ 10的五次方，1 ≤ Ai ≤ 10的九次方。 思路： 直接暴力肯定超时。我们可以先进行一次操作，对所有数字进行遍历。求出对于每个数，后数为多少时满足题目要求。因为所有数都小于等于十的九次方，即最多为10位数，所以我们只需要求每个数在后数为1位数到10位数时对后数的余数要求即可。然后再遍历一次判定满足要求的后数，总答案加上对该后数的需求即可。数据接收数组选择long long，防止运算中数据超限。答案也选择long long，防止储存不下。 具体思路如下： 整式为 （数一*10^数二的位数^+数二）%k &#x3D;&#x3D; 0 即数一数二满足要求 我们遍历整个数组，按 （k - 数一*10^1-10^%k）%k 求出数一在1-10次方的情况下对后数余数的要求。这次遍历统计的是数一对于数二的需求。 用一个二维数组 mymap[位数][余数需求] 来储存对于 特定数二 的需求数量。 再次遍历整个数组，对数组元素的位数与余数进行计算，如果位数与余数满足需求，总答案则加上上一步中统计的需求数量。这次遍历是为了寻找数二。 在遍历中，我们需要进行去重判定。如果一个数跟自己组合也满足条件，说明上面多加了一次，总答案减去1。 AC代码： OJ链接 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;long long myarray[100001];//存数 int mymap[11][100001];//存不同幂情况下对余数的需求 mymap[幂][需求]=数量 long long ans=0;//答案 void func1(int n,int k)//将各个位数可组合数的需求进行统计 &#123; for(int now=0;now&lt;n;now++) &#123; for(int temp=1;temp&lt;=10;temp++) &#123; int times=(long long)pow(10,temp)%k; mymap[temp][(k-myarray[now]*times%k)%k]++;//在temp次幂的情况下 对后数余数为 k-array[now]*times%k 的需求加一 //即后数为temp位数 并且余数为 k-array[now]*times%k 即可成功组合 //因为 array[now]*times%k 可能等于0 所以k减它可能等于k 所以需要总体%k一下 &#125; &#125;&#125;void func2(int n,int k)//遍历所有数 答案加上需求数 顺便去重 &#123; for(int now=0;now&lt;n;now++) &#123; int times=(int)log10(myarray[now])+1;//当前数位数 ans+=mymap[times][myarray[now]%k];//加上所有可以组合的 if((myarray[now]*(int)pow(10,times)%k+myarray[now]%k)%k==0)//去重 &#123; ans--;//如果一个数跟自己组合也满足条件 说明上面多加了一次 减去它 &#125; &#125;&#125; int main() &#123; int n,k; memset(mymap,0,sizeof(mymap)); scanf(&quot;%d %d&quot;,&amp;n,&amp;k); for(int now=0;now&lt;n;now++) &#123; scanf(&quot;%lld&quot;,&amp;myarray[now]); &#125; func1(n,k); func2(n,k); printf(&quot;%lld&quot;,ans); return 0;&#125; 试题 J: 网络分析时间限制: 1.0s 内存限制: 256.0MB 本题总分：25 分问题：小明正在做一个网络实验。他设置了 n 台电脑，称为节点，用于收发和存储数据。初始时，所有节点都是独立的，不存在任何连接。小明可以通过网线将两个节点连接起来，连接后两个节点就可以互相了。两个节点如果存在网线连接，称为相邻。小明有时会测试当时的网络，他会在某个节点发送一条信息，信息会到每个相邻的节点，之后这些节点又会转发到自己相邻的节点，直到所有或间接相邻的节点都收到了信息。所有发送和接收的节点都会将信息存储一条信息只存储一次。给出小明连接和测试的过程，请计算出每个节点存储信息的大小。 输入：输入的第一行包含两个整数 n, m，分别表示节点数量和操作数量。节1 至 n 编号。接下来 m 行，每行三个整数，表示一个操作。如果操作为 1 a b，表示将节点 a 和节点 b 通过网线连接起来。当 时，表示连接了一个自环，对网络没有实质影响。如果操作为 2 p t，表示在节点 p 上发送一条大小为 t 的信息。 输出：输出一行，包含 n 个整数，相邻整数之间用一个空格分割，依次表示完上述操作后节点 1 至节点 n 上存储信息的大小。 样例输入：4 81 1 22 1 102 3 51 4 12 2 21 1 21 2 42 2 1 样例输出：13 13 5 3 评测用例规模与约定：对于 30% 的评测用例，1 ≤ n ≤ 20，1 ≤ m ≤ 100。对于 50% 的评测用例，1 ≤ n ≤ 100，1 ≤ m ≤ 1000。对于 70% 的评测用例，1 ≤ n ≤ 1000，1 ≤ m ≤ 10000。对于所有评测用例，1 ≤ n ≤ 10000，1 ≤ m ≤ 100000，1 ≤ t ≤ 100。 思路： 核心思路是并查集。一个数组用来存旧值，一个数组用来存根结点权值，一个数组是并查集的father数组。执行2操作时，查集寻找到操作值的根结点并加权。执行1操作时，若两数在一个集内则不操作；若两数不在一个集内，则对所有节点进行遍历，使他们的旧值数组加上其根节点的权值，随后进行并集操作。记得对权值数组进行清零，防止后面重复计算。 AC代码： OJ链接 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;int old_[10001],new_[10001],father[10001],n,m;//存老值 存根节点新值 父节点数组 int find(int a)&#123; return father[a]==a ? a : father[a]=find(father[a]);//路径压缩&#125;void union_(int a,int b)&#123; int temp_a=find(a),temp_b=find(b); if(temp_a!=temp_b) &#123; for(register int now=1;now&lt;=n;now++) &#123; old_[now]+=new_[find(now)];//旧值数组遍历加上权值 &#125; memset(new_,0,sizeof(new_));//重置权值数组，防止重复计算 father[temp_a]=temp_b; &#125;&#125;int main()&#123; int a,b,c; memset(new_,0,sizeof(new_)); for(register int now=1;now&lt;=10000;now++) &#123; father[now]=now;//father数组初始化 &#125; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); while(m--) &#123; scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c); if(a==1) &#123; union_(b,c); &#125; else &#123; new_[find(b)]+=c; &#125; &#125; for(register int now=1;now&lt;=n;now++) &#123; printf(&quot;%d &quot;,old_[now]+new_[find(now)]); &#125; return 0;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://zgg2001.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}]},{"title":"2020 蓝桥杯 C/C++实现 7月C组省赛","slug":"20200903_2020蓝桥杯C-C++实现7月C组省赛","date":"2020-09-03T14:54:29.000Z","updated":"2020-09-03T14:54:29.000Z","comments":true,"path":"2020/09/03/20200903_2020蓝桥杯C-C++实现7月C组省赛/","permalink":"https://zgg2001.github.io/2020/09/03/20200903_2020%E8%93%9D%E6%A1%A5%E6%9D%AFC-C++%E5%AE%9E%E7%8E%B07%E6%9C%88C%E7%BB%84%E7%9C%81%E8%B5%9B/","excerpt":"2020蓝桥杯 C&#x2F;C++ 7月C组省赛原题 &amp; 题解","text":"2020蓝桥杯 C&#x2F;C++ 7月C组省赛原题 &amp; 题解 试题 A: 指数计算本题总分：5 分问题：请计算：7 ^ 2020 mod 1921，其中 A mod B 表示 A 除以 B 的余数。 思路： 快速幂。 答案： 480 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;long long ksm(int a,int b,int c)&#123; if(b==0) &#123; return 1; &#125; if(b==1) &#123; return a; &#125; if(b&amp;1) &#123; return a*ksm(a,b-1,c)%c; &#125; else &#123; long long ans=ksm(a,b/2,c)%c; return ans*ans%c; &#125;&#125;int main()&#123; printf(&quot;%lld&quot;,ksm(7,2020,1921)); return 0;&#125; 试题 B: 解密本题总分：5 分问题:小明设计了一种文章加密的方法：对于每个字母 c，将它变成某个另外的字符 Tc。下表给出了字符变换的规则：例如，将字符串 YeRi 加密可得字符串 EaFn。小明有一个随机的字符串，加密后为EaFnjISplhFviDhwFbEjRjfIBBkRyY(由 30 个大小写英文字母组成，不包含换行符），请问原字符串是多少？（如果你把以上字符串和表格复制到文本文件中，请务必检查复制的内容是否与文档中的一致。在试题目录下有一个文件 str.txt，第一行为上面的字符串，后面 52 行依次为表格中的内容。） 思路： 因为我没有文本形式的这个对照表。。。所以用的最笨的方法。 答案： YeRikGSunlRzgDlvRwYkXkrGWWhXaA 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string a=&quot;EaFnjISplhFviDhwFbEjRjfIBBkRyY&quot;; //cin&gt;&gt;a; //EaFnjISplhFviDhwFbEjRjfIBBkRyY for(int now=0;now&lt;a.size();now++) &#123; switch(a[now]) &#123; case &#x27;a&#x27;:cout&lt;&lt;&#x27;e&#x27;;break; case &#x27;b&#x27;:cout&lt;&lt;&#x27;w&#x27;;break; case &#x27;c&#x27;:cout&lt;&lt;&#x27;f&#x27;;break; case &#x27;d&#x27;:cout&lt;&lt;&#x27;d&#x27;;break; case &#x27;e&#x27;:cout&lt;&lt;&#x27;y&#x27;;break; case &#x27;f&#x27;:cout&lt;&lt;&#x27;r&#x27;;break; case &#x27;g&#x27;:cout&lt;&lt;&#x27;o&#x27;;break; case &#x27;h&#x27;:cout&lt;&lt;&#x27;l&#x27;;break; case &#x27;i&#x27;:cout&lt;&lt;&#x27;g&#x27;;break; case &#x27;j&#x27;:cout&lt;&lt;&#x27;k&#x27;;break; case &#x27;k&#x27;:cout&lt;&lt;&#x27;h&#x27;;break; case &#x27;l&#x27;:cout&lt;&lt;&#x27;n&#x27;;break; case &#x27;m&#x27;:cout&lt;&lt;&#x27;c&#x27;;break; case &#x27;n&#x27;:cout&lt;&lt;&#x27;i&#x27;;break; case &#x27;o&#x27;:cout&lt;&lt;&#x27;p&#x27;;break; case &#x27;p&#x27;:cout&lt;&lt;&#x27;u&#x27;;break; case &#x27;q&#x27;:cout&lt;&lt;&#x27;m&#x27;;break; case &#x27;r&#x27;:cout&lt;&lt;&#x27;x&#x27;;break; case &#x27;s&#x27;:cout&lt;&lt;&#x27;s&#x27;;break; case &#x27;t&#x27;:cout&lt;&lt;&#x27;j&#x27;;break; case &#x27;u&#x27;:cout&lt;&lt;&#x27;q&#x27;;break; case &#x27;v&#x27;:cout&lt;&lt;&#x27;z&#x27;;break; case &#x27;w&#x27;:cout&lt;&lt;&#x27;v&#x27;;break; case &#x27;x&#x27;:cout&lt;&lt;&#x27;b&#x27;;break; case &#x27;y&#x27;:cout&lt;&lt;&#x27;a&#x27;;break; case &#x27;z&#x27;:cout&lt;&lt;&#x27;t&#x27;;break; case &#x27;A&#x27;:cout&lt;&lt;&#x27;E&#x27;;break; case &#x27;B&#x27;:cout&lt;&lt;&#x27;W&#x27;;break; case &#x27;C&#x27;:cout&lt;&lt;&#x27;F&#x27;;break; case &#x27;D&#x27;:cout&lt;&lt;&#x27;D&#x27;;break; case &#x27;E&#x27;:cout&lt;&lt;&#x27;Y&#x27;;break; case &#x27;F&#x27;:cout&lt;&lt;&#x27;R&#x27;;break; case &#x27;G&#x27;:cout&lt;&lt;&#x27;O&#x27;;break; case &#x27;H&#x27;:cout&lt;&lt;&#x27;L&#x27;;break; case &#x27;I&#x27;:cout&lt;&lt;&#x27;G&#x27;;break; case &#x27;J&#x27;:cout&lt;&lt;&#x27;K&#x27;;break; case &#x27;K&#x27;:cout&lt;&lt;&#x27;H&#x27;;break; case &#x27;L&#x27;:cout&lt;&lt;&#x27;N&#x27;;break; case &#x27;M&#x27;:cout&lt;&lt;&#x27;C&#x27;;break; case &#x27;N&#x27;:cout&lt;&lt;&#x27;I&#x27;;break; case &#x27;O&#x27;:cout&lt;&lt;&#x27;P&#x27;;break; case &#x27;P&#x27;:cout&lt;&lt;&#x27;U&#x27;;break; case &#x27;Q&#x27;:cout&lt;&lt;&#x27;M&#x27;;break; case &#x27;R&#x27;:cout&lt;&lt;&#x27;X&#x27;;break; case &#x27;S&#x27;:cout&lt;&lt;&#x27;S&#x27;;break; case &#x27;T&#x27;:cout&lt;&lt;&#x27;J&#x27;;break; case &#x27;U&#x27;:cout&lt;&lt;&#x27;Q&#x27;;break; case &#x27;V&#x27;:cout&lt;&lt;&#x27;Z&#x27;;break; case &#x27;W&#x27;:cout&lt;&lt;&#x27;V&#x27;;break; case &#x27;X&#x27;:cout&lt;&lt;&#x27;B&#x27;;break; case &#x27;Y&#x27;:cout&lt;&lt;&#x27;A&#x27;;break; case &#x27;Z&#x27;:cout&lt;&lt;&#x27;T&#x27;;break; &#125; &#125; return 0;&#125; 试题 C: 跑步训练本题总分：10 分问题：小明要做一个跑步训练。初始时，小明充满体力，体力值计为 10000。如果小明跑步，每分钟损耗600 的体力。如果小明休息，每分钟增加 300 的体力。体力的损耗和增加都是均匀变化的。小明打算跑一分钟、休息一分钟、再跑一分钟、再休息一分钟……如此循环。如果某个时刻小明的体力到达 0，他就停止锻炼。请问小明在多久后停止锻炼。为了使答案为整数，请以秒为单位输出答案。答案中只填写数，不填写单位。 思路： 简单循环即可。 答案： 3880 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int first=10000,ans=0; while(first) &#123; if(first&gt;=600) &#123; first-=600; ans+=60; first+=300; ans+=60; &#125; else &#123; ans+=first/10; first=0; &#125; &#125; cout&lt;&lt;ans; return 0;&#125; 试题 D: 合并检测本题总分：10 分问题：新冠疫情由新冠病毒引起，最近在 A 国蔓延，为了尽快控制疫情，A 国准 备给大量民众进病毒核酸检测。然而，用于检测的试剂盒紧缺。 为了解决这一困难，科学家想了一个办法：合并检测。即将从多个人（k 个）采集的标本放到同一个试剂盒中进行检测。如果结果为阴性，则说明这 k 个人都是阴性，用一个试剂盒完成了 k 个人的检测。如果结果为阳性，则说明 至少有一个人为阳性，需要将这 k 个人的样本全部重新独立检测（从理论上看， 如果检测前 k−1 个人都是阴性可以推断出第 k 个人是阳性，但是在实际操作中 不会利用此推断，而是将 k 个人独立检测），加上最开始的合并检测，一共使用 了 k + 1 个试剂盒完成了 k 个人的检测。 A 国估计被测的民众的感染率大概是 **1%**，呈均匀分布。请问 k 取多少能 最节省试剂盒？ 思路： 假设有一共检测m个人，则第一批检测需要m&#x2F;k个试剂盒（向上取整）。由于感染率为1%，且均匀分布，则有0.01 * m个试剂盒会有阳性反应。这时进行第二批挨个检测，检测盒数量即为0.01 * m * k个。则总需求盒子数即为m&#x2F;k+0.01 * m * k个（m&#x2F;k向上取整）。 答案： 10 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int min_=999,min_k=0; int m=100;//假设初始人有100 for(int k=1;k&lt;=100;k++) &#123; int need=m/k+0.01*m*k; if(m%k!=0) need++; if(need&lt;min_) &#123; min_=need; min_k=k; &#125; &#125; cout&lt;&lt;min_k; return 0;&#125; 试题 E: REPEAT 程序本题总分：15 分问题：附件 prog.txt 中是一个用某种语言写的程序。prog.txt 附件下载地址其中 REPEAT k 表示一个次数为 k 的循环。循环控制的范围由缩进表达，从次行开始连续的缩进比该行多的（前面的空白更长的）为循环包含的内容。例如如下片段： A &#x3D; A + 4 所在的行到 A &#x3D; A + 8 所在的行都在第一行的循环两次中。REPEAT 6: 所在的行到 A &#x3D; A + 7 所在的行都在 REPEAT 5: 循环中。A &#x3D; A + 5 实际总共的循环次数是 2 × 5 × 6 &#x3D; 60 次。请问该程序执行完毕之后，A 的值是多少？ 思路： 可以建立一个栈来存放循环的信息，一个变量times存放当前行数被执行的次数。通过对文本的观察我们发现，可以通过每一行前面的空格数量来判断当前行数的“等级”，4个空格代表一个等级。如果当前行等级比上一层循环的等级低则说明退出了上一层循环，对栈和times进行改变即可。随后我们发现整个文本里面，所有数字都为单位数，所以我们直接用循环找到一个数字即可提取出该行的有效数字。 答案： 241830 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string string_; stack&lt;int&gt;stack_; freopen(&quot;prog.txt&quot;, &quot;rb&quot;, stdin); getline(cin, string_);//读第一行 A=0 int A=0,times=1,old_counts=0;//A=0,当前倍数，老的层数 while(getline(cin, string_)) &#123; int counts=0;//当前的层数， for(counts=0;counts&lt;string_.size();counts++) &#123; //记录空格数 4个空格是一层 if(string_[counts]!=&#x27; &#x27;) break; &#125; counts/=4;//这句话的层数 while(counts&lt;old_counts)//新层数低 则退出一层循环 pop &#123; times/=stack_.top(); stack_.pop(); old_counts--; &#125; if(string_[counts*4]==&#x27;R&#x27;)//R开头就是新增循环 &#123; for(int now=counts*4;now&lt;string_.size();now++)//找到数字 &#123; if(string_[now]&gt;=&#x27;0&#x27;&amp;&amp;string_[now]&lt;=&#x27;9&#x27;)//如果是数字 &#123; stack_.push(string_[now]-&#x27;0&#x27;); times*=string_[now]-&#x27;0&#x27;; old_counts++; break; &#125; &#125; &#125; else//否则就是执行计算操作 &#123; for(int now=counts*4;now&lt;string_.size();now++)//找到数字 &#123; if(string_[now]&gt;=&#x27;0&#x27;&amp;&amp;string_[now]&lt;=&#x27;9&#x27;)//如果是数字 &#123; A+=(string_[now]-&#x27;0&#x27;)*times; break; &#125; &#125; &#125; &#125; cout&lt;&lt;A; return 0;&#125; 试题 F: 分类计数时间限制: 1.0s 内存限制: 512.0MB 本题总分：15 分问题：输入一个字符串，请输出这个字符串包含多少个大写字母，多少个小写字母，多少个数字。 输入：输入一行包含一个字符串。 输出：输出三行，每行一个整数，分别表示大写字母、小写字母和数字的个数。 样例输入：1+a&#x3D;Aab 样例输出：131 思路： 简单循环。 代码： 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string string_; getline(cin,string_); int ans_1=0,ans_2=0,ans_3=0;//大写，小写，数字 for (int now=0;now&lt;string_.size();now++) &#123; if(string_[now]&lt;=&#x27;Z&#x27;&amp;&amp;string_[now]&gt;=&#x27;A&#x27;) &#123; ans_1++; &#125; else if(string_[now]&lt;=&#x27;z&#x27;&amp;&amp;string_[now]&gt;=&#x27;a&#x27;) &#123; ans_2++; &#125; else if(string_[now]&lt;=&#x27;9&#x27;&amp;&amp;string_[now]&gt;=&#x27;0&#x27;) &#123; ans_3++; &#125; &#125; printf(&quot;%d\\n%d\\n%d\\n&quot;,ans_1,ans_2,ans_3); return 0;&#125; 试题 G: 整除序列时间限制: 1.0s 内存限制: 512.0MB 本题总分：20 分问题：有一个序列，序列的第一个数是 n，后面的每个数是前一个数整除 2，请输出这个序列中值为正数的项。 输入：输入一行包含一个整数 n。 输出：输出一行，包含多个整数，相邻的整数之间用一个空格分隔，表示答案。 样例输入：20 样例输出：20 10 5 2 1 评测用例规模与约定：对于 80% 的评测用例，1 ≤ n ≤ 10的9次方。对于所有评测用例，1 ≤ n ≤ 10的18次方。 思路： 简单循环即可。 代码： 1234567891011121314#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; long long n; scanf(&quot;%lld&quot;,&amp;n); while(n) &#123; printf(&quot;%lld &quot;,n); n&gt;&gt;=1; &#125; return 0;&#125; 试题 H: 走方格时间限制: 1.0s 内存限制: 512.0MB 本题总分：20 分问题：在平面上有一些二维的点阵。这些点的编号就像二维数组的编号一样，从上到下依次为第 1 至第 n 行，从左到右依次为第 1 至第 m 列，每一个点可以用行号和列号来表示。现在有个人站在第 1 行第 1 列，要走到第 n 行第 m 列。只能向右或者向下走。注意，如果行号和列数都是偶数，不能走入这一格中。问有多少种方案。 输入：输入一行包含两个整数 n, m。 输出：输出一个整数，表示答案。 样例输入1：3 4 样例输出1：2 样例输入2：6 6 样例输出2：0 评测用例规模与约定：对于所有评测用例，1 ≤ n ≤ 30, 1 ≤ m ≤ 30。 思路： dfs暴力搜索的话，当n&#x3D;29，m&#x3D;30的时候应该会超时。我们可以用dp把结果都记录下来然后直接输出。记得行号列号都是偶数的时候跳过，因为不能走入这种方格。 代码： dfs写法12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;int fx[2][2]=&#123;&#123;0,1&#125;,&#123;1,0&#125;&#125;,ans=0;//右/下 答案 int n,m,a1,b1;//n,m void dfs(int a,int b)&#123; if(a==n&amp;&amp;b==m) &#123; ans++; return; &#125; for(int now=0;now&lt;2;now++) &#123; a1=a+fx[now][0]; b1=b+fx[now][1]; if(a1&gt;n||b1&gt;m) continue; if(!(a1&amp;1)&amp;&amp;!(b1&amp;1)) continue; dfs(a1,b1); &#125;&#125; int main()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); if(!(n&amp;1)&amp;&amp;!(m&amp;1)) &#123; cout&lt;&lt;0; return 0; &#125; dfs(1,1); cout&lt;&lt;ans; return 0;&#125; dp写法 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int dp[31][31];//dp int n,m;//n,m scanf(&quot;%d %d&quot;,&amp;n,&amp;m); memset(dp,0,sizeof(dp)); dp[1][1]=1; for(int now=1;now&lt;=30;now++) &#123; for(int now1=1;now1&lt;=30;now1++) &#123; if(!(now&amp;1)&amp;&amp;!(now1&amp;1))//都是偶数就跳过 continue; if(now-1&gt;=1) &#123; dp[now][now1]+=dp[now-1][now1]; &#125; if(now1-1&gt;=1) &#123; dp[now][now1]+=dp[now][now1-1]; &#125; &#125; &#125; /*for(int now=1;now&lt;=30;now++) &#123; for(int now1=1;now1&lt;=30;now1++) &#123; printf(&quot;%d &quot;,dp[now][now1]); &#125; printf(&quot;\\n&quot;); &#125;*/ cout&lt;&lt;dp[n][m]; return 0;&#125; 试题 I: 字符串编码时间限制: 1.0s 内存限制: 512.0MB 本题总分：25 分问题：小明发明了一种给由全大写字母组成的字符串编码的方法。对于每一个大写字母，小明将它转换成它在 26 个英文字母中序号，即 A → 1, B → 2, … Z →26。这样一个字符串就能被转化成一个数字序列：比如 ABCXYZ → 123242526。现在给定一个转换后的数字序列，小明想还原出原本的字符串。当然这样的还原有可能存在多个符合条件的字符串。小明希望找出其中字典序最大的字符串。 输入：一个数字序列。 输出：一个只包含大写字母的字符串，代表答案 样例输入：123242526 样例输出：LCXYZ 评测用例规模与约定对于 20% 的评测用例，输入的长度不超过 20。对于所有评测用例，输入的长度不超过 200000。 思路： 多条件判定，连着两个数和大于26的单个输出，后数第两个值为0的单个输出……大概要点好像就这么多，欢迎补充。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string string_; getline(cin,string_); for(int now=0;now&lt;string_.size();) &#123; if(string_[now]==&#x27;1&#x27;)//开头为1 &#123; if(now+2&lt;string_.size())//后两位有数 &#123; if(string_[now+2]!=&#x27;0&#x27;)//后第两位不是0 &#123; printf(&quot;%c&quot;,(string_[now]-&#x27;0&#x27;)*10+string_[now+1]-&#x27;0&#x27;+&#x27;A&#x27;-1); now+=2;//后移两位 &#125; else &#123; printf(&quot;%c&quot;,string_[now]-&#x27;0&#x27;+&#x27;A&#x27;-1); now++;//后移一位 &#125; &#125; else if(now+1&lt;string_.size())//后一位有数 &#123; printf(&quot;%c&quot;,(string_[now]-&#x27;0&#x27;)*10+string_[now+1]-&#x27;0&#x27;+&#x27;A&#x27;-1); now+=2;//后移两位 &#125; else//最后一位直接输出 &#123; printf(&quot;%c&quot;,string_[now]-&#x27;0&#x27;+&#x27;A&#x27;-1); now++;//后移一位 &#125; &#125; else if(string_[now]==&#x27;2&#x27;)//开头为2 &#123; if(now+2&lt;string_.size())//后两位有数 &#123; if(string_[now+2]!=&#x27;0&#x27;)//后第两位不是0 &#123; if(string_[now+1]&lt;=&#x27;6&#x27;)//小于26 &#123; printf(&quot;%c&quot;,(string_[now]-&#x27;0&#x27;)*10+string_[now+1]-&#x27;0&#x27;+&#x27;A&#x27;-1); now+=2;//后移两位 &#125; else &#123; printf(&quot;%c&quot;,string_[now]-&#x27;0&#x27;+&#x27;A&#x27;-1); now++;//后移一位 &#125; &#125; else &#123; printf(&quot;%c&quot;,string_[now]-&#x27;0&#x27;+&#x27;A&#x27;-1); now++;//后移一位 &#125; &#125; else if(now+1&lt;string_.size())//后一位有数 &#123; if(string_[now+1]&lt;=&#x27;6&#x27;)//小于26 &#123; printf(&quot;%c&quot;,(string_[now]-&#x27;0&#x27;)*10+string_[now+1]-&#x27;0&#x27;+&#x27;A&#x27;-1); now+=2;//后移两位 &#125; else &#123; printf(&quot;%c&quot;,string_[now]-&#x27;0&#x27;+&#x27;A&#x27;-1); now++;//后移一位 &#125; &#125; else//最后一位直接输出 &#123; printf(&quot;%c&quot;,string_[now]-&#x27;0&#x27;+&#x27;A&#x27;-1); now++;//后移一位 &#125; &#125; else//其余直接输出 &#123; printf(&quot;%c&quot;,string_[now]-&#x27;0&#x27;+&#x27;A&#x27;-1); now++;//后移一位 &#125; &#125; return 0;&#125; 试题 J: 整数小拼接时间限制: 1.0s 内存限制: 512.0MB 本题总分：25 分问题：给定义个长度为 n 的数组 A1, A2, · · · , An。你可以从中选出两个数 Ai 和 Aj (i不等于 j)，然后将 Ai 和 Aj 一前一后拼成一个新的整数。例如 12 和 345 可以拼成 12345 或 34512 。注意交换 Ai 和 Aj 的顺序总是被视为 2 种拼法，即便是 Ai &#x3D; Aj 时。请你计算有多少种拼法满足拼出的整数小于等于 K。 输入：第一行包含 2 个整数 n 和 K。第二行包含 n 个整数 A1, A2, · · · , An。 输出：一个整数代表答案。 样例输入：4 331 2 3 4 样例输出：8 评测用例规模与约定：对于 30% 的评测用例，1 ≤ N ≤ 1000, 1 ≤ K ≤ 10的8次方, 1 ≤ Ai ≤ 10的四次方。对于所有评测用例，1 ≤ N ≤ 100000，1 ≤ K ≤ 10的十次方，1 ≤ Ai ≤ 10的九次方。 思路： 暴力求解应该只能过30%样例。我的思路是在第一次接收数组的时候，直接再次按位数存到二维数组里。在接下来的判断中，两个数的位数相加小于K的位数的话，就是合法值。两个数的位数相加等于K的时候再相加准确计算，由于数据最大为十的十次方，所以用long long存。这样的思路应该能比直接暴力快不少，评测点应该能多过几个，但是能不能AC我也不清楚，毕竟现在也没样例数据。如果大佬们有好的思路，麻烦指导下谢谢。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;long long array[100001];//存数据 vector&lt;long long&gt;mymap[10];//存上面数组的每个数的位数 int main()&#123; long long n,k,ans=0; scanf(&quot;%lld %lld&quot;,&amp;n,&amp;k); for(int now=0;now&lt;n;now++) &#123; scanf(&quot;%lld&quot;,&amp;array[now]); mymap[(int)log10(array[now])+1].push_back(array[now]);//按位数存进mymap里 &#125; int k_count=(int)log10(k)+1,temp,temp1;//k的位数 中间值（后面用） for(int now=1;now&lt;k_count-1;now++)//两个数位数相加小于k的位数 说明肯定小于k 直接交叉相乘 &#123; for(int now1=1;now1+now&lt;k_count;now1++) &#123; ans+=mymap[now].size()*mymap[now1].size(); if(now==now1)//如果位数相同 则有重复计算 &#123; ans-=mymap[now].size();//减去一部分 &#125; &#125; &#125; sort(array,array+n);//先排个序 一会循环到位数大于等于k的位数的时候 直接break; for(int now=0;now&lt;n;now++)//两个数位数相加等于k的情况 挨个判断 &#123; temp=(int)log10(array[now])+1; if(temp&gt;=k_count) break; temp1=mymap[k_count-temp].size(); for(int now1=0;now1&lt;temp1;now1++) &#123; //cout&lt;&lt;array[now]*pow(10,k_count-temp)+mymap[k_count-temp][now1]&lt;&lt;&quot; &quot;&lt;&lt;k&lt;&lt;endl; if(array[now]*pow(10,k_count-temp)+mymap[k_count-temp][now1]&lt;=k)//两数相加小于等于k &#123; ans++; &#125; &#125; if(temp==k_count-temp&amp;&amp;array[now]*pow(10,k_count-temp)+array[now]&lt;=k)//重复计数 减一个 &#123; ans--; &#125; &#125; printf(&quot;%d&quot;,ans); return 0;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://zgg2001.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}]},{"title":"c/c++算法 基础题 练手汇总","slug":"20200902_c++算法基础题练手汇总","date":"2020-09-02T10:40:16.000Z","updated":"2020-09-02T10:40:16.000Z","comments":true,"path":"2020/09/02/20200902_c++算法基础题练手汇总/","permalink":"https://zgg2001.github.io/2020/09/02/20200902_c++%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E9%A2%98%E7%BB%83%E6%89%8B%E6%B1%87%E6%80%BB/","excerpt":"因为是基础题所以都不算难，个人把碰见过的感觉比较好的练手基础题在这里做个汇总，方便查阅。","text":"因为是基础题所以都不算难，个人把碰见过的感觉比较好的练手基础题在这里做个汇总，方便查阅。 枚举 一般都是数据量比较小的简单题，难点在于对数据的判断处理。用循环直接对数据区间枚举随后进行判断即可。如果数据量较大，就优化判断条件或者找共性减少运算时间。 1.安全区题目描述在一个nn的网格图上有m个探测器，第i个探测器位于(xi,yi)位置，探测半径为ri。求出nn个点中有多少个是安全的点，即未被探测的点。 输入第一行为两个整数n,m(1&lt;&#x3D;n&lt;&#x3D;100,1&lt;&#x3D;m&lt;&#x3D;n*n)接下来m行每行3个整数表示xi,yi,ri（1&lt;&#x3D;xi,yi,ri&lt;&#x3D;n） 输出输出一个整数表示答案 样例输入5 23 3 14 2 1 样例输出17 OJ链接 思路： 重点是半径判断，我是用sqrt((x-x1) * (x-x1) + (y-y1) * (y-y1)) &gt; r 来判断是否在检测半径内，同时用二维数组来储存是否能被探测到。 AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;bool mymap[101][101];void func(int x,int y,int r,int n)//中心点 x y 探测半径 r 地图总长 n&#123; for(int a=x-r;a&lt;=x+r;a++) &#123; if(a&lt;1||a&gt;n)//x超界 continue; for(int b=y-r;b&lt;=y+r;b++) &#123; if(b&lt;1||b&gt;n)//y超界 continue; if(sqrt((x-a)*(x-a)+(y-b)*(y-b))&gt;r)//不在半径内 continue; //printf(&quot;%lf %d\\n&quot;,sqrt((x-a)*(x-a)+(y-b)*(y-b)),r); if(!mymap[a][b]) mymap[a][b]=true; &#125; &#125;&#125;int main()&#123; memset(mymap,false,sizeof(mymap)); int n,m,xi,yi,ri,ans=0; cin&gt;&gt;n&gt;&gt;m; /*for(int a=1;a&lt;=n;a++) &#123; for(int b=1;b&lt;=n;b++) &#123; printf(&quot;%d &quot;,mymap[a][b]); &#125; printf(&quot;\\n&quot;); &#125;*/ for(int temp=0;temp&lt;m;temp++) &#123; cin&gt;&gt;xi&gt;&gt;yi&gt;&gt;ri; func(xi,yi,ri,n); &#125; for(int a=1;a&lt;=n;a++) &#123; for(int b=1;b&lt;=n;b++) &#123; //printf(&quot;%d &quot;,mymap[a][b]); if(mymap[a][b]==false) ans++; &#125; //printf(&quot;\\n&quot;); &#125; cout&lt;&lt;ans; return 0;&#125; 2.统计方形题目描述有一个n*m方格的棋盘，求其方格包含多少正方形、长方形（此处长方形不包含正方形） 输入输入存在多组测试数据。每组测试数据输入两个整数n,m，数字不超过5000 输出对于每组数据输出一行包含两个整数，分别表示正方形数目和长方形数目 样例输入2 3 样例输出8 10 思路： 就是两层循环，代表当前图形的长和宽，长宽一样就是正方形，不一样就是长方形。然后求出这一行能有多少个这种图形(1+(m-b))，再求这一列有多少种这种图形(1+(n-a))，两者相乘就是这个图里有多少种这种图形。然后加到总数里，等循环跑完就是答案。 代码： 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n,m; long long ans1=0,ans2=0;//ans1=正方形 ans2=长方形 cin&gt;&gt;n&gt;&gt;m; for(int a=1;a&lt;=n;a++) &#123; for(int b=1;b&lt;=m;b++) &#123; if(a==b) &#123; ans1+=(1+(n-a))*(1+(m-a)); &#125; else &#123; ans2+=(1+(n-a))*(1+(m-b)); &#125; &#125; &#125; cout&lt;&lt;ans1&lt;&lt;&quot; &quot;&lt;&lt;ans2; return 0;&#125; 但是这样复杂度会比较高，可能会超时，所以有第二种求法。先求出总的矩形个数，再用一层循环求出正方形个数，总的减去正方形的就是长方形的。 AC代码： 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std; int main ()&#123; /*对于一个n*m的棋盘，共有矩形 (m+m-1+m-2+...+1)*(n+n-1+n-2+...+1) 即[m*(m+1)/2]*[n*(n+1)/2]个，这一步可知用前一个式子循环道加，也可版用后一个式子直接算； 共有正方形（假设m&gt;n) m*n+(m-1)*(n-1)+...+(m-n+1)*1 个，这步用循环做就行； 长方形就用 矩形权数 减去 正方形数 就行了。*/ int n,m; while(scanf(&quot;%d %d&quot;,&amp;n,&amp;m)!=EOF) &#123; long long sum1=0; for(int i=1;i&lt;=min(n,m);i++) &#123; sum1+=(n-i+1)*(m-i+1); &#125; printf(&quot;%lld &quot;,sum1); long long sum2=1LL*n*(n+1)/2*1LL*m*(m+1)/2;//1 printf(&quot;%lld\\n&quot;,sum2-sum1); &#125; return 0;&#125; 3.连续自然数和（尺取法）题目对于给定自然数N，求出存在多少个连续自然数段，长度至少为2，使得这些连续的自然数段之和为N。 输入输入有若干行，每行一个正整数n。(1&lt;&#x3D;n&lt;&#x3D;2000000) 输出对于每组测试数据输出第一个数字表示答案 样例输入910000 样例输出24 思路： 可以用for循环暴力循环出来，但是我下面是用的尺取法，来减少复杂度。 AC代码： 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n; while(scanf(&quot;%d&quot;,&amp;n)!=EOF) &#123; int ans=0,temp=0,f=1,e=1;//答案个数 中间值 头 尾 while(n!=0)//尺取 &#123; while(temp&lt;n&amp;&amp;e&lt;n) &#123; temp+=e; e++; &#125; if(temp&lt;n) &#123; break; &#125; if(temp==n&amp;&amp;e-f&gt;=1) &#123; ans++; &#125; temp-=f; f++; &#125; printf(&quot;%d\\n&quot;,ans); &#125; return 0;&#125; 4.蓝桥杯 数字分组问题描述 输入任意10个浮点数，根据它们的聚集程度划分为3组，输出每一组的平均值。 提供老师上课讲的一种思路：将10个数字进行在数轴上排序，然后计算每两个点间的距离，在所有的距离中选取两个最大距离处断开，这样就把10个数字分为了3组。 本题难度较大，如果深入讨论会比较复杂，大家可以只考虑如下面样例所示的分组情况非常简单的情况，只要简单情况能够成功计算，本题就能得分。 另外，本题内容有些超前，推荐大家自学一下数组那一章中第一节一维数组，然后使用一维数组来做。排序算法可以参考trustie平台上传的冒泡排序法参考资料。 输入格式 十个待输入的浮点数，使用空格隔开 输出格式 三组数的平均数，每输出一个需要换行 样例输入一个满足题目要求的输入范例。例1：50.4 51.3 52.3 9.5 10.4 11.6 19.1 20.8 21.9 49.6例2：8.6 7.4 3.5 17.9 19.1 18.5 37.6 40.4 38.5 40.0 样例输出与上面的样例输入对应的输出。例1：10.520.650.9例2:6.518.539.125 思路： 直接循环枚举检测间隔即可。 AC代码： OJ链接 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;double shuzu[10];int main()&#123; double max1=0,max2=0,m1,m2; for(int a=0;a&lt;10;a++) &#123; scanf(&quot;%lf&quot;,&amp;shuzu[a]); &#125; sort(shuzu,shuzu+10); for(int a=0;a&lt;9;a++) &#123; double temp=shuzu[a+1]-shuzu[a]; if(temp&gt;max1) &#123; max2=max1; m2=m1; max1=temp; m1=a; &#125; else if(temp&gt;max2) &#123; max2=temp; m2=a; &#125; &#125; double temp=0; for(int a=0;a&lt;=min(m1,m2);a++) &#123; temp+=shuzu[a]; &#125; printf(&quot;%g\\n&quot;,temp/(min(m1,m2)+1)); temp=0; for(int a=min(m1,m2)+1;a&lt;=max(m1,m2);a++) &#123; temp+=shuzu[a]; &#125; printf(&quot;%g\\n&quot;,temp/(max(m1,m2)-min(m1,m2))); temp=0; for(int a=max(m1,m2)+1;a&lt;=9;a++) &#123; temp+=shuzu[a]; &#125; printf(&quot;%g\\n&quot;,temp/(9-max(m1,m2))); return 0; &#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"2016 蓝桥杯 剪邮票 dfs","slug":"20200831_2016蓝桥杯剪邮票dfs","date":"2020-08-31T13:23:21.000Z","updated":"2020-08-31T13:23:21.000Z","comments":true,"path":"2020/08/31/20200831_2016蓝桥杯剪邮票dfs/","permalink":"https://zgg2001.github.io/2020/08/31/20200831_2016%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%89%AA%E9%82%AE%E7%A5%A8dfs/","excerpt":"这是2016年蓝桥杯C语言省赛B组的第七题","text":"这是2016年蓝桥杯C语言省赛B组的第七题 题目：如下图, 有12张连在一起的12生肖的邮票。现在你要从中剪下5张来，要求必须是连着的。（仅仅连接一个角不算相连） 比如，下面两张图中，粉红色所示部分就是合格的剪取。 请你计算，一共有多少种不同的剪取方法。 输出：请填写表示方案数目的整数。 OJ链接 思路： 首先，我们将数组储存为1 2 3 46 7 8 911 12 13 14这样如果两数相减绝对值是5则是上下相邻关系，绝对值是1则是左右相邻关系。 通过对上图的观察我们可以发现，如果满足题意，则各邮票的相连邮票数量之和一定大于等于8，且每个邮票都有相连邮票。（上面两个图的相连数量之和都为8，如果剪12567的话相连数量就是9）按照这个规律我们就可以用双重循环来搜索答案了。 前面用5层循环来组合出所有可能，防止重复。 AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt; using namespace std;int temp[]=&#123;1,2,3,4,6,7,8,9,11,12,13,14&#125;;int shuzu[5]; int ans=0;/*1 2 3 46 7 8 911 12 13 14*/bool judge()&#123; int count=0; for(int now=0;now&lt;5;now++)//取前五个 看是否都相连 &#123; int flag=0;//先假设不相连 for(int now1=0;now1&lt;5;now1++)//挨个判断 &#123; if(now==now1) continue; if(abs(shuzu[now1]-shuzu[now])==5||abs(shuzu[now1]-shuzu[now])==1)//上下相连 绝对值为5 或者 左右相连 绝对值为1 &#123; flag+=1;//相连点位+1 &#125; &#125; if(flag==0)//如果是孤立点 没有相连点位 就直接返回false &#123; return false; &#125; count+=flag;//加上连接数 &#125; if(count&lt;8)//如果连接数小于8 则说明5个点位没有相互相邻 &#123; return false; &#125; //printf(&quot;%d %d %d %d %d\\n&quot;,shuzu[0],shuzu[1],shuzu[2],shuzu[3],shuzu[4]); return true;&#125;int main()&#123; for(int a=0;a&lt;12;a++) &#123; for(int b=a+1;b&lt;12;b++) &#123; for(int c=b+1;c&lt;12;c++) &#123; for(int d=c+1;d&lt;12;d++) &#123; for(int e=d+1;e&lt;12;e++) &#123; shuzu[0]=temp[a],shuzu[1]=temp[b],shuzu[2]=temp[c],shuzu[3]=temp[d],shuzu[4]=temp[e]; if(judge()) &#123; ans++; &#125; &#125; &#125; &#125; &#125; &#125; cout&lt;&lt;ans; return 0;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://zgg2001.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}]},{"title":"2017 蓝桥杯 日期问题","slug":"20200828_2017蓝桥杯日期问题","date":"2020-08-28T15:17:42.000Z","updated":"2020-08-28T15:17:42.000Z","comments":true,"path":"2020/08/28/20200828_2017蓝桥杯日期问题/","permalink":"https://zgg2001.github.io/2020/08/28/20200828_2017%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%97%A5%E6%9C%9F%E9%97%AE%E9%A2%98/","excerpt":"这是2017年蓝桥杯C语言省赛B组的第七题","text":"这是2017年蓝桥杯C语言省赛B组的第七题 题目描述小明正在整理一批历史文献。这些历史文献中出现了很多日期。小明知道这些日期都在1960年1月1日至2059年12月31日。令小明头疼的是，这些日期采用的格式非常不统一，有采用年&#x2F;月&#x2F;日的，有采用月&#x2F;日&#x2F;年的，还有采用日&#x2F;月&#x2F;年的。更加麻烦的是，年份也都省略了前两位，使得文献上的一个日期，存在很多可能的日期与其对应。比如02&#x2F;03&#x2F;04，可能是2002年03月04日、2004年02月03日或2004年03月02日。给出一个文献上的日期，你能帮助小明判断有哪些可能的日期对其对应吗？ 输入一个日期，格式是”AA&#x2F;BB&#x2F;CC”。 (0 &lt;&#x3D; A, B, C &lt;&#x3D; 9) 输出输出若干个不相同的日期，每个日期一行，格式是”yyyy-MM-dd”。多个日期按从早到晚排列。 样例输入02&#x2F;03&#x2F;04 样例输出2002-03-042004-02-032004-03-02 OJ链接 思路： 本来刚看见这道题，我还觉得很简单。。。但是一写发现情况很复杂，需要判定的东西很多，果然好歹也是偏后面的题，不会太简单。 我的思路就是主函数进行接收数据，然后在主函数里数据排序后，利用一个judge函数进行判定日期是否合法，如果合法就输出。 judge函数判定主要为：月是否合理、根据月份判断日是否合理（首先要判断是不是30&#x2F;31天的月，如果是2月则要判定是不是闰年，随后看日期是否超限）。 随后需要注意的是，相同日期只用输出一次，所以在主函数里我们需要判定judge函数的传参是否相同，如果相同就说明是相同日期，输出一次即可。 AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;using namespace std;void judge(int a,int b,int c)//判断是否合理 合理即输出 &#123; if(b&lt;1||b&gt;12)//月超标 pass return; if(c&lt;1||c&gt;31)//日超标 pass return; if((b==1||b==3||b==5||b==7||b==8||b==10||b==12)&amp;&amp;c&gt;31)//如果是 1 3 5 7 8 10 12月 并且日期大于31 pass return; if((b==4||b==6||b==9||b==11)&amp;&amp;c&gt;30)//如果是 4 6 9 11 月 并且日期大于30 pass return; if(b==2)//如果是2月就判断是不是闰年 &#123; if(a%400==0||(a%4==0&amp;&amp;a%100!=0))//是闰年 &#123; if(c&gt;29)//大于29天 pass return; &#125; else &#123; if(c&gt;28)//大于28天 pass return; &#125; &#125; printf(&quot;%d-%02d-%02d\\n&quot;,a,b,c);//成功输出 &#125;int main()&#123; int a,b,c,a1,c1; scanf(&quot;%d/%d/%d&quot;,&amp;a,&amp;b,&amp;c); a1=a; c1=c; if(a&lt;=59)//加100方便比较 a1+=100; if(c&lt;=59) c1+=100; /* 三种情况 a b c 年 月 日 （1） 月 日 年 （2) 日 月 年 (3) */ if(a1&lt;c1)//a小于c的话 先输出（1） 再（2）（3） &#123; judge(1900+a1,b,c);//判断是否合理 合理即输出 int max_temp = max(a,b);//取b,c最大值和最小值 int min_temp = min(a,b); judge(1900+c1,min_temp,max_temp);//按从小到大 输出（2）（3） if(max_temp!=min_temp)//防止重复输出 judge(1900+c1,max_temp,min_temp); &#125; else if(a1==c1)//只有一个年份 &#123; if(a==b)//三数相等就只输出一次 judge(1900+a1,b,c); else//否则按顺序输出 &#123; int max_temp = max(a,b);//取b,c最大值和最小值 int min_temp = min(a,b); judge(1900+a1,min_temp,max_temp); judge(1900+c1,max_temp,min_temp); &#125; &#125; else//先输出（2）（3）再（1） &#123; int max_temp = max(a,b);//取b,c最大值和最小值 int min_temp = min(a,b); judge(1900+c1,min_temp,max_temp);//按从小到大 输出（2）（3） if(max_temp!=min_temp)//防止重复输出 judge(1900+c1,max_temp,min_temp); judge(1900+a1,b,c);//判断是否合理 合理即输出 （1） &#125; return 0;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://zgg2001.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}]},{"title":"2018 蓝桥杯 日志统计 尺取法","slug":"20200827_2018蓝桥杯日志统计尺取法","date":"2020-08-27T03:09:37.000Z","updated":"2020-08-27T03:09:37.000Z","comments":true,"path":"2020/08/27/20200827_2018蓝桥杯日志统计尺取法/","permalink":"https://zgg2001.github.io/2020/08/27/20200827_2018%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%97%A5%E5%BF%97%E7%BB%9F%E8%AE%A1%E5%B0%BA%E5%8F%96%E6%B3%95/","excerpt":"这是2018年蓝桥杯C语言省赛B组的第八题","text":"这是2018年蓝桥杯C语言省赛B组的第八题 题目描述小明维护着一个程序员论坛。现在他收集了一份”点赞”日志，日志共有N行。其中每一行的格式是：ts id。表示在ts时刻编号id的帖子收到一个”赞”。现在小明想统计有哪些帖子曾经是”热帖”。如果一个帖子曾在任意一个长度为D的时间段内收到不少于K个赞，小明就认为这个帖子曾是”热帖”。具体来说，如果存在某个时刻T满足该帖在[T, T+D)这段时间内(注意是左闭右开区间)收到不少于K个赞，该帖就曾是”热帖”。给定日志，请你帮助小明统计出所有曾是”热帖”的帖子编号。 输入第一行包含三个整数N、D和K。以下N行每行一条日志，包含两个整数ts和id。1 &lt;&#x3D; K &lt;&#x3D; N &lt;&#x3D; 100000 0 &lt;&#x3D; ts &lt;&#x3D; 100000 0 &lt;&#x3D; id &lt;&#x3D; 100000 输出按从小到大的顺序输出热帖id。每个id一行。 样例输入7 10 20 10 1010 1010 19 1100 3100 3 样例输出13 OJ链接 思路：我的思路是一个二维数组储存每个id的点赞时间，即maps[id][]&#x3D;ts。然后根据maps数组对每个id运用尺取法进行条件判定，如果符合要求就是答案。为了减少对数组的搜索，我引入了一个set用来储存出现过的id号，然后对出现过的id号关联的数组进行查询即可。 尺取法： 我认为就是在一个连续的集合里，设定一个子集的首位位置和末尾位置，然后不断的推进首尾位置，寻找符合条件的子集。因为这题要计算相差的时间，所以数据必须是有序的，所以下面的代码中我使用了sort对maps数组进行排序。 AC代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt;maps[100001]; //二维数组储存每个节点的被点赞的时间 maps[x][0]就是x号帖子第一次被点赞的时间 set&lt;int&gt;alls; //储存出现的帖子编号 与maps配合 避免不必要的查询 直接maps[alls][]就行 int main()&#123; int n,d,k,ts,id; scanf(&quot;%d %d %d&quot;,&amp;n,&amp;d,&amp;k); while(n--) &#123; scanf(&quot;%d %d&quot;,&amp;ts,&amp;id); alls.insert(id); //储存出现的id号 maps[id].push_back(ts); //将点赞时间储存至maps[id][] &#125; for(set&lt;int&gt;::iterator iter=alls.begin();iter!=alls.end();iter++) //对整个maps[alls][]数组进行排序 方便后面的时间统计 &#123; sort(maps[*iter].begin(),maps[*iter].end()); //对有数据的数组进行排序 即 maps[alls][] &#125; for(set&lt;int&gt;::iterator iter=alls.begin();iter!=alls.end();iter++) //对有数据的maps数组进行查找 &#123; int all=0,first=0,end=0; //点赞数量 第一个赞的位置 最后一个赞的位置 while(1) //尺取法 &#123; while(all&lt;k&amp;&amp;end&lt;maps[*iter].size()) //点赞数小于要求 &amp;&amp; 数组里的数据还没有统计完 &#123; all++; end++; &#125; if(all&lt;k) //统计完了 赞也不够 break; if(maps[*iter][end-1]-maps[*iter][first]&lt;d) //赞够 并且 第一个赞和末尾赞的时间相隔符合要求 &#123; printf(&quot;%d\\n&quot;,*iter); //由于set有序 所以直接输出即可 break; &#125; all--; first++; &#125; &#125; return 0;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://zgg2001.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}]},{"title":"2018 蓝桥杯 全球变暖(dfs) 深度优先遍历写法","slug":"20200826_2018蓝桥杯全球变暖(dfs)深度优先遍历写法","date":"2020-08-26T02:44:25.000Z","updated":"2020-08-26T02:44:25.000Z","comments":true,"path":"2020/08/26/20200826_2018蓝桥杯全球变暖(dfs)深度优先遍历写法/","permalink":"https://zgg2001.github.io/2020/08/26/20200826_2018%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%85%A8%E7%90%83%E5%8F%98%E6%9A%96(dfs)%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E5%86%99%E6%B3%95/","excerpt":"这是2018年蓝桥杯C语言省赛B组的第九题","text":"这是2018年蓝桥杯C语言省赛B组的第九题 题目你有一张某海域NxN像素的照片，”.”表示海洋、”#”表示陆地，如下所示： 其中”上下左右”四个方向上连在一起的一片陆地组成一座岛屿。例如上图就有2座岛屿。由于全球变暖导致了海面上升，科学家预测未来几十年，岛屿边缘一个像素的范围会被海水淹没。具体来说如果一块陆地像素与海洋相邻(上下左右四个相邻像素中有海洋)，它就会被淹没。例如上图中的海域未来会变成如下样子： 请你计算：依照科学家的预测，照片中有多少岛屿会被完全淹没。 输入第一行包含一个整数N。 (1 &lt;&#x3D; N &lt;&#x3D; 1000)以下N行N列代表一张海域照片。照片保证第1行、第1列、第N行、第N列的像素都是海洋。 输出一个整数表示答案。 样例输入样例输出1 OJ链接 思路：在接收初始图之后，首先搜索查找初始岛屿数，在找到一个岛屿后，对整个岛屿进行标记，防止重复计数。随后再次进行搜索，如果有四周均为陆地的坐标，则标记此坐标未被淹没。最后查找所有未被淹没的坐标，并将坐标所处的整个岛标记，防止重复计数。初始岛屿数量减去未被淹没岛的数量，即为被淹没的岛的数量。 AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;bits/stdc++.h&gt;using namespace std;char maps[1001][1001];void dfs1(int x,int y)&#123; if(maps[x][y]!=&#x27;#&#x27;) return; maps[x][y]=&#x27;1&#x27;;//将#标记为1 dfs1(x+1,y);//把整个岛都进行标记 防止重复计算 dfs1(x-1,y); dfs1(x,y+1); dfs1(x,y-1);&#125; void dfs2(int x,int y)&#123; if(maps[x][y]==&#x27;.&#x27;) return; if(maps[x+1][y]==&#x27;1&#x27;&amp;&amp;maps[x-1][y]==&#x27;1&#x27;&amp;&amp;maps[x][y+1]==&#x27;1&#x27;&amp;&amp;maps[x][y-1]==&#x27;1&#x27;)//四周都是陆地 则标记为2 &#123; maps[x][y]=&#x27;2&#x27;; &#125; dfs1(x+1,y);//找4个方向 dfs1(x-1,y); dfs1(x,y+1); dfs1(x,y-1);&#125; void dfs3(int x,int y)&#123; if(maps[x][y]==&#x27;.&#x27;) return; maps[x][y]=&#x27;.&#x27;;//将#标记为 . dfs3(x+1,y);//把整个岛都进行沉没操作 防止重复计算 dfs3(x-1,y); dfs3(x,y+1); dfs3(x,y-1);&#125; int main()&#123; int n,first_num=0,end_num=0;//层数 初始岛屿数量 末尾岛屿数量 scanf(&quot;%d&quot;,&amp;n); for(int a=1;a&lt;=n;a++) &#123; for(int b=1;b&lt;=n;b++) &#123; while(1) &#123; scanf(&quot;%c&quot;,&amp;maps[a][b]); if(maps[a][b]==&#x27;.&#x27;||maps[a][b]==&#x27;#&#x27;) break; &#125; &#125; &#125; //先查找有多少个岛屿 for(int a=1;a&lt;=n;a++) &#123; for(int b=1;b&lt;=n;b++) &#123; if(maps[a][b]==&#x27;#&#x27;) &#123; dfs1(a,b); first_num++;//初始岛屿+1 &#125; &#125; &#125; //再对整个岛屿进行变化 for(int a=1;a&lt;=n;a++) &#123; for(int b=1;b&lt;=n;b++) &#123; if(maps[a][b]==&#x27;1&#x27;) &#123; dfs2(a,b); &#125; &#125; &#125; //最后查找剩余多少个岛屿 for(int a=1;a&lt;=n;a++) &#123; for(int b=1;b&lt;=n;b++) &#123; if(maps[a][b]==&#x27;2&#x27;) &#123; dfs3(a,b); end_num++;//最终岛屿+1 &#125; &#125; &#125; cout&lt;&lt;first_num-end_num; return 0;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://zgg2001.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}]},{"title":"2018 蓝桥杯 递增三元组 sort排序","slug":"20200825_2018蓝桥杯递增三元组sort排序","date":"2020-08-25T01:52:19.000Z","updated":"2020-08-25T01:52:19.000Z","comments":true,"path":"2020/08/25/20200825_2018蓝桥杯递增三元组sort排序/","permalink":"https://zgg2001.github.io/2020/08/25/20200825_2018%E8%93%9D%E6%A1%A5%E6%9D%AF%E9%80%92%E5%A2%9E%E4%B8%89%E5%85%83%E7%BB%84sort%E6%8E%92%E5%BA%8F/","excerpt":"这是2018年蓝桥杯C语言省赛B组的第六题","text":"这是2018年蓝桥杯C语言省赛B组的第六题 题目：给定三个整数数组A &#x3D; [A1, A2, … AN],B &#x3D; [B1, B2, … BN],C &#x3D; [C1, C2, … CN]，请你统计有多少个三元组(i, j, k) 满足： 1 &lt;&#x3D; i, j, k &lt;&#x3D; N Ai &lt; Bj &lt; Ck 输入第一行包含一个整数N。第二行包含N个整数A1, A2, … AN。第三行包含N个整数B1, B2, … BN。第四行包含N个整数C1, C2, … CN。1 &lt;&#x3D; N &lt;&#x3D; 100000 0 &lt;&#x3D; Ai, Bi, Ci &lt;&#x3D; 100000 输出一个整数表示答案 样例输入31 1 12 2 23 3 3 样例输出27 OJ链接 思路：先用sort对三个数组进行排序。随后对B数组进行遍历，用lower_bound函数求出A数组中小于B数组当前元素的数量，用upper_bound函数求出C数组中大于B数组当前元素的数量，两者相乘算出B数组当前元素下可行解的数量，把B数组遍历一遍即可求出总解。PS：记得用long long，用int的话会爆。 AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;int a[100001],b[100001],c[100001];int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); for(int now=0;now&lt;n;now++) &#123; scanf(&quot;%d&quot;,&amp;a[now]); &#125; for(int now=0;now&lt;n;now++) &#123; scanf(&quot;%d&quot;,&amp;b[now]); &#125; for(int now=0;now&lt;n;now++) &#123; scanf(&quot;%d&quot;,&amp;c[now]); &#125; sort(a,a+n);//排序 sort(b,b+n); sort(c,c+n); long long ans=0;//记得用long long for(int now=0;now&lt;n;now++)//b为中间值 遍历 &#123; long long s1=lower_bound(a,a+n,b[now])-a;//获取a中小于b【now】的个数 long long s2=n-(upper_bound(c,c+n,b[now])-c);//获取c中大于b【now】的个数 ans+=s1*s2; &#125; cout&lt;&lt;ans; return 0; &#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://zgg2001.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}]},{"title":"并查集学习记录：模板/思路汇总","slug":"20200819_并查集学习记录：模板思路汇总","date":"2020-08-19T05:35:53.000Z","updated":"2020-08-19T05:35:53.000Z","comments":true,"path":"2020/08/19/20200819_并查集学习记录：模板思路汇总/","permalink":"https://zgg2001.github.io/2020/08/19/20200819_%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%80%9D%E8%B7%AF%E6%B1%87%E6%80%BB/","excerpt":"HB小咸鱼学习记录 自我对于“并查集”的理解有时候一些题，是让你判断图中一些数据是否在一个集合中。例如1和3联通，2和3联通，问你1和2是否联通。这其实问的就是1和2是否在一个联通集合里，如果用搜索进行遍历的话，就需要挨个对路径进行尝试，如果数据量大的话，消耗时间就会过多，这时候就可以用并查集来解决问题。","text":"HB小咸鱼学习记录 自我对于“并查集”的理解有时候一些题，是让你判断图中一些数据是否在一个集合中。例如1和3联通，2和3联通，问你1和2是否联通。这其实问的就是1和2是否在一个联通集合里，如果用搜索进行遍历的话，就需要挨个对路径进行尝试，如果数据量大的话，消耗时间就会过多，这时候就可以用并查集来解决问题。 并查集的大致思路并查集的核心操作就是“并”与“查”。“并”指的是将两个数据放到一个集合里，“查”就是查询一个数据在哪个集合里。首先，我们声明一个father数组，数组的值是指向当前下标元素的父节点。其次，我们对这个数组进行初始化，使得当前下标的值是他本身。代表他是自己的父节点，即他是根节点，这个情况下可以看作每个元素都是一个单独的集合。 12345int father[MAX];for(int now=1;now&lt;MAX;now++)//初始化 &#123; father[now]=now;&#125; 接着，我们建立“查”操作，查询某一数据属于哪个集合，就是查询他的根节点。因为我们设定了father数组，所以我们不断查找该数据的父节点，即可知道该数据的根节点。我们如果要查询两个数据是否属于一个集合，即可通过“查”操作获取两个数据的根节点，如果两个数据的根节点相同，则说明两个数属于同一个集合。 12345678910111213141516//第一种写法（递归）//第一种写法可以用三目运算符缩写为 return father[a]==a ? a : find(father[a]);int find(int a)&#123; if(father[a]==a) return a; return find(father[a]);&#125;//第二种写法int find(int a)&#123; int temp = father[a]; while(father[temp]!=temp) temp = father[temp]; return temp;&#125; 最后，我们建立“并”操作，可以将两个集合合并。我们首先获取想要合并的数据A和数据B的根节点。如果根节点相同，则说明两个数据本来就属于一个集合，所以不用进行合并处理；如果根节点不同，则说明两个数据不属于同一个集合，此时我们需要进行合并操作。合并操作很简单，让一个数据的根节点指向另一个数据的根节点即可。 123456789int union_(int a,int b)&#123; int temp_a=find(a); int temp_b=find(b); if(temp_a!=temp_b) &#123; father[temp_a]=temp_b; &#125; &#125; 一些优化 秩优化我们在进行“并”操作时，如果和上面一样，规定无论如何都是数据A往数据B并，那么很有可能大树并小树，导致整个集合的深度增加，最极端的例子是形成了一条链，此时如果find链尾，则会将整个链遍历一遍，时间消耗会大大增加。所以我们在进行“并”操作时，可以获取两个数据所处集合的深度，让深度低的成为深度高的子集。而当深度一样时，则可以看你的喜好进行合并。 12345678910111213141516171819202122int deep[MAX] = &#123;0&#125;;//深度数组，初始深度都为0，储存各个集合的深度 int union_(int a,int b)&#123; int temp_a=find(a); int temp_b=find(b); if(temp_a!=temp_b)//两个数据不在同一个集合 &#123; if(deep[temp_a]&gt;deep[temp_b])//a比b深度高 &#123; father[temp_b]=temp_a;//b成为a的子集 &#125; else if(deep[temp_a]&lt;deep[temp_b])//a比b深度低 &#123; father[temp_a]=temp_b;//a成为b的子集 &#125; else//深度一样 &#123; father[temp_b]=temp_a;//b成为a的子集 deep[temp_a]++;//a的根节点的深度加一 &#125; &#125; &#125; 路径压缩 在我们进行find查询时，如果我们只在乎某数据的根节点，而不在意他的各个父节点时，我们可以进行路径压缩。让这个数据的父节点直接指向根节点，这样被称作“路径压缩”。在进行路径压缩后，所有的节点都指向根节点，这样集合的深度只有1，在之后进行数据的根节点查询时的复杂度只有O(1),大大提升查询速度。 1234567891011121314151617181920212223//第一种写法（递归）//第一种写法可以用三目运算符缩写为 return father[a]==a ? a : father[a] = find(father[a]);int find(int a)&#123; if(father[a]==a) return a; return father[a] = find(father[a]);&#125;//第二种写法int find(int a) &#123; int temp = father[a]; while(father[temp]!=temp) temp = father[temp]; int i=a,j; while(i!=temp) //路径压缩 &#123; j=father[i]; // 在改变上级之前用临时变量j记录下他的值 father[i]=temp; //把上级改为根节点 i=j; &#125; return temp ;&#125; 并查集的大致模板这是秩优化+路径压缩的模板，其余版本看上面的思路模块即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445int father[MAX];//父节点数组int deep[MAX] = &#123;0&#125;;//深度数组，初始深度都为0，储存各个集合的深度 void init()//初始化 &#123; for(int now=1;now&lt;MAX;now++) &#123; father[now]=now; &#125;&#125;int find(int a)//查询&#123; if(father[a]==a) return a; return father[a] = find(father[a]);&#125;int union_(int a,int b)//合并&#123; int temp_a=find(a); int temp_b=find(b); if(temp_a!=temp_b)//两个数据不在同一个集合 &#123; if(deep[temp_a]&gt;deep[temp_b])//a比b深度高 &#123; father[temp_b]=temp_a;//b成为a的子集 &#125; else if(deep[temp_a]&lt;deep[temp_b])//a比b深度低 &#123; father[temp_a]=temp_b;//a成为b的子集 &#125; else//深度一样 &#123; father[temp_b]=temp_a;//b成为a的子集 deep[temp_a]++;//a的根节点的深度加一 &#125; &#125; &#125;int main()&#123; ........ return 0;&#125; 并查集例题1.畅通工程某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？ Input测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( &lt; 1000 )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。注意:两个城市之间可以有多条道路相通,也就是说3 31 21 22 1这种输入也是合法的当N为0时，输入结束，该用例不被处理。 Output对每个测试用例，在1行里输出最少还需要建设的道路数目。 Sample Input4 21 34 33 31 21 32 35 21 23 5999 00 Sample Output102998 题目地址 思路：这题在把所有的数据接收后，运用并查集进行集合合并，最后根节点的个数就是集合的个数。而联通n个节点最少需要n-1条边，故根节点的个数减去1就是建设道路的最少值。由于题中只在乎最后根节点的个数，所有使用了路径压缩，提高代码的运算速度。 AC代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;int father[1001];int find(int a)&#123; return father[a]==a ? a : father[a] = find(father[a]);&#125; int compose(int a,int b)&#123; int temp_a=find(a); int temp_b=find(b); if(temp_a!=temp_b) &#123; father[temp_a]=temp_b; &#125; &#125;int main()&#123; int a,b,c,d; while(scanf(&quot;%d&quot;,&amp;a)&amp;&amp;a) &#123; scanf(&quot;%d&quot;,&amp;b); for(int now=1;now&lt;=a;now++)//初始化 &#123; father[now]=now; &#125; while(b--) &#123; scanf(&quot;%d %d&quot;,&amp;c,&amp;d); compose(c,d); &#125; int ans=0; for(int now=1;now&lt;=a;now++) &#123; if(father[now]==now) ans++; &#125; cout&lt;&lt;ans-1&lt;&lt;endl; &#125; return 0;&#125; 2.修改数组给定一个长度为N 的数组A &#x3D; [A1, A2,…,AN]，数组中有可能有重复出现的整数。现在小明要按以下方法将其修改为没有重复整数的数组。小明会依次修改A2,A3,…, AN。当修改Ai 时，小明会检查Ai 是否在A1~ Ai-1 中出现过。如果出现过，则小明会给Ai 加上1 ；如果新的Ai 仍在之前出现过，小明会持续给Ai 加1 ，直到Ai 没有在A1~Ai-1中出现过。当AN 也经过上述修改之后，显然A数组中就没有重复的整数了。现在给定初始的A 数组，请你计算出最终的A 数组。 输入第一行包含一个整数N(1&lt;&#x3D;N&lt;&#x3D;100000)第二行包含N个整数A1,A2,…,AN(1&lt;&#x3D;Ai&lt;&#x3D;1000000) 输出输出N个整数，依次是最终的A1,A2,…,AN 样例输入 Copy52 1 1 3 4 样例输出 Copy2 1 3 4 5 题目地址 思路：我们可以把用过的数字放到一个集合里，而让他的父节点指向下一个可以用的数字，具体操作就是**father[a]&#x3D;find(father[a]+1)**。这样我们就会一直对使用过的数字的父节点进行加一操作，直到找到一个没有被使用过的数字。由于这题只需要知道该数字是否被使用过，即是否在“被使用过”这个集合里，所以我们可以使用路径压缩，提高运算效率。 AC代码： 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;int father[1000001];int find(int a)&#123; if(father[a]==-1) &#123; father[a]=a; return a; &#125; return father[a]=find(father[a]+1);&#125;int main()&#123; int input,aa; cin&gt;&gt;input; memset(father,-1,sizeof(father)); for(int now=1;now&lt;=input;now++) &#123; cin&gt;&gt;aa; aa=find(aa); cout&lt;&lt;aa&lt;&lt;&quot; &quot;; &#125; return 0;&#125; 3.敌人俗话说得好，敌人的敌人就是朋友。现在有n个人，编号1至n，初始互不相识。接下来有m个操作，操作分为两种： （1）检查x号和y号是否是朋友，若不是，则变成敌人（2）询问x号的朋友有多少个请你针对每个操作中的询问给出回答。 输入第一行两个正整数n、m，表示人的数量和操作的数量。接下来m行，依次描述输入。每行的第一个整数为1或2表示操作种类。对于操作（1），随后有两个正整数x，y。对于操作（2），随后一个正整数x。 输出输出包含m行，对于操作（1），输入’N’或”Y”，’N’表示x和y之前不是朋友，’Y’表示是朋友。对于操作（2），输出x的朋友数量。 输入示例5 81 1 21 1 31 2 32 31 4 52 31 1 42 3 输出示例NNY1N1N2 思路：这道题相比之前的题，一个不同的特点就是我们无法直接将两个数据放进同一个集合，因为输入的数据要变为“敌人”关系，即不在同一个集合内。那么我们如何能将两个数据放进同一个集合呢？我们可以扩大father数组，使它是原来的两倍大。假如一共有N个数，则1到N代表本身，N+1到2N则代表1到N的敌人。当我们设定两个数是敌人的时候，只需要把第一个数据和第二个数据的敌人放在一个集合，第二个数据和第一个数据的敌人防在一个集合，即可完成合并的操作。因为当和一个数的敌人是朋友时，那和这个数就是敌人。当查询一个数的朋友时，遍历查询与其根节点相同的点的个数，再减去一（它本身），即为朋友的个数。本题由于也是只看根节点，所以可以使用路径压缩。 AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;int father[600001];//最大300000个数 数的敌人也有300000个 故一共600000int find(int a)//查询&#123; return father[a]==a ? a : father[a] = find(father[a]);&#125;int compose(int a,int b)//合并&#123; int temp_a=find(a); int temp_b=find(b); if(temp_a!=temp_b) &#123; father[temp_a]=temp_b; &#125;&#125;int main()&#123; int input1,input2,a,b,c; cin&gt;&gt;input1&gt;&gt;input2; for(int now=1;now&lt;=input1*2;now++)//初始化 &#123; father[now]=now; &#125; for(int now=0;now&lt;input2;now++)//接收初始值 &#123; cin&gt;&gt;a; if(a==1)//1操作 &#123; cin&gt;&gt;b&gt;&gt;c; if(find(b)==find(c))//是朋友 &#123; cout&lt;&lt;&quot;Y&quot;&lt;&lt;endl; &#125; else &#123; compose(b,c+input1);//将输入的第一个数据和第二个数据的敌人放在一个集合里 compose(c,b+input1);//将输入的第二个数据和第一个数据的敌人放在一个集合里 cout&lt;&lt;&quot;N&quot;&lt;&lt;endl; &#125; &#125; else if(a==2)//2操作 &#123; cin&gt;&gt;b; int ans=0; /*for(int now=1;now&lt;=input1*2;now++) &#123; cout&lt;&lt;father[now]&lt;&lt;&quot; &quot;; &#125;*/ for(int now=1;now&lt;=input1;now++)//如果根节点相同则说明在同一集合，是朋友 &#123; if(find(b)==find(now)) ans++; &#125; cout&lt;&lt;ans-1&lt;&lt;endl; &#125; &#125; return 0;&#125; 4.食物链有N只动物分别编号为1，2，……，N。所有动物都属于A，B，C中的一类。已知A能吃掉B，B能吃掉C，C能吃掉A。按顺序给出下面的两种信息共K条： 第一种：x和y属于同一类； 第二种：x吃y。然而这些信息可能会出错，有可能有的信息和之前给出的信息矛盾，也有的信息可能给出的x和y不在1到N的范围内。求在K条信息中有多少条是不正确的。计算过程中，我们将忽视诸如此类的错误信息。 输入第一行两个自然数，两数间用一个空格分隔，分别表示N和K，接下来的K行，每行有三个数，第一个数为0或1，分别对应第一种或第二种，接着的两个数，分别为该条信息的x和y，三个数两两之间用一个空格分隔。 输出一个自然数，表示错误信息的条数。 输入示例100 70 101 11 1 21 2 31 3 30 1 31 3 10 5 5 输出示例3 思路：与上一题“敌人”相似，这一题也可以通过扩展数组建立多重关系来做。这一题存在同类、吃、被吃这三个关系。所以我们把数组扩到到原来的三倍，1到N代表本身，N+1到2N代表被“本身”吃的，2N+1到3N代表吃“本身”的。当我们建立0操作的“A和B同类”关系时，只需要把三个区域同等合并即可，即A本身和B本身合并为一类，A吃的和B吃的合并为一类，吃A的和吃B的合并为一类，即可说明A和B地位相同。当我们建立1操作的“A吃B”关系时，将B和A吃的划为一类，B吃的和吃A的划为一类，A和吃B的划为一类，即可实现A吃B关系网的建立。而当输入超限、在0操作时判断出A和B是吃或被吃关系、在1操作时判断出A和B是同类或被吃关系时，即为语句错误，答案数量加一。由此结束时输出即可。 AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;using namespace std;int father[150001];int find(int a)&#123; return father[a]==a ? a : father[a] = find(father[a]);&#125;int compose(int a,int b)&#123; int temp_a=find(a); int temp_b=find(b); if(temp_a!=temp_b) &#123; father[temp_a]=temp_b; &#125;&#125;int main()&#123; int input1,input2,a,b,c,ans=0; cin&gt;&gt;input1&gt;&gt;input2; for(int now=1;now&lt;=input1*3;now++)//初始化 &#123; father[now]=now; &#125; for(int now=0;now&lt;input2;now++)//接收初始值 &#123; cin&gt;&gt;a; if(a==0)//输入0 x与y同类 &#123; cin&gt;&gt;b&gt;&gt;c; if(b&gt;input1||b&lt;1||c&gt;input1||c&lt;1)//输入不合法 &#123; ans++; continue; &#125; else &#123; if(find(b)==find(c+input1)||find(b)==find(c+2*input1))//如果属于吃或者被吃关系 &#123; ans++; continue; &#125; else//指向平级，代表同类 &#123; compose(b,c); compose(b+input1,c+input1); compose(b+input1*2,c+input1*2); &#125; &#125; &#125; else if(a==1)//输入1 x吃y &#123; cin&gt;&gt;b&gt;&gt;c; if(b&gt;input1||b&lt;1||c&gt;input1||c&lt;1)//输入不合法 &#123; ans++; continue; &#125; else &#123; if(find(b)==find(c)||find(b)==find(c+input1))//属于同一类或者被吃关系 &#123; ans++; continue; &#125; else &#123; compose(b+input1,c);//b吃的 和 c一类 即 b吃c compose(b+input1*2,c+input1);//吃b的 和 c吃的一类 compose(b,c+input1*2);//b 和 吃c的一类 &#125; &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl;//结果 return 0;&#125; 5. 网络分析时间限制: 1.0s 内存限制: 256.0MB 本题总分：25 分问题：小明正在做一个网络实验。他设置了 n 台电脑，称为节点，用于收发和存储数据。初始时，所有节点都是独立的，不存在任何连接。小明可以通过网线将两个节点连接起来，连接后两个节点就可以互相了。两个节点如果存在网线连接，称为相邻。小明有时会测试当时的网络，他会在某个节点发送一条信息，信息会到每个相邻的节点，之后这些节点又会转发到自己相邻的节点，直到所有或间接相邻的节点都收到了信息。所有发送和接收的节点都会将信息存储一条信息只存储一次。给出小明连接和测试的过程，请计算出每个节点存储信息的大小。 输入：输入的第一行包含两个整数 n, m，分别表示节点数量和操作数量。节1 至 n 编号。接下来 m 行，每行三个整数，表示一个操作。如果操作为 1 a b，表示将节点 a 和节点 b 通过网线连接起来。当 时，表示连接了一个自环，对网络没有实质影响。如果操作为 2 p t，表示在节点 p 上发送一条大小为 t 的信息。 输出：输出一行，包含 n 个整数，相邻整数之间用一个空格分割，依次表示完上述操作后节点 1 至节点 n 上存储信息的大小。 样例输入：4 81 1 22 1 102 3 51 4 12 2 21 1 21 2 42 2 1 样例输出：13 13 5 3 评测用例规模与约定：对于 30% 的评测用例，1 ≤ n ≤ 20，1 ≤ m ≤ 100。对于 50% 的评测用例，1 ≤ n ≤ 100，1 ≤ m ≤ 1000。对于 70% 的评测用例，1 ≤ n ≤ 1000，1 ≤ m ≤ 10000。对于所有评测用例，1 ≤ n ≤ 10000，1 ≤ m ≤ 100000，1 ≤ t ≤ 100。 思路： 核心思路是并查集。一个数组用来存旧值，一个数组用来存根结点权值，一个数组是并查集的father数组。执行2操作时，查集寻找到操作值的根结点并加权。执行1操作时，若两数在一个集内则不操作；若两数不在一个集内，则对所有节点进行遍历，使他们的旧值数组加上其根节点的权值，随后进行并集操作。记得对权值数组进行清零，防止后面重复计算。 AC代码： OJ链接 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;int old_[10001],new_[10001],father[10001],n,m;//存老值 存根节点新值 父节点数组 int find(int a)&#123; return father[a]==a ? a : father[a]=find(father[a]);//路径压缩&#125;void union_(int a,int b)&#123; int temp_a=find(a),temp_b=find(b); if(temp_a!=temp_b) &#123; for(register int now=1;now&lt;=n;now++) &#123; old_[now]+=new_[find(now)];//旧值数组遍历加上权值 &#125; memset(new_,0,sizeof(new_));//重置权值数组，防止重复计算 father[temp_a]=temp_b; &#125;&#125;int main()&#123; int a,b,c; memset(new_,0,sizeof(new_)); for(register int now=1;now&lt;=10000;now++) &#123; father[now]=now;//father数组初始化 &#125; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); while(m--) &#123; scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c); if(a==1) &#123; union_(b,c); &#125; else &#123; new_[find(b)]+=c; &#125; &#125; for(register int now=1;now&lt;=n;now++) &#123; printf(&quot;%d &quot;,old_[now]+new_[find(now)]); &#125; return 0;&#125; 小结在使用并查集中，要根据题目数据选择合适的优化。一般都得用路径压缩提高效率，但是秩优化用的比较少（我感觉），因为在进行路径压缩后秩优化后的结构就不复存在的，我感觉二者是有点矛盾的。但是两者一起使用相较于只使用路径压缩也会在第一次接收数据时提高一点效率，但是为了敲代码的效率，我还是喜欢只敲路径压缩。使用并查集时，要选择合适的数据结构例如秩优化时的储存深度的数组、例题第三题“敌人”的长数组、以及涉及带权并查集的结构。总之，还是得多刷题，多积累经验。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"bfs学习记录：模板/思路汇总","slug":"20200814_bfs学习记录：模板思路汇总","date":"2020-08-14T14:19:12.000Z","updated":"2020-08-14T14:19:12.000Z","comments":true,"path":"2020/08/14/20200814_bfs学习记录：模板思路汇总/","permalink":"https://zgg2001.github.io/2020/08/14/20200814_bfs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%80%9D%E8%B7%AF%E6%B1%87%E6%80%BB/","excerpt":"HB小咸鱼学习记录 一点看法蓝桥杯刷了不少的搜索题，但是bfs的题很少，大部分都是dfs的题。但是去年蓝桥杯就考了bfs，所以还是得好好刷题。bfs由于是一个循环进行搜索，所以没法回溯，因而每个点位只能被走一次。这样加快了搜索速度，但是由于每个点只能走一次导致无法列举出所有的可走路径。而这样的好处是避免了绕远路，搜索到结果时一定是最短路。所以大部分的求最短路的题都用bfs.","text":"HB小咸鱼学习记录 一点看法蓝桥杯刷了不少的搜索题，但是bfs的题很少，大部分都是dfs的题。但是去年蓝桥杯就考了bfs，所以还是得好好刷题。bfs由于是一个循环进行搜索，所以没法回溯，因而每个点位只能被走一次。这样加快了搜索速度，但是由于每个点只能走一次导致无法列举出所有的可走路径。而这样的好处是避免了绕远路，搜索到结果时一定是最短路。所以大部分的求最短路的题都用bfs. 自我对于“广度优先搜索”的理解bfs,字面来看就是以广度为优先的搜索方式。搜索时以原点向四周扩散。如果说dfs是“搜完一个屋子再搜另一个屋子”，那bfs就是“把每个屋子的柜子搜了再搜每个屋子的桌子……”这样层层深入的搜索。这样可以优先搜索物品可能在的地方，从而减少搜索的时间。就像我们规定以“前左右”的顺序走迷宫，而在寻找迷宫的出口时就可以看成进行了一次搜索。我们首先记录下来第一个路口能前往哪几个路口，随后再按照规定的顺序（前左右）查看这几个路口的又能前往哪几个路口。途中前往过的路口要进行标记，防止重复的查看。直到查看一个路口，它可以前往到终点或者它就是终点，此时搜索结束。我们查看的轮数就是前往该终点的最小步数。而在搜索过程中，我们可以使用适当的数据结构来储存前往终点所经过的路口，这就是最短路径。这样进行搜索的范围大，查找到终点的路径始终是最短路径。但缺点是我们没办法迭代出所有的可前往终点的路径。 bfs的大致思路首先，如上个片段所说，我们首先需要一个二维数组，来对迷宫进行标记，标记出可以走的点和障碍（不可以走的点）。其次，我们建立一个队列，把起点加入到队列中。接着，我们建立一个while循环，设定在队列不为空的时候执行循环。循环中，我们首先获取队列的头结点坐标，随后我们需要对移动的规则进行规定。例如上文的例子规定的“上左右”，我们可以用一个二维数组来储存移动后坐标的变化： 1int direction[4][2] = &#123;&#123;0,-1&#125;,&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,1&#125;&#125;; 这个数组里面的四组数据就分别代表“上左右下”，在对坐标变换时进行 12int x1=x+direction[a][0];int y1=y+direction[a][1]; 即可实现对坐标的变化。我们按照这个顺序，对头结点的周围进行判断，如果可以前往的话，就将变换后的数据点加入队列。然后将新点（x1,y1）的状态进行更改，代表你已经来过这里了。防止重复的搜索。最后，我们需要设定上一步循环的中止条件，从而在找到出口时停止或者返回一些信息。我们常常在循环中获取头结点后进行判定，如果头结点数据是我们想要搜索到的信息，我们就中止循环。 bfs的大致模板1234567891011121314151617181920void BFS(传入的数据)&#123; queue&lt;int&gt;q; //建立一个队列 q.push(初始坐标); //把头结点（初始点）加入队列 while(队列不为空) &#123; top = q.front(); //取出队首元素top if(队首元素top就是你要搜索的目标) &#123; 执行一些操作 return; &#125; top.pop(); //将队首元素出队； for(按顺序寻找top的所有子节点) &#123; 把可以前往的子节点入队 标记入队的子节点，防止下次重复入队 &#125; &#125;&#125; bfs例题蓝桥杯 学霸的迷宫样例输入Input Sample 1:3 3001100110样例输出Output Sample 1:4RDRD 题目链接 这一题算是bfs的经典例题，题目不止让求了最短的步数，还让输出了最短的路径。所以我们在队列结点的数据结构中添加了一个string字符串，用来储存到达某个点的最短路径。在找到终点时，输出最短步数和最短路径即可。ac代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt; using namespace std;struct data //队列里的数据结构 &#123; int x; //坐标x int y; //坐标y int times; //步数 string road; //走过的路径 data(int a,int b,int d,string c) //构造函数 &#123; x=a; y=b; times=d; road = c; &#125; &#125;;queue&lt;data&gt;datas; //队列用来存放点位数据 bool maps[501][501]; //存放迷宫地图的点位 false代表可前往 true代表不可前往 char fx[] = &#123;&#x27;D&#x27;,&#x27;L&#x27;,&#x27;R&#x27;,&#x27;U&#x27;&#125;; //方向ascii码从小到大排列 int site[4][2] = &#123;&#123;0,1&#125;,&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;&#125;; //下 左 右 上的坐标变化 void bfs(int n,int m) //传参为迷宫的大小 n为宽 m为长 &#123; datas.push(data(1,1,0,&quot;&quot;)); //把起始点压入队列 maps[1][1]=true; //标记初始点已走过 while(!datas.empty()) //如果队列不为空 &#123; data now = datas.front(); //声明一个结构体变量 让now变量指向队列的头结点 datas.pop(); //弹出头结点 //cout&lt;&lt;now.x&lt;&lt;&quot; &quot;&lt;&lt;now.y&lt;&lt;endl; if(now.x==n&amp;&amp;now.y==m) //如果头结点就是要找的点 就搜索结束 &#123; cout&lt;&lt;now.times&lt;&lt;endl&lt;&lt;now.road&lt;&lt;endl; //输出走过的路径 和步数 return; &#125; for(int temp=0;temp&lt;4;temp++) //开始查找该点的四周点位 （因为只有上下左右4个走法 所以循4次 &#123; int x1=now.x+site[temp][0]; //变换过的x坐标 int y1=now.y+site[temp][1]; //变换过的y坐标 if(maps[y1][x1]) //如果该点已经走过或者有障碍 跳过 continue; if(x1&lt;1||y1&lt;1||x1&gt;n||y1&gt;m) //如果坐标超出范围 就跳过此循环 continue; datas.push(data(x1,y1,now.times+1,now.road+fx[temp])); //把新点位压入队列 路径加上新选择的fx[temp] maps[y1][x1] = true; //标记已走过 &#125; &#125; &#125;int main()&#123; memset(maps,false,sizeof(maps)); //初始化 int x,y; //接收迷宫大小 char input; cin&gt;&gt;y&gt;&gt;x; getchar(); for(int y1=1;y1&lt;=y;y1++) //迷宫长 &#123; for(int x1=1;x1&lt;=x;x1++) //迷宫宽 &#123; cin&gt;&gt;input; if(input==&#x27;1&#x27;) maps[y1][x1]=true; //如果输入是1就标记不可走 &#125; getchar(); &#125; bfs(x,y); //bfs 迷宫长宽 与 xy坐标是相反的 所以传反着的坐标 return 0;&#125; 小结在使用bfs中，要根据题目数据选择合适的数据类型。bfs的题中往往不会只让你输出最短路径的长度，一般还会带点别的东西，所以要建立合适的结构来储存数据。bfs的常用环境一般是用来寻找不带权值的图的最短路。问题关键词常为“能否到达”、“最短路径”。目前来看蓝桥杯中对bfs的考察度往往低于dfs，但是蓝桥杯最近几年对bfs的考察也在变多，所以还得好好练。总之，还是得多刷题，多积累经验。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"dfs学习记录：模板/思路汇总","slug":"20200813_dfs学习记录：模板思路汇总","date":"2020-08-13T10:37:50.000Z","updated":"2020-08-13T10:37:50.000Z","comments":true,"path":"2020/08/13/20200813_dfs学习记录：模板思路汇总/","permalink":"https://zgg2001.github.io/2020/08/13/20200813_dfs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%80%9D%E8%B7%AF%E6%B1%87%E6%80%BB/","excerpt":"HB小咸鱼学习记录 因为疫情，大一在校半年便草草结束了，大二转眼将至。疫情期间在家没事便抽空预习了预习大二要学的数据结构。思来想去还是决定把学习的过程记录下来，方便自己以后查阅或者总结。","text":"HB小咸鱼学习记录 因为疫情，大一在校半年便草草结束了，大二转眼将至。疫情期间在家没事便抽空预习了预习大二要学的数据结构。思来想去还是决定把学习的过程记录下来，方便自己以后查阅或者总结。 一点看法在我看来，计算机的一大优势便是计算速度快。由此，人们在对某些问题的计算方面上，就不用像高斯找到1加到100的特殊技巧那样费力寻找技巧，直接依靠着计算机的计算力从1直接加到100就好。这种不需要技巧的运算方式就是暴力运算。而当你需要对图进行搜索的时候，最基础的就是暴力搜索。就我目前的接触而言，常见的暴力搜索方式便是深度优先遍历与广度优先遍历了。 自我对于“深度优先搜索”的理解dfs,字面来看就是以深度为优先的搜索方式。用通俗点来讲就是一条道走到黑。就像我们规定以“前左右”的顺序走迷宫，而在寻找迷宫的出口时就可以看成进行了一次搜索。这样首先便是一直向前走下去。直到前面没有路了，我们就按照“前左右”再向左走，要是左边还走不通就再向右走直到走到死胡同里。当走到死胡同里的时候说明我们走完了一条迷宫的支线，此时我们可以认为自己单刀直入了这条支线的最深处。此时我们还需要找迷宫的出口，于是我们后退到上一个交叉路口的位置，按照“前左右”的顺序寻找一个没有进入过的支线。如果这个路口的支线已经全部走过，则再次后退到上一个交叉路口进行搜索 ……直到找到出口。由此看来，如果运气好，我们第一次走便可能直接走到出口；但是运气差的话，可能把整个迷宫走完才能找到出口。 dfs的大致思路首先，如上个片段所说，我们首先需要一个二维数组，来储存迷宫的大致情况，包括可以走的路、障碍物、入口、出口……其次，我们对于已经走过的分叉路口要进行标记，防止进入已经进入过的路口，就像在走迷宫时你会主动避开走过的路线一样。这个通常用一个与上面地图大小相同的二维数组来储存坐标的状态。例如false代表没走过，true代表走过。接着，我们需要对移动的规则进行规定。例如上文的例子规定的“上左右”，我们可以用一个二维数组来储存移动后坐标的变化： 1int direction[4][2] = &#123;&#123;0,-1&#125;,&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,1&#125;&#125;; 这个数组里面的四组数据就分别代表“上左右下”，在对坐标变换时进行 12int x1=x+direction[a][0];int y1=y+direction[a][1]; 即可实现对坐标的变化。且在变化后将x1,y1的点的状态进行更改，代表你已经来过这里了。而当你到达死路进行后退且前往别的点的时候，记得把刚来过的点的状态进行更改，使下一次也能前往。最后，我们需要进行判定，从而在找到出口时停止或者返回一些信息。 dfs的大致模板123456789101112131415161718192021void dfs(当前点位的信息)&#123; if(到达中止条件) &#123; 执行一些东西; return; &#125; if(当前点位越界或者不符合规定)//即进行剪枝 return; for(按照搜索的方向进行循环) &#123; 根据当前点位进行修改得到新点位; if(新点位可以前往) &#123; 执行一些东西; 把新点位标记; dfs(新点位的信息); 取消新点位的标记; &#125; &#125; &#125; 按照上面的思路大致可写以下代码： 123456789101112131415161718192021222324int map[100][100]; //地图 其中值为0则代表可走 bool b_map[100][100]; //点状态集 值为false代表没被走过 true代表被走过 int direction[4][2] = &#123;&#123;0,-1&#125;,&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,1&#125;&#125;; //搜索方向坐标变化集 int X,Y; //终点坐标 void dfs(int x,int y,int times) //传入当前点的x,y坐标以及走的次数 &#123; if(x==X&amp;&amp;y==Y) //当走到出口时 &#123; std::cout&lt;&lt;times&lt;&lt;&quot;\\n&quot;; //输出走的步数 return; &#125; for(int a=0;a&lt;4;a++) //对搜索方向进行遍历 &#123; int x1=x+direction[a][0]; //x加上当前搜索方向的变化 int y1=y+direction[a][1]; //y加上当前搜索方向的变化 if(!map[x1][y1]&amp;&amp;!b_map[x1][y1]) //判定x1,y1点是否可走 &#123; b_map[x1][y1] = true; //可走的话就标记以走过 dfs(x1,y1,time+1); //递归 传入新点位的坐标 以及走的次数加一 进行下一个坐标点的判定 b_map[x1][y1] = false; //取消标记 表示该线路以及搜索完毕 &#125; &#125; &#125; dfs的相关例题dfs虽然搜索细致，但是在搜索过程中会进行大量的无意义运算，浪费时间，于是在运算中就要进行“剪枝”，即根据所求信息增加判定要求，从而最大限度的减少递归的调用次数，加快运算时间。 1.蓝桥杯 迷宫OJ链接 思路： 在这道蓝桥杯的题目里，由于是求最短路径，所以用bfs来写比较简单。用dfs来写的话由于数据过大，不剪枝或者剪的不够的话稳稳的超时。但是我们可以引入一个与图一样大小的二维数组，该数组用来储存到达该点的最小步数。则如果在递归中，当前步数大于当前点的最小步数，说明到达当前点多走歪路了，则中止递归。在该条件的约束下，该dfs的运算效率得到了极大的提升。 AC代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;using namespace std;#define X 30#define Y 50 int a_map[31][51],ans=100000000,zhj=100000000;bool b_map[31][51];char fx[10000];char t_fx[10000];int z_4[4][2] = &#123;&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125;,&#123;-1,0&#125;&#125;; char z[4] = &#123;&#x27;D&#x27;,&#x27;L&#x27;,&#x27;R&#x27;,&#x27;U&#x27;&#125;;int dp[31][51];void dfs(int x,int y,int time,int he)//当前点的x,y坐标 走的步数 当前的路程权值&#123; if(x==X&amp;&amp;y==Y) &#123; if(time&lt;zhj&amp;&amp;he&lt;ans) &#123; for(int now=0;now&lt;time;now++) fx[now]=t_fx[now]; zhj=time-1; &#125; return; &#125; for(int a=0;a&lt;4;a++) &#123; if(he+z[a]&gt;ans)//条件判定 continue; int x1=x+z_4[a][0]; int y1=y+z_4[a][1]; if(x1&lt;1 || y1&lt;1 || x1&gt;X || y1&gt;Y)//条件判定 continue; if(b_map[x1][y1])//条件判定 continue; if(time+1&gt;dp[x1][y1])//条件判定 continue; dp[x1][y1]=time+1;//当前点的最小步数更新 b_map[x1][y1]=true; t_fx[time] = z[a]; dfs(x1,y1,time+1,he+z[a]); b_map[x1][y1]=false; &#125;&#125;int main()&#123; memset(fx,0,sizeof(fx)); memset(a_map,0,sizeof(a_map)); memset(b_map,false,sizeof(b_map)); memset(dp,999999,sizeof(dp)); for(int a=1;a&lt;=X;a++) &#123; for(int b=1;b&lt;=Y;b++) &#123; a_map[a][b] = getchar()-&#x27;0&#x27;; if(a_map[a][b]==1) b_map[a][b]=true; &#125; getchar(); &#125; b_map[1][1] = true; dfs(1,1,0,0); for(int now=0;now&lt;=zhj;now++) &#123; printf(&quot;%c&quot;,fx[now]); &#125; return 0;&#125; 该思路原地址 2.蓝桥杯 全球变暖题目你有一张某海域NxN像素的照片，”.”表示海洋、”#”表示陆地，如下所示： 其中”上下左右”四个方向上连在一起的一片陆地组成一座岛屿。例如上图就有2座岛屿。由于全球变暖导致了海面上升，科学家预测未来几十年，岛屿边缘一个像素的范围会被海水淹没。具体来说如果一块陆地像素与海洋相邻(上下左右四个相邻像素中有海洋)，它就会被淹没。例如上图中的海域未来会变成如下样子： 请你计算：依照科学家的预测，照片中有多少岛屿会被完全淹没。 输入第一行包含一个整数N。 (1 &lt;&#x3D; N &lt;&#x3D; 1000)以下N行N列代表一张海域照片。照片保证第1行、第1列、第N行、第N列的像素都是海洋。 输出一个整数表示答案。 样例输入样例输出1 OJ链接 思路：在接收初始图之后，首先搜索查找初始岛屿数，在找到一个岛屿后，对整个岛屿进行标记，防止重复计数。随后再次进行搜索，如果有四周均为陆地的坐标，则标记此坐标未被淹没。最后查找所有未被淹没的坐标，并将坐标所处的整个岛标记，防止重复计数。初始岛屿数量减去未被淹没岛的数量，即为被淹没的岛的数量。 AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;bits/stdc++.h&gt;using namespace std;char maps[1001][1001];void dfs1(int x,int y)&#123; if(maps[x][y]!=&#x27;#&#x27;) return; maps[x][y]=&#x27;1&#x27;;//将#标记为1 dfs1(x+1,y);//把整个岛都进行标记 防止重复计算 dfs1(x-1,y); dfs1(x,y+1); dfs1(x,y-1);&#125; void dfs2(int x,int y)&#123; if(maps[x][y]==&#x27;.&#x27;) return; if(maps[x+1][y]==&#x27;1&#x27;&amp;&amp;maps[x-1][y]==&#x27;1&#x27;&amp;&amp;maps[x][y+1]==&#x27;1&#x27;&amp;&amp;maps[x][y-1]==&#x27;1&#x27;)//四周都是陆地 则标记为2 &#123; maps[x][y]=&#x27;2&#x27;; &#125; dfs1(x+1,y);//找4个方向 dfs1(x-1,y); dfs1(x,y+1); dfs1(x,y-1);&#125; void dfs3(int x,int y)&#123; if(maps[x][y]==&#x27;.&#x27;) return; maps[x][y]=&#x27;.&#x27;;//将#标记为 . dfs3(x+1,y);//把整个岛都进行沉没操作 防止重复计算 dfs3(x-1,y); dfs3(x,y+1); dfs3(x,y-1);&#125; int main()&#123; int n,first_num=0,end_num=0;//层数 初始岛屿数量 末尾岛屿数量 scanf(&quot;%d&quot;,&amp;n); for(int a=1;a&lt;=n;a++) &#123; for(int b=1;b&lt;=n;b++) &#123; while(1) &#123; scanf(&quot;%c&quot;,&amp;maps[a][b]); if(maps[a][b]==&#x27;.&#x27;||maps[a][b]==&#x27;#&#x27;) break; &#125; &#125; &#125; //先查找有多少个岛屿 for(int a=1;a&lt;=n;a++) &#123; for(int b=1;b&lt;=n;b++) &#123; if(maps[a][b]==&#x27;#&#x27;) &#123; dfs1(a,b); first_num++;//初始岛屿+1 &#125; &#125; &#125; //再对整个岛屿进行变化 for(int a=1;a&lt;=n;a++) &#123; for(int b=1;b&lt;=n;b++) &#123; if(maps[a][b]==&#x27;1&#x27;) &#123; dfs2(a,b); &#125; &#125; &#125; //最后查找剩余多少个岛屿 for(int a=1;a&lt;=n;a++) &#123; for(int b=1;b&lt;=n;b++) &#123; if(maps[a][b]==&#x27;2&#x27;) &#123; dfs3(a,b); end_num++;//最终岛屿+1 &#125; &#125; &#125; cout&lt;&lt;first_num-end_num; return 0;&#125; 3.leetcode 路径总和给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。说明: 叶子节点是指没有子节点的节点。 示例:给定如下二叉树，以及目标和 sum &#x3D; 22， 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\ 7 2 1 返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum OJ链接著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码： 12345678910111213141516171819202122232425262728class Solution &#123;public: bool hasPathSum(TreeNode* root, int sum) &#123; kg=false; if(root!=NULL) dfs(root,root-&gt;val,sum); return kg; &#125; void dfs(TreeNode* root,int now,int end) &#123; if(now==end&amp;&amp;root-&gt;left==NULL&amp;&amp;root-&gt;right==NULL) &#123; kg = true; return; &#125; if(root-&gt;left==NULL&amp;&amp;root-&gt;right==NULL) &#123; return; &#125; if(root-&gt;left!=NULL) dfs(root-&gt;left,now+root-&gt;left-&gt;val,end); if(root-&gt;right!=NULL) dfs(root-&gt;right,now+root-&gt;right-&gt;val,end); &#125;private: bool kg;&#125;; 4.leetcode 路径总和II给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。说明: 叶子节点是指没有子节点的节点。 示例:给定如下二叉树，以及目标和 sum &#x3D; 22， 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\ 7 2 5 1 返回: [ [5,4,11,2], [5,8,4,5]] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum-ii OJ链接著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123; if(root) &#123; temp.push_back(root-&gt;val); dfs(root,sum-root-&gt;val); &#125; return ps; &#125;private: vector&lt;vector&lt;int&gt;&gt;ps; vector&lt;int&gt;temp; void dfs(TreeNode* root,int end) &#123; if(end==0&amp;&amp;!root-&gt;left&amp;&amp;!root-&gt;right) &#123; vector&lt;int&gt;t=temp; ps.push_back(t); return; &#125; if(!root-&gt;left&amp;&amp;!root-&gt;right) &#123; return; &#125; if(root-&gt;left) &#123; temp.push_back(root-&gt;left-&gt;val); dfs(root-&gt;left,end-root-&gt;left-&gt;val); temp.pop_back(); &#125; if(root-&gt;right) &#123; temp.push_back(root-&gt;right-&gt;val); dfs(root-&gt;right,end-root-&gt;right-&gt;val); temp.pop_back(); &#125; &#125;&#125;; 小结在使用dfs中，要根据题目数据选择合适的数据类型。比如在题目数据过大时，申请较大的二维数组很容易失败。即使申请成功也会造成极大的内存浪费，循环时也很不方便。这时就可以使用stl里的vector来储存数据，可以很好的提高的数据获取效率。要尽量多的进行筛选，增加效率好多题不止考的是dfs，甚至会考一点dp，所以要多想多做，寻找搜索中的共同点并对症下药。dfs的常用环境找最长路，特殊路等等等等。一般对带权图的搜索都用dfs。在刷蓝桥杯的题的途中发现好多题都可以用dfs进行暴力，但是往往会超时。要想ac还得换题目想让你用的方法。但是往往能过几个检测点，所以不会的题都可以dfs一下混点分哈哈哈哈哈。总之，还是得多刷题，多积累经验。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]}],"categories":[{"name":"Redis","slug":"Redis","permalink":"https://zgg2001.github.io/categories/Redis/"},{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/categories/C-C/"},{"name":"Golang","slug":"Golang","permalink":"https://zgg2001.github.io/categories/Golang/"},{"name":"Linux","slug":"Linux","permalink":"https://zgg2001.github.io/categories/Linux/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"网络","slug":"网络","permalink":"https://zgg2001.github.io/categories/%E7%BD%91%E7%BB%9C/"},{"name":"Mysql","slug":"Mysql","permalink":"https://zgg2001.github.io/categories/Mysql/"},{"name":"Java","slug":"Java","permalink":"https://zgg2001.github.io/categories/Java/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://zgg2001.github.io/tags/Redis/"},{"name":"源码阅读","slug":"源码阅读","permalink":"https://zgg2001.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"},{"name":"C/C++","slug":"C-C","permalink":"https://zgg2001.github.io/tags/C-C/"},{"name":"C++","slug":"C","permalink":"https://zgg2001.github.io/tags/C/"},{"name":"C++标准库学习","slug":"C-标准库学习","permalink":"https://zgg2001.github.io/tags/C-%E6%A0%87%E5%87%86%E5%BA%93%E5%AD%A6%E4%B9%A0/"},{"name":"dpdk","slug":"dpdk","permalink":"https://zgg2001.github.io/tags/dpdk/"},{"name":"Linux","slug":"Linux","permalink":"https://zgg2001.github.io/tags/Linux/"},{"name":"Golang","slug":"Golang","permalink":"https://zgg2001.github.io/tags/Golang/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zgg2001.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"STL","slug":"STL","permalink":"https://zgg2001.github.io/tags/STL/"},{"name":"网络","slug":"网络","permalink":"https://zgg2001.github.io/tags/%E7%BD%91%E7%BB%9C/"},{"name":"网络编程","slug":"网络编程","permalink":"https://zgg2001.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"Mysql","slug":"Mysql","permalink":"https://zgg2001.github.io/tags/Mysql/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://zgg2001.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"},{"name":"QT","slug":"QT","permalink":"https://zgg2001.github.io/tags/QT/"},{"name":"Java","slug":"Java","permalink":"https://zgg2001.github.io/tags/Java/"},{"name":"C语言","slug":"C语言","permalink":"https://zgg2001.github.io/tags/C%E8%AF%AD%E8%A8%80/"}]}