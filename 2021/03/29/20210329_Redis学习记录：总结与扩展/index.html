<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"zgg2001.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"show_result":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="&emsp;&emsp;本文将个人在Redis数据库学习中记录的知识点进行了总结，方便日后的复习以及对明年春招实习的准备。">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis学习记录：总结与扩展">
<meta property="og:url" content="https://zgg2001.github.io/2021/03/29/20210329_Redis%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E6%80%BB%E7%BB%93%E4%B8%8E%E6%89%A9%E5%B1%95/index.html">
<meta property="og:site_name" content="小咸鱼的自留地">
<meta property="og:description" content="&emsp;&emsp;本文将个人在Redis数据库学习中记录的知识点进行了总结，方便日后的复习以及对明年春招实习的准备。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zgg2001.github.io/images/2021-03-29/1.jpg">
<meta property="og:image" content="https://zgg2001.github.io/images/2021-03-29/2.jpg">
<meta property="og:image" content="https://zgg2001.github.io/images/2021-03-29/3.jpg">
<meta property="og:image" content="https://zgg2001.github.io/images/2021-03-29/4.jpg">
<meta property="og:image" content="https://zgg2001.github.io/images/2021-03-29/5.jpg">
<meta property="og:image" content="https://zgg2001.github.io/images/2021-03-29/6.jpg">
<meta property="og:image" content="https://zgg2001.github.io/images/2021-03-29/7.jpg">
<meta property="og:image" content="https://zgg2001.github.io/images/2021-03-29/8.jpg">
<meta property="og:image" content="https://zgg2001.github.io/images/2021-03-29/8-1.jpg">
<meta property="og:image" content="https://zgg2001.github.io/images/2021-03-29/9.jpg">
<meta property="og:image" content="https://zgg2001.github.io/images/2021-03-29/10.jpg">
<meta property="og:image" content="https://zgg2001.github.io/images/2021-03-29/11.jpg">
<meta property="og:image" content="https://zgg2001.github.io/images/2021-03-29/12.jpg">
<meta property="og:image" content="https://zgg2001.github.io/images/2021-03-29/13.jpg">
<meta property="og:image" content="https://zgg2001.github.io/images/2021-03-29/14.jpg">
<meta property="og:image" content="https://zgg2001.github.io/images/2021-03-29/15.jpg">
<meta property="article:published_time" content="2021-03-29T09:20:12.000Z">
<meta property="article:modified_time" content="2021-03-29T09:20:12.000Z">
<meta property="article:author" content="Zgg2001">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zgg2001.github.io/images/2021-03-29/1.jpg">


<link rel="canonical" href="https://zgg2001.github.io/2021/03/29/20210329_Redis%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E6%80%BB%E7%BB%93%E4%B8%8E%E6%89%A9%E5%B1%95/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://zgg2001.github.io/2021/03/29/20210329_Redis%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E6%80%BB%E7%BB%93%E4%B8%8E%E6%89%A9%E5%B1%95/","path":"2021/03/29/20210329_Redis学习记录：总结与扩展/","title":"Redis学习记录：总结与扩展"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Redis学习记录：总结与扩展 | 小咸鱼的自留地</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">小咸鱼的自留地</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80"><span class="nav-text">一、基础</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">二、数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">1. 基础数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%91%A0-string"><span class="nav-text">① string</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%91%A1-hash"><span class="nav-text">② hash</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%91%A2-list"><span class="nav-text">③ list</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%91%A3-set"><span class="nav-text">④ set</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%91%A4-sorted-set"><span class="nav-text">⑤ sorted_set</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">2. 高级数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%91%A0-Bitmaps"><span class="nav-text">① Bitmaps</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%91%A1-HyperLogLog"><span class="nav-text">② HyperLogLog</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%91%A2-GEO"><span class="nav-text">③ GEO</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E9%80%9A%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="nav-text">三、通用指令</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-key%E6%93%8D%E4%BD%9C"><span class="nav-text">1. key操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C"><span class="nav-text">2. 数据库操作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81Linux%E4%B8%8BRedis%E7%9A%84%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3"><span class="nav-text">四、Linux下Redis的配置相关</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-text">五、持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-RDB-%E5%BF%AB%E7%85%A7"><span class="nav-text">1. RDB - 快照</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-AOF-%E6%97%A5%E5%BF%97"><span class="nav-text">2. AOF - 日志</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E4%BA%8B%E5%8A%A1"><span class="nav-text">六、事务</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4"><span class="nav-text">1. 基本指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E9%94%81"><span class="nav-text">2. 锁</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="nav-text">七、删除策略</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%95%B0%E6%8D%AE%E5%88%A0%E9%99%A4"><span class="nav-text">1. 数据删除</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%95%B0%E6%8D%AE%E9%80%90%E5%87%BA"><span class="nav-text">2. 数据逐出</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AB%E3%80%81Redis%E9%9B%86%E7%BE%A4"><span class="nav-text">八、Redis集群</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%B8%BB%E4%BB%8E%E8%BF%9E%E6%8E%A5"><span class="nav-text">1. 主从连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%93%A8%E5%85%B5"><span class="nav-text">2. 哨兵</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E9%9B%86%E7%BE%A4"><span class="nav-text">3. 集群</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B9%9D%E3%80%81%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-text">九、企业级解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD"><span class="nav-text">1. 缓存预热</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="nav-text">2. 缓存雪崩</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="nav-text">3. 缓存击穿</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="nav-text">4. 缓存穿透</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E6%8C%87%E6%A0%87"><span class="nav-text">5. 性能监控指标</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zgg2001"
      src="/images/hbxxy.jpg">
  <p class="site-author-name" itemprop="name">Zgg2001</p>
  <div class="site-description" itemprop="description">河边小咸鱼</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">65</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/zgg2001" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zgg2001" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/397606244@qq.com" title="E-Mail → 397606244@qq.com" rel="noopener me"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zgg2001.github.io/2021/03/29/20210329_Redis%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E6%80%BB%E7%BB%93%E4%B8%8E%E6%89%A9%E5%B1%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hbxxy.jpg">
      <meta itemprop="name" content="Zgg2001">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小咸鱼的自留地">
      <meta itemprop="description" content="河边小咸鱼">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Redis学习记录：总结与扩展 | 小咸鱼的自留地">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis学习记录：总结与扩展
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-29 17:20:12" itemprop="dateCreated datePublished" datetime="2021-03-29T17:20:12+08:00">2021-03-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>19k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>17 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>&emsp;&emsp;本文将个人在Redis数据库学习中记录的知识点进行了总结，方便日后的复习以及对明年春招实习的准备。</p>
<span id="more"></span>

<h1 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Redis是什么：</span><br><span class="line">	Redis是一种NoSql，即<span class="keyword">Not</span><span class="operator">-</span><span class="keyword">Only</span><span class="operator">-</span><span class="keyword">Sql</span>。是一种&quot;高性能键值对数据库&quot;，是对常规数据库的一种补充。</span><br><span class="line"></span><br><span class="line">Redis的存在需求：</span><br><span class="line">	当一些数据需要被频繁操作时，不断的从常规<span class="keyword">sql</span>中读取<span class="operator">/</span>更改数据会大大提高磁盘IO次数，消耗大量时间。</span><br><span class="line">	此时就需要一个中间件对热点数据进行储存与操作，从而提高操作效率。</span><br><span class="line"></span><br><span class="line">Redis的思路：</span><br><span class="line">	通过<span class="string">&#x27;在内存进行储存&#x27;</span>的思路，降低磁盘的IO次数。</span><br><span class="line">	通过<span class="string">&#x27;不储存关系，仅储存数据&#x27;</span>的思路，去除数据间的关系，从而减少内存消耗。</span><br><span class="line"></span><br><span class="line">Redis的优点：</span><br><span class="line">	<span class="number">1.</span>可扩容，可伸缩</span><br><span class="line">	<span class="number">2.</span>大数据下高性能</span><br><span class="line">	<span class="number">3.</span>灵活的数据类型</span><br><span class="line">	<span class="number">4.</span>高可用</span><br><span class="line"></span><br><span class="line">Redis的速度快的原因：</span><br><span class="line">	<span class="number">1.</span>内存操作</span><br><span class="line">	<span class="number">2.</span>IO多路复用机制，减少了阻塞</span><br><span class="line">	<span class="number">3.</span>单线程避免了线程切换的开销和竞争问题</span><br><span class="line">	<span class="number">4.</span>C语言编写，与操作系统交互，命令执行快</span><br><span class="line"></span><br><span class="line">Redis的使用场景：</span><br><span class="line">	<span class="number">1.</span>对热点数据进行储存，提高热点数据的操作效率。</span><br><span class="line">	<span class="number">2.</span>排行榜等实时变化性强的数据存储。</span><br><span class="line">	<span class="number">3.</span>具有时效性的数据存储，方便删除与更新。</span><br><span class="line">	<span class="number">4.</span>...	</span><br><span class="line">	总之，我认为Redis相当于一个缓存区，对于操作频率高的数据可以放在该缓存区里，方便客户端进行操作。</span><br></pre></td></tr></table></figure>

<h1 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h1><h2 id="1-基础数据类型"><a href="#1-基础数据类型" class="headerlink" title="1. 基础数据类型"></a>1. 基础数据类型</h2><h3 id="①-string"><a href="#①-string" class="headerlink" title="① string"></a>① string</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">string类型 最大纯数值范围为long long <span class="number">512</span>M </span><br><span class="line"><span class="string">&#x27;讲究整体性，更新少时用&#x27;</span></span><br><span class="line"></span><br><span class="line">基础操作:</span><br><span class="line">· <span class="keyword">set</span> key <span class="keyword">value</span>							添加修改键值对</span><br><span class="line">· <span class="keyword">get</span> key								根据键 获取值</span><br><span class="line">· del key								根据键 删除键值对</span><br><span class="line">· strlen key							根据键 获取值字符个数</span><br><span class="line">· append key <span class="keyword">value</span>						追加内容到原始信息尾部，不存在则新建</span><br><span class="line"></span><br><span class="line">· mset key1 value1 key2 value2...		添加<span class="operator">/</span>修改多个键值对</span><br><span class="line">· mget key1 key2...						根据键 获取多个值</span><br><span class="line"></span><br><span class="line">设置数值增加指定的值: #实现按次案例 加一个负数即为减</span><br><span class="line">· incr key								</span><br><span class="line">· incrby key increment</span><br><span class="line">· incrbyfloat key increment</span><br><span class="line"></span><br><span class="line">设置数值减少指定的值:</span><br><span class="line">· decr key</span><br><span class="line">· decrby key increment</span><br><span class="line"></span><br><span class="line">设置数值具有指定的生命周期: #实现按时案例</span><br><span class="line">· setex key seconds <span class="keyword">value</span></span><br><span class="line">· psetex key milliseconds <span class="keyword">value</span></span><br></pre></td></tr></table></figure>
<h3 id="②-hash"><a href="#②-hash" class="headerlink" title="② hash"></a>② hash</h3><p><img src="/images/2021-03-29/1.jpg" alt="hash"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">hash类型 </span><br><span class="line"><span class="string">&#x27;一个空间保存多个键值对数据&#x27;</span></span><br><span class="line"></span><br><span class="line">基础操作:</span><br><span class="line">· hset key field <span class="keyword">value</span>							添加<span class="operator">/</span>修改 键<span class="operator">/</span>字段<span class="operator">/</span>值</span><br><span class="line">· hget key field								获取值</span><br><span class="line">· hgetall key									获取全部值</span><br><span class="line">· hdel key field1...							删除</span><br><span class="line"></span><br><span class="line">· hmset key field1 value1 field2 value2...		多个添加<span class="operator">/</span>修改 键<span class="operator">/</span>字段<span class="operator">/</span>值</span><br><span class="line">· hmget key field1 field2...					获取多个值</span><br><span class="line">· hexists key field								获取表中是否存在指定字段</span><br><span class="line">· hlen key										获取字段数量</span><br><span class="line"></span><br><span class="line">· hkeys key										查看所有字段名</span><br><span class="line">· hvals key										查看所有字段值</span><br><span class="line"></span><br><span class="line">· hsetnx key field <span class="keyword">value</span>						添加 键<span class="operator">/</span>字段<span class="operator">/</span>值，有就不改，无则添加</span><br><span class="line"></span><br><span class="line">设置数值增加指定的值: #实现按次案例 加一个负数即为减							</span><br><span class="line">· hincrby key field increment</span><br><span class="line">· hincrbyfloat key field increment</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line"><span class="number">1.</span><span class="keyword">value</span>只能是字符串<span class="operator">/</span>数值，不能嵌套数据结构。</span><br><span class="line"><span class="number">2.</span>每个hash最多 <span class="number">2</span><span class="operator">^</span><span class="number">32</span><span class="number">-1</span> 个键值对</span><br><span class="line"><span class="number">3.</span>不可滥用，不可以全面作为对象列表使用</span><br><span class="line"><span class="number">4.</span><span class="string">&#x27;hgetall&#x27;</span>在field很多时，效率低，存在瓶颈</span><br><span class="line"><span class="number">5.</span>hash更新方便</span><br></pre></td></tr></table></figure>
<h3 id="③-list"><a href="#③-list" class="headerlink" title="③ list"></a>③ list</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">list类型 底层为双向链表 实现消息队列</span><br><span class="line"><span class="string">&#x27;一个空间储存多个数据，且体现顺序&#x27;</span></span><br><span class="line"></span><br><span class="line">· lpush key value1 value2...			从左 添加<span class="operator">/</span>修改数据</span><br><span class="line">· rpush key value1 value2...			从右 添加<span class="operator">/</span>修改数据</span><br><span class="line"></span><br><span class="line">· lrange key <span class="keyword">start</span> stop					取<span class="keyword">start</span>到stop的数据 #下标从<span class="number">0</span>开始 <span class="number">-1</span>为倒数第一个数据</span><br><span class="line">· lindex key index						依据index索引取数据</span><br><span class="line">· llen key								获取长度</span><br><span class="line"></span><br><span class="line">· lpop key								从左 获取并移除数据 #类似java的pop</span><br><span class="line">· rpop key								从右 获取并移除数据</span><br><span class="line"></span><br><span class="line"># <span class="type">time</span>单位为秒 当list内为空时，不会立刻返回，直到时间归零返回空，或者有人入队返回数据</span><br><span class="line">· blpop key... <span class="type">time</span>						从左 在规定的时间内获取并移除数据 </span><br><span class="line">· brpop key... <span class="type">time</span>						从右 在规定的时间内获取并移除数据 </span><br><span class="line"></span><br><span class="line">· lrem key count <span class="keyword">value</span>					移除指定数据 #count为移除数量，<span class="keyword">value</span>为要移除的值</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line"><span class="number">1.</span>每个list最多 <span class="number">2</span><span class="operator">^</span><span class="number">32</span><span class="number">-1</span> 个元素</span><br><span class="line"><span class="number">2.</span>可以实现栈<span class="operator">/</span>队列</span><br><span class="line"><span class="number">3.</span><span class="string">&#x27;-1&#x27;</span>表示的是倒数第一</span><br><span class="line"><span class="number">4.</span>可以分页 #<span class="string">&#x27;lrange&#x27;</span>取指定个数据</span><br></pre></td></tr></table></figure>
<h3 id="④-set"><a href="#④-set" class="headerlink" title="④ set"></a>④ set</h3><p><img src="/images/2021-03-29/2.jpg" alt="set"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>类型 hash结构 hash中field储存值 hash中<span class="keyword">value</span>为空</span><br><span class="line"><span class="string">&#x27;储存大量数据，查询效率高&#x27;</span></span><br><span class="line"></span><br><span class="line">基础操作:</span><br><span class="line">· sadd key member1 member2...					添加<span class="operator">/</span>修改 键<span class="operator">/</span>值</span><br><span class="line">· smembers key									获取全部数据</span><br><span class="line">· srem key member1 member2...					删除数据</span><br><span class="line">· scard key										获取集合数据总量</span><br><span class="line">· sismember key <span class="keyword">member</span>							判断集合中是否包含指定数据</span><br><span class="line"></span><br><span class="line"># 可以实现随机推荐</span><br><span class="line">· srandmember key [count]						随机获取集合中指定数量的数据</span><br><span class="line">· spop key [count]								随机获取集合中指定数量的数据，并将其移出集合</span><br><span class="line"></span><br><span class="line"># 可以实现相关推送、共同好友等</span><br><span class="line">求集合的交、并、差集:</span><br><span class="line">· sinter key1 [key2]</span><br><span class="line">· sunion key1 [key2]</span><br><span class="line">· sdiff key1 [key2]</span><br><span class="line"></span><br><span class="line"># 数据合并</span><br><span class="line">求集合的交、并、差集并储存到指定的集合中:</span><br><span class="line">· sinterstore destination key1 [key2]</span><br><span class="line">· sunionstore destination key1 [key2]</span><br><span class="line">· sdiffstore destination key1 [key2]</span><br><span class="line"></span><br><span class="line"># 数据合并</span><br><span class="line">将指定数据从原始集合中移动到目标集合中:</span><br><span class="line">smove source destination <span class="keyword">member</span></span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line"><span class="number">1.</span>不会重复</span><br><span class="line"><span class="number">2.</span>与hash的储存空间相同，但是无法启用hash中储存值的空间 #全为空</span><br><span class="line"><span class="number">3.</span>去重可以实现记录访问数据</span><br><span class="line"><span class="number">4.</span>由上可以实现黑<span class="operator">/</span>白名单 #ID<span class="operator">/</span>IP<span class="operator">/</span>设备</span><br></pre></td></tr></table></figure>
<h3 id="⑤-sorted-set"><a href="#⑤-sorted-set" class="headerlink" title="⑤ sorted_set"></a>⑤ sorted_set</h3><p><img src="/images/2021-03-29/3.jpg" alt="sorted_set"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">sorted_set类型 在<span class="keyword">set</span>的基础上增加了score模块 可以根据score进行排序</span><br><span class="line"><span class="string">&#x27;可排序的set&#x27;</span></span><br><span class="line"></span><br><span class="line">基础操作:</span><br><span class="line">· zadd key score1 member1 score2 member2...					添加<span class="operator">/</span>修改 键<span class="operator">/</span>值<span class="operator">/</span>分</span><br><span class="line">· zrem key member1 member2...								删除数据</span><br><span class="line"></span><br><span class="line">依据排名获取全部数据: #withscores为值带分</span><br><span class="line">· zrange key <span class="keyword">start</span> stop [withscores] 						小到大					</span><br><span class="line">· zrevrange key <span class="keyword">start</span> stop [withscores] 					大到小</span><br><span class="line"></span><br><span class="line">依据分数获取全部数据: #withscores为值带分</span><br><span class="line">· zrangebyscore key min max [withscores] 					小到大					</span><br><span class="line">· zrevrangebyscore key max min [withscores] 				大到小</span><br><span class="line"></span><br><span class="line">按条件删除数据:</span><br><span class="line">· zremrangebyrank key <span class="keyword">start</span> stop							按从大到小的排名</span><br><span class="line">· zremrangebyscore key min max								按分数</span><br><span class="line"></span><br><span class="line">获取集合数据数量:</span><br><span class="line">· zcard key</span><br><span class="line">· zcount key min max</span><br><span class="line"></span><br><span class="line"># 数据合并</span><br><span class="line">求集合的交、并集并储存到指定的集合中:</span><br><span class="line">· zinterstore destination numkeys key1 [key2] #后续参数为score最终结果:求和<span class="operator">/</span>最大<span class="operator">/</span>最小</span><br><span class="line">· zunionstore destination numkeys key1 [key2]</span><br><span class="line"></span><br><span class="line">获取数据对应的索引排名 #下标<span class="number">0</span>开始</span><br><span class="line">· zrank key <span class="keyword">member</span></span><br><span class="line">· zrevrank key <span class="keyword">member</span></span><br><span class="line"></span><br><span class="line">score值获取与修改:</span><br><span class="line">· zscore key <span class="keyword">member</span></span><br><span class="line">· zincrby key increment <span class="keyword">member</span> #increment为加值</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line"><span class="number">1.</span>有<span class="keyword">set</span>的特性，反复添加会覆盖</span><br><span class="line"><span class="number">2.</span>long long为范围，<span class="number">64</span>位，小数则为<span class="keyword">double</span>，可能丢失精度</span><br><span class="line"><span class="number">3.</span>可以实现：时间队列、优先队列、VIP、权重</span><br></pre></td></tr></table></figure>
<h2 id="2-高级数据类型"><a href="#2-高级数据类型" class="headerlink" title="2. 高级数据类型"></a>2. 高级数据类型</h2><h3 id="①-Bitmaps"><a href="#①-Bitmaps" class="headerlink" title="① Bitmaps"></a>① Bitmaps</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Bitmaps类型 </span><br><span class="line"><span class="string">&#x27;状态统计&#x27;</span></span><br><span class="line"></span><br><span class="line">· getbit key <span class="keyword">offset</span>								获取指定key对应偏移量上的bit值</span><br><span class="line">· setbit key <span class="keyword">offset</span> <span class="keyword">value</span>						设置指定key对应偏移量上的bit值 #只能是<span class="number">0</span>或<span class="number">1</span></span><br><span class="line"></span><br><span class="line">· bitop op destkey key1 key2...					进行<span class="string">&#x27;操作&#x27;</span>结果保存到destkey</span><br><span class="line">  op: <span class="keyword">and</span>交 <span class="keyword">or</span>并 <span class="keyword">not</span>非 xor异或</span><br><span class="line"></span><br><span class="line"># 一个字节有八个bit 后面的<span class="keyword">start</span>和<span class="keyword">end</span>是字节</span><br><span class="line">· bitcount key [<span class="keyword">start</span> <span class="keyword">end</span>]						统计指定key中<span class="number">1</span>的数量</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line"><span class="number">1.</span>可以进行单日数据的统计 例如某电影今日是否被点播</span><br><span class="line"><span class="number">2.</span>可以进行并操作来对多日数据进行合并等等</span><br><span class="line"><span class="number">3.</span>可以通过统计<span class="number">1</span>的数量来实现类似<span class="string">&#x27;统计今日电影被点播种数&#x27;</span>的功能</span><br></pre></td></tr></table></figure>
<h3 id="②-HyperLogLog"><a href="#②-HyperLogLog" class="headerlink" title="② HyperLogLog"></a>② HyperLogLog</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HyperLogLog类型 底层为loglog算法 统计独立的元素个数</span><br><span class="line"><span class="string">&#x27;基数统计&#x27;</span></span><br><span class="line"></span><br><span class="line">· pfadd key element1 element2...				添加数据</span><br><span class="line">· pfcount key1 key2...							统计数据</span><br><span class="line">· pfmerge destkey sourcekey1 sourcekey2...		合并数据</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line"><span class="number">1.</span>HyperLogLog只进行基数统计，不记录具体数据</span><br><span class="line"><span class="number">2.</span>核心是基数统计算法，存在一定误差，大概是百分之<span class="number">0.81</span> #该算法中存储的都是近似值 所以有误差</span><br><span class="line"><span class="number">3.</span>该数据类型消耗内存最大为<span class="number">12</span>K，相比<span class="keyword">set</span>上M的内存消耗很小</span><br><span class="line"><span class="number">4.</span>HyperLogLog数据不断累积最大为<span class="number">12</span>K，合并数据后结果消耗直接为最大的<span class="number">12</span>K</span><br></pre></td></tr></table></figure>
<h3 id="③-GEO"><a href="#③-GEO" class="headerlink" title="③ GEO"></a>③ GEO</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GEO类型</span><br><span class="line"><span class="string">&#x27;地理信息&#x27;</span></span><br><span class="line"></span><br><span class="line">· geoadd key logitude latitude <span class="keyword">member</span> [logitude latitude <span class="keyword">member</span>]		添加坐标点</span><br><span class="line">· geopos key <span class="keyword">member</span> [<span class="keyword">member</span>]											获取坐标点</span><br><span class="line">· geodist key member1 member2 [unit]									计算距离 默认为m [unit]参数是m<span class="operator">/</span>km</span><br><span class="line"></span><br><span class="line">根据坐标求范围内的数据:</span><br><span class="line">· georadius key longitude latitude radius m<span class="operator">|</span>km<span class="operator">|</span>ft<span class="operator">|</span>mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count]</span><br><span class="line"></span><br><span class="line">根据点求范围内的数据:</span><br><span class="line">· georadiusbymember key <span class="keyword">member</span> radius m<span class="operator">|</span>km<span class="operator">|</span>ft<span class="operator">|</span>mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count]</span><br><span class="line"></span><br><span class="line">获取指定点对应的坐标hash值:</span><br><span class="line">· geohash key <span class="keyword">member</span> [<span class="keyword">member</span> ...]</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line"><span class="number">1.</span>基本都是估算，存在误差，但是不追求高精度也够用</span><br><span class="line"><span class="number">2.</span>可以实现<span class="string">&#x27;附近的人&#x27;</span>之类的功能</span><br></pre></td></tr></table></figure>
<h1 id="三、通用指令"><a href="#三、通用指令" class="headerlink" title="三、通用指令"></a>三、通用指令</h1><h2 id="1-key操作"><a href="#1-key操作" class="headerlink" title="1. key操作"></a>1. key操作</h2><p>基本操作:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">· del key				删除指定的key</span><br><span class="line">· <span class="keyword">exists</span> key			获取key是否存在</span><br><span class="line">· type key 				获取key的类型</span><br></pre></td></tr></table></figure>
<p>时效性控制:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">为指定的key设置有效期: #前两个是秒<span class="operator">/</span>毫秒 后两个是时间戳</span><br><span class="line">· expire key seconds</span><br><span class="line">· pexpire key milliseconds</span><br><span class="line">· expireat key <span class="type">timestamp</span></span><br><span class="line">· pexpireat key milliseconds<span class="operator">-</span><span class="type">timestamp</span></span><br><span class="line"></span><br><span class="line">获取key的有效时间: #剩余秒<span class="operator">/</span>毫秒 xx为时效 <span class="number">-1</span>为永久 <span class="number">-2</span>为失效</span><br><span class="line">· ttl key</span><br><span class="line">· pttl key</span><br><span class="line"></span><br><span class="line">切换key从时效性至永久</span><br><span class="line">· persist key</span><br></pre></td></tr></table></figure>
<p>查询模式:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">keys <span class="keyword">pattern</span>			查询key</span><br><span class="line"><span class="keyword">pattern</span>: <span class="operator">*</span>为所有 ?为匹配一个任意符号 []为匹配一个指定符号 </span><br><span class="line">eg: keys u[st]er:<span class="number">1</span>  匹配一个以u开头，以er:<span class="number">1</span>结尾，中间包含一个字母s<span class="operator">/</span>t的key</span><br></pre></td></tr></table></figure>
<p>其他操作:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">为key改名:</span><br><span class="line">· rename key newkey #会覆盖</span><br><span class="line">· renamenx key newkey #不会覆盖</span><br><span class="line"></span><br><span class="line">对所有key排序:</span><br><span class="line">· sort key #支持<span class="keyword">set</span> list zset 只排序结果 不动原表</span><br><span class="line"></span><br><span class="line">其他:</span><br><span class="line">· help <span class="variable">@generio</span></span><br></pre></td></tr></table></figure>
<h2 id="2-数据库操作"><a href="#2-数据库操作" class="headerlink" title="2. 数据库操作"></a>2. 数据库操作</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">切换数据库: #默认<span class="number">0</span> <span class="number">0</span><span class="number">-15</span> 共<span class="number">16</span>个 可以从配置文件里改总数</span><br><span class="line">· <span class="keyword">select</span> index</span><br><span class="line"></span><br><span class="line">· quit				退出</span><br><span class="line">· ping				测联通</span><br><span class="line">· echo message		控制台日志</span><br><span class="line"></span><br><span class="line">· move key db		数据移动</span><br><span class="line"></span><br><span class="line">· dbsize			获取当前库中key的数量</span><br><span class="line">· flushdb			删当前库</span><br><span class="line">· flushall			删全部</span><br></pre></td></tr></table></figure>
<h1 id="四、Linux下Redis的配置相关"><a href="#四、Linux下Redis的配置相关" class="headerlink" title="四、Linux下Redis的配置相关"></a>四、Linux下Redis的配置相关</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">打开服务端:		· redis<span class="operator">-</span>server [<span class="comment">--port 6379] 			</span></span><br><span class="line">打开客户端:		· redis<span class="operator">-</span>cli [<span class="operator">-</span>h ip] [<span class="operator">-</span>p host]</span><br><span class="line"></span><br><span class="line">按配置文件打开服务端:</span><br><span class="line">· redis<span class="operator">-</span>server redis<span class="number">-6379.</span>conf</span><br><span class="line"></span><br><span class="line">配置文件基础:</span><br><span class="line">· port 端口					设置当前服务启动端口</span><br><span class="line">· daemonize yes<span class="operator">|</span><span class="keyword">no</span>			若yes则以守护进程方式启动，日志不再打印到命令窗口</span><br><span class="line">· logfile &quot;xxx.log&quot;			设置日志文件名，便于查阅</span><br><span class="line">· dir &quot;/.../redis/data&quot;		设置当前服务文件保存位置 [日志<span class="operator">/</span>持久化等]</span><br><span class="line">· bind <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>			设置本机地址</span><br><span class="line">· databases <span class="number">16</span>				设置库数量</span><br><span class="line">· maxclients <span class="number">0</span>				设置最大连接数</span><br><span class="line">· timeout <span class="number">300</span>				设置客户端限制最大时长 #<span class="number">0</span>为关</span><br><span class="line">· loglevel debug<span class="operator">|</span>verbase<span class="operator">|</span>notice<span class="operator">|</span>warning		设置日志级别 #默认是verbase 线上一般用notice简化日志</span><br><span class="line">· include <span class="operator">/</span>path<span class="operator">/</span>server<span class="operator">-</span>host.conf			导入<span class="operator">/</span>加载指定conf 便于维护</span><br><span class="line"></span><br><span class="line">注:</span><br><span class="line"><span class="number">1.</span>使用<span class="string">&#x27;ps -ef | grep redis-&#x27;</span>命令即可筛选出redis相关进程</span><br><span class="line"><span class="number">2.</span>当以守护进程方式启动时，日志不再显示，可以通过上述ps命令找到进程，使用<span class="string">&#x27;kill -s 9 进程ID&#x27;</span>关闭服务端</span><br></pre></td></tr></table></figure>
<h1 id="五、持久化"><a href="#五、持久化" class="headerlink" title="五、持久化"></a>五、持久化</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">持久化主要分为两种: RDB与AOF</span><br><span class="line">其中AOF是相对主流的持久化方案</span><br></pre></td></tr></table></figure>
<h2 id="1-RDB-快照"><a href="#1-RDB-快照" class="headerlink" title="1. RDB - 快照"></a>1. RDB - 快照</h2><p>相关:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">首先，RDB的原理是生成一张当前redis的状态的快照(二进制压缩文件)。</span><br><span class="line">恢复则是根据该快照进行全面的恢复。</span><br><span class="line">快照的占用空间较少(因为进行了压缩)，存取的速度相对较慢(全部保存)，但恢复速度快(整体恢复)。</span><br><span class="line"></span><br><span class="line">rdb保存分为两种: save 和 bgsave</span><br><span class="line">· save是直接保存，当保存数据较多时，由于是单线程，会阻塞进程。</span><br><span class="line">同步<span class="operator">/</span>阻塞<span class="operator">/</span>无额外内存<span class="operator">/</span>不启动新进程</span><br><span class="line">· bgsave是后台保存，执行该命令后，redis新建子进程进行save保存，不会阻塞进程。但是CPU消耗会相对增大。</span><br><span class="line">异步<span class="operator">/</span>不阻塞<span class="operator">/</span>有额外内存<span class="operator">/</span>启动新进程</span><br></pre></td></tr></table></figure>
<p>配置文件相关:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">· dbfilename dump<span class="number">-6379.</span>rdb			设置本地数据库rdb名</span><br><span class="line">· dir &quot;/.../redis/data&quot;				设置当前服务文件保存位置 [日志<span class="operator">/</span>持久化等]</span><br><span class="line">· rdbcompression yes<span class="operator">|</span><span class="keyword">no</span>				储存本地库时是否压缩(LZF压缩) #通常开启 否则节省CPU运行时间 但是数据文件增大</span><br><span class="line">· rdbchecksum yes<span class="operator">|</span><span class="keyword">no</span>				设置是否进行RDB文件格式校验(读<span class="operator">/</span>写时) #通常开启 否则节省约<span class="number">10</span><span class="operator">%</span>时间 但可能损坏数据</span><br><span class="line"></span><br><span class="line">· stop<span class="operator">-</span>writes<span class="operator">-</span><span class="keyword">on</span><span class="operator">-</span>bgsave<span class="operator">-</span>error yes<span class="operator">|</span><span class="keyword">no</span>	若bgsave出现错误，是否停止写入 #默认开启 		</span><br><span class="line">如果为yes，redis会创建一个新的后台进程dump rdb。</span><br><span class="line">假设创建快照需要<span class="number">20</span>s时间，redis主进程在这<span class="number">20</span>s内则会继续接受客户端命令。</span><br><span class="line">若在这<span class="number">20</span>s内创建快照出错，那么redis会拒绝新的写入。</span><br><span class="line"></span><br><span class="line"># 满足在指定时间 <span class="keyword">second</span> 中改变 changes 个 key 即会执行 bgsave</span><br><span class="line">· save <span class="keyword">second</span> changes				自动save #执行的是bgsave 根据业务量进行设置</span><br><span class="line">在执行命令返回结果后，系统会对该命令进行判定，服务器成功执行一个数据库修改命令，则计数器<span class="operator">+</span><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>相关命令:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">· save 					手动执行一次保存操作</span><br><span class="line">· bgsave				手动执行一次后台保存操作</span><br><span class="line"></span><br><span class="line">· debug reload			重启服务端并执行rdb</span><br><span class="line">· shutdown save			关机并执行rdb</span><br></pre></td></tr></table></figure>
<p>bgsave流程:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>bgsave指令</span><br><span class="line"><span class="number">2.</span>发送指令至服务器</span><br><span class="line"><span class="number">3.</span>服务器调用fork函数生成子进程，并返回<span class="string">&#x27;Background saving started&#x27;</span></span><br><span class="line"><span class="number">4.</span>成功创建rdb文件后，返回成功消息至log日志文件</span><br></pre></td></tr></table></figure>
<p>RDB优缺点:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">优点:</span><br><span class="line"><span class="number">1.</span>效率高 使用压缩二进制保存</span><br><span class="line"><span class="number">2.</span>使用快照 进行全量复制</span><br><span class="line"><span class="number">3.</span>恢复快</span><br><span class="line"></span><br><span class="line">缺点:</span><br><span class="line"><span class="number">1.</span>无法实时持久化 两次快照之间必定存在时间</span><br><span class="line"><span class="number">2.</span>牺牲了性能 快照时消耗较大</span><br><span class="line"><span class="number">3.</span>不同redis版本可能对rdb文件不兼容</span><br></pre></td></tr></table></figure>
<h2 id="2-AOF-日志"><a href="#2-AOF-日志" class="headerlink" title="2. AOF - 日志"></a>2. AOF - 日志</h2><p>相关:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AOF为记录数据产生的工程，即日志。</span><br><span class="line">主要注重<span class="string">&#x27;实时性&#x27;</span>。</span><br><span class="line"></span><br><span class="line">AOF有三种日志策略</span><br><span class="line">· always(每次)				零误差，性能低</span><br><span class="line">· everysec(每秒<span class="operator">/</span>默认)		准确性较高，性能较高，宕机丢失一秒数据 #每秒操作先存在aof缓存区中</span><br><span class="line">· <span class="keyword">no</span>(系统控制)				整体不可控，操作系统控制周期</span><br></pre></td></tr></table></figure>
<p>配置文件相关:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">· appendonly yes<span class="operator">|</span><span class="keyword">no</span>						是否开启aof #默认<span class="keyword">no</span></span><br><span class="line">· appendfsync always<span class="operator">|</span>everysec<span class="operator">|</span><span class="keyword">no</span>		选择策略</span><br><span class="line">· appendfilename appendonly<span class="number">-6379.</span>aof	设置本地数据库aof名</span><br><span class="line">· dir &quot;/.../redis/data&quot;					设置当前服务文件保存位置 [日志<span class="operator">/</span>持久化等]</span><br><span class="line"></span><br><span class="line">· auto<span class="operator">-</span>aof<span class="operator">-</span>rewrite<span class="operator">-</span>min<span class="operator">-</span>size size			最小尺寸</span><br><span class="line">· auto<span class="operator">-</span>aof<span class="operator">-</span>rewrite<span class="operator">-</span>percentage percentage 	百分比</span><br><span class="line">自动参数: #info查看</span><br><span class="line">aof_current_size	当前大小</span><br><span class="line">aof_base_size		</span><br><span class="line">条件: #满足则系统更新</span><br><span class="line"><span class="number">1.</span>aof_current_size <span class="operator">&gt;</span> auto<span class="operator">-</span>aof<span class="operator">-</span>rewrite<span class="operator">-</span>min<span class="operator">-</span>size</span><br><span class="line"><span class="number">2.</span>(aof_current_size <span class="operator">-</span> aof_base_size) <span class="operator">/</span> aof_base_size <span class="operator">&gt;=</span> auto<span class="operator">-</span>aof<span class="operator">-</span>rewrite<span class="operator">-</span>percentage percentage</span><br></pre></td></tr></table></figure>
<p>AOF重写机制:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">日志中大量重复命令存在会大大增加资源消耗，此时可以进行数据重写。</span><br><span class="line"></span><br><span class="line">按照以下规律:</span><br><span class="line"><span class="number">1.</span>已超时数据不再写入文件</span><br><span class="line"><span class="number">2.</span>忽略无效命令 重写时使用进程内的数据生成 这样新的AOF文件只保存最终写入命令</span><br><span class="line"><span class="number">3.</span>对同一数据的多条命令合并为一条命令</span><br><span class="line">注:在aof缓存区后，有aof重写缓存区提供数据</span><br><span class="line"></span><br><span class="line">好处:</span><br><span class="line"><span class="number">1.</span>降低占用空间 利用率up</span><br><span class="line"><span class="number">2.</span>提高效率 降低时间 提高IO性能</span><br><span class="line"><span class="number">3.</span>恢复时间减少 提高恢复效率</span><br></pre></td></tr></table></figure>
<p>相关命令:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">· bgrewriteaof			手动重写 #和 bgsave 机制差不多</span><br></pre></td></tr></table></figure>
<p>AOF流程:<br><img src="/images/2021-03-29/4.jpg" alt="流程"><br>AOF与RDB对比:</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>RDB</th>
<th>AOF</th>
</tr>
</thead>
<tbody><tr>
<td>占用空间</td>
<td>小(压缩)</td>
<td>大(重写)</td>
</tr>
<tr>
<td>存储速度</td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td>恢复速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>安全性</td>
<td>会丢失数据</td>
<td>依据策略不同</td>
</tr>
<tr>
<td>资源消耗</td>
<td>高&#x2F;重量级</td>
<td>低&#x2F;轻量级</td>
</tr>
<tr>
<td>启动优先</td>
<td>优先级低</td>
<td>优先级高</td>
</tr>
<tr>
<td>选择</td>
<td>呈现阶段有效性(如回档)</td>
<td>数据敏感</td>
</tr>
<tr>
<td>注:</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1.灾难恢复一般选择RDB</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2.可以进行双保险备份</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="六、事务"><a href="#六、事务" class="headerlink" title="六、事务"></a>六、事务</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;一个队列中，一次性，顺序性，排他性的执行一系列命令&#x27;</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/2021-03-29/5.jpg" alt="事务"></p>
<h2 id="1-基本指令"><a href="#1-基本指令" class="headerlink" title="1. 基本指令"></a>1. 基本指令</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">· multi				开启事务		执行后，后续指令加入事务</span><br><span class="line">· <span class="keyword">exec</span>				执行事务		执行事务，与multi成对使用</span><br><span class="line">· discard			取消事务</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line"><span class="number">1.</span>出现语法错误后，销毁队列，所有不执行 #书写错误</span><br><span class="line"><span class="number">2.</span>出现命令执行错误后，对正确的命令执行，错误的不执行</span><br><span class="line"><span class="number">3.</span>redis事务执行后不会回滚，需要程序员自己备份</span><br></pre></td></tr></table></figure>
<h2 id="2-锁"><a href="#2-锁" class="headerlink" title="2. 锁"></a>2. 锁</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">监视锁<span class="operator">/</span>乐观锁:</span><br><span class="line">· watch key1 [key2]			添加监视锁</span><br><span class="line">· unwatch					取消监视锁</span><br><span class="line">如果在事务提交之前，监视的key进行了变动，则该事务失效</span><br><span class="line"></span><br><span class="line">公共锁<span class="operator">/</span>悲观锁: #个人觉得类似线程锁</span><br><span class="line">· setnx lock<span class="operator">-</span>key <span class="keyword">value</span>		设置公共锁</span><br><span class="line"># 返回设置成功 说明有控制权 </span><br><span class="line"># 返回设置失败 则说明不具有控制权 进行排队<span class="operator">/</span>等待</span><br><span class="line">· del lock<span class="operator">-</span>key				删除公共锁</span><br><span class="line"></span><br><span class="line">为公共锁添加时间限定: #时间到了自动解锁 防止死锁</span><br><span class="line">· expire lock<span class="operator">-</span>key seconds		</span><br><span class="line">· pexpire lock<span class="operator">-</span>key milliseconds	</span><br><span class="line">注:一般都是微秒或毫秒级，具体需要测试 #推荐: 最大耗时 <span class="operator">*</span> <span class="number">120</span><span class="operator">%</span> <span class="operator">+</span> 平均网络延迟 <span class="operator">*</span> <span class="number">110</span><span class="operator">%</span></span><br></pre></td></tr></table></figure>
<h1 id="七、删除策略"><a href="#七、删除策略" class="headerlink" title="七、删除策略"></a>七、删除策略</h1><h2 id="1-数据删除"><a href="#1-数据删除" class="headerlink" title="1. 数据删除"></a>1. 数据删除</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">·定时删除 #时间换空间</span><br><span class="line">优点:节约内存</span><br><span class="line">缺点:CPU压力大</span><br><span class="line"></span><br><span class="line">·惰性删除 &quot;过期后，不做处理，下次访问时删除，不过期则返回&quot; #空间换时间</span><br><span class="line">优点:节约CPU</span><br><span class="line">缺点:内存压力大</span><br><span class="line"></span><br><span class="line">·定期删除 &quot;随机抽查，重点检查&quot; #每秒消耗固定的CPU资源 可以自由调整</span><br><span class="line"><span class="number">1.</span>读取配置server.hz的值，默认为<span class="number">0</span></span><br><span class="line"><span class="number">2.</span>每秒钟执行server.hz次serverCron()</span><br><span class="line"><span class="number">3.</span>serverCron()会调用databasesCron()获取数据</span><br><span class="line"><span class="number">4.</span>获取数据后，调用activeExpireCycle()随机抽取数据检测</span><br><span class="line"><span class="number">5.</span>若该数据超时，则删除</span><br><span class="line">注意:</span><br><span class="line"><span class="number">1.</span>抽取判定数据的时长为<span class="number">250</span>ms<span class="operator">/</span>server.hz</span><br><span class="line"><span class="number">2.</span>W取值为ACTIVE_EXPIRE_CYCLE_LOOKUPS_PRE_LOOP属性值，若本次删除数据 <span class="operator">&gt;</span> W<span class="operator">*</span><span class="number">25</span><span class="operator">%</span>，则再次执行删除过程</span><br><span class="line"><span class="number">3.</span>若本次删除数据 <span class="operator">&lt;</span> W<span class="operator">*</span><span class="number">25</span><span class="operator">%</span>，则检查下一个库</span><br><span class="line"><span class="number">4.</span>有参数current_db记录本次检测执行到哪个库，下次继续即可</span><br><span class="line"><span class="number">5.</span>通常使用定期删除和惰性删除</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>删除策略</th>
<th>优缺点</th>
<th>特性</th>
<th>总结</th>
</tr>
</thead>
<tbody><tr>
<td>定时删除</td>
<td>节约内存，无占用</td>
<td>不分时段占用CPU资源，频度高</td>
<td>拿时间换空间</td>
</tr>
<tr>
<td>惰性删除</td>
<td>内存占用严重</td>
<td>延时执行，CPU利用率高</td>
<td>拿空间换时间</td>
</tr>
<tr>
<td>定期删除</td>
<td>内存定期随机清理</td>
<td>每秒花费固定的CPU资源维护内存</td>
<td>随机抽查，重点抽查</td>
</tr>
</tbody></table>
<h2 id="2-数据逐出"><a href="#2-数据逐出" class="headerlink" title="2. 数据逐出"></a>2. 数据逐出</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">主要依靠&quot;逐出算法&quot; #可能失效</span><br><span class="line">执行命令前，调用freeMemoryIfNeeded()检测内存是否够多</span><br><span class="line">不够则临时删除一些数据清理空间</span><br><span class="line"></span><br><span class="line">info命令可以看缓存hit和miss的次数，根据业务进行调优</span><br><span class="line"></span><br><span class="line">conf配置:</span><br><span class="line">· maxmemory					最大可使用内存 #默认为<span class="number">0</span>即不限 通常设置<span class="number">50</span><span class="operator">%</span>以上</span><br><span class="line">· maxmemory<span class="operator">-</span>sampless		设置每次选取待删除数据个数 #默认为<span class="number">5</span></span><br><span class="line">· maxmemory<span class="operator">-</span>policy			设置删除策略 #选项见下图</span><br></pre></td></tr></table></figure>
<p><img src="/images/2021-03-29/6.jpg" alt="策略"></p>
<h1 id="八、Redis集群"><a href="#八、Redis集群" class="headerlink" title="八、Redis集群"></a>八、Redis集群</h1><h2 id="1-主从连接"><a href="#1-主从连接" class="headerlink" title="1. 主从连接"></a>1. 主从连接</h2><p>理论基础:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">我们建立服务器的最终目标是:</span><br><span class="line"><span class="number">1.</span>高并发 <span class="number">2.</span>高性能 <span class="number">3.</span>高可用</span><br><span class="line">其中，高可用的理论目标是全年宕机低于<span class="number">315</span>秒。</span><br><span class="line"></span><br><span class="line">对此，我们可以建立主从连接来提高可用性，即一台主服务器对应多台从服务器。</span><br><span class="line">主服务器只进行写操作，从服务器只进行读操作，读写分离提高效率。</span><br><span class="line">而当主服务器出现问题时，可以让一台从服务器接替成为主服务器，从而保证服务器集群正常运行。</span><br><span class="line"></span><br><span class="line">主从连接的特点:</span><br><span class="line"><span class="number">1.</span>读写分离 	提高效率。</span><br><span class="line"><span class="number">2.</span>负载均衡 	基于主从结构，配合读写分离，slave分担master负载。根据需求改变slave的数量，分担负载，提高并发与吞吐。</span><br><span class="line"><span class="number">3.</span>故障恢复	由于主从服务器上的数据是一致的，当需要恢复数据时，直接复制另一台服务器上的数据即可。</span><br><span class="line"><span class="number">4.</span>数据冗余持久化		由于是集群形态，相同数据在多个服务器上，造成数据冗余，易于持久化。</span><br><span class="line"><span class="number">5.</span>高可用基础		主从连接是高可用服务器的基础。	</span><br></pre></td></tr></table></figure>
<p>主从连接的方式:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">方法一: 客户端发送命令</span><br><span class="line">· slaveof <span class="operator">&lt;</span>masterip<span class="operator">&gt;</span> <span class="operator">&lt;</span>masterport<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line">方法二: 启动服务器参数</span><br><span class="line">· redis<span class="operator">-</span>server <span class="operator">-</span>slaveof <span class="operator">&lt;</span>masterip<span class="operator">&gt;</span> <span class="operator">&lt;</span>masterport<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line">方法三: 服务器配置 #主流</span><br><span class="line">· slaveof <span class="operator">&lt;</span>masterip<span class="operator">&gt;</span> <span class="operator">&lt;</span>masterport<span class="operator">&gt;</span>	</span><br></pre></td></tr></table></figure>
<p>主从复制的三个阶段:</p>
<ul>
<li>阶段一：建立连接阶段<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>slave 	<span class="operator">-</span>	发送<span class="string">&#x27;slaveof ip port&#x27;</span>，申请建立连接</span><br><span class="line"><span class="number">2.</span>master	<span class="operator">-</span>	接收到指令，发送信息响应对方</span><br><span class="line"><span class="number">3.</span>slave		<span class="operator">-</span>	保存master的IP和端口</span><br><span class="line"><span class="number">4.</span>slave		<span class="operator">-</span>	与master建立socket连接</span><br><span class="line"><span class="number">5.</span>slave		<span class="operator">-</span>	ping</span><br><span class="line"><span class="number">6.</span>master	<span class="operator">-</span>	pong</span><br><span class="line"><span class="number">7.</span>slave		<span class="operator">-</span>	发送指令</span><br><span class="line"><span class="number">8.</span>master	<span class="operator">-</span>	验证授权</span><br><span class="line"><span class="number">9.</span>slave		<span class="operator">-</span>	发送指令 port端口</span><br><span class="line"><span class="number">10.</span>master	<span class="operator">-</span>	保存端口号</span><br><span class="line"></span><br><span class="line">相关:</span><br><span class="line"># 从属客户端发送命令</span><br><span class="line">· slaveof <span class="operator">&lt;</span>masterip<span class="operator">&gt;</span> <span class="operator">&lt;</span>masterport<span class="operator">&gt;</span>	主从连接</span><br><span class="line">· slaveof <span class="keyword">no</span> <span class="keyword">one</span>					主从断开连接</span><br><span class="line"></span><br><span class="line">· requirepass <span class="operator">&lt;</span>password<span class="operator">&gt;</span>				master配置文件设置密码</span><br><span class="line">· config <span class="keyword">set</span> requirepass <span class="operator">&lt;</span>password<span class="operator">&gt;</span>		master客户端发送命令设置密码</span><br><span class="line">· config <span class="keyword">get</span> requirepass</span><br><span class="line">· auth <span class="operator">&lt;</span>password<span class="operator">&gt;</span>						slave客户端发送命令设置密码</span><br><span class="line">· masterauth <span class="operator">&lt;</span>password<span class="operator">&gt;</span>					slave配置文件设置密码</span><br><span class="line">· redis<span class="operator">-</span>cli <span class="operator">-</span>a <span class="operator">&lt;</span>password<span class="operator">&gt;</span>				启动客户端设置密码</span><br></pre></td></tr></table></figure></li>
<li>阶段二：数据同步阶段<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">服务器运行ID (runid) # info Server 查看相关信息</span><br><span class="line">· 是每一台服务器每次运行的身份识别码，一台服务器多次运行可用生成多个运行id</span><br><span class="line">· id由<span class="number">40</span>位字符组成，是一个随机的十六进制字符</span><br><span class="line">· 用于识别身份，进行操作时需要首先进行id比对</span><br><span class="line"></span><br><span class="line"># 以下为全量复制 复制大部分整体</span><br><span class="line"><span class="number">1.</span>slave		<span class="operator">-</span>	发送指令<span class="string">&#x27;psync2 &lt;runid&gt; &lt;offset&gt;&#x27;</span> # ? <span class="number">-1</span> 此时不知道runid 和 <span class="keyword">offset</span></span><br><span class="line"><span class="number">2.</span>master	<span class="operator">-</span>	接收指令，执行bgsave生成RDB文件，记录当前的复制偏移量</span><br><span class="line"><span class="number">3.</span>master	<span class="operator">-</span>	发送<span class="string">&#x27;+FULLRESYNC runid offset&#x27;</span>，通过socket发送RDB文件给slave，期间接收客户端命令，<span class="keyword">offset</span>发生了变化</span><br><span class="line"><span class="number">4.</span>slave		<span class="operator">-</span>	收到<span class="string">&#x27;+FULLRESYNC&#x27;</span>，保存master的runid和<span class="keyword">offset</span>，清空当前全部数据，通过socket接收RDB文件，恢复RDB数据</span><br><span class="line"># 以下为部分复制 复制发送RDB文件期间master接收到的命令</span><br><span class="line"><span class="number">5.</span>slave		<span class="operator">-</span>	发送指令<span class="string">&#x27;psync2 runid offset&#x27;</span></span><br><span class="line"><span class="number">6.</span>master	<span class="operator">-</span>	接收命令，判定runid是否匹配，判定<span class="keyword">offset</span>是否在复制缓冲区内</span><br><span class="line"><span class="number">7.</span>master	<span class="operator">-</span>	如果runid或<span class="keyword">offset</span>有一个不满足，执行全量复制 #执行步骤<span class="number">2</span>	</span><br><span class="line"><span class="number">7.</span>master	<span class="operator">-</span>	如果runid和<span class="keyword">offset</span>校验通过，<span class="keyword">offset</span>与本机<span class="keyword">offset</span>相同，忽略</span><br><span class="line"><span class="number">7.</span>master	<span class="operator">-</span>	如果runid和<span class="keyword">offset</span>校验通过，<span class="keyword">offset</span>与本机<span class="keyword">offset</span>不相同，发送<span class="string">&#x27;+CONTINUE offset&#x27;</span></span><br><span class="line">				通过socket发送复制缓冲区中<span class="keyword">offset</span>到本机<span class="keyword">offset</span>的数据</span><br><span class="line"><span class="number">8.</span>slave		<span class="operator">-</span>	收到<span class="string">&#x27;+CONTINUE&#x27;</span>，保存master的<span class="keyword">offset</span>，接收消息后，执行bgrewriteaof恢复数据</span><br><span class="line"></span><br><span class="line">相关: #配置文件</span><br><span class="line">· repl<span class="operator">-</span>backlog<span class="operator">-</span>size <span class="number">1</span>mb				设置复制缓冲区大小</span><br><span class="line">· slave<span class="operator">-</span>serve<span class="operator">-</span>stale<span class="operator">-</span>data yes<span class="operator">|</span><span class="keyword">no</span>		slave在同步期间是否关闭对外服务</span><br><span class="line"></span><br><span class="line">· master一般占用内存的<span class="number">50</span><span class="operator">%</span><span class="number">-70</span><span class="operator">%</span>，剩下的<span class="number">30</span><span class="operator">%</span><span class="number">-50</span><span class="operator">%</span>给bgsave和缓冲区用</span><br><span class="line">· 同时请求复制，发送的RDB文件多，所以需要错峰请求</span><br><span class="line">· 或者采用拓扑结构，一主多从改成树状结构，但是一致性会变差</span><br></pre></td></tr></table></figure></li>
<li>阶段三：命令传播阶段<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>master发送命令:ping	<span class="operator">/</span>	slave发送命令:replconf ack <span class="keyword">offset</span></span><br><span class="line"><span class="number">2.</span>master	<span class="operator">-</span>	接收命令，判定<span class="keyword">offset</span>是否在复制缓冲区内</span><br><span class="line"><span class="number">3.</span>master	<span class="operator">-</span>	如果不在缓冲区，则执行全量复制</span><br><span class="line"><span class="number">3.</span>master	<span class="operator">-</span>	如果在缓冲区，且<span class="keyword">offset</span>与<span class="keyword">offset</span>相同，忽略</span><br><span class="line"><span class="number">3.</span>master	<span class="operator">-</span>	如果在缓冲区，且<span class="keyword">offset</span>与<span class="keyword">offset</span>不同，发送<span class="string">&#x27;+CONTINUE offset&#x27;</span></span><br><span class="line">				通过socket发送复制缓冲区中<span class="keyword">offset</span>到本机<span class="keyword">offset</span>的数据</span><br><span class="line"><span class="number">4.</span>slave		<span class="operator">-</span>	收到<span class="string">&#x27;+CONTINUE&#x27;</span>，保存master的<span class="keyword">offset</span>，接收消息后，执行bgrewriteaof恢复数据</span><br><span class="line"></span><br><span class="line">相关:</span><br><span class="line"># 心跳机制     master:ping     slave:REPLCONF ACK</span><br><span class="line">· repl<span class="operator">-</span>ping<span class="operator">-</span>slave<span class="operator">-</span><span class="keyword">period</span> <span class="number">10</span>		master不断<span class="string">&#x27;ping&#x27;</span>的周期，判断slave是否在线</span><br><span class="line"># 当slave数量少于<span class="number">2</span>个，或者所有slave的延迟都大于等于<span class="number">10</span>秒时，强制关闭master写功能，停止数据同步 </span><br><span class="line">· min<span class="operator">-</span>slaves<span class="operator">-</span><span class="keyword">to</span><span class="operator">-</span>write <span class="number">2</span>		#保障数据稳定性</span><br><span class="line">· min<span class="operator">-</span>slaves<span class="operator">-</span>max<span class="operator">-</span>lag <span class="number">10</span>		#发送 REPLCONF ACK 命令  获取当前数量与延迟</span><br><span class="line"></span><br><span class="line">闪断闪联: 忽略</span><br><span class="line">短时间中断: 部分复制</span><br><span class="line">长时间终端: 全量复制</span><br></pre></td></tr></table></figure>
主从复制常见问题:<br><img src="/images/2021-03-29/7.jpg" alt="在这里插入图片描述"><br><img src="/images/2021-03-29/8.jpg" alt="在这里插入图片描述"><br><img src="/images/2021-03-29/8-1.jpg" alt="在这里插入图片描述"><br><img src="/images/2021-03-29/9.jpg" alt="在这里插入图片描述"><br><img src="/images/2021-03-29/10.jpg" alt="在这里插入图片描述"></li>
</ul>
<h2 id="2-哨兵"><a href="#2-哨兵" class="headerlink" title="2. 哨兵"></a>2. 哨兵</h2><p>思路:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>宕机master下线</span><br><span class="line"><span class="number">2.</span>找一个slave成为新master</span><br><span class="line"><span class="number">3.</span>通知所有slave连接新master</span><br><span class="line"><span class="number">4.</span>启动新的master与slave</span><br><span class="line"><span class="number">5.</span>全量复制<span class="operator">/</span>部分复制</span><br><span class="line"></span><br><span class="line">其中观测下线服务器以及推选新master的服务器，就被称为哨兵。</span><br></pre></td></tr></table></figure>
<p>结构与作用:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;分布式系统，监控全部&#x27;</span></span><br><span class="line">· 监控				检查master和slave是否正常</span><br><span class="line">· 通知				出问题时，通知哨兵和客户端</span><br><span class="line">· 自动故障转移		断开master和slave连接，推选新的master，其他slave连接到新master，告知客户端新地址</span><br><span class="line"></span><br><span class="line">注:</span><br><span class="line"><span class="number">1.</span>哨兵也是redis服务器，只是不提供数据</span><br><span class="line"><span class="number">2.</span>哨兵数量通常为单数，便于投票选举</span><br></pre></td></tr></table></figure>
<p>哨兵基础配置文件与启动:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">· port <span class="number">26379</span>											服务端口 通常最前加<span class="number">2</span></span><br><span class="line">· dir &quot;/.../redis/data&quot;									哨兵工作信息储存目录</span><br><span class="line">· sentinel monitor mymaster <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379</span> <span class="number">2</span>			监控的主服务器 当有<span class="number">2</span>个哨兵觉得它挂了，它就算挂了 #数量一半<span class="operator">+</span><span class="number">1</span> </span><br><span class="line">· sentinel down<span class="operator">-</span>after<span class="operator">-</span>milliseconds mymaster <span class="number">30000</span>		<span class="number">30</span>秒连接无响应，该哨兵认定它挂了</span><br><span class="line">· sentinel failover<span class="operator">-</span>timeout mymaster <span class="number">180000</span>				<span class="number">180</span>秒未同步完成，认定同步超时</span><br><span class="line">· sentinel parallel<span class="operator">-</span>syncs mymaster <span class="number">1</span>					重连了以后，一次一台进行同步</span><br><span class="line"></span><br><span class="line">· redis<span class="operator">-</span>sentinel sentinel<span class="operator">-</span>port.conf						启动哨兵</span><br><span class="line">启动顺序: 主<span class="operator">-</span>从<span class="operator">-</span>哨</span><br></pre></td></tr></table></figure>
<p>哨兵工作原理:<br><img src="/images/2021-03-29/11.jpg" alt="在这里插入图片描述"></p>
<p><img src="/images/2021-03-29/12.jpg" alt="监控阶段"><br><img src="/images/2021-03-29/13.jpg" alt="在这里插入图片描述"><br><img src="/images/2021-03-29/14.jpg" alt="在这里插入图片描述"></p>
<h2 id="3-集群"><a href="#3-集群" class="headerlink" title="3. 集群"></a>3. 集群</h2><p>简介:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">当redis单机提供的服务OPS不足，或者单机内存容量不足时，可用采用集群的方式解决上述问题。</span><br><span class="line"></span><br><span class="line">架构:</span><br><span class="line">· 集群就是使用网络将若干台计算机联通起来，并提供统一的管理方式，使其对外呈现单机的服务效果</span><br><span class="line"></span><br><span class="line">作用:</span><br><span class="line">· 分散单台服务器的访问压力，实现负载均衡</span><br><span class="line">· 分散单台服务器的存储压力，实现可扩展性</span><br><span class="line">· 降低单台服务器宕机带来的业务灾难</span><br></pre></td></tr></table></figure>
<p>设计:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">数据存储设计:</span><br><span class="line">· 通过算法设计，计算出key应该保存的位置</span><br><span class="line">· 将所有的存储空间计划切割成<span class="number">16384</span>份，每台主机保存一部分 #槽</span><br><span class="line">  每份代表的是一个储存空间，不少一个key的保存空间</span><br><span class="line">· 将key按照计算出的结结果放到对应的存储空间</span><br><span class="line"></span><br><span class="line">· 当一台新的服务器加入集群时，每台服务器拿出一部分存储空间(槽)给新的服务器，即可将新的服务器加入集群</span><br><span class="line">· 增强可扩展性</span><br><span class="line"></span><br><span class="line">内部通讯设计:</span><br><span class="line">· 每个服务器数据库互相通信，保存各个库里储存空间(槽)的编号数据</span><br><span class="line">· 如果客户端访问的数据库中有想要的数据，直接返回 #一次命中，直接返回</span><br><span class="line">· 如果客户端访问的数据库中没有想要的数据，根据编号数据，去新的库里找 #一次未命中，告知具体位置</span><br><span class="line"># 这样可以保证最多查询两次，可以返回结果，提高查询效率</span><br></pre></td></tr></table></figure>
<p>相关配置与命令:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">配置:</span><br><span class="line">· clusetr<span class="operator">-</span>enabled yes<span class="operator">|</span><span class="keyword">no</span>				设置加入cluster，成为其中的节点</span><br><span class="line">· cluster<span class="operator">-</span>config<span class="operator">-</span>file <span class="operator">&lt;</span>filename.conf<span class="operator">&gt;</span>	cluster配置文件名，该文件自动生成，仅用于查找文件并查询文件内容</span><br><span class="line">· cluster<span class="operator">-</span>node<span class="operator">-</span>timeout <span class="operator">&lt;</span>milliseconds<span class="operator">&gt;</span>	响应超时判定，判定该节点是否下线或切换为从节点 #一秒连接一次</span><br><span class="line">· cluster<span class="operator">-</span>migration<span class="operator">-</span>barrier <span class="operator">&lt;</span>count<span class="operator">&gt;</span>		master连接的slave最小数量</span><br><span class="line"></span><br><span class="line">命令:</span><br><span class="line">· cluster nodes							查看集群节点信息</span><br><span class="line">· cluster replicate <span class="operator">&lt;</span>master<span class="operator">-</span>id<span class="operator">&gt;</span>			进入一个从节点redis，切换其主节点</span><br><span class="line">· cluster meet ip:port					发现一个新节点，新增主节点</span><br><span class="line">· cluster forget <span class="operator">&lt;</span>id<span class="operator">&gt;</span>					忽略一个没有solt的节点</span><br><span class="line">· cluster failover						手动故障转移</span><br><span class="line"></span><br><span class="line">集群构建启动:</span><br><span class="line">· 先把服务端全部启动，按照上面的配置文件</span><br><span class="line">· .<span class="operator">/</span>redis<span class="operator">-</span>trib.rb <span class="keyword">create</span> <span class="comment">--replicas 1 127.0.0.1:6379</span></span><br><span class="line"># <span class="number">1</span>代表一个master连一个slave 后面写master的IP:PORT</span><br><span class="line"></span><br><span class="line">集群操控:</span><br><span class="line">· redis<span class="operator">-</span>cli <span class="operator">-</span>c							登陆集群的客户端</span><br><span class="line">· redis<span class="operator">-</span>cli <span class="operator">-</span>c <span class="operator">-</span>p <span class="number">6382</span></span><br></pre></td></tr></table></figure>
<h1 id="九、企业级解决方案"><a href="#九、企业级解决方案" class="headerlink" title="九、企业级解决方案"></a>九、企业级解决方案</h1><h2 id="1-缓存预热"><a href="#1-缓存预热" class="headerlink" title="1. 缓存预热"></a>1. 缓存预热</h2><p>情况</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">启动后迅速宕机</span><br></pre></td></tr></table></figure>
<p>问题排查</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 请求数量较高</span><br><span class="line"><span class="number">2.</span> 主从之间数据吞吐量较大，数据同步操作频度较高</span><br></pre></td></tr></table></figure>
<p>解决方案</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">前置准备工作:</span><br><span class="line"><span class="number">1.</span> 日常例行统计数据访问记录，统计访问频度较高的热点数据</span><br><span class="line"><span class="number">2.</span> 利用LRU数据删除策略，构建数据留存队列  (例如: storm与kafka配合)</span><br><span class="line">准备工作:</span><br><span class="line"><span class="number">3.</span> 将统计结果中的数据分类，设置级别，redis优先加载级别较高的热点数据</span><br><span class="line"><span class="number">4.</span> 利用分布式多服务器同时进行数据读取，提速数据加载过程</span><br><span class="line">实施:</span><br><span class="line"><span class="number">1.</span> 使用脚本程序固定触发数据预热过程</span><br><span class="line"><span class="number">2.</span> 如果条件允许，使用了CDN(内容分发网络)，效果会更好</span><br></pre></td></tr></table></figure>
<p>总结</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">· 缓存预热就是系统启动前，提前将相关的缓存数据直接加载到缓存系统。</span><br><span class="line">· 避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题。</span><br><span class="line">  用户直接查询事先被预热的缓存数据。</span><br></pre></td></tr></table></figure>
<h2 id="2-缓存雪崩"><a href="#2-缓存雪崩" class="headerlink" title="2. 缓存雪崩"></a>2. 缓存雪崩</h2><p>情况</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 系统平稳运行过程中，忽然数据库连接量激增</span><br><span class="line"><span class="number">2.</span> 应用服务器无法及时处理请求</span><br><span class="line"><span class="number">3.</span> 大量<span class="number">408</span><span class="operator">/</span><span class="number">500</span>错误页面出现</span><br><span class="line"><span class="number">4.</span> 客户反复刷新页面获取数据</span><br><span class="line"><span class="number">5.</span> 数据库崩溃</span><br><span class="line"><span class="number">6.</span> 应用服务器崩溃</span><br><span class="line"><span class="number">7.</span> 重启应用服务器无效</span><br><span class="line"><span class="number">8.</span> Redis服务器崩溃</span><br><span class="line"><span class="number">9.</span> Redis集群崩溃</span><br><span class="line"><span class="number">10.</span> 重启数据库后再次被瞬间流量放倒</span><br></pre></td></tr></table></figure>
<p>问题排查</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 在一个较短的时间内，缓存中较多的key集中过期</span><br><span class="line"><span class="number">2.</span> 此周期内请求访问过期的数据，redis未命中，redis向数据库获取数据</span><br><span class="line"><span class="number">3.</span> 数据库同时接收到大量的请求无法及时处理</span><br><span class="line"><span class="number">4.</span> Redis大量请求被积压，开始出现超时现象</span><br><span class="line"><span class="number">5.</span> 数据库流量激增，数据库崩溃</span><br><span class="line"><span class="number">6.</span> 重启后仍然面对缓存中无数据可用</span><br><span class="line"><span class="number">7.</span> Redis服务器资源被严重占用，Redis服务器崩溃</span><br><span class="line"><span class="number">8.</span> Redis集群呈现崩塌，集群瓦解</span><br><span class="line"><span class="number">9.</span> 应用服务器无法及时得到数据响应请求，来自客户端的请求数量越来越多，应用服务器崩溃</span><br><span class="line"><span class="number">10.</span> 应用服务器<span class="operator">/</span>redis<span class="operator">/</span>数据库全部重启，效果不理想</span><br></pre></td></tr></table></figure>
<p>解决方案(理论)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>更多的页面静态化处理</span><br><span class="line">(减少请求)</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>构建多级缓存架构</span><br><span class="line">(Nginx缓存<span class="operator">+</span>redis缓存<span class="operator">+</span>ehcache缓存)</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>检测Mysql严重耗时业务进行优化</span><br><span class="line">(对数据库的瓶颈排查:例如超时查询、耗时较高事务等)</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>灾难预警机制</span><br><span class="line">监控redis服务器性能指标:</span><br><span class="line">· CPU占用、CPU使用率</span><br><span class="line">· 内存容量</span><br><span class="line">· 查询平均响应时间</span><br><span class="line">· 线程数</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>限流、降级</span><br><span class="line">(短时间范围内牺牲一些客户体验，限制一部分请求访问，降低应用服务器压力，待业务低速运转后再逐步放开访问)</span><br></pre></td></tr></table></figure>
<p>解决方案(方法)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>LRU与LFU切换</span><br><span class="line">(内存替换算法)</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>数据有效期策略调整</span><br><span class="line">· 根据业务数据有效期进行分类错峰 eg:A类<span class="number">90</span>分钟，B类<span class="number">80</span>分钟，C类<span class="number">70</span>分钟</span><br><span class="line">· 过期时间使用固定时间<span class="operator">+</span>随机值的形式，稀释集中到期的key的数量</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>超热数据使用永久key</span><br><span class="line">(避免key过期)</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>定期维护(自动<span class="operator">+</span>人工)</span><br><span class="line">(对即将过期数据做访问量分析，确认是否延时，配合访问量统计，做热点数据的延时)</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>加锁</span><br><span class="line">(慎用<span class="operator">!</span>)</span><br></pre></td></tr></table></figure>
<p>总结</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">· 缓存雪崩就是瞬间过期数据量太大，导致对数据库服务器造成压力。</span><br><span class="line">· 如能够有效避免过期时间集中，可以有效解决雪崩现象的出现(约<span class="number">40</span><span class="operator">%</span>)，</span><br><span class="line">  配合其他策略一起使用，并监控服务器的运行数据，根据运行记录做快速调整。</span><br></pre></td></tr></table></figure>
<h2 id="3-缓存击穿"><a href="#3-缓存击穿" class="headerlink" title="3. 缓存击穿"></a>3. 缓存击穿</h2><p>情况</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 系统平稳运行过程中</span><br><span class="line"><span class="number">2.</span> 数据库连接量瞬间激增</span><br><span class="line"><span class="number">3.</span> Redis服务器无大量key过期</span><br><span class="line"><span class="number">4.</span> Redis内存平稳，无波动</span><br><span class="line"><span class="number">5.</span> Redis服务器CPU正常</span><br><span class="line"><span class="number">6.</span> 数据库崩溃</span><br></pre></td></tr></table></figure>
<p>问题排查&#x2F;分析</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> Redis中某个key过期，该key访问量巨大</span><br><span class="line"><span class="number">2.</span> 多个数据请求从服务器直接压到Redis后，均未命中</span><br><span class="line"><span class="number">3.</span> Redis在短时间内发起了大量对数据库中同一数据的访问</span><br><span class="line"></span><br><span class="line">· 单个key高热数据</span><br><span class="line">· key过期</span><br></pre></td></tr></table></figure>
<p>解决方案</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>预先设定</span><br><span class="line">· 以电商为例，每个商家根据店铺等级，指定若干款主打商品，在购物节期间，加大此类信息key的过期时长</span><br><span class="line">· 注意: 购物节不仅仅指当天，以及后续若干天，访问峰值呈现逐渐降低的趋势</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>现场调整</span><br><span class="line">(监控访问量，对自然流量激增的数据延长过期时间或设置为永久性key)</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>后台刷新数据</span><br><span class="line">(启动定时任务，高峰期来临之前,刷新数据有效期，确保不丢失)</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>二级缓存</span><br><span class="line">(设置不同的失效时间，保障不会被同时淘汰就行)</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>加锁</span><br><span class="line">(分布式锁，防止被击穿，但是要注意也是性能瓶颈，慎重<span class="operator">!</span>)</span><br></pre></td></tr></table></figure>
<p>总结</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">· 缓存击穿就是单个高热数据过期的瞬间，数据访问量较大，未命中redis后，</span><br><span class="line">  发起了大量对同一数据的数据库访问，导致对数据库服务器造成压力。</span><br><span class="line">· 应对策略应该在业务数据分析与预方面进行，配合运行监控测试与即时调整策略，</span><br><span class="line">  毕竟单个key的过期监控难度较高，配合雪崩处理策略即可。</span><br></pre></td></tr></table></figure>
<h2 id="4-缓存穿透"><a href="#4-缓存穿透" class="headerlink" title="4. 缓存穿透"></a>4. 缓存穿透</h2><p>情况</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 系统平稳运行过程中</span><br><span class="line"><span class="number">2.</span> 应用服务器流量随时间增量较大</span><br><span class="line"><span class="number">3.</span> Redis服务器命中率随时间逐步降低</span><br><span class="line"><span class="number">4.</span> Redis内存平稳，内存无压力</span><br><span class="line"><span class="number">5.</span> Redis服务器CPU占用激增</span><br><span class="line"><span class="number">6.</span> 数据库服务器压力激增</span><br><span class="line"><span class="number">7.</span> 数据库崩溃</span><br></pre></td></tr></table></figure>
<p>问题排查&#x2F;分析</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> Redis中大面积出现未命中</span><br><span class="line"><span class="number">2.</span> 出现非正常URL访问</span><br><span class="line"></span><br><span class="line">· 获取的数据在数据库中也不存在,数据库查询未得到对应数据</span><br><span class="line">· Redis获取到<span class="keyword">null</span>数据未进行持久化，直接返回</span><br><span class="line">· 下次此类数据到达重复上述过程</span><br><span class="line">· 出现黑客攻击服务器</span><br></pre></td></tr></table></figure>
<p>解决方案</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>缓存<span class="keyword">null</span></span><br><span class="line">(对查询结果为<span class="keyword">null</span>的数据进行缓存(长期使用，定期清理)，设定短时限，例如<span class="number">30</span><span class="number">-60</span>秒，最高<span class="number">5</span>分钟)</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>白名单策略</span><br><span class="line">· 提前预热各种分类数据id对应的bitmaps，id作为bitmaps的<span class="keyword">offset</span>，相当于设置了数据白名单。</span><br><span class="line">  当加载正常数据时，放行，加载异常数据时直接拦截(效率偏低)</span><br><span class="line">· 使用布隆过滤器(有关布隆过滤器的命中问题对当前状况可以忽略)</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>．实施监控</span><br><span class="line">实时监控redis命中率(业务正常范围时，通常会有一个波动值)与<span class="keyword">null</span>数据的占比</span><br><span class="line">· 非活动时段波动:通常检测<span class="number">3</span><span class="number">-5</span>倍，超过<span class="number">5</span>倍纳入重点排查对象</span><br><span class="line">· 活动时段波动:通常检测<span class="number">10</span><span class="number">-50</span>倍，超过<span class="number">50</span>倍纳入重点排查对象</span><br><span class="line">根据倍数不同，启动不同的排查流程。然后使用黑名单进行防控(运营)</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> key加密</span><br><span class="line">问题出现后，临时启动防灾业务key，对key进行业务层传输加密服务，设定校验程序，过来的key校验</span><br><span class="line">例如每天随机分配<span class="number">60</span>个加密串，挑选<span class="number">2</span>到<span class="number">3</span>个，混淆到页面数据id中，发现访问key不满足规则，驳回数据访问</span><br></pre></td></tr></table></figure>
<p>总结</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">· 缓存击穿访问了不存在的数据，跳过了合法数据的redis数据缓存阶段，每次均访问数据库，导致对数据库服务器造成压力。</span><br><span class="line">· 通常此类数据的出现量是一个较低的值，当出现此类情况时要及时处理并报警。</span><br><span class="line">  应对策略应该在临时预案防范方面多做文章。无论是黑名单还是白名单，都是对整体系统的压力，警报解除后尽快移除。</span><br></pre></td></tr></table></figure>
<h2 id="5-性能监控指标"><a href="#5-性能监控指标" class="headerlink" title="5. 性能监控指标"></a>5. 性能监控指标</h2><p><img src="/images/2021-03-29/15.jpg" alt="在这里插入图片描述"><br>benchmark</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">· 命令</span><br><span class="line">redis<span class="operator">-</span>benchmark [<span class="operator">-</span>h] [<span class="operator">-</span>p] [<span class="operator">-</span>c] [<span class="operator">-</span>n <span class="operator">&lt;</span>requests]<span class="operator">&gt;</span> [<span class="operator">-</span>k]</span><br><span class="line"></span><br><span class="line">· 范例<span class="number">1</span></span><br><span class="line">redis<span class="operator">-</span>benchmark</span><br><span class="line">说明:<span class="number">50</span>个连接，<span class="number">10000</span>次请求对应的性能</span><br><span class="line"></span><br><span class="line">· 范例<span class="number">2</span></span><br><span class="line">redis<span class="operator">-</span>benchmark <span class="operator">-</span>c <span class="number">100</span> <span class="operator">-</span>n <span class="number">5000</span></span><br><span class="line">说明:<span class="number">100</span>个连接，<span class="number">5000</span>次请求对应的性能</span><br></pre></td></tr></table></figure>
<p>monitor</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">· 命令</span><br><span class="line">monitor</span><br><span class="line">打印服务器调试信息</span><br></pre></td></tr></table></figure>
<p>slowlog</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">· 命令</span><br><span class="line">slowlog [operator]</span><br><span class="line">	· <span class="keyword">get</span>:获取慢查询日志</span><br><span class="line">	· len:获取慢查询日志条目数</span><br><span class="line">	· reset:重置慢查询日志</span><br><span class="line"></span><br><span class="line">· 相关配置</span><br><span class="line">slowlog<span class="operator">-</span>log<span class="operator">-</span>slower<span class="operator">-</span>than <span class="number">1000</span> #设置慢查询的时间下线，单位:微妙</span><br><span class="line">slowlog<span class="operator">-</span>max<span class="operator">-</span>len <span class="number">100</span> #设置慢查询命令对应的日志显示长度，单位:命令数</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>感谢金主</div>
  <button>
    赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechat.jpg" alt="Zgg2001 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alibaba.jpg" alt="Zgg2001 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/Redis/" rel="tag"># Redis</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/03/22/20210322_MySql%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/" rel="prev" title="MySql学习记录：基础总结">
                  <i class="fa fa-angle-left"></i> MySql学习记录：基础总结
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/04/26/20210426_C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E9%A1%B9%E7%9B%AE%E5%8C%96(%E5%8A%A0%E5%85%A5%E5%86%85%E5%AD%98%E6%B1%A0%E9%9D%99%E6%80%81%E5%BA%93-%E6%8A%A5%E6%96%87%E5%8A%A8%E6%80%81%E5%BA%93)/" rel="next" title="C++网络编程学习：项目化 (加入内存池静态库 / 报文动态库)">
                  C++网络编程学习：项目化 (加入内存池静态库 / 报文动态库) <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Zgg2001</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">713k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">10:48</span>
  </span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
-->

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/zgg2001" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  





</body>
</html>
