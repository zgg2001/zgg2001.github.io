<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"zgg2001.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"show_result":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="本篇笔记汇总了C++11中的主要新语言功能，根据个人理解与查阅的资料进行记录。 主要参考地址：cppreference">
<meta property="og:type" content="article">
<meta property="og:title" content="C++11学习记录：核心语言功能特性">
<meta property="og:url" content="https://zgg2001.github.io/2021/12/02/20211202_C++11%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E6%A0%B8%E5%BF%83%E8%AF%AD%E8%A8%80%E5%8A%9F%E8%83%BD%E7%89%B9%E6%80%A7/index.html">
<meta property="og:site_name" content="小咸鱼的自留地">
<meta property="og:description" content="本篇笔记汇总了C++11中的主要新语言功能，根据个人理解与查阅的资料进行记录。 主要参考地址：cppreference">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zgg2001.github.io/images/2021-12-02/1.jpg">
<meta property="og:image" content="https://zgg2001.github.io/images/2021-12-02/2.jpg">
<meta property="og:image" content="https://zgg2001.github.io/images/2021-12-02/3.jpg">
<meta property="og:image" content="https://zgg2001.github.io/images/2021-12-02/4.jpg">
<meta property="og:image" content="https://zgg2001.github.io/images/2021-12-02/5-0.jpg">
<meta property="og:image" content="https://zgg2001.github.io/images/2021-12-02/5.jpg">
<meta property="og:image" content="https://zgg2001.github.io/images/2021-12-02/6.jpg">
<meta property="og:image" content="https://zgg2001.github.io/images/2021-12-02/7.jpg">
<meta property="og:image" content="https://zgg2001.github.io/images/2021-12-02/8.jpg">
<meta property="article:published_time" content="2021-12-01T16:00:02.000Z">
<meta property="article:modified_time" content="2021-12-01T16:00:02.000Z">
<meta property="article:author" content="Zgg2001">
<meta property="article:tag" content="C++标准库学习">
<meta property="article:tag" content="C&#x2F;C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zgg2001.github.io/images/2021-12-02/1.jpg">


<link rel="canonical" href="https://zgg2001.github.io/2021/12/02/20211202_C++11%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E6%A0%B8%E5%BF%83%E8%AF%AD%E8%A8%80%E5%8A%9F%E8%83%BD%E7%89%B9%E6%80%A7/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://zgg2001.github.io/2021/12/02/20211202_C++11%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E6%A0%B8%E5%BF%83%E8%AF%AD%E8%A8%80%E5%8A%9F%E8%83%BD%E7%89%B9%E6%80%A7/","path":"2021/12/02/20211202_C++11学习记录：核心语言功能特性/","title":"C++11学习记录：核心语言功能特性"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>C++11学习记录：核心语言功能特性 | 小咸鱼的自留地</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">小咸鱼的自留地</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%C2%B7-%E6%A8%A1%E6%9D%BF%E4%BC%98%E5%8C%96"><span class="nav-text">· 模板优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%AF%B9%E5%8F%B3%E5%B0%96%E6%8B%AC%E5%8F%B7%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-text">1. 对右尖括号的优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E9%BB%98%E8%AE%A4%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0"><span class="nav-text">2. 默认模板参数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%C2%B7-auto-%E4%B8%8E-decltype"><span class="nav-text">· auto 与 decltype</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-auto"><span class="nav-text">1. auto</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-decltype"><span class="nav-text">2. decltype</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%C2%B7-%E9%A2%84%E7%BD%AE%E4%B8%8E%E5%BC%83%E7%BD%AE%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-text">· 预置与弃置的函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E9%A2%84%E7%BD%AE"><span class="nav-text">1. 预置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%BC%83%E7%BD%AE"><span class="nav-text">2. 弃置</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%C2%B7-final-%E4%B8%8E-override"><span class="nav-text">· final 与 override</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-final"><span class="nav-text">1. final</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-override"><span class="nav-text">2. override</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%C2%B7-%E5%B0%BE%E9%9A%8F%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="nav-text">· 尾随返回类型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%C2%B7-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="nav-text">· 右值引用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%C2%B7-%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">· 移动构造函数与移动赋值运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">1. 移动构造函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">2. 移动赋值运算符</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%C2%B7-%E6%9C%89%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9E%9A%E4%B8%BE"><span class="nav-text">· 有作用域枚举</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%C2%B7-constexpr-%E4%B8%8E%E5%AD%97%E9%9D%A2%E7%B1%BB%E5%9E%8B"><span class="nav-text">· constexpr 与字面类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-constexpr"><span class="nav-text">1. constexpr</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%AD%97%E9%9D%A2%E7%B1%BB%E5%9E%8B"><span class="nav-text">2. 字面类型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%C2%B7-%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">· 列表初始化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%C2%B7-%E5%A7%94%E6%89%98%E4%B8%8E%E7%BB%A7%E6%89%BF%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">· 委托与继承的构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">1. 委托构造函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E7%BB%A7%E6%89%BF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">2. 继承构造函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%C2%B7-%E8%8A%B1%E6%8B%AC%E5%8F%B7%E6%88%96%E7%AD%89%E5%8F%B7%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8"><span class="nav-text">· 花括号或等号初始化器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%C2%B7-nullptr"><span class="nav-text">· nullptr</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%C2%B7-long-long"><span class="nav-text">· long long</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%C2%B7-char16-t-%E4%B8%8E-char32-t"><span class="nav-text">· char16_t 与 char32_t</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%C2%B7-%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="nav-text">· 类型别名</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%C2%B7-%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-text">· 变参数模板</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%C2%B7-%E6%8E%A8%E5%B9%BF%E7%9A%84%EF%BC%88%E9%9D%9E%E5%B9%B3%E5%87%A1%EF%BC%89%E8%81%94%E5%90%88%E4%BD%93"><span class="nav-text">· 推广的（非平凡）联合体</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%C2%B7-%E6%8E%A8%E5%B9%BF%E7%9A%84-POD-%EF%BC%88%E5%B9%B3%E5%87%A1%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%A0%87%E5%87%86%E5%B8%83%E5%B1%80%E7%B1%BB%E5%9E%8B%EF%BC%89"><span class="nav-text">· 推广的 POD （平凡类型与标准布局类型）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%C2%B7-Unicode-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="nav-text">· Unicode 字符串字面量</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%C2%B7-%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="nav-text">· 用户定义字面量</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%C2%B7-%E5%B1%9E%E6%80%A7"><span class="nav-text">· 属性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%C2%B7-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">· lambda 表达式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%C2%B7-noexcept-%E8%AF%B4%E6%98%8E%E7%AC%A6%E4%B8%8E-noexcept-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">· noexcept 说明符与 noexcept 运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-noexcept-%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="nav-text">1. noexcept 说明符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-noexcept-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">2. noexcept 运算符</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%C2%B7-alignof-%E4%B8%8E-alignas"><span class="nav-text">· alignof 与 alignas</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-alignof"><span class="nav-text">1. alignof</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-alignas"><span class="nav-text">2. alignas</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%C2%B7-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="nav-text">· 多线程内存模型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%C2%B7-%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%AD%98%E5%82%A8"><span class="nav-text">· 线程局部存储</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%C2%B7-GC-%E6%8E%A5%E5%8F%A3"><span class="nav-text">· GC 接口</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%C2%B7-%E8%8C%83%E5%9B%B4-for-%EF%BC%88%E5%9F%BA%E4%BA%8E-Boost-%E5%BA%93%EF%BC%89"><span class="nav-text">· 范围 for （基于 Boost 库）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%C2%B7-static-assert-%EF%BC%88%E5%9F%BA%E4%BA%8E-Boost-%E5%BA%93%EF%BC%89"><span class="nav-text">· static_assert （基于 Boost 库）</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zgg2001"
      src="/images/hbxxy.jpg">
  <p class="site-author-name" itemprop="name">Zgg2001</p>
  <div class="site-description" itemprop="description">河边小咸鱼</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">71</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/zgg2001" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zgg2001" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/zgg2001z" title="Weixin → zgg2001z" rel="noopener me"><i class="fab fa-weixin fa-fw"></i>Weixin</a>
      </span>
      <span class="links-of-author-item">
        <a href="/397606244@qq.com" title="E-Mail → 397606244@qq.com" rel="noopener me"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zgg2001.github.io/2021/12/02/20211202_C++11%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E6%A0%B8%E5%BF%83%E8%AF%AD%E8%A8%80%E5%8A%9F%E8%83%BD%E7%89%B9%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hbxxy.jpg">
      <meta itemprop="name" content="Zgg2001">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小咸鱼的自留地">
      <meta itemprop="description" content="河边小咸鱼">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="C++11学习记录：核心语言功能特性 | 小咸鱼的自留地">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++11学习记录：核心语言功能特性
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-02 00:00:02" itemprop="dateCreated datePublished" datetime="2021-12-02T00:00:02+08:00">2021-12-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>10k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>36 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><ul>
<li>本篇笔记汇总了C++11中的主要新语言功能，根据个人理解与查阅的资料进行记录。</li>
<li>主要参考地址：<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/11">cppreference</a></li>
</ul>
<span id="more"></span>

<h1 id="·-模板优化"><a href="#·-模板优化" class="headerlink" title="· 模板优化"></a>· 模板优化</h1><h2 id="1-对右尖括号的优化"><a href="#1-对右尖括号的优化" class="headerlink" title="1. 对右尖括号的优化"></a>1. 对右尖括号的优化</h2><p>&emsp;&emsp; 简单来讲，就是在C++11以前，当在模板使用中出现双右尖括号的时候，编译器会解析为右移符号 <code>&gt;&gt;</code>。这就导致模板嵌套写起来不太方便，右括号之间需要用空格来空开。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此句在C++11前是错误的，因为 &gt;&gt; 会解释为右移符号</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; test;</span><br><span class="line"><span class="comment">//在C++11前，一般都加个空格给空开</span></span><br><span class="line">vector&lt; vector&lt;<span class="type">int</span>&gt; &gt; test;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在C++11中其改进了编译器的解析规则，<strong>尽可能多的将多个右尖括号</strong> <code>&gt;</code> <strong>解析成模板参数结束符</strong>，从而方便代码编写。</p>
<h2 id="2-默认模板参数"><a href="#2-默认模板参数" class="headerlink" title="2. 默认模板参数"></a>2. 默认模板参数</h2><p>&emsp;&emsp;在C++11中，模板参数支持设定默认值。<strong>当未设定模板类型时，编译器首先会根据传参进行类型推导，当推导失败时，就会使用模板参数的默认值（默认值没有的话就会报错）。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T = <span class="type">long</span>, <span class="keyword">typename</span> U = <span class="type">int</span>&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">test</span>(T t = <span class="string">&#x27;a&#x27;</span>, U u = <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; t  &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; u &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//test&lt;char, char&gt;</span></span><br><span class="line"><span class="built_in">test</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);				<span class="comment">//a - b</span></span><br><span class="line"><span class="comment">//test&lt;int, char&gt;</span></span><br><span class="line"><span class="built_in">test</span>&lt;<span class="type">int</span>&gt;(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);		<span class="comment">//97 - b</span></span><br><span class="line"><span class="comment">//test&lt;char, char&gt;</span></span><br><span class="line"><span class="built_in">test</span>&lt;<span class="type">char</span>&gt;(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);		<span class="comment">//a - b</span></span><br><span class="line"><span class="comment">//test&lt;int, char&gt;</span></span><br><span class="line"><span class="built_in">test</span>&lt;<span class="type">int</span>, <span class="type">char</span>&gt;(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);	<span class="comment">//97 - b</span></span><br><span class="line"><span class="comment">//test&lt;char, int&gt;</span></span><br><span class="line"><span class="built_in">test</span>&lt;<span class="type">char</span>, <span class="type">int</span>&gt;(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);	<span class="comment">//a - 98</span></span><br><span class="line"><span class="comment">//test&lt;long, int&gt; 无法推导</span></span><br><span class="line"><span class="built_in">test</span>();						<span class="comment">//97 - 98</span></span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h1 id="·-auto-与-decltype"><a href="#·-auto-与-decltype" class="headerlink" title="· auto 与 decltype"></a>· auto 与 decltype</h1><h2 id="1-auto"><a href="#1-auto" class="headerlink" title="1. auto"></a>1. auto</h2><p>&emsp;&emsp;C++11中，出现了一个非常有用的关键字 <code>auto</code>，即占位类型说明符，它可以自动推导出占位处的类型。在C++11中，其只能服务于变量；在C++14中，其可以服务于函数返回值；在C++17中，它可以服务于非模板形参 <code>template&lt;auto I&gt; struct A;</code>；在C++20中，其也可以服务于函数形参 <code>void f(auto);</code>。<strong>下面单就C++11中的</strong> <code>auto</code> <strong>用法(变量)进行一定的总结。</strong></p>
<p>&emsp;&emsp;首先，其基本用法为 <code>auto x = expr;</code>，此时编译器会从初始化器推导类型，具体规则参考模板实参推导的规则。所以在使用 <code>auto</code> 的时候，必须要指定初始化内容，这样才可以正确的推导出类型进行初始化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = <span class="number">3.14</span>;	<span class="comment">//double</span></span><br><span class="line"><span class="keyword">auto</span> b = <span class="number">520</span>;	<span class="comment">//int</span></span><br><span class="line"><span class="keyword">auto</span> c = <span class="string">&#x27;a&#x27;</span>;	<span class="comment">//char</span></span><br><span class="line"><span class="keyword">auto</span> d;			<span class="comment">//error未初始化</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;由于推导规则与模板实参推导规则一致，所以cv关键字的保留情况相同：</p>
<ul>
<li>当变量不是指针或者引用类型时，推导的结果中不会保留 <code>const</code>、 <code>volatile</code> 关键字。</li>
<li>当变量是指针或者引用类型时，推导的结果中会保留 <code>const</code>、 <code>volatile</code> 关键字。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> temp = <span class="number">222</span>;</span><br><span class="line"><span class="keyword">auto</span>* a = &amp;temp;	<span class="comment">//auto = int -&gt; a : int*</span></span><br><span class="line"><span class="keyword">auto</span> b = &amp;temp; 	<span class="comment">//auto = int* -&gt; b : int*</span></span><br><span class="line"><span class="keyword">auto</span>&amp; c = temp; 	<span class="comment">//auto = int -&gt; c : int&amp;</span></span><br><span class="line"><span class="keyword">auto</span> d = temp; 		<span class="comment">//auto = int -&gt; d : int</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> e = temp;	<span class="comment">//auto = int -&gt; e : const int</span></span><br><span class="line"><span class="keyword">auto</span> f = e;				<span class="comment">//auto = int -&gt; f : int (忽略const)</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp; g = temp; 	<span class="comment">//auto = int -&gt; g : const int&amp;</span></span><br><span class="line"><span class="keyword">auto</span>&amp; h = g;			<span class="comment">//auto = const int -&gt; h : const int&amp;</span></span><br><span class="line"><span class="keyword">auto</span>* i = &amp;e; 			<span class="comment">//auto = const int -&gt; i : const int*</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;另外在C++11中，<code>auto</code> 不允许使用的场景主要有四个：</p>
<ol>
<li>不能作为函数参数，因为函数调用时才会传实参，<code>auto</code> 使用要求必须要给修饰的变量赋值，二者矛盾。</li>
<li>不能用于类的非静态成员变量初始化。原因和上一条一样，因为类的非静态成员变量在没创建对象的时候也是未定义的。</li>
<li>不能使用 <code>auto</code> 关键字定义数组。<code>int array[] = &#123;...&#125;</code> 后，<code>auto a = array</code> 是被允许的，a 被推导为 <code>int*</code> 类型；而 <code>auto b[] = array</code> 是非法的，因为 <code>auto</code> 无法定义数组。</li>
<li>无法使用 <code>auto</code> 推导函数模板。<code>Test&lt;double&gt; t;</code> 后，<code>Test&lt;auto&gt; t1 = t</code> 是不被允许的，因为 <code>auto</code> 不算是一个类型，是没办法传进去的。</li>
</ol>
<h2 id="2-decltype"><a href="#2-decltype" class="headerlink" title="2. decltype"></a>2. decltype</h2><p>&emsp;&emsp;即 <code>declare type</code> 的缩写。其作用也是推导类型，其推导和 <code>auto</code> 一样都是在编译期完成的。语法为 <code>decltype(表达式)</code>，其仅用于表达式类型的推导，不会理会表达式的值。但是有一点，<code>auto</code> 只能推导已初始化的变量类型，而 <code>decltype</code> 的可以推导比较复杂的表达式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a) b = <span class="number">20</span>;					<span class="comment">//b : int </span></span><br><span class="line"><span class="keyword">decltype</span>(a * <span class="number">2</span> + <span class="number">3.14</span>) c = <span class="number">13.14</span>; 	<span class="comment">//c : double</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>decltype</code> 的主要规则如下，简单来说就是当表达式为纯右值时推导出来会剔除cv修饰(因为纯右值不能被cv修饰)，其余都会都会保存cv修饰。</p>
<ol>
<li>如果 表达式 的值类别是亡值，将会 <code>decltype</code> 产生 T&amp;&amp;。</li>
<li>如果 表达式 的值类别是左值，或者被括号 <code>()</code> 包围，将会 <code>decltype</code> 产生 T&amp;。</li>
<li>如果 表达式 的值类别是纯右值，将会 <code>decltype</code> 产生 T。</li>
</ol>
<p>&emsp;</p>
<h1 id="·-预置与弃置的函数"><a href="#·-预置与弃置的函数" class="headerlink" title="· 预置与弃置的函数"></a>· 预置与弃置的函数</h1><h2 id="1-预置"><a href="#1-预置" class="headerlink" title="1. 预置"></a>1. 预置</h2><p>&emsp;&emsp;语法为 <code>函数 = default;</code>。通过将函数体定义为 <code>default</code> 来显式预置函数定义。</p>
<p>&emsp;&emsp;在声明类或者结构体的时候，如果未创建构造参数，则编译器会自动帮你创建一个空参空函数体的默认构造函数。例子如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Test <span class="title">t</span><span class="params">()</span></span>;<span class="comment">//可以编译</span></span><br><span class="line"></span><br><span class="line">编译器生成默认构造函数的Test类:</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Test</span>() &#123;&#125;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line">所以上面才可以调用空参构造</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;但是，一旦添加了其他有参数的构造函数，编译器就不再生成缺省的构造函数了。而在C++11中，其允许我们使用 <code>= default</code> 来要求编译器生成一个默认构造函数：<code>Test() = default</code>，这样就可以在使用其余带参构造函数时也能使用默认构造函数了。</p>
<h2 id="2-弃置"><a href="#2-弃置" class="headerlink" title="2. 弃置"></a>2. 弃置</h2><p>&emsp;&emsp;语法为 <code>函数 = delete;</code>。通过将函数体定义为 <code>delete</code> 来显式弃置函数定义。其可以删除特殊成员函数以及普通成员函数和非成员函数，以阻止定义或调用它们。函数的弃置定义必须是翻译单元中的首条声明，已经声明过的函数不能声明为弃置的。</p>
<p>&emsp;&emsp;在 <code>std::unique_ptr</code> 里删除了传参为 <code>unique_ptr</code> 左值的构造参数，以及相关的 <code>=</code> 操作。这样就可以保证此智能指针的唯一性。我个人感觉还是挺有用的，这样直接删除就不用重载了。<br><img src="/images/2021-12-02/1.jpg" alt="4"><br>&emsp;</p>
<h1 id="·-final-与-override"><a href="#·-final-与-override" class="headerlink" title="· final 与 override"></a>· final 与 override</h1><h2 id="1-final"><a href="#1-final" class="headerlink" title="1. final"></a>1. final</h2><p>&emsp;&emsp;其作用为指定某个虚函数不能在派生类中被覆盖，或者某个类不能被派生。也就是说，其可以作用于函数或者类，但是作用于函数时只能是<strong>虚函数</strong>。此关键字写于虚函数或类的后面。</p>
<ol>
<li>作用于虚函数：使用 <code>final</code> 修饰虚函数，阻止子类重写父类的此函数。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">final</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
<li>作用于类：使用 <code>final</code> 修饰类，此类无法被继承。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">final</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="2-override"><a href="#2-override" class="headerlink" title="2. override"></a>2. override</h2><p>&emsp;&emsp;其作用为指定一个虚函数覆盖另一个虚函数。在成员函数的声明或定义中，<code>override</code> 说明符确保该函数为虚函数并覆盖某个基类中的虚函数。如果不是这样，那么程序会生成编译错误。</p>
<p><code>override</code> <strong>是在成员函数声明符之后使用时拥有特殊含义的标识符，其他情况下它不是保留的关键词。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>&emsp;</p>
<h1 id="·-尾随返回类型"><a href="#·-尾随返回类型" class="headerlink" title="· 尾随返回类型"></a>· 尾随返回类型</h1><p>&emsp;&emsp;尾随返回类型语法为<code>auto 函数名(传参) -&gt; decltype(表达式) &#123; 函数体 &#125;</code>，返回值类型为 <code>decltype</code> 推导出的类型。</p>
<p>&emsp;&emsp;这个东西我感觉主要是为模板服务，使用场景主要是：</p>
<ol>
<li>返回值随模板类型变化<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T x, U y)</span> -&gt; <span class="title">decltype</span><span class="params">(x + y)</span><span class="comment">//这里说一嘴，此处的decltype不能填函数体内新声明的变量，比如z</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> z = x + y;</span><br><span class="line">	<span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">double</span> b = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">auto</span> ret = <span class="built_in">add</span>(a, b);</span><br><span class="line">cout &lt;&lt; ret &lt;&lt; endl;	<span class="comment">//4.14</span></span><br></pre></td></tr></table></figure></li>
<li>返回值类型比较复杂<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fpif</span><span class="params">(<span class="type">int</span>)</span> -&gt; <span class="title">int</span><span class="params">(*)</span><span class="params">(<span class="type">int</span>)</span></span></span><br></pre></td></tr></table></figure>
&emsp;</li>
</ol>
<h1 id="·-右值引用"><a href="#·-右值引用" class="headerlink" title="· 右值引用"></a>· 右值引用</h1><p>&emsp;&emsp;C++11中增加了一个新的很好用的类型，右值引用 <code>&amp;&amp;</code>，就是对右值的引用。首先看一下左右值的区别，其实主要就是看能不能取地址：</p>
<ul>
<li>左值为 <code>locator value</code>，即 <code>lvalue</code>；右值为 <code>read value</code>，即 <code>rvalue</code>。</li>
<li>左值：储存在内存中、有明确存储地址的数据(可取地址)</li>
<li>右值：可以提供数据值的数据(不可取地址)</li>
</ul>
<p>&emsp;&emsp;那么右值引用有什么作用？<strong>主要的作用就是延长右值的生命周期，以提高效率。</strong> 那么是如何提高效率的呢？比如说如下这个场景：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;vt;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;temp&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">vt.<span class="built_in">push_back</span>(temp);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;此段代码中，先声明了二维数组 <code>vt</code>，随后声明一个一维数组 <code>temp</code> 来塞入容器 <code>vt</code>。自此一维数组 <code>temp</code> 使命完成，其储存的右值也没有作用了。在 <code>push_back()</code> 操作中，其首先会将 <code>temp</code> 以左值引用传进去，随后再使用 <code>construct</code> 来创建一个 <code>vector&lt;int&gt;</code> 拷贝储存传进来的值，最后再放入容器(如下图)。这就导致在函数中，此组数据被完整拷贝了一次，降低了效率。<br><img src="/images/2021-12-02/2.jpg" alt="2"><br>&emsp;&emsp;那么，既然 <code>temp</code> 只在此处有用，可否直接把 <code>temp</code> 放入 <code>vt</code> 中来减少那次拷贝呢？右值引用就是为了这个场景而出现的。例如上面这个问题的本质为：<code>temp</code> 的右值生命周期到此为止，想要将其生命周期延长给另一个变量 <code>vt</code>，来避免对 <code>temp</code> 右值的复制。这时就可以传入右值来提高 <code>vector::push_back()</code> 的效率。 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45698148/article/details/120680378">std::move源码分析</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;vt;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;temp&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">vt.<span class="built_in">push_back</span>(<span class="built_in">move</span>(temp));<span class="comment">//这里的std::move的作用是将左值转为右值</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;C++11中，STL中已经重载了很多函数的传右值引用版本，比如下图中 <code>vector::push_back()</code> 的右值引用版本，其只调用了 <code>emplace_back</code> 函数来延长生命周期，从而避免使用 <code>construct</code> 重新拷贝创建。<br><img src="/images/2021-12-02/3.jpg" alt="3"><br>&emsp;&emsp;<strong>所以呢，在C++11以前，右值引用没出现时，实际面临的问题是分辨传入的是右值还是左值。</strong> 当右值引用出现后，函数就可以判断传入的是右值还是左值，从而做出更优的选择。例如 <code>vector::push_back()</code> 在接收到右值的时候，它就知道可以直接给这个右值改变”所有者”，从而提高效率。</p>
<p>&emsp;</p>
<h1 id="·-移动构造函数与移动赋值运算符"><a href="#·-移动构造函数与移动赋值运算符" class="headerlink" title="· 移动构造函数与移动赋值运算符"></a>· 移动构造函数与移动赋值运算符</h1><h2 id="1-移动构造函数"><a href="#1-移动构造函数" class="headerlink" title="1. 移动构造函数"></a>1. 移动构造函数</h2><p>&emsp;&emsp;移动构造函数其实就是传参为<strong>本类右值</strong>的构造参数，来实现将传入右值拥有的内存资源”移为已用”，这部分内容的实现被叫做<strong>移动语义</strong>。上面右值引用中举得 <code>vector::push_back(value_type&amp;&amp;)</code> 例子中，其实就是移动语义的一种实现，它延长了传入右值的存活时间。</p>
<p>&emsp;&emsp;移动构造函数在检测到传入内容为右值时，会将右值内容赋予新建的对象，并且删除右值原属主的内容，来实现<strong>移动语义</strong>。此类将内容”移为已用”的构造参数即可被称为<strong>移动构造参数</strong>。下面就是一个移动构造参数的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> n) : <span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(n))</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;copy construct&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移动构造函数</span></span><br><span class="line">    <span class="built_in">Test</span>(Test&amp;&amp; t) : <span class="built_in">num</span>(t.num)</span><br><span class="line">    &#123;</span><br><span class="line">        t.num = <span class="literal">nullptr</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;move construct&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">t</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">Test <span class="title">t1</span><span class="params">(move(t))</span></span>;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">copy construct</span><br><span class="line">move construct</span><br></pre></td></tr></table></figure>
<h2 id="2-移动赋值运算符"><a href="#2-移动赋值运算符" class="headerlink" title="2. 移动赋值运算符"></a>2. 移动赋值运算符</h2><p>&emsp;&emsp;移动赋值函数和上面的移动构造函数相似，只不过移动构造函数是在构造函数里接收右值操作，而移动赋值运算符是重载了 <code>operator =</code> 操作，使其接收一个右值，从而类可以进行 <code>类名 = 类右值</code> 这样的<strong>移动语义</strong>操作。下面是一个例子，其中移动构造函数和移动赋值运算符都有定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    std::string s;</span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">s</span>(<span class="string">&quot;测试&quot;</span>) &#123; &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; o) : <span class="built_in">s</span>(o.s) &#123; std::cout &lt;&lt; <span class="string">&quot;移动失败！\n&quot;</span>; &#125;</span><br><span class="line">    <span class="built_in">A</span>(A&amp;&amp; o) : <span class="built_in">s</span>(std::<span class="built_in">move</span>(o.s)) &#123; &#125;</span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">         s = other.s;</span><br><span class="line">         std::cout &lt;&lt; <span class="string">&quot;复制赋值\n&quot;</span>;</span><br><span class="line">         <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(A&amp;&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">         s = std::<span class="built_in">move</span>(other.s);</span><br><span class="line">         std::cout &lt;&lt; <span class="string">&quot;移动赋值\n&quot;</span>;</span><br><span class="line">         <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a1, a2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;尝试从右值临时量移动赋值 A\n&quot;</span>;</span><br><span class="line">    a1 = <span class="built_in">f</span>(<span class="built_in">A</span>()); <span class="comment">// 从右值临时量移动赋值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;尝试从亡值移动赋值 A\n&quot;</span>;</span><br><span class="line">    a2 = std::<span class="built_in">move</span>(a1); <span class="comment">// 从亡值移动赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;</p>
<h1 id="·-有作用域枚举"><a href="#·-有作用域枚举" class="headerlink" title="· 有作用域枚举"></a>· 有作用域枚举</h1><p>&emsp;&emsp;在C++11之前，枚举类型可能会出现一个问题：<strong>枚举值的重复</strong>。比如说下面这种情况：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三原色</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">LightColor</span></span><br><span class="line">&#123;</span><br><span class="line">	red,<span class="comment">//note: previous declaration ‘LightColor red’</span></span><br><span class="line">	green,</span><br><span class="line">	blue<span class="comment">//note: previous declaration ‘LightColor blue’</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//三基色</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">PaintColor</span></span><br><span class="line">&#123;</span><br><span class="line">	red,<span class="comment">//‘red’ conflicts with a previous declaration</span></span><br><span class="line">	yellow,</span><br><span class="line">	blue<span class="comment">//‘blue’ conflicts with a previous declaration</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//如上这样定义就会出现枚举值重复情况 无法正常编译</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在C++11之前为了解决这种情况都是将其放入另一个作用域(类或命名空间)中，比如下面就是放入别的命名空间：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三原色</span></span><br><span class="line"><span class="keyword">namespace</span> Light</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">enum</span> <span class="title class_">Color</span></span><br><span class="line">	&#123;</span><br><span class="line">		red,</span><br><span class="line">		green,</span><br><span class="line">		blue</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//三基色</span></span><br><span class="line"><span class="keyword">namespace</span> Paint</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">enum</span> <span class="title class_">Color</span></span><br><span class="line">	&#123;</span><br><span class="line">		red,</span><br><span class="line">		yellow,</span><br><span class="line">		blue</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line">Light::Color c1 = Light::red;</span><br><span class="line">Paint::Color c2 = Paint::red;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;但是使用命名空间或类这个解法明显有点繁琐以及浪费，于是在C++11中推出了<strong>有作用域枚举</strong>。如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三原色</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">LightColor</span></span><br><span class="line">&#123;</span><br><span class="line">	red,</span><br><span class="line">	green,</span><br><span class="line">	blue</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//三基色</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">PaintColor</span></span><br><span class="line">&#123;</span><br><span class="line">	red,</span><br><span class="line">	yellow,</span><br><span class="line">	blue</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line">LightColor c1 = LightColor::red;</span><br><span class="line">PaintColor c2 = PaintColor::red;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这样，既解决了常规枚举值重复的问题，也让整体定义和使用变得没那么繁琐。</p>
<p>&emsp;</p>
<h1 id="·-constexpr-与字面类型"><a href="#·-constexpr-与字面类型" class="headerlink" title="· constexpr 与字面类型"></a>· constexpr 与字面类型</h1><h2 id="1-constexpr"><a href="#1-constexpr" class="headerlink" title="1. constexpr"></a>1. constexpr</h2><p>&emsp;&emsp;在C语言中，<code>const</code> 关键字只有”只读”这一语义，但在C++中其引入了”常量”语义。<strong>在C++中，所谓”只读”和”常量”的区别大致在编译期间能不能直接确定初始值，若不能则被作为”只读变量”处理，若可以确定则被作为”常量”处理。</strong> 在 <code>constexpr</code> 出现之前，<code>const</code> 一直同时承担两种语义，故 <code>constexpr</code> 出现的意义便是承担”常量”这一语义。</p>
<p>&emsp;&emsp;所以，<code>constexpr</code> 表示在编译期就可以确定的内容，而 <code>const</code> 只保证运行时不直接被修改。我记得官方是建议凡是”常量”语义的场景都使用 <code>constexpr</code>，只对”只读”语义使用 <code>const</code>。另外在C++11中，<code>constexpr</code> 函数必须把一切放在单条 return 语句中，而在C++14后就无此要求了。</p>
<p>&emsp;&emsp;<code>constexpr</code> 可以修饰变量和函数。可以看到，C++标准库里的模板元编程内容都加上了 <code>constexpr</code> 修饰，因为这部分内容都是在编译期里可以被推出的。通过关键字 <code>constexpr</code> 的修饰，可以让编译器更好的优化、替换相关的常量，从而提高执行效率。当然，给一段不是常量返回值的函数加上关键字 <code>constexpr</code> 是无效的，编译器会在判定后忽略关键字。</p>
<p>&emsp;&emsp;另外存在 <code>noexcept</code> 运算符始终对常量表达式返回 true，所以它可以用于检查具体特定的 <code>constexpr</code> 函数返回是否采用常量表达式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>; </span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> b1 = <span class="built_in">noexcept</span>(<span class="built_in">f</span>()); <span class="comment">// false，constexpr 函数未定义</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> b2 = <span class="built_in">noexcept</span>(<span class="built_in">f</span>()); <span class="comment">// true，f() 是常量表达式</span></span><br></pre></td></tr></table></figure>
<h2 id="2-字面类型"><a href="#2-字面类型" class="headerlink" title="2. 字面类型"></a>2. 字面类型</h2><p>&emsp;&emsp;指明一个类型为字面类型。字面类型是 <code>constexpr</code> 变量所拥有的类型，且能通过 <code>constexpr</code> 函数构造、操作及返回它们。简单来说就是一个为了配合 <code>constexpr</code> 的理论概念。<br>&emsp;&emsp;<strong>注意：标准中并没有定义具有这个名字的具名要求。这是核心语言所定义的一种类型类别。将它作为具名要求包含于此只是为了保持一致性。</strong></p>
<p>&emsp;</p>
<h1 id="·-列表初始化"><a href="#·-列表初始化" class="headerlink" title="· 列表初始化"></a>· 列表初始化</h1><p>&emsp;&emsp;在C++11之前，变量、数组、对象等都有不同的初始化方法。而在C++11中出现了一种新的初始化方式，<strong>其统一了初始化方式并且让初始化行为具有确定的效果</strong>，即列表初始化。</p>
<p>&emsp;&emsp;列表初始化的语法就是在要初始化的内容后加上一个大括号（括号前可以加等号），其中写上初始化的内容即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Test <span class="title">t</span><span class="params">(<span class="number">520</span>)</span></span>;		<span class="comment">//普通构造</span></span><br><span class="line">Test t = <span class="number">520</span>;		<span class="comment">//隐式转换</span></span><br><span class="line">Test t = &#123;<span class="number">520</span>&#125;;		<span class="comment">//列表初始化</span></span><br><span class="line">Test t &#123;<span class="number">520</span>&#125;;		<span class="comment">//列表初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以下均为列表初始化</span></span><br><span class="line"><span class="type">int</span> i = &#123;<span class="number">1314</span>&#125;;		</span><br><span class="line"><span class="type">int</span> i &#123;<span class="number">1314</span>&#125;;		</span><br><span class="line"><span class="type">int</span> ii[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> ii[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;	</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span> &#123;<span class="number">5201314</span>&#125;;</span><br><span class="line"><span class="type">double</span> b = <span class="type">double</span> &#123;<span class="number">13.14</span>&#125;;</span><br><span class="line"><span class="type">int</span>* array = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;注意：类中的私有成员或者静态成员无法进行列表初始化。<strong>这个官方一点的总结应该是只有聚合类型才可以无条件使用列表初始化。</strong> 如果一个非聚合类也想使用列表初始化，那它必须得拥有相对应的构造函数。<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/list_initialization">cppreference解释链接</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">test</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="type">int</span> y;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> z;</span><br><span class="line">&#125;t&#123;<span class="number">123</span>, <span class="number">321</span>&#125;;<span class="comment">//accept</span></span><br><span class="line"><span class="comment">//静态成员初始化</span></span><br><span class="line"><span class="type">int</span> test::z = <span class="number">222</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;</p>
<h1 id="·-委托与继承的构造函数"><a href="#·-委托与继承的构造函数" class="headerlink" title="· 委托与继承的构造函数"></a>· 委托与继承的构造函数</h1><h2 id="1-委托构造函数"><a href="#1-委托构造函数" class="headerlink" title="1. 委托构造函数"></a>1. 委托构造函数</h2><p>&emsp;&emsp;委托构造函数允许使用同一个类中的一个构造函数调用其他的构造函数，从而简化相关变量的初始化。我感觉这部分内容没什么好讲的，简单说就是可以通过 <code>:</code> 来调用其他的构造函数来简化操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Test</span>(<span class="type">int</span> max)</span><br><span class="line">	&#123;</span><br><span class="line">		max = max &gt; <span class="number">0</span> ? max : <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Test</span>(<span class="type">int</span> max, <span class="type">int</span> min) : <span class="built_in">Test</span>(max)</span><br><span class="line">	&#123;</span><br><span class="line">		min = min &gt; <span class="number">0</span> &amp;&amp; min &lt; max ? min : <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Test</span>(<span class="type">int</span> max, <span class="type">int</span> min, <span class="type">int</span> mid) : <span class="built_in">Test</span>(max, min)</span><br><span class="line">	&#123;</span><br><span class="line">		mid = mid &lt; max &amp;&amp; mid &gt; min ? mid : <span class="number">50</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> _max;</span><br><span class="line">	<span class="type">int</span> _min;</span><br><span class="line">	<span class="type">int</span> _middle;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2-继承构造函数"><a href="#2-继承构造函数" class="headerlink" title="2. 继承构造函数"></a>2. 继承构造函数</h2><p>&emsp;&emsp;继承构造函数可以让派生类直接使用基类的构造函数，而无需自己再写构造函数，尤其是在基类有很多构造函数的情况下，可以极大的简化派生类构造函数的编写。</p>
<p>&emsp;&emsp;比如下面这个例子，如果想要使用基类的构造函数，挨个重写 <code>Child(int i) : Base(i) &#123;&#125;</code> 明显很麻烦，但是直接使用 <code>using Base::Base;</code> 就可以直接继承基类的构造函数，方便很多。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>(<span class="type">int</span> i) : <span class="built_in">m_i</span>(i) &#123;&#125;</span><br><span class="line">	<span class="built_in">Base</span>(<span class="type">int</span> i, <span class="type">double</span> j) : <span class="built_in">m_i</span>(i), <span class="built_in">m_j</span>(j) &#123;&#125;</span><br><span class="line">	<span class="built_in">Base</span>(<span class="type">int</span> i, <span class="type">double</span> j, string k) : <span class="built_in">m_i</span>(i), <span class="built_in">m_j</span>(j), <span class="built_in">m_k</span>(k) &#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> m_i;</span><br><span class="line">	<span class="type">double</span> m_j;</span><br><span class="line">	string m_k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">using</span> Base::Base;</span><br><span class="line">	<span class="comment">//甚至可以 using Base::func 这样来继承父类的成员函数func()</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;</p>
<h1 id="·-花括号或等号初始化器"><a href="#·-花括号或等号初始化器" class="headerlink" title="· 花括号或等号初始化器"></a>· 花括号或等号初始化器</h1><p>&emsp;&emsp;如下，直接摘自<strong>cppreference</strong>。<br><img src="/images/2021-12-02/4.jpg" alt="5"><br>&emsp;</p>
<h1 id="·-nullptr"><a href="#·-nullptr" class="headerlink" title="· nullptr"></a>· nullptr</h1><p>&emsp;&emsp;在C语言中，空指针普遍使用 <code>NULL</code> 来表示，其实际定义为 <code>(void *)0</code>。但在C++中，<code>NULL</code> 的实际定义为 <code>0</code>，这是<strong>因为C++中不能将void *类型的指针隐式转换成其他指针类型</strong>。C++是一门强类型的语言，这样将0当成空指针很明显不符合语言的特性，因为 <code>NULL</code> 往往会被推导成 <code>long int</code> 类型而不是指针类型，于是在C++11中推出了 <code>nullptr</code> 来定义各个类型的空指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++与C中NULL的定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> NULL</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__cplusplus)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL ((void *)0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>nullptr</code> 实际是 <code>std::nullptr_t</code> 类型的纯右值，它可以转换成任意指针类型。这样就可以解决C++中不能将(void *)类型的指针隐式转换成其他指针类型的问题，从而避免 <code>NULL</code> 歧义出现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;Pointer to integer overload\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">double</span>*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;Pointer to double overload\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std::<span class="type">nullptr_t</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;null pointer overload\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>* pi &#123;&#125;; <span class="type">double</span>* pd &#123;&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">f</span>(pi);</span><br><span class="line">    <span class="built_in">f</span>(pd);</span><br><span class="line">    <span class="built_in">f</span>(<span class="literal">nullptr</span>); <span class="comment">// 无 void f(nullptr_t) 可能有歧义</span></span><br><span class="line">    <span class="comment">// f(0);    // 歧义调用：三个函数全部为候选</span></span><br><span class="line">    <span class="comment">// f(NULL); // 若 NULL 是整数空指针常量则为歧义</span></span><br><span class="line">                <span class="comment">// （如在大部分实现中的情况）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">Pointer to integer overload</span><br><span class="line">Pointer to <span class="type">double</span> overload</span><br><span class="line">null pointer overload</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h1 id="·-long-long"><a href="#·-long-long" class="headerlink" title="· long long"></a>· long long</h1><p>&emsp;&emsp;就是C++11里新增的一组基础整数类型，简单来说其核心就是保证至少 64 位的宽度（8个字节），我觉得没什么好说的。<br><img src="/images/2021-12-02/5-0.jpg" alt="图ll"><br><img src="/images/2021-12-02/5.jpg" alt="图ll2"><br>&emsp;</p>
<h1 id="·-char16-t-与-char32-t"><a href="#·-char16-t-与-char32-t" class="headerlink" title="· char16_t 与 char32_t"></a>· char16_t 与 char32_t</h1><p>&emsp;&emsp;这两个是C++11里新增的字符类型，主要是为了服务UTF编码的。其与普通 <code>char</code> 的差别就是位宽不一样。具体定义如下：</p>
<ul>
<li><code>char16_t</code>: UTF-16 字符表示的类型，要求大到足以表示任何 UTF-16 编码单元（ 16 位）。它与 std::uint_least16_t 具有相同的大小、符号性和对齐，但它是独立的类型。使用<code>u</code>来表示utf-16字符: <code>char16_t c&#123; u&#39;a&#39; &#125;;</code></li>
<li><code>char32_t</code>: UTF-32 字符表示的类型，要求大到足以表示任何 UTF-32 编码单元（ 32 位）。它与 std::uint_least32_t 具有相同的大小、符号性和对齐，但它是独立的类型。使用<code>U</code>来表示utf-32字符:<code>char32_t c&#123; U&#39;a&#39; &#125;;</code></li>
</ul>
<p>&emsp;</p>
<h1 id="·-类型别名"><a href="#·-类型别名" class="headerlink" title="· 类型别名"></a>· 类型别名</h1><p>&emsp;&emsp;C++11中，给关键字 <code>using</code> 添加了一个新的功能：定义类型的别名。就我的使用经验来看，其和 <code>typedef</code> 是一样的效果，没有区别。虽然 <code>using</code> 看起来更简洁一点，但是我感觉已经用 <code>typedef</code> 用习惯了…</p>
<ul>
<li>使用场景一，和基础类型和函数指针搭配<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法</span></span><br><span class="line"><span class="keyword">using</span> 新类型 = 旧类型;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下两者相同</span></span><br><span class="line"><span class="keyword">using</span> func = <span class="built_in">void</span> (*) (<span class="type">int</span>, <span class="type">int</span>); </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*func)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span> </span>&#123;&#125;</span><br><span class="line">func f = test;</span><br></pre></td></tr></table></figure></li>
<li>使用场景二，和模板搭配，在STL源码里经常见<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyMap</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> map&lt;<span class="type">int</span>, T&gt; mapType;</span><br><span class="line">&#125;;</span><br><span class="line">MyMap&lt;<span class="type">int</span>&gt;::mapType m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> MyMap = map&lt;<span class="type">int</span>, T&gt;;</span><br><span class="line">MyMap&lt;<span class="type">int</span>&gt; m;</span><br></pre></td></tr></table></figure>
&emsp;</li>
</ul>
<h1 id="·-变参数模板"><a href="#·-变参数模板" class="headerlink" title="· 变参数模板"></a>· 变参数模板</h1><blockquote>
<p>形参包：模板形参包是接受零或更多模板实参（非类型、类型或模板）的模板形参。函数形参包是接受零或更多函数实参的函数形参，至少有一个形参包的模板被称作变参模板。</p>
</blockquote>
<p>&emsp;&emsp;在C++11中，新出现了变参数模板，即可将任意数量的模板实参实例化。语法为：<code>template&lt;class|typename ... Types&gt;</code>。其弥补了C++模板不能灵活定义参数数量的不足。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> --------------------------------------------------------------------</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span><span class="comment">//基础函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">const</span> T&amp; t, <span class="type">const</span> Args&amp;... a)</span><span class="comment">//递归变参函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test</span>(a...);<span class="comment">//递归调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test</span>(<span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>), <span class="string">&quot;world1&quot;</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> --------------------------------------------------------------------</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format)</span><span class="comment">//基础函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; format;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Targs&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, T value, Targs... Fargs)</span><span class="comment">//递归变参函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; *format != <span class="string">&#x27;\0&#x27;</span>; format++ ) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( *format == <span class="string">&#x27;%&#x27;</span> ) &#123;</span><br><span class="line">           std::cout &lt;&lt; value;</span><br><span class="line">           <span class="built_in">tprintf</span>(format<span class="number">+1</span>, Fargs...);<span class="comment">//递归调用</span></span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; *format;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">tprintf</span>(<span class="string">&quot;% world% %\n&quot;</span>,<span class="string">&quot;Hello&quot;</span>,<span class="string">&#x27;!&#x27;</span>,<span class="number">123</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如上两个例子所示，变参数模板一般都是拥有一个基础函数，以及一个变参模板函数。在变参模板函数里处理定量的传参后递归调用，直至参数处理完毕。<strong>总体而言我感觉它的思路和一般的递归函数是相似的，其基础函数即为边界。</strong></p>
<p>&emsp;</p>
<h1 id="·-推广的（非平凡）联合体"><a href="#·-推广的（非平凡）联合体" class="headerlink" title="· 推广的（非平凡）联合体"></a>· 推广的（非平凡）联合体</h1><p>&emsp;&emsp;<br>&emsp;</p>
<h1 id="·-推广的-POD-（平凡类型与标准布局类型）"><a href="#·-推广的-POD-（平凡类型与标准布局类型）" class="headerlink" title="· 推广的 POD （平凡类型与标准布局类型）"></a>· 推广的 POD （平凡类型与标准布局类型）</h1><p>&emsp;&emsp;<br>&emsp;</p>
<h1 id="·-Unicode-字符串字面量"><a href="#·-Unicode-字符串字面量" class="headerlink" title="· Unicode 字符串字面量"></a>· Unicode 字符串字面量</h1><p>&emsp;&emsp;在C++11之前，C++中只有<strong>通常字符串字面量：</strong><code>&quot;内容&quot;</code> 以及<strong>宽字符串字面量：</strong><code>L&quot;内容&quot;</code>。其中前者是最常用的一种，每个字符占一个字节；而后者则是代表每个字符占用两个字节。</p>
<p>&emsp;&emsp;上文中提到，C++11中提供了两个新字符类型 <code>char16_t</code> 与 <code>char32_t</code>，于是C++也更新了相对应的字符串字面量 <code>u&quot;内容&quot;</code> 和 <code>U&quot;内容&quot;</code>。此外还提供了另外新的两种字符串字面量 <code>u8&quot;内容&quot;</code> 和 <code>R&quot;xxx(内容)xxx&quot;</code>，这四种新的字面量的具体解释如下：</p>
<ol>
<li><code>u8&quot;内容&quot;</code>：<strong>UTF-8 字符串字面量。</strong> 字符串字面量的类型是 <code>const char[N]</code>(C++20 前) <code>const char8_t[N]</code>(C++20 起)，其中 N 是以 UTF-8 编码单元计的字符串的大小，包含空终止符。</li>
<li><code>u&quot;内容&quot;</code>：<strong>UTF-16 字符串字面量。</strong> 字符串字面量的类型是 <code>const char16_t[N]</code>，其中 N 是以 UTF-16 编码单元计的字符串的大小，包含空终止符。</li>
<li><code>U&quot;内容&quot;</code>：<strong>UTF-32 字符串字面量。</strong> 字符串字面量的类型是 <code>const char32_t[N]</code>，其中 N 是以 UTF-32 编码单元计的字符串的大小，包含空终止符。</li>
<li><code>R&quot;xxx(内容)xxx&quot;</code>：<strong>原始字符串字面量。</strong> 用于避免转义任何字符。这个我感觉还是挺有用的，在这里记录一下用法：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">	在原始字符串字面量的定义内容中，将不存在任何转义。</span><br><span class="line">	比如常见的路径字符串 <span class="string">&quot;C:\\demo\\test.txt&quot;</span>，其中使用<span class="string">&quot;\\&quot;</span>的原因是避免<span class="string">&quot;\&quot;进行转义。</span></span><br><span class="line"><span class="string">	而当使用原始字符串字面量定义时，就可以直接 R&quot;</span>(C:\demo\test.txt)<span class="string">&quot;，因为字符串中不会进行任何转义，所以就不需要使用&quot;</span>\\<span class="string">&quot;了。</span></span><br><span class="line"><span class="string">eg:</span></span><br><span class="line"><span class="string">	样例输入：</span></span><br><span class="line"><span class="string">	cout &lt;&lt; R&quot;</span>(hello world \n)<span class="string">&quot;;</span></span><br><span class="line"><span class="string">	样例输出：</span></span><br><span class="line"><span class="string">	hello world \n</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	另外有些时候，字符串太长或者说需要分段，常规来讲是通过&quot;</span>\n<span class="string">&quot;和&quot;</span>\<span class="string">&quot;来实现的，比如说下面这个例子，通过连接符和回车来实现分段。</span></span><br><span class="line"><span class="string">eg:	</span></span><br><span class="line"><span class="string">	样例输入：</span></span><br><span class="line"><span class="string">	cout &lt;&lt; &quot;</span><span class="number">1</span>\n\</span><br><span class="line">    <span class="number">2</span>\n\</span><br><span class="line">    <span class="number">3</span><span class="string">&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="string">	样例输出：</span></span><br><span class="line"><span class="string">	1</span></span><br><span class="line"><span class="string">    2</span></span><br><span class="line"><span class="string">    3</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    而当使用原始字符串字面量定义时，直接按位置输入即可，字符串中会根据位置自动换行。</span></span><br><span class="line"><span class="string">eg:</span></span><br><span class="line"><span class="string">    样例输入：</span></span><br><span class="line"><span class="string">    cout &lt;&lt; R&quot;</span>(<span class="number">1</span></span><br><span class="line">    <span class="number">2</span></span><br><span class="line">    <span class="number">3</span>)<span class="string">&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="string">    样例输出：</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">    2</span></span><br><span class="line"><span class="string">    3</span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string">	另外，原始字符串字面量的那个&quot;</span>xxx<span class="string">&quot;部分我个人认为与注释相似，没有实际影响，而且得注意前后必须一致。</span></span><br><span class="line"><span class="string">eg:</span></span><br><span class="line"><span class="string">	样例输入：</span></span><br><span class="line"><span class="string">	cout &lt;&lt; R&quot;</span><span class="built_in">hello</span>(hello world \n)hello<span class="string">&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="string">	样例输出：</span></span><br><span class="line"><span class="string">	hello world \n</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>&emsp;</p>
<h1 id="·-用户定义字面量"><a href="#·-用户定义字面量" class="headerlink" title="· 用户定义字面量"></a>· 用户定义字面量</h1><p>&emsp;&emsp;C++11新标准中引入了用户自定义字面量，也叫自定义后缀操作符，即通过实现一个后缀操作符，将申明了该后缀标识的字面量转化为需要的类型。比如如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">double</span> <span class="keyword">operator</span><span class="string">&quot;&quot;</span> _mm(<span class="type">long</span> <span class="type">double</span> x) &#123; <span class="keyword">return</span> x / <span class="number">1000</span>; &#125;</span><br><span class="line"><span class="type">long</span> <span class="type">double</span> <span class="keyword">operator</span><span class="string">&quot;&quot;</span> _m(<span class="type">long</span> <span class="type">double</span> x)  &#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="type">long</span> <span class="type">double</span> <span class="keyword">operator</span><span class="string">&quot;&quot;</span> _km(<span class="type">long</span> <span class="type">double</span> x) &#123; <span class="keyword">return</span> x * <span class="number">1000</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="number">1.0</span>_mm &lt;&lt; endl; <span class="comment">//0.001</span></span><br><span class="line">    cout &lt;&lt; <span class="number">1.0</span>_m  &lt;&lt; endl; <span class="comment">//1</span></span><br><span class="line">    cout &lt;&lt; <span class="number">1.0</span>_km &lt;&lt; endl; <span class="comment">//1000</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果:</span><br><span class="line"><span class="number">0.001</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1000</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我个人而言这块内容是没有使用过，然后去网上找了一下相关的资料，感觉这东西是为了用户自定义类型的字面量解析输出…比如说下面这个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个自定义的rgb类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RGBA</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> r, g, b, a;</span><br><span class="line">	<span class="built_in">RGBA</span>(<span class="type">uint8_t</span> r, <span class="type">uint8_t</span> g, <span class="type">uint8_t</span> b, <span class="type">uint8_t</span> a):<span class="built_in">r</span>(r),<span class="built_in">g</span>(g),<span class="built_in">b</span>(b),<span class="built_in">a</span>(a)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//自定义字面量后缀</span></span><br><span class="line">RGBA <span class="keyword">operator</span><span class="string">&quot;&quot;</span> _RGBA(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* r = <span class="literal">nullptr</span>, *g = <span class="literal">nullptr</span>, *b = <span class="literal">nullptr</span>, *a = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span>* p = str; p != str + size; ++p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (*p == <span class="string">&#x27;r&#x27;</span>) r = p + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (*p == <span class="string">&#x27;g&#x27;</span>) g = p + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (*p == <span class="string">&#x27;b&#x27;</span>) b = p + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (*p == <span class="string">&#x27;a&#x27;</span>) a = p + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (r == <span class="literal">nullptr</span> || g == <span class="literal">nullptr</span> || b == <span class="literal">nullptr</span>) <span class="keyword">throw</span>;</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">RGBA</span>(<span class="built_in">atoi</span>(r),<span class="built_in">atoi</span>(g),<span class="built_in">atoi</span>(b),<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">RGBA</span>(<span class="built_in">atoi</span>(r), <span class="built_in">atoi</span>(g), <span class="built_in">atoi</span>(b),<span class="built_in">atoi</span>(a));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出运算符重载</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,<span class="type">const</span> RGBA&amp; color)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> os&lt;&lt;<span class="string">&quot;r=&quot;</span>&lt;&lt; (<span class="type">int</span>)color.r&lt;&lt;<span class="string">&quot; g=&quot;</span>&lt;&lt; (<span class="type">int</span>)color.g&lt;&lt;<span class="string">&quot; b=&quot;</span>&lt;&lt; (<span class="type">int</span>)color.b&lt;&lt;<span class="string">&quot; a=&quot;</span>&lt;&lt; (<span class="type">int</span>)color.a&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//自定义字面量来表示RGBA对象</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;r255 g255 b255 a40&quot;</span>_RGBA &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果:</span><br><span class="line">r=<span class="number">255</span> g=<span class="number">255</span> b=<span class="number">255</span> a=<span class="number">40</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;值得注意的是，用户定义字面量中，只有下面的7种参数列表才是合法的，而且后面四种会自动计算出字符串的长度，挺好用的。具体可以看下面：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="type">const</span> *</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span></span><br><span class="line"><span class="type">long</span> <span class="type">double</span></span><br><span class="line"><span class="type">char</span> <span class="type">const</span> *, <span class="type">size_t</span></span><br><span class="line"><span class="type">wchar_t</span> <span class="type">const</span> *, <span class="type">size_t</span></span><br><span class="line"><span class="type">char16_t</span> <span class="type">const</span> *, <span class="type">size_t</span></span><br><span class="line"><span class="type">char32_t</span> <span class="type">const</span> *, <span class="type">size_t</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例子</span></span><br><span class="line"><span class="type">size_t</span> <span class="keyword">operator</span><span class="string">&quot;&quot;</span> _len(<span class="type">char</span> <span class="type">const</span> * str, <span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hello&quot;</span>_len &lt;&lt;endl; <span class="comment">//结果为5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;</p>
<h1 id="·-属性"><a href="#·-属性" class="headerlink" title="· 属性"></a>· 属性</h1><p>&emsp;&emsp;C++11中新增了一个概念：属性(attributes)，其功能为<strong>为类型、对象、代码等引入由实现定义的属性</strong>。在C++11中，其语法仅为<code>[[ 属性列表 ]]</code>，标准属性也只有下图的前两个：<br><img src="/images/2021-12-02/6.jpg" alt="7"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[gnu::always_inline]] [[gnu::hot]] [[gnu::<span class="type">const</span>]] [[nodiscard]]</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>; <span class="comment">// 声明 f 带四个属性</span></span><br><span class="line"> </span><br><span class="line">[[gnu::always_inline, gnu::<span class="type">const</span>, gnu::hot, nodiscard]]</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>; <span class="comment">// 同上，但使用含有四个属性的单个属性说明符</span></span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h1 id="·-lambda-表达式"><a href="#·-lambda-表达式" class="headerlink" title="· lambda 表达式"></a>· lambda 表达式</h1><p>&emsp;&emsp;即匿名函数表达式，其主要语法为：<code>[捕获列表] (参数列表) 函数选项 -&gt; 返回值类型 &#123; 函数体 &#125;;</code>，就是中、小、大三种括号来一遍。</p>
<ul>
<li><p>捕获列表可以指定需要”捕获”哪些变量，以及按什么方式”捕获”。简单来说，就是lambda表达式的函数体是独立的区域，如果想使用外部的变量，就必须先给它”捕获”进来。具体方式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[]			不捕获任何变量</span><br><span class="line">[&amp;]			捕获外部作用域中的所有变量，并作为引用在函数体内使用（按引用捕获）</span><br><span class="line">[=]			捕获外部作用域中的所有变量，并作为副本在函数体内使用（按值捕获）</span><br><span class="line">[=, &amp;foo]	按值捕获外部作用域中所有变量，并按照引用捕获外部变量foo</span><br><span class="line">[bar]		按值捕获bar变量，同时不捕获其他变量</span><br><span class="line">[&amp;bar]		按引用捕获bar变量，同时不捕获其他变量</span><br><span class="line">[<span class="keyword">this</span>]		捕获当前类中的<span class="keyword">this</span>指针</span><br><span class="line">	- 让lambda表达式拥有和当前类成员函数同样的访问权限</span><br><span class="line">	- 如果以及使用了&amp;或=，则默认添加此选项</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> S2 &#123; <span class="type">void</span> <span class="built_in">f</span>(<span class="type">int</span> i); &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">S2::f</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    [&amp;]&#123;&#125;;          <span class="comment">// OK：默认以引用捕获</span></span><br><span class="line">    [&amp;, i]&#123;&#125;;       <span class="comment">// OK：以引用捕获，但 i 以值捕获</span></span><br><span class="line">    [&amp;, &amp;i] &#123;&#125;;     <span class="comment">// 错误：以引用捕获为默认时后续不能以引用捕获</span></span><br><span class="line">    [&amp;, <span class="keyword">this</span>] &#123;&#125;;   <span class="comment">// OK：等价于 [&amp;]</span></span><br><span class="line">    [&amp;, <span class="keyword">this</span>, i]&#123;&#125;; <span class="comment">// OK：等价于 [&amp;, i]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S2</span> &#123; <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i)</span></span>; &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">S2::f</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    [=]&#123;&#125;;          <span class="comment">// OK：默认以复制捕获</span></span><br><span class="line">    [=, &amp;i]&#123;&#125;;      <span class="comment">// OK：以复制捕获，但 i 以引用捕获</span></span><br><span class="line">    [=, *<span class="keyword">this</span>]&#123;&#125;;   <span class="comment">// C++17 前：错误：无效语法</span></span><br><span class="line">                    <span class="comment">// C++17 起：OK：以复制捕获外围的 S2</span></span><br><span class="line">    [=, <span class="keyword">this</span>] &#123;&#125;;   <span class="comment">// C++20 前：错误：= 为默认时的 this</span></span><br><span class="line">                    <span class="comment">// C++20 起：OK：同 [=]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S2</span> &#123; <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i)</span></span>; &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">S2::f</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    [i, i] &#123;&#125;;        <span class="comment">// 错误：i 重复</span></span><br><span class="line">    [<span class="keyword">this</span>, *<span class="keyword">this</span>] &#123;&#125;; <span class="comment">// 错误：&quot;this&quot; 重复 (C++17)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>参数列表和普通函数的相似，就是小括号里写上接收什么类型的参数之类的。当没有传参的时候，可以直接写空括号 <code>()</code>，或者干脆省略括号 <code>auto f = []&#123;return 1;&#125;;</code>，但是不推荐不写因为我感觉会影响可读性。</p>
</li>
<li><p>函数选项主要有两个，<code>mutable</code> 和 <code>exception</code>：前者 <code>mutable</code> 含义为可以修改按值传递进来的拷贝(修改拷贝，不是值本身)；后者 <code>exception</code> 含义为指定函数抛出的异常，如抛出整数类型的异常，可以使用 <code>throw();</code>。这部分内容不需要可以直接省略不写，说实话我也没用过…</p>
</li>
<li><p>返回值类型是典型的”尾随返回类型”，但是一般是不写它的，因为会自动推导返回值类型。不过有一些情况下编译器无法推导返回类型，比如说返回一个初始化列表 <code>return &#123;1, 2&#125;;</code>，此时就必须指定返回值类型了。</p>
</li>
</ul>
<p>&emsp;&emsp;<strong>lambda的本质其实是一个仿函数</strong>，当以值捕获变量时，其默认是 <code>const</code> 的，所以无法更改，而选项 <code>mutable</code> 的功能就是去掉 <code>const</code> 修饰。<strong>而当一个lambda表达式未捕获任何变量时，其还可以转换成一个普通的函数指针。</strong></p>
<p>&emsp;</p>
<h1 id="·-noexcept-说明符与-noexcept-运算符"><a href="#·-noexcept-说明符与-noexcept-运算符" class="headerlink" title="· noexcept 说明符与 noexcept 运算符"></a>· noexcept 说明符与 noexcept 运算符</h1><h2 id="1-noexcept-说明符"><a href="#1-noexcept-说明符" class="headerlink" title="1. noexcept 说明符"></a>1. noexcept 说明符</h2><p>&emsp;&emsp;指定函数是否抛出异常。在函数后添加 <code>noexcept</code> 即可，也可以指定 <code>false</code>，默认即为 <code>noexcept(false)</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>; <span class="comment">// 错误：不同的异常说明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>; <span class="comment">// OK： g 的两个声明均为潜在抛出</span></span><br></pre></td></tr></table></figure>
<h2 id="2-noexcept-运算符"><a href="#2-noexcept-运算符" class="headerlink" title="2. noexcept 运算符"></a>2. noexcept 运算符</h2><p>&emsp;&emsp;<code>noexcept</code> 运算符进行编译时检查，若表达式声明为不抛出任何异常则返回 <code>true</code>。它可用于函数模板的 <code>noexcept</code> 说明符中，以声明函数将对某些类型抛出异常，但不对其他类型抛出。其语法为 <code>noexcept(表达式)</code>。</p>
<p>&emsp;&emsp;<code>noexcept </code> 运算符不对<strong>表达式</strong>求值。若<strong>表达式</strong>的潜在异常集合为空，则结果为 true，否则结果为 false。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">may_throw</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">no_throw</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">auto</span> lmay_throw = []&#123;&#125;;</span><br><span class="line"><span class="keyword">auto</span> lno_throw = []() <span class="keyword">noexcept</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ~<span class="built_in">T</span>()&#123;&#125; <span class="comment">// 析构函数妨碍了移动构造函数</span></span><br><span class="line">         <span class="comment">// 复制构造函数为 noexcept</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">U</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ~<span class="built_in">U</span>()&#123;&#125; <span class="comment">// 析构函数妨碍了移动构造函数</span></span><br><span class="line">         <span class="comment">// 复制构造函数为 noexcept(false)</span></span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">V</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  T t;</span><br><span class="line">  U u;</span><br><span class="line">  V v;</span><br><span class="line"> </span><br><span class="line">  std::cout &lt;&lt; std::boolalpha</span><br><span class="line">           &lt;&lt; <span class="string">&quot;Is may_throw() noexcept? &quot;</span> &lt;&lt; <span class="built_in">noexcept</span>(<span class="built_in">may_throw</span>()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">           &lt;&lt; <span class="string">&quot;Is no_throw() noexcept? &quot;</span> &lt;&lt; <span class="built_in">noexcept</span>(<span class="built_in">no_throw</span>()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">           &lt;&lt; <span class="string">&quot;Is lmay_throw() noexcept? &quot;</span> &lt;&lt; <span class="built_in">noexcept</span>(<span class="built_in">lmay_throw</span>()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">           &lt;&lt; <span class="string">&quot;Is lno_throw() noexcept? &quot;</span> &lt;&lt; <span class="built_in">noexcept</span>(<span class="built_in">lno_throw</span>()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">           &lt;&lt; <span class="string">&quot;Is ~T() noexcept? &quot;</span> &lt;&lt; <span class="built_in">noexcept</span>(std::<span class="built_in">declval</span>&lt;T&gt;().~<span class="built_in">T</span>()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">           <span class="comment">// 注：以下各项测试也要求 ~T() 为 noexcept</span></span><br><span class="line">           <span class="comment">// 因为 noexccept 中的表达式构造并销毁了临时量</span></span><br><span class="line">           &lt;&lt; <span class="string">&quot;Is T(rvalue T) noexcept? &quot;</span> &lt;&lt; <span class="built_in">noexcept</span>(<span class="built_in">T</span>(std::<span class="built_in">declval</span>&lt;T&gt;())) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">           &lt;&lt; <span class="string">&quot;Is T(lvalue T) noexcept? &quot;</span> &lt;&lt; <span class="built_in">noexcept</span>(<span class="built_in">T</span>(t)) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">           &lt;&lt; <span class="string">&quot;Is U(rvalue U) noexcept? &quot;</span> &lt;&lt; <span class="built_in">noexcept</span>(<span class="built_in">U</span>(std::<span class="built_in">declval</span>&lt;U&gt;())) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">           &lt;&lt; <span class="string">&quot;Is U(lvalue U) noexcept? &quot;</span> &lt;&lt; <span class="built_in">noexcept</span>(<span class="built_in">U</span>(u)) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>  </span><br><span class="line">           &lt;&lt; <span class="string">&quot;Is V(rvalue V) noexcept? &quot;</span> &lt;&lt; <span class="built_in">noexcept</span>(<span class="built_in">V</span>(std::<span class="built_in">declval</span>&lt;V&gt;())) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">           &lt;&lt; <span class="string">&quot;Is V(lvalue V) noexcept? &quot;</span> &lt;&lt; <span class="built_in">noexcept</span>(<span class="built_in">V</span>(v)) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"><span class="function">Is <span class="title">may_throw</span><span class="params">()</span> <span class="keyword">noexcept</span>? <span class="literal">false</span></span></span><br><span class="line"><span class="function">Is <span class="title">no_throw</span><span class="params">()</span> <span class="keyword">noexcept</span>? <span class="literal">true</span></span></span><br><span class="line"><span class="function">Is <span class="title">lmay_throw</span><span class="params">()</span> <span class="keyword">noexcept</span>? <span class="literal">false</span></span></span><br><span class="line"><span class="function">Is <span class="title">lno_throw</span><span class="params">()</span> <span class="keyword">noexcept</span>? <span class="literal">true</span></span></span><br><span class="line"><span class="function">Is ~<span class="title">T</span><span class="params">()</span> <span class="keyword">noexcept</span>? <span class="literal">true</span></span></span><br><span class="line"><span class="function">Is <span class="title">T</span><span class="params">(rvalue T)</span> <span class="keyword">noexcept</span>? <span class="literal">true</span></span></span><br><span class="line"><span class="function">Is <span class="title">T</span><span class="params">(lvalue T)</span> <span class="keyword">noexcept</span>? <span class="literal">true</span></span></span><br><span class="line"><span class="function">Is <span class="title">U</span><span class="params">(rvalue U)</span> <span class="keyword">noexcept</span>? <span class="literal">false</span></span></span><br><span class="line"><span class="function">Is <span class="title">U</span><span class="params">(lvalue U)</span> <span class="keyword">noexcept</span>? <span class="literal">false</span></span></span><br><span class="line"><span class="function">Is <span class="title">V</span><span class="params">(rvalue V)</span> <span class="keyword">noexcept</span>? <span class="literal">true</span></span></span><br><span class="line"><span class="function">Is <span class="title">V</span><span class="params">(lvalue V)</span> <span class="keyword">noexcept</span>? <span class="literal">false</span></span></span><br></pre></td></tr></table></figure>

<p>&emsp;</p>
<h1 id="·-alignof-与-alignas"><a href="#·-alignof-与-alignas" class="headerlink" title="· alignof 与 alignas"></a>· alignof 与 alignas</h1><h2 id="1-alignof"><a href="#1-alignof" class="headerlink" title="1. alignof"></a>1. alignof</h2><p>&emsp;&emsp;查询类型的对齐要求。其语法为 <code>alignof(类型标识)	</code>，返回 <code>std::size_t</code> 类型的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="type">int</span>   i;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="type">char</span>  c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 注：下面的 `alignas(alignof(long double))` 如果需要可以简化为 </span></span><br><span class="line"><span class="comment">// `alignas(long double)`</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="built_in">alignof</span>(<span class="type">long</span> <span class="type">double</span>)) Foo2 &#123;</span><br><span class="line">    <span class="comment">// Foo2 成员的定义...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Empty</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">64</span>) Empty64 &#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;对齐字节数&quot;</span>  <span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;- char             ：&quot;</span> &lt;&lt; <span class="built_in">alignof</span>(<span class="type">char</span>)    &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;- 指针             ：&quot;</span> &lt;&lt; <span class="built_in">alignof</span>(<span class="type">int</span>*)    &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;- Foo 类           ：&quot;</span> &lt;&lt; <span class="built_in">alignof</span>(Foo)     &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;- Foo2 类          ：&quot;</span> &lt;&lt; <span class="built_in">alignof</span>(Foo2)     &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;- 空类             ：&quot;</span> &lt;&lt; <span class="built_in">alignof</span>(Empty)   &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;- alignas(64) Empty：&quot;</span> &lt;&lt; <span class="built_in">alignof</span>(Empty64) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">可能的输出:</span><br><span class="line">对齐字节数</span><br><span class="line">- <span class="type">char</span>             ：<span class="number">1</span></span><br><span class="line">- 指针             ：<span class="number">8</span></span><br><span class="line">- Foo 类           ：<span class="number">4</span></span><br><span class="line">- Foo2 类          ：<span class="number">16</span></span><br><span class="line">- 空类             ：<span class="number">1</span></span><br><span class="line">- <span class="built_in">alignas</span>(<span class="number">64</span>) Empty：<span class="number">64</span></span><br></pre></td></tr></table></figure>

<h2 id="2-alignas"><a href="#2-alignas" class="headerlink" title="2. alignas"></a>2. alignas</h2><p>&emsp;&emsp;指定类型或对象的对齐要求。语法为 (1)<code>alignas(表达式)</code>、(2)<code>alignas(类型标识)</code>、(3)<code>alignas(包 ...)</code>。</p>
<ol>
<li><code>alignas(表达式)</code> 必须是求值为零或合法的对齐或扩展对齐的整型常量表达式。</li>
<li>等价于 <code>alignas(alignof(类型))</code></li>
<li>等价于对同一说明应用多个 <code>alignas</code> 说明符，逐个对应于形参包的各个成员，形参包可以是类型或非类型形参包。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个 struct_float 类型对象都将被对齐到 alignof(float) 边界</span></span><br><span class="line"><span class="comment">// （通常为 4）：</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="built_in">alignof</span>(<span class="type">float</span>)) struct_float</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义在此</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// sse_t 类型的每个对象将对齐到 32 字节边界</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">32</span>) <span class="type">sse_t</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">float</span> sse_data[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 数组 &quot;cacheline&quot; 将对齐到 64 字节边界</span></span><br><span class="line"><span class="built_in">alignas</span>(<span class="number">64</span>) <span class="type">char</span> cacheline[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">default_aligned</span> &#123; <span class="type">float</span> data[<span class="number">4</span>]; &#125; a, b, c;</span><br><span class="line">    <span class="type">sse_t</span> x, y, z;</span><br><span class="line"> </span><br><span class="line">    std::cout</span><br><span class="line">        &lt;&lt; <span class="string">&quot;alignof(struct_float) = &quot;</span> &lt;&lt; <span class="built_in">alignof</span>(struct_float) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;sizeof(sse_t) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">sse_t</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;alignof(sse_t) = &quot;</span> &lt;&lt; <span class="built_in">alignof</span>(<span class="type">sse_t</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;alignof(cacheline) = &quot;</span> &lt;&lt; <span class="built_in">alignof</span>(<span class="built_in">alignas</span>(<span class="number">64</span>) <span class="type">char</span>[<span class="number">64</span>]) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        &lt;&lt; std::hex &lt;&lt; std::showbase</span><br><span class="line">        &lt;&lt; <span class="string">&quot;&amp;a: &quot;</span> &lt;&lt; &amp;a &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;&amp;b: &quot;</span> &lt;&lt; &amp;b &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;&amp;c: &quot;</span> &lt;&lt; &amp;c &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;&amp;x: &quot;</span> &lt;&lt; &amp;x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;&amp;y: &quot;</span> &lt;&lt; &amp;y &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;&amp;z: &quot;</span> &lt;&lt; &amp;z &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">可能的输出:</span><br><span class="line"><span class="built_in">alignof</span>(struct_float) = <span class="number">4</span></span><br><span class="line"><span class="built_in">sizeof</span>(<span class="type">sse_t</span>) = <span class="number">32</span></span><br><span class="line"><span class="built_in">alignof</span>(<span class="type">sse_t</span>) = <span class="number">32</span></span><br><span class="line"><span class="built_in">alignof</span>(cacheline) = <span class="number">64</span></span><br><span class="line">&amp;a: <span class="number">0x7ffc835270d0</span></span><br><span class="line">&amp;b: <span class="number">0x7ffc835270e0</span></span><br><span class="line">&amp;c: <span class="number">0x7ffc835270f0</span></span><br><span class="line">&amp;x: <span class="number">0x7ffc83527100</span></span><br><span class="line">&amp;y: <span class="number">0x7ffc83527120</span></span><br><span class="line">&amp;z: <span class="number">0x7ffc83527140</span></span><br></pre></td></tr></table></figure>

<p>&emsp;</p>
<h1 id="·-多线程内存模型"><a href="#·-多线程内存模型" class="headerlink" title="· 多线程内存模型"></a>· 多线程内存模型</h1><p>&emsp;&emsp;应该指的是对原子操作那个库的相关支持吧，深入一点说实话我也不太了解。可以参考一下这位大佬的文：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7d237771dc94">C++11多线程-内存模型</a></p>
<p>&emsp;</p>
<h1 id="·-线程局部存储"><a href="#·-线程局部存储" class="headerlink" title="· 线程局部存储"></a>· 线程局部存储</h1><p>&emsp;&emsp;线程局部存储在其它语言中都是以库的形式提供的(库函数或类)。但在C++11中以关键字的形式，做为一种存储类型出现，由此可见C++11对线程局部存储的重视。C++11中有如下几种存储类型:</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>类型</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>auto</td>
<td>该关键字用于两种情况：<br>1. 声明变量时，根据初始化表达式自动推断变量类型。<br>2. 声明函数作为函数返回值的占位符。</td>
</tr>
<tr>
<td>2</td>
<td>static</td>
<td>static变量只初始化一次，除此之外它还有可见性的属性：<br>1. static修饰函数内的“局部”变量时，表明它不需要在进入或离开函数时创建或销毁。且仅在函数内可见。<br>2. static修饰全局变量时，表明该变量仅在当前(声明它的)文件内可见。<br>3. static修饰类的成员变量时，则该变量被该类的所有实例共享。</td>
</tr>
<tr>
<td>3</td>
<td>register</td>
<td>寄存器变量。该变量存储在CPU寄存器中，而不是RAM(栈或堆)中。<br>该变量的最大尺寸等于寄存器的大小。由于是存储于寄存器中，因此不能对该变量进行取地址操作。</td>
</tr>
<tr>
<td>4</td>
<td>extern</td>
<td>引用一个全局变量。当在一个文件中定义了一个全局变量时，就可以在其它文件中使用extern来声明并引用该变量。</td>
</tr>
<tr>
<td>5</td>
<td>mutable</td>
<td>仅适用于类成员变量。以mutable修饰的成员变量可以在const成员函数中修改。</td>
</tr>
<tr>
<td>6</td>
<td>thread_local</td>
<td>线程周期</td>
</tr>
</tbody></table>
<p><code>thread_local</code> 修饰的变量具有如下特性:</p>
<ul>
<li>变量在线程创建时生成(不同编译器实现略有差异，但在线程内变量第一次使用前必然已构造完毕)。</li>
<li>线程结束时被销毁(析构，利用析构特性，<code>thread_local</code> 变量可以感知线程销毁事件)。</li>
<li>每个线程都拥有其自己的变量副本。</li>
<li><code>thread_local</code> 可以和 <code>static</code> 或 <code>extern</code> 联合使用，这将会影响变量的链接属性。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">thread_local</span> <span class="type">unsigned</span> <span class="type">int</span> rage = <span class="number">1</span>; </span><br><span class="line">std::mutex cout_mutex;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increase_rage</span><span class="params">(<span class="type">const</span> std::string&amp; thread_name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ++rage; <span class="comment">// 在锁外修改 OK；这是线程局部变量</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(cout_mutex)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; thread_name &lt;&lt; <span class="string">&quot; 的愤怒计数：&quot;</span> &lt;&lt; rage &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">a</span><span class="params">(increase_rage, <span class="string">&quot;a&quot;</span>)</span>, <span class="title">b</span><span class="params">(increase_rage, <span class="string">&quot;b&quot;</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(cout_mutex)</span></span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;main 的愤怒计数：&quot;</span> &lt;&lt; rage &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    a.<span class="built_in">join</span>();</span><br><span class="line">    b.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">a 的愤怒计数：<span class="number">2</span></span><br><span class="line">main 的愤怒计数：<span class="number">1</span></span><br><span class="line">b 的愤怒计数：<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>&emsp;</p>
<h1 id="·-GC-接口"><a href="#·-GC-接口" class="headerlink" title="· GC 接口"></a>· GC 接口</h1><p>&emsp;&emsp;C++11中新增了对 <strong>GC(垃圾回收)</strong> 的支持，但是好像在C++23的目标里要进行删除…这部分感觉用的也挺少的，我也没怎么研究，<del>就简单贴个图过了吧。</del><br><img src="/images/2021-12-02/7.jpg" alt="6"></p>
<p>&emsp;</p>
<h1 id="·-范围-for-（基于-Boost-库）"><a href="#·-范围-for-（基于-Boost-库）" class="headerlink" title="· 范围 for （基于 Boost 库）"></a>· 范围 for （基于 Boost 库）</h1><p>&emsp;&emsp;在C++11中新增了一种范围for，这东西用的蛮多的，使用场景基本都是为了遍历各种容器，搭配 <code>auto</code> 使用非常方便。</p>
<p>&emsp;&emsp;<strong>注意：此类范围for循环在遍历过程中只会访问一次容器。</strong> 在第一次也是唯一一次访问中，其会确认边界，随后根据边界进行遍历。因此其不会每次遍历都判定条件，这也可能造成在遍历中增减元素会出现问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;test&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="comment">//此处i为拷贝，无法修改原值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : test)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此处i为引用，可以修改原值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : test)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; i++ &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;</p>
<h1 id="·-static-assert-（基于-Boost-库）"><a href="#·-static-assert-（基于-Boost-库）" class="headerlink" title="· static_assert （基于 Boost 库）"></a>· static_assert （基于 Boost 库）</h1><p>&emsp;&emsp;其功能为编译时进行断言检查，即静态断言。语法为 <code>static_assert(布尔常量表达式, 字符串字面量)</code>，当布尔<strong>常量</strong>表达式为 <code>false</code> 时，则会出现后面指定的字符串字面量，同时编译失败。</p>
<p>&emsp;&emsp;静态断言的好处就是可以在编译期就更早的发现错误，以及减少运行时开销。我看了一小部分C++标准库源码，发现静态断言出现的频率还挺高的，感觉标准委员会是挺推崇这东西的。<br><img src="/images/2021-12-02/8.jpg" alt="1"><br>&emsp;</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>感谢金主</div>
  <button>
    赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechat.jpg" alt="Zgg2001 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alibaba.jpg" alt="Zgg2001 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/C-%E6%A0%87%E5%87%86%E5%BA%93%E5%AD%A6%E4%B9%A0/" rel="tag"># C++标准库学习</a>
              <a href="/tags/C-C/" rel="tag"># C/C++</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/11/21/20211121_dpdk%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E5%AE%9E%E7%8E%B0(%E4%BA%8C)%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E9%80%80%E5%87%BA/" rel="prev" title="dpdk源码分析：交互式命令行的实现(二) 初始化与退出">
                  <i class="fa fa-angle-left"></i> dpdk源码分析：交互式命令行的实现(二) 初始化与退出
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/12/08/20211208_C++14%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E6%96%B0%E8%AF%AD%E8%A8%80%E5%8A%9F%E8%83%BD%E7%89%B9%E6%80%A7/" rel="next" title="C++14学习记录：新语言功能特性">
                  C++14学习记录：新语言功能特性 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Zgg2001</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">188k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">11:22</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
-->

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/zgg2001" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"zgg2001/zgg2001.github.io","issue_term":"pathname","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>

</body>
</html>
