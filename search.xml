<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>dfs学习记录：模板/思路汇总</title>
    <url>/2020/08/13/20200813_dfs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%80%9D%E8%B7%AF%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p><strong>HB小咸鱼学习记录</strong></p>
<p><strong>因为疫情</strong>，大一在校半年便草草结束了，大二转眼将至。<br>疫情期间在家没事便抽空预习了预习大二要学的数据结构。<br>思来想去还是决定把学习的过程记录下来，方便自己以后查阅或者总结。</p>
<span id="more"></span>

<h1 id="一点看法"><a href="#一点看法" class="headerlink" title="一点看法"></a>一点看法</h1><p>在我看来，计算机的一大优势便是计算速度快。由此，人们在对某些问题的计算方面上，就不用像高斯找到1加到100的特殊技巧那样费力寻找技巧，直接依靠着计算机的计算力从1直接加到100就好。这种不需要技巧的运算方式就是暴力运算。而当你需要对图进行搜索的时候，最基础的就是暴力搜索。<br>就我目前的接触而言，常见的暴力搜索方式便是深度优先遍历与广度优先遍历了。</p>
<h1 id="自我对于“深度优先搜索”的理解"><a href="#自我对于“深度优先搜索”的理解" class="headerlink" title="自我对于“深度优先搜索”的理解"></a>自我对于“深度优先搜索”的理解</h1><p>dfs,字面来看就是以深度为优先的搜索方式。用通俗点来讲就是一条道走到黑。<br>就像我们规定以“前左右”的顺序走迷宫，而在寻找迷宫的出口时就可以看成进行了一次搜索。这样首先便是一直向前走下去。直到前面没有路了，我们就按照“前左右”再向左走，要是左边还走不通就再向右走直到走到死胡同里。当走到死胡同里的时候说明我们走完了一条迷宫的支线，此时我们可以认为自己单刀直入了这条支线的最深处。此时我们还需要找迷宫的出口，于是我们后退到上一个交叉路口的位置，按照“前左右”的顺序寻找一个没有进入过的支线。如果这个路口的支线已经全部走过，则再次后退到上一个交叉路口进行搜索	……直到找到出口。<br>由此看来，如果运气好，我们第一次走便可能直接走到出口；但是运气差的话，可能把整个迷宫走完才能找到出口。</p>
<h1 id="dfs的大致思路"><a href="#dfs的大致思路" class="headerlink" title="dfs的大致思路"></a>dfs的大致思路</h1><p><strong>首先</strong>，如上个片段所说，我们首先需要一个二维数组，来储存迷宫的大致情况，包括可以走的路、障碍物、入口、出口……<br><strong>其次</strong>，我们对于已经走过的分叉路口要进行标记，防止进入已经进入过的路口，就像在走迷宫时你会主动避开走过的路线一样。这个通常用一个与上面地图大小相同的二维数组来储存坐标的状态。例如<strong>false</strong>代表没走过，<strong>true</strong>代表走过。<br><strong>接着</strong>，我们需要对移动的规则进行规定。例如上文的例子规定的“上左右”，我们可以用一个二维数组来储存移动后坐标的变化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> direction[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;; </span><br></pre></td></tr></table></figure>
<p>这个数组里面的四组数据就分别代表“上左右下”，在对坐标变换时进行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x1=x+direction[a][<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span> y1=y+direction[a][<span class="number">1</span>]; </span><br></pre></td></tr></table></figure>
<p>即可实现对坐标的变化。且在变化后将x1,y1的点的状态进行更改，代表你已经来过这里了。<br>而当你到达死路进行后退且前往别的点的时候，记得把刚来过的点的状态进行更改，使下一次也能前往。<br><strong>最后</strong>，我们需要进行判定，从而在找到出口时停止或者返回一些信息。</p>
<h1 id="dfs的大致模板"><a href="#dfs的大致模板" class="headerlink" title="dfs的大致模板"></a>dfs的大致模板</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(当前点位的信息)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(到达中止条件)</span><br><span class="line">	&#123;</span><br><span class="line">		执行一些东西;</span><br><span class="line">		<span class="keyword">return</span>; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">if</span>(当前点位越界或者不符合规定)<span class="comment">//即进行剪枝</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">for</span>(按照搜索的方向进行循环)</span><br><span class="line">	&#123;</span><br><span class="line">		根据当前点位进行修改得到新点位;</span><br><span class="line">		<span class="keyword">if</span>(新点位可以前往)</span><br><span class="line">		&#123;</span><br><span class="line">			执行一些东西;</span><br><span class="line">			把新点位标记;</span><br><span class="line">			<span class="built_in">dfs</span>(新点位的信息);</span><br><span class="line">			取消新点位的标记; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照上面的思路大致可写以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> map[<span class="number">100</span>][<span class="number">100</span>];		<span class="comment">//地图 其中值为0则代表可走 </span></span><br><span class="line"><span class="type">bool</span> b_map[<span class="number">100</span>][<span class="number">100</span>];		<span class="comment">//点状态集	值为false代表没被走过 true代表被走过 </span></span><br><span class="line"><span class="type">int</span> direction[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;; 		<span class="comment">//搜索方向坐标变化集 </span></span><br><span class="line"><span class="type">int</span> X,Y;	<span class="comment">//终点坐标 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> times)</span>		<span class="comment">//传入当前点的x,y坐标以及走的次数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==X&amp;&amp;y==Y)		<span class="comment">//当走到出口时 </span></span><br><span class="line">	&#123;</span><br><span class="line">		std::cout&lt;&lt;times&lt;&lt;<span class="string">&quot;\n&quot;</span>;		<span class="comment">//输出走的步数 </span></span><br><span class="line">		<span class="keyword">return</span>; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">0</span>;a&lt;<span class="number">4</span>;a++)   	 <span class="comment">//对搜索方向进行遍历  </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x1=x+direction[a][<span class="number">0</span>];	 <span class="comment">//x加上当前搜索方向的变化 </span></span><br><span class="line">		<span class="type">int</span> y1=y+direction[a][<span class="number">1</span>]; 	 <span class="comment">//y加上当前搜索方向的变化 </span></span><br><span class="line">		<span class="keyword">if</span>(!map[x1][y1]&amp;&amp;!b_map[x1][y1])	<span class="comment">//判定x1,y1点是否可走 </span></span><br><span class="line">		&#123;</span><br><span class="line">			b_map[x1][y1] = <span class="literal">true</span>;	 <span class="comment">//可走的话就标记以走过 </span></span><br><span class="line">			<span class="built_in">dfs</span>(x1,y1,time<span class="number">+1</span>);		<span class="comment">//递归 传入新点位的坐标 以及走的次数加一 进行下一个坐标点的判定 </span></span><br><span class="line">			b_map[x1][y1] = <span class="literal">false</span>;	  <span class="comment">//取消标记 表示该线路以及搜索完毕 </span></span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="dfs的相关例题"><a href="#dfs的相关例题" class="headerlink" title="dfs的相关例题"></a>dfs的相关例题</h1><p>dfs虽然搜索细致，但是在搜索过程中会进行大量的无意义运算，浪费时间，于是在运算中就要进行“剪枝”，即根据所求信息增加判定要求，从而最大限度的减少递归的调用次数，加快运算时间。</p>
<h2 id="1-蓝桥杯-迷宫"><a href="#1-蓝桥杯-迷宫" class="headerlink" title="1.蓝桥杯 迷宫"></a>1.蓝桥杯 迷宫</h2><p><img src="/images/2020-08-13/1.jpg" alt="蓝桥杯 迷宫"><br><a href="http://oj.ecustacm.cn/problem.php?id=1455">OJ链接</a></p>
<p><strong>思路：</strong> 在这道蓝桥杯的题目里，由于是求最短路径，所以用<strong>bfs</strong>来写比较简单。用<strong>dfs</strong>来写的话由于数据过大，不剪枝或者剪的不够的话稳稳的超时。<br>但是我们可以引入一个与图一样大小的二维数组，该数组用来储存到达该点的最小步数。则如果在递归中，当前步数大于当前点的最小步数，说明到达当前点多走歪路了，则中止递归。<br>在该条件的约束下，该dfs的运算效率得到了极大的提升。</p>
<p><strong>AC代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X 30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Y 50 </span></span><br><span class="line"><span class="type">int</span> a_map[<span class="number">31</span>][<span class="number">51</span>],ans=<span class="number">100000000</span>,zhj=<span class="number">100000000</span>;</span><br><span class="line"><span class="type">bool</span> b_map[<span class="number">31</span>][<span class="number">51</span>];</span><br><span class="line"><span class="type">char</span> fx[<span class="number">10000</span>];</span><br><span class="line"><span class="type">char</span> t_fx[<span class="number">10000</span>];</span><br><span class="line"><span class="type">int</span> z_4[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;; </span><br><span class="line"><span class="type">char</span> z[<span class="number">4</span>] = &#123;<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;L&#x27;</span>,<span class="string">&#x27;R&#x27;</span>,<span class="string">&#x27;U&#x27;</span>&#125;;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">31</span>][<span class="number">51</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> time,<span class="type">int</span> he)</span><span class="comment">//当前点的x,y坐标 走的步数 当前的路程权值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==X&amp;&amp;y==Y)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(time&lt;zhj&amp;&amp;he&lt;ans)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;time;now++)</span><br><span class="line">				fx[now]=t_fx[now];</span><br><span class="line">			zhj=time<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">0</span>;a&lt;<span class="number">4</span>;a++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(he+z[a]&gt;ans)<span class="comment">//条件判定</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="type">int</span> x1=x+z_4[a][<span class="number">0</span>];</span><br><span class="line">		<span class="type">int</span> y1=y+z_4[a][<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(x1&lt;<span class="number">1</span> || y1&lt;<span class="number">1</span> || x1&gt;X || y1&gt;Y)<span class="comment">//条件判定</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(b_map[x1][y1])<span class="comment">//条件判定</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(time<span class="number">+1</span>&gt;dp[x1][y1])<span class="comment">//条件判定</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		dp[x1][y1]=time<span class="number">+1</span>;<span class="comment">//当前点的最小步数更新</span></span><br><span class="line">		b_map[x1][y1]=<span class="literal">true</span>;</span><br><span class="line">		t_fx[time] = z[a];</span><br><span class="line">		<span class="built_in">dfs</span>(x1,y1,time<span class="number">+1</span>,he+z[a]);</span><br><span class="line">		b_map[x1][y1]=<span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(fx,<span class="number">0</span>,<span class="built_in">sizeof</span>(fx));</span><br><span class="line">	<span class="built_in">memset</span>(a_map,<span class="number">0</span>,<span class="built_in">sizeof</span>(a_map));</span><br><span class="line">	<span class="built_in">memset</span>(b_map,<span class="literal">false</span>,<span class="built_in">sizeof</span>(b_map));</span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">999999</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">1</span>;a&lt;=X;a++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> b=<span class="number">1</span>;b&lt;=Y;b++)</span><br><span class="line">		&#123;</span><br><span class="line">			a_map[a][b] = <span class="built_in">getchar</span>()-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">			<span class="keyword">if</span>(a_map[a][b]==<span class="number">1</span>)</span><br><span class="line">				b_map[a][b]=<span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	b_map[<span class="number">1</span>][<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;=zhj;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,fx[now]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/jziwjxjd/article/details/104078653">该思路原地址</a></p>
<h2 id="2-蓝桥杯-全球变暖"><a href="#2-蓝桥杯-全球变暖" class="headerlink" title="2.蓝桥杯 全球变暖"></a>2.蓝桥杯 全球变暖</h2><p><strong>题目</strong><br>你有一张某海域NxN像素的照片，”.”表示海洋、”#”表示陆地，如下所示：<br><img src="/images/2020-08-13/2.jpg" alt="1"></p>
<p>其中”上下左右”四个方向上连在一起的一片陆地组成一座岛屿。例如上图就有2座岛屿。<br>由于全球变暖导致了海面上升，科学家预测未来几十年，岛屿边缘一个像素的范围会被海水淹没。<br>具体来说如果一块陆地像素与海洋相邻(上下左右四个相邻像素中有海洋)，它就会被淹没。<br>例如上图中的海域未来会变成如下样子：<br><img src="/images/2020-08-13/3.jpg" alt="2"></p>
<p>请你计算：依照科学家的预测，照片中有多少岛屿会被完全淹没。</p>
<p><strong>输入</strong><br>第一行包含一个整数N。  (1 &lt;&#x3D; N &lt;&#x3D; 1000)<br>以下N行N列代表一张海域照片。<br>照片保证第1行、第1列、第N行、第N列的像素都是海洋。  </p>
<p><strong>输出</strong><br>一个整数表示答案。</p>
<p><strong>样例输入</strong><br><img src="/images/2020-08-13/4.jpg" alt="3"><br><strong>样例输出</strong><br>1</p>
<p><a href="http://oj.ecustacm.cn/problem.php?id=1365">OJ链接</a></p>
<p><strong>思路</strong>：在接收初始图之后，<strong>首先</strong>搜索查找初始岛屿数，在找到一个岛屿后，对整个岛屿进行标记，防止重复计数。<strong>随后</strong>再次进行搜索，如果有四周均为陆地的坐标，则标记此坐标未被淹没。<strong>最后</strong>查找所有未被淹没的坐标，并将坐标所处的整个岛标记，防止重复计数。初始岛屿数量减去未被淹没岛的数量，即为被淹没的岛的数量。</p>
<p><strong>AC代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> maps[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(maps[x][y]!=<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	maps[x][y]=<span class="string">&#x27;1&#x27;</span>;<span class="comment">//将#标记为1 </span></span><br><span class="line">	<span class="built_in">dfs1</span>(x<span class="number">+1</span>,y);<span class="comment">//把整个岛都进行标记 防止重复计算 </span></span><br><span class="line">	<span class="built_in">dfs1</span>(x<span class="number">-1</span>,y);</span><br><span class="line">	<span class="built_in">dfs1</span>(x,y<span class="number">+1</span>);</span><br><span class="line">	<span class="built_in">dfs1</span>(x,y<span class="number">-1</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(maps[x][y]==<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(maps[x<span class="number">+1</span>][y]==<span class="string">&#x27;1&#x27;</span>&amp;&amp;maps[x<span class="number">-1</span>][y]==<span class="string">&#x27;1&#x27;</span>&amp;&amp;maps[x][y<span class="number">+1</span>]==<span class="string">&#x27;1&#x27;</span>&amp;&amp;maps[x][y<span class="number">-1</span>]==<span class="string">&#x27;1&#x27;</span>)<span class="comment">//四周都是陆地 则标记为2</span></span><br><span class="line">	&#123;	</span><br><span class="line">		maps[x][y]=<span class="string">&#x27;2&#x27;</span>; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">dfs1</span>(x<span class="number">+1</span>,y);<span class="comment">//找4个方向 </span></span><br><span class="line">	<span class="built_in">dfs1</span>(x<span class="number">-1</span>,y);</span><br><span class="line">	<span class="built_in">dfs1</span>(x,y<span class="number">+1</span>);</span><br><span class="line">	<span class="built_in">dfs1</span>(x,y<span class="number">-1</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs3</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(maps[x][y]==<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	maps[x][y]=<span class="string">&#x27;.&#x27;</span>;<span class="comment">//将#标记为 . </span></span><br><span class="line">	<span class="built_in">dfs3</span>(x<span class="number">+1</span>,y);<span class="comment">//把整个岛都进行沉没操作 防止重复计算 </span></span><br><span class="line">	<span class="built_in">dfs3</span>(x<span class="number">-1</span>,y);</span><br><span class="line">	<span class="built_in">dfs3</span>(x,y<span class="number">+1</span>);</span><br><span class="line">	<span class="built_in">dfs3</span>(x,y<span class="number">-1</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,first_num=<span class="number">0</span>,end_num=<span class="number">0</span>;<span class="comment">//层数 初始岛屿数量 末尾岛屿数量 </span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n); </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">1</span>;a&lt;=n;a++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> b=<span class="number">1</span>;b&lt;=n;b++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;maps[a][b]);</span><br><span class="line">				<span class="keyword">if</span>(maps[a][b]==<span class="string">&#x27;.&#x27;</span>||maps[a][b]==<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//先查找有多少个岛屿 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">1</span>;a&lt;=n;a++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> b=<span class="number">1</span>;b&lt;=n;b++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(maps[a][b]==<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">dfs1</span>(a,b);</span><br><span class="line">				first_num++;<span class="comment">//初始岛屿+1 </span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//再对整个岛屿进行变化</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">1</span>;a&lt;=n;a++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> b=<span class="number">1</span>;b&lt;=n;b++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(maps[a][b]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">dfs2</span>(a,b);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//最后查找剩余多少个岛屿 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">1</span>;a&lt;=n;a++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> b=<span class="number">1</span>;b&lt;=n;b++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(maps[a][b]==<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">dfs3</span>(a,b);</span><br><span class="line">				end_num++;<span class="comment">//最终岛屿+1 </span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;first_num-end_num;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="3-leetcode-路径总和"><a href="#3-leetcode-路径总和" class="headerlink" title="3.leetcode 路径总和"></a>3.leetcode 路径总和</h2><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。<br>说明: 叶子节点是指没有子节点的节点。</p>
<p><strong>示例:</strong><br>给定如下二叉树，以及目标和 sum &#x3D; 22，</p>
<pre><code>          5
         / \
        4   8
       /   / \
      11  13  4
     /  \      \
    7    2      1
</code></pre>
<p>返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/path-sum">https://leetcode-cn.com/problems/path-sum</a> <a href="https://leetcode-cn.com/problems/path-sum/">OJ链接</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p><strong>AC代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> sum)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        kg=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">dfs</span>(root,root-&gt;val,sum);</span><br><span class="line">        <span class="keyword">return</span> kg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="type">int</span> now,<span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(now==end&amp;&amp;root-&gt;left==<span class="literal">NULL</span>&amp;&amp;root-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            kg = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span>&amp;&amp;root-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">dfs</span>(root-&gt;left,now+root-&gt;left-&gt;val,end);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right!=<span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">dfs</span>(root-&gt;right,now+root-&gt;right-&gt;val,end);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> kg;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="4-leetcode-路径总和II"><a href="#4-leetcode-路径总和II" class="headerlink" title="4.leetcode 路径总和II"></a>4.leetcode 路径总和II</h2><p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。<br>说明: 叶子节点是指没有子节点的节点。</p>
<p><strong>示例:</strong><br>给定如下二叉树，以及目标和 sum &#x3D; 22，</p>
<pre><code>          5
         / \
        4   8
       /   / \
      11  13  4
     /  \    / \
    7    2  5   1
</code></pre>
<p>返回:</p>
<p>[<br>   [5,4,11,2],<br>   [5,8,4,5]<br>]</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/path-sum-ii">https://leetcode-cn.com/problems/path-sum-ii</a> <a href="https://leetcode-cn.com/problems/path-sum-ii/">OJ链接</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p><strong>AC代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="type">int</span> sum) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            <span class="built_in">dfs</span>(root,sum-root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ps;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;ps;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;temp;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(end==<span class="number">0</span>&amp;&amp;!root-&gt;left&amp;&amp;!root-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt;t=temp;</span><br><span class="line">            ps.<span class="built_in">push_back</span>(t);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left&amp;&amp;!root-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(root-&gt;left-&gt;val);</span><br><span class="line">            <span class="built_in">dfs</span>(root-&gt;left,end-root-&gt;left-&gt;val);</span><br><span class="line">            temp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(root-&gt;right-&gt;val);</span><br><span class="line">            <span class="built_in">dfs</span>(root-&gt;right,end-root-&gt;right-&gt;val);</span><br><span class="line">            temp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p><strong>在使用dfs中，要根据题目数据选择合适的数据类型。</strong><br>比如在题目数据过大时，申请较大的二维数组很容易失败。即使申请成功也会造成极大的内存浪费，循环时也很不方便。<br>这时就可以使用stl里的vector来储存数据，可以很好的提高的数据获取效率。<br><strong>要尽量多的进行筛选，增加效率</strong><br>好多题不止考的是dfs，甚至会考一点dp，所以要多想多做，寻找搜索中的共同点并对症下药。<br><strong>dfs的常用环境</strong><br>找最长路，特殊路等等等等。一般对带权图的搜索都用dfs。<br>在刷蓝桥杯的题的途中发现好多题都可以用dfs进行暴力，但是往往会超时。要想ac还得换题目想让你用的方法。但是往往能过几个检测点，所以不会的题都可以dfs一下混点分哈哈哈哈哈。<br><strong>总之，还是得多刷题，多积累经验。</strong></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集学习记录：模板/思路汇总</title>
    <url>/2020/08/19/20200819_%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%80%9D%E8%B7%AF%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p><strong>HB小咸鱼学习记录</strong></p>
<h1 id="自我对于“并查集”的理解"><a href="#自我对于“并查集”的理解" class="headerlink" title="自我对于“并查集”的理解"></a>自我对于“并查集”的理解</h1><p>有时候一些题，是让你判断图中一些数据是否在一个集合中。例如1和3联通，2和3联通，问你1和2是否联通。这其实问的就是1和2是否在一个联通集合里，如果用搜索进行遍历的话，就需要挨个对路径进行尝试，如果数据量大的话，消耗时间就会过多，这时候就可以用并查集来解决问题。</p>
<span id="more"></span>

<h1 id="并查集的大致思路"><a href="#并查集的大致思路" class="headerlink" title="并查集的大致思路"></a>并查集的大致思路</h1><p>并查集的核心操作就是“并”与“查”。<br>“并”指的是将两个数据放到一个集合里，“查”就是查询一个数据在哪个集合里。<br><strong>首先</strong>，我们声明一个father数组，数组的值是指向当前下标元素的父节点。<br><strong>其次</strong>，我们对这个数组进行初始化，使得当前下标的值是他本身。代表他是自己的父节点，即他是根节点，这个情况下可以看作每个元素都是一个单独的集合。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> father[MAX];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1</span>;now&lt;MAX;now++)<span class="comment">//初始化 </span></span><br><span class="line">&#123;</span><br><span class="line">	father[now]=now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>接着</strong>，我们建立“查”操作，查询某一数据属于哪个集合，就是查询他的根节点。<br>因为我们设定了father数组，所以我们不断查找该数据的父节点，即可知道该数据的根节点。<br>我们如果要查询两个数据是否属于一个集合，即可通过“查”操作获取两个数据的根节点，如果两个数据的根节点相同，则说明两个数属于同一个集合。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种写法（递归）</span></span><br><span class="line"><span class="comment">//第一种写法可以用三目运算符缩写为 return father[a]==a ? a : find(father[a]);</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(father[a]==a)</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">find</span>(father[a]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二种写法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = father[a];</span><br><span class="line">	<span class="keyword">while</span>(father[temp]!=temp)</span><br><span class="line">		temp = father[temp];</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>最后</strong>，我们建立“并”操作，可以将两个集合合并。<br>我们首先获取想要合并的数据A和数据B的根节点。如果根节点相同，则说明两个数据本来就属于一个集合，所以不用进行合并处理；如果根节点不同，则说明两个数据不属于同一个集合，此时我们需要进行合并操作。<br>合并操作很简单，让一个数据的根节点指向另一个数据的根节点即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">union_</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp_a=<span class="built_in">find</span>(a);</span><br><span class="line">	<span class="type">int</span> temp_b=<span class="built_in">find</span>(b);</span><br><span class="line">	<span class="keyword">if</span>(temp_a!=temp_b)</span><br><span class="line">	&#123;</span><br><span class="line">		father[temp_a]=temp_b;	</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="一些优化"><a href="#一些优化" class="headerlink" title="一些优化"></a>一些优化</h2><p> <strong>秩优化</strong><br>我们在进行“并”操作时，如果和上面一样，规定无论如何都是数据A往数据B并，那么很有可能大树并小树，导致整个集合的深度增加，最极端的例子是形成了一条链，此时如果find链尾，则会将整个链遍历一遍，时间消耗会大大增加。所以我们在进行“并”操作时，可以获取两个数据所处集合的深度，让深度低的成为深度高的子集。而当深度一样时，则可以看你的喜好进行合并。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> deep[MAX] = &#123;<span class="number">0</span>&#125;;<span class="comment">//深度数组，初始深度都为0，储存各个集合的深度 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">union_</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp_a=<span class="built_in">find</span>(a);</span><br><span class="line">	<span class="type">int</span> temp_b=<span class="built_in">find</span>(b);</span><br><span class="line">	<span class="keyword">if</span>(temp_a!=temp_b)<span class="comment">//两个数据不在同一个集合</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(deep[temp_a]&gt;deep[temp_b])<span class="comment">//a比b深度高 </span></span><br><span class="line">		&#123;</span><br><span class="line">			father[temp_b]=temp_a;<span class="comment">//b成为a的子集 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(deep[temp_a]&lt;deep[temp_b])<span class="comment">//a比b深度低 </span></span><br><span class="line">		&#123;</span><br><span class="line">			father[temp_a]=temp_b;<span class="comment">//a成为b的子集 </span></span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//深度一样 </span></span><br><span class="line">		&#123;</span><br><span class="line">			father[temp_b]=temp_a;<span class="comment">//b成为a的子集 </span></span><br><span class="line">			deep[temp_a]++;<span class="comment">//a的根节点的深度加一 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>路径压缩</strong><br> 在我们进行find查询时，如果我们只在乎某数据的根节点，而不在意他的各个父节点时，我们可以进行路径压缩。让这个数据的父节点直接指向根节点，这样被称作“路径压缩”。在进行路径压缩后，所有的节点都指向根节点，这样集合的深度只有1，在之后进行数据的根节点查询时的复杂度只有O(1),大大提升查询速度。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种写法（递归）</span></span><br><span class="line"><span class="comment">//第一种写法可以用三目运算符缩写为 return father[a]==a ? a : father[a] = find(father[a]);</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(father[a]==a)</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">return</span> father[a] = <span class="built_in">find</span>(father[a]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二种写法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = father[a];</span><br><span class="line">	<span class="keyword">while</span>(father[temp]!=temp)</span><br><span class="line">		temp = father[temp];</span><br><span class="line">    <span class="type">int</span> i=a,j;</span><br><span class="line">    <span class="keyword">while</span>(i!=temp) <span class="comment">//路径压缩</span></span><br><span class="line">    &#123;</span><br><span class="line">         j=father[i]; <span class="comment">// 在改变上级之前用临时变量j记录下他的值</span></span><br><span class="line">         father[i]=temp; <span class="comment">//把上级改为根节点</span></span><br><span class="line">         i=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="并查集的大致模板"><a href="#并查集的大致模板" class="headerlink" title="并查集的大致模板"></a>并查集的大致模板</h1><p>这是秩优化+路径压缩的模板，<br>其余版本看上面的思路模块即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> father[MAX];<span class="comment">//父节点数组</span></span><br><span class="line"><span class="type">int</span> deep[MAX] = &#123;<span class="number">0</span>&#125;;<span class="comment">//深度数组，初始深度都为0，储存各个集合的深度 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span><span class="comment">//初始化 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1</span>;now&lt;MAX;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		father[now]=now;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span><span class="comment">//查询</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(father[a]==a)</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">return</span> father[a] = <span class="built_in">find</span>(father[a]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">union_</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span><span class="comment">//合并</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp_a=<span class="built_in">find</span>(a);</span><br><span class="line">	<span class="type">int</span> temp_b=<span class="built_in">find</span>(b);</span><br><span class="line">	<span class="keyword">if</span>(temp_a!=temp_b)<span class="comment">//两个数据不在同一个集合</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(deep[temp_a]&gt;deep[temp_b])<span class="comment">//a比b深度高 </span></span><br><span class="line">		&#123;</span><br><span class="line">			father[temp_b]=temp_a;<span class="comment">//b成为a的子集 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(deep[temp_a]&lt;deep[temp_b])<span class="comment">//a比b深度低 </span></span><br><span class="line">		&#123;</span><br><span class="line">			father[temp_a]=temp_b;<span class="comment">//a成为b的子集 </span></span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//深度一样 </span></span><br><span class="line">		&#123;</span><br><span class="line">			father[temp_b]=temp_a;<span class="comment">//b成为a的子集 </span></span><br><span class="line">			deep[temp_a]++;<span class="comment">//a的根节点的深度加一 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	........</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="并查集例题"><a href="#并查集例题" class="headerlink" title="并查集例题"></a>并查集例题</h1><h2 id="1-畅通工程"><a href="#1-畅通工程" class="headerlink" title="1.畅通工程"></a>1.畅通工程</h2><p>某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？</p>
<p>Input<br>测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( &lt; 1000 )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。<br>注意:两个城市之间可以有多条道路相通,也就是说<br>3 3<br>1 2<br>1 2<br>2 1<br>这种输入也是合法的<br>当N为0时，输入结束，该用例不被处理。</p>
<p>Output<br>对每个测试用例，在1行里输出最少还需要建设的道路数目。</p>
<p>Sample Input<br>4 2<br>1 3<br>4 3<br>3 3<br>1 2<br>1 3<br>2 3<br>5 2<br>1 2<br>3 5<br>999 0<br>0</p>
<p>Sample Output<br>1<br>0<br>2<br>998</p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1232">题目地址</a></p>
<p>思路：这题在把所有的数据接收后，运用并查集进行集合合并，最后根节点的个数就是集合的个数。而联通n个节点最少需要n-1条边，故根节点的个数减去1就是建设道路的最少值。由于题中只在乎最后根节点的个数，所有使用了路径压缩，提高代码的运算速度。</p>
<p>AC代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> father[<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> father[a]==a ? a : father[a] = <span class="built_in">find</span>(father[a]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compose</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp_a=<span class="built_in">find</span>(a);</span><br><span class="line">	<span class="type">int</span> temp_b=<span class="built_in">find</span>(b);</span><br><span class="line">	<span class="keyword">if</span>(temp_a!=temp_b)</span><br><span class="line">	&#123;</span><br><span class="line">		father[temp_a]=temp_b;	</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a,b,c,d;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a)&amp;&amp;a)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1</span>;now&lt;=a;now++)<span class="comment">//初始化 </span></span><br><span class="line">		&#123;</span><br><span class="line">			father[now]=now;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(b--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;c,&amp;d);</span><br><span class="line">			<span class="built_in">compose</span>(c,d);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1</span>;now&lt;=a;now++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(father[now]==now)</span><br><span class="line">				ans++;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		cout&lt;&lt;ans<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-修改数组"><a href="#2-修改数组" class="headerlink" title="2.修改数组"></a>2.修改数组</h2><p>给定一个长度为N 的数组A &#x3D; [A1, A2,…,AN]，数组中有可能有重复出现的整数。<br>现在小明要按以下方法将其修改为没有重复整数的数组。小明会依次修改A2,A3,…, AN。<br>当修改Ai 时，小明会检查Ai 是否在A1~ Ai-1 中出现过。<br>如果出现过，则小明会给Ai 加上1 ；<br>如果新的Ai 仍在之前出现过，小明会持续给Ai 加1 ，直到Ai 没有在A1~Ai-1中出现过。<br>当AN 也经过上述修改之后，显然A数组中就没有重复的整数了。<br>现在给定初始的A 数组，请你计算出最终的A 数组。</p>
<p>输入<br>第一行包含一个整数N(1&lt;&#x3D;N&lt;&#x3D;100000)<br>第二行包含N个整数A1,A2,…,AN(1&lt;&#x3D;Ai&lt;&#x3D;1000000)</p>
<p>输出<br>输出N个整数，依次是最终的A1,A2,…,AN</p>
<p>样例输入 Copy<br>5<br>2 1 1 3 4</p>
<p>样例输出 Copy<br>2 1 3 4 5</p>
<p><a href="http://oj.ecustacm.cn/problem.php?id=1459">题目地址</a></p>
<p>思路：我们可以把用过的数字放到一个集合里，而让他的父节点指向下一个可以用的数字，具体操作就是**father[a]&#x3D;find(father[a]+1)**。这样我们就会一直对使用过的数字的父节点进行加一操作，直到找到一个没有被使用过的数字。由于这题只需要知道该数字是否被使用过，即是否在“被使用过”这个集合里，所以我们可以使用路径压缩，提高运算效率。</p>
<p>AC代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> father[<span class="number">1000001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(father[a]==<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		father[a]=a;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> father[a]=<span class="built_in">find</span>(father[a]<span class="number">+1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> input,aa;</span><br><span class="line">	cin&gt;&gt;input;</span><br><span class="line">	<span class="built_in">memset</span>(father,<span class="number">-1</span>,<span class="built_in">sizeof</span>(father));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1</span>;now&lt;=input;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;aa;</span><br><span class="line">		aa=<span class="built_in">find</span>(aa);</span><br><span class="line">		cout&lt;&lt;aa&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-敌人"><a href="#3-敌人" class="headerlink" title="3.敌人"></a>3.敌人</h2><p>俗话说得好，敌人的敌人就是朋友。<br>现在有n个人，编号1至n，初始互不相识。接下来有m个操作，操作分为两种：</p>
<p>（1）检查x号和y号是否是朋友，若不是，则变成敌人<br>（2）询问x号的朋友有多少个<br>请你针对每个操作中的询问给出回答。</p>
<p>输入<br>第一行两个正整数n、m，表示人的数量和操作的数量。<br>接下来m行，依次描述输入。每行的第一个整数为1或2表示操作种类。对于操作（1），随后有两个正整数x，y。对于操作（2），随后一个正整数x。</p>
<p>输出<br>输出包含m行，对于操作（1），输入’N’或”Y”，’N’表示x和y之前不是朋友，’Y’表示是朋友。对于操作（2），输出x的朋友数量。</p>
<p>输入示例<br>5 8<br>1 1 2<br>1 1 3<br>1 2 3<br>2 3<br>1 4 5<br>2 3<br>1 1 4<br>2 3</p>
<p>输出示例<br>N<br>N<br>Y<br>1<br>N<br>1<br>N<br>2</p>
<p>思路：这道题相比之前的题，一个不同的特点就是我们无法直接将两个数据放进同一个集合，因为输入的数据要变为“敌人”关系，即不在同一个集合内。那么我们如何能将两个数据放进同一个集合呢？我们可以扩大father数组，使它是原来的两倍大。假如一共有N个数，则1到N代表本身，N+1到2N则代表1到N的敌人。当我们设定两个数是敌人的时候，只需要把第一个数据和第二个数据的敌人放在一个集合，第二个数据和第一个数据的敌人防在一个集合，即可完成合并的操作。因为当和一个数的敌人是朋友时，那和这个数就是敌人。当查询一个数的朋友时，遍历查询与其根节点相同的点的个数，再减去一（它本身），即为朋友的个数。本题由于也是只看根节点，所以可以使用路径压缩。</p>
<p>AC代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> father[<span class="number">600001</span>];<span class="comment">//最大300000个数 数的敌人也有300000个 故一共600000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span><span class="comment">//查询</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> father[a]==a ? a : father[a] = <span class="built_in">find</span>(father[a]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compose</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span><span class="comment">//合并</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp_a=<span class="built_in">find</span>(a);</span><br><span class="line">	<span class="type">int</span> temp_b=<span class="built_in">find</span>(b);</span><br><span class="line">	<span class="keyword">if</span>(temp_a!=temp_b)</span><br><span class="line">	&#123;</span><br><span class="line">		father[temp_a]=temp_b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> input1,input2,a,b,c;</span><br><span class="line">	cin&gt;&gt;input1&gt;&gt;input2;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1</span>;now&lt;=input1*<span class="number">2</span>;now++)<span class="comment">//初始化 </span></span><br><span class="line">	&#123;</span><br><span class="line">		father[now]=now;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;input2;now++)<span class="comment">//接收初始值 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;a;</span><br><span class="line">		<span class="keyword">if</span>(a==<span class="number">1</span>)<span class="comment">//1操作</span></span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;b&gt;&gt;c;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">find</span>(b)==<span class="built_in">find</span>(c))<span class="comment">//是朋友</span></span><br><span class="line">			&#123;</span><br><span class="line">				cout&lt;&lt;<span class="string">&quot;Y&quot;</span>&lt;&lt;endl;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">compose</span>(b,c+input1);<span class="comment">//将输入的第一个数据和第二个数据的敌人放在一个集合里</span></span><br><span class="line">				<span class="built_in">compose</span>(c,b+input1);<span class="comment">//将输入的第二个数据和第一个数据的敌人放在一个集合里</span></span><br><span class="line">				cout&lt;&lt;<span class="string">&quot;N&quot;</span>&lt;&lt;endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="number">2</span>)<span class="comment">//2操作</span></span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;b;</span><br><span class="line">			<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">			<span class="comment">/*for(int now=1;now&lt;=input1*2;now++) </span></span><br><span class="line"><span class="comment">			&#123;</span></span><br><span class="line"><span class="comment">				cout&lt;&lt;father[now]&lt;&lt;&quot; &quot;;</span></span><br><span class="line"><span class="comment">			&#125;*/</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1</span>;now&lt;=input1;now++)<span class="comment">//如果根节点相同则说明在同一集合，是朋友 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">find</span>(b)==<span class="built_in">find</span>(now))</span><br><span class="line">					ans++;</span><br><span class="line">			&#125;</span><br><span class="line">			cout&lt;&lt;ans<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-食物链"><a href="#4-食物链" class="headerlink" title="4.食物链"></a>4.食物链</h2><p>有N只动物分别编号为1，2，……，N。所有动物都属于A，B，C中的一类。已知A能吃掉B，B能吃掉C，C能吃掉A。按顺序给出下面的两种信息共K条：<br>  第一种：x和y属于同一类；<br>  第二种：x吃y。<br>然而这些信息可能会出错，有可能有的信息和之前给出的信息矛盾，也有的信息可能给出的x和y不在1到N的范围内。求在K条信息中有多少条是不正确的。计算过程中，我们将忽视诸如此类的错误信息。</p>
<p>输入<br>第一行两个自然数，两数间用一个空格分隔，分别表示N和K，接下来的K行，每行有三个数，第一个数为0或1，分别对应第一种或第二种，接着的两个数，分别为该条信息的x和y，三个数两两之间用一个空格分隔。</p>
<p>输出<br>一个自然数，表示错误信息的条数。</p>
<p>输入示例<br>100 7<br>0 101 1<br>1 1 2<br>1 2 3<br>1 3 3<br>0 1 3<br>1 3 1<br>0 5 5</p>
<p>输出示例<br>3</p>
<p>思路：与上一题“敌人”相似，这一题也可以通过扩展数组建立多重关系来做。这一题存在同类、吃、被吃这三个关系。所以我们把数组扩到到原来的三倍，1到N代表本身，N+1到2N代表被“本身”吃的，2N+1到3N代表吃“本身”的。当我们建立0操作的“A和B同类”关系时，只需要把三个区域同等合并即可，即A本身和B本身合并为一类，A吃的和B吃的合并为一类，吃A的和吃B的合并为一类，即可说明A和B地位相同。当我们建立1操作的“A吃B”关系时，将B和A吃的划为一类，B吃的和吃A的划为一类，A和吃B的划为一类，即可实现A吃B关系网的建立。<br>而当输入超限、在0操作时判断出A和B是吃或被吃关系、在1操作时判断出A和B是同类或被吃关系时，即为语句错误，答案数量加一。由此结束时输出即可。</p>
<p>AC代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> father[<span class="number">150001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> father[a]==a ? a : father[a] = <span class="built_in">find</span>(father[a]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compose</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp_a=<span class="built_in">find</span>(a);</span><br><span class="line">	<span class="type">int</span> temp_b=<span class="built_in">find</span>(b);</span><br><span class="line">	<span class="keyword">if</span>(temp_a!=temp_b)</span><br><span class="line">	&#123;</span><br><span class="line">		father[temp_a]=temp_b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> input1,input2,a,b,c,ans=<span class="number">0</span>;</span><br><span class="line">	cin&gt;&gt;input1&gt;&gt;input2;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1</span>;now&lt;=input1*<span class="number">3</span>;now++)<span class="comment">//初始化 </span></span><br><span class="line">	&#123;</span><br><span class="line">		father[now]=now;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;input2;now++)<span class="comment">//接收初始值 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;a;</span><br><span class="line">		<span class="keyword">if</span>(a==<span class="number">0</span>)<span class="comment">//输入0 x与y同类 </span></span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;b&gt;&gt;c;</span><br><span class="line">			<span class="keyword">if</span>(b&gt;input1||b&lt;<span class="number">1</span>||c&gt;input1||c&lt;<span class="number">1</span>)<span class="comment">//输入不合法 </span></span><br><span class="line">			&#123;</span><br><span class="line">				ans++;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">find</span>(b)==<span class="built_in">find</span>(c+input1)||<span class="built_in">find</span>(b)==<span class="built_in">find</span>(c<span class="number">+2</span>*input1))<span class="comment">//如果属于吃或者被吃关系 </span></span><br><span class="line">				&#123;</span><br><span class="line">					ans++;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span><span class="comment">//指向平级，代表同类 </span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">compose</span>(b,c); </span><br><span class="line">					<span class="built_in">compose</span>(b+input1,c+input1);</span><br><span class="line">					<span class="built_in">compose</span>(b+input1*<span class="number">2</span>,c+input1*<span class="number">2</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="number">1</span>)<span class="comment">//输入1 x吃y </span></span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;b&gt;&gt;c;</span><br><span class="line">			<span class="keyword">if</span>(b&gt;input1||b&lt;<span class="number">1</span>||c&gt;input1||c&lt;<span class="number">1</span>)<span class="comment">//输入不合法 </span></span><br><span class="line">			&#123;</span><br><span class="line">				ans++;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">find</span>(b)==<span class="built_in">find</span>(c)||<span class="built_in">find</span>(b)==<span class="built_in">find</span>(c+input1))<span class="comment">//属于同一类或者被吃关系 </span></span><br><span class="line">				&#123;</span><br><span class="line">					ans++;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">compose</span>(b+input1,c);<span class="comment">//b吃的 和 c一类 即 b吃c </span></span><br><span class="line">					<span class="built_in">compose</span>(b+input1*<span class="number">2</span>,c+input1);<span class="comment">//吃b的 和 c吃的一类  </span></span><br><span class="line">					<span class="built_in">compose</span>(b,c+input1*<span class="number">2</span>);<span class="comment">//b 和 吃c的一类 </span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;<span class="comment">//结果</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-网络分析"><a href="#5-网络分析" class="headerlink" title="5. 网络分析"></a>5. 网络分析</h2><p>时间限制: 1.0s 内存限制: 256.0MB 本题总分：25 分<br><strong>问题：</strong><br>小明正在做一个网络实验。<br>他设置了 n 台电脑，称为节点，用于收发和存储数据。<br>初始时，所有节点都是独立的，不存在任何连接。<br>小明可以通过网线将两个节点连接起来，连接后两个节点就可以互相了。两个节点如果存在网线连接，称为相邻。<br>小明有时会测试当时的网络，他会在某个节点发送一条信息，信息会到每个相邻的节点，之后这些节点又会转发到自己相邻的节点，直到所有或间接相邻的节点都收到了信息。所有发送和接收的节点都会将信息存储一条信息只存储一次。<br>给出小明连接和测试的过程，请计算出每个节点存储信息的大小。</p>
<p><strong>输入：</strong><br>输入的第一行包含两个整数 n, m，分别表示节点数量和操作数量。节1 至 n 编号。<br>接下来 m 行，每行三个整数，表示一个操作。<br>如果操作为 1 a b，表示将节点 a 和节点 b 通过网线连接起来。当 时，表示连接了一个自环，对网络没有实质影响。<br>如果操作为 2 p t，表示在节点 p 上发送一条大小为 t 的信息。</p>
<p><strong>输出：</strong><br>输出一行，包含 n 个整数，相邻整数之间用一个空格分割，依次表示完上述操作后节点 1 至节点 n 上存储信息的大小。</p>
<p><strong>样例输入：</strong><br>4 8<br>1 1 2<br>2 1 10<br>2 3 5<br>1 4 1<br>2 2 2<br>1 1 2<br>1 2 4<br>2 2 1</p>
<p><strong>样例输出：</strong><br>13 13 5 3</p>
<p><strong>评测用例规模与约定：</strong><br>对于 30% 的评测用例，1 ≤ n ≤ 20，1 ≤ m ≤ 100。<br>对于 50% 的评测用例，1 ≤ n ≤ 100，1 ≤ m ≤ 1000。<br>对于 70% 的评测用例，1 ≤ n ≤ 1000，1 ≤ m ≤ 10000。<br>对于所有评测用例，1 ≤ n ≤ 10000，1 ≤ m ≤ 100000，1 ≤ t ≤ 100。</p>
<p><strong>思路：</strong> 核心思路是并查集。一个数组用来存旧值，一个数组用来存根结点权值，一个数组是并查集的father数组。执行2操作时，查集寻找到操作值的根结点并加权。执行1操作时，若两数在一个集内则不操作；若两数不在一个集内，则对所有节点进行遍历，使他们的旧值数组加上其根节点的权值，随后进行并集操作。记得对权值数组进行清零，防止后面重复计算。</p>
<p><strong>AC代码：</strong> <a href="https://www.acwing.com/problem/content/description/2071/">OJ链接</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> old_[<span class="number">10001</span>],new_[<span class="number">10001</span>],father[<span class="number">10001</span>],n,m;<span class="comment">//存老值 存根节点新值 父节点数组 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> father[a]==a ? a : father[a]=<span class="built_in">find</span>(father[a]);<span class="comment">//路径压缩</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">union_</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp_a=<span class="built_in">find</span>(a),temp_b=<span class="built_in">find</span>(b);</span><br><span class="line">	<span class="keyword">if</span>(temp_a!=temp_b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> now=<span class="number">1</span>;now&lt;=n;now++)</span><br><span class="line">		&#123;</span><br><span class="line">			old_[now]+=new_[<span class="built_in">find</span>(now)];<span class="comment">//旧值数组遍历加上权值</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">memset</span>(new_,<span class="number">0</span>,<span class="built_in">sizeof</span>(new_));<span class="comment">//重置权值数组，防止重复计算</span></span><br><span class="line">		father[temp_a]=temp_b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a,b,c;</span><br><span class="line">	<span class="built_in">memset</span>(new_,<span class="number">0</span>,<span class="built_in">sizeof</span>(new_));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> now=<span class="number">1</span>;now&lt;=<span class="number">10000</span>;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		father[now]=now;<span class="comment">//father数组初始化 </span></span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">while</span>(m--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">		<span class="keyword">if</span>(a==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">union_</span>(b,c);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			new_[<span class="built_in">find</span>(b)]+=c;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> now=<span class="number">1</span>;now&lt;=n;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,old_[now]+new_[<span class="built_in">find</span>(now)]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p><strong>在使用并查集中，要根据题目数据选择合适的优化。</strong><br>一般都得用路径压缩提高效率，但是秩优化用的比较少（我感觉），因为在进行路径压缩后秩优化后的结构就不复存在的，我感觉二者是有点矛盾的。但是两者一起使用相较于只使用路径压缩也会在第一次接收数据时提高一点效率，但是为了敲代码的效率，我还是喜欢只敲路径压缩。<br><strong>使用并查集时，要选择合适的数据结构</strong><br>例如秩优化时的储存深度的数组、例题第三题“敌人”的长数组、以及涉及带权并查集的结构。<br><strong>总之，还是得多刷题，多积累经验。</strong></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2018 蓝桥杯 递增三元组 sort排序</title>
    <url>/2020/08/25/20200825_2018%E8%93%9D%E6%A1%A5%E6%9D%AF%E9%80%92%E5%A2%9E%E4%B8%89%E5%85%83%E7%BB%84sort%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p><strong>这是2018年蓝桥杯C语言省赛B组的第六题</strong></p>
<span id="more"></span>

<p><strong>题目：</strong><br>给定三个整数数组<br>A &#x3D; [A1, A2, … AN],<br>B &#x3D; [B1, B2, … BN],<br>C &#x3D; [C1, C2, … CN]，<br>请你统计有多少个三元组(i, j, k) 满足：</p>
<ol>
<li>1 &lt;&#x3D; i, j, k &lt;&#x3D; N  </li>
<li>Ai &lt; Bj &lt; Ck</li>
</ol>
<p><strong>输入</strong><br>第一行包含一个整数N。<br>第二行包含N个整数A1, A2, … AN。<br>第三行包含N个整数B1, B2, … BN。<br>第四行包含N个整数C1, C2, … CN。<br>1 &lt;&#x3D; N &lt;&#x3D; 100000 0 &lt;&#x3D; Ai, Bi, Ci &lt;&#x3D; 100000 </p>
<p><strong>输出</strong><br>一个整数表示答案</p>
<p><strong>样例输入</strong><br>3<br>1 1 1<br>2 2 2<br>3 3 3</p>
<p><strong>样例输出</strong><br>27</p>
<p><a href="http://oj.ecustacm.cn/problem.php?id=1371">OJ链接</a></p>
<p><strong>思路</strong>：先用sort对三个数组进行排序。随后对B数组进行遍历，用lower_bound函数求出A数组中小于B数组当前元素的数量，用upper_bound函数求出C数组中大于B数组当前元素的数量，两者相乘算出B数组当前元素下可行解的数量，把B数组遍历一遍即可求出总解。<br><strong>PS</strong>：记得用long long，用int的话会爆。</p>
<p><strong>AC代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">100001</span>],b[<span class="number">100001</span>],c[<span class="number">100001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;n;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[now]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;n;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[now]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;n;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;c[now]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">sort</span>(a,a+n);<span class="comment">//排序</span></span><br><span class="line">	<span class="built_in">sort</span>(b,b+n);</span><br><span class="line">	<span class="built_in">sort</span>(c,c+n);</span><br><span class="line">	</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;<span class="comment">//记得用long long</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;n;now++)<span class="comment">//b为中间值 遍历</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">long</span> <span class="type">long</span> s1=<span class="built_in">lower_bound</span>(a,a+n,b[now])-a;<span class="comment">//获取a中小于b【now】的个数</span></span><br><span class="line">		<span class="type">long</span> <span class="type">long</span> s2=n-(<span class="built_in">upper_bound</span>(c,c+n,b[now])-c);<span class="comment">//获取c中大于b【now】的个数</span></span><br><span class="line">		ans+=s1*s2;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构与算法</tag>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title>2018 蓝桥杯 全球变暖(dfs) 深度优先遍历写法</title>
    <url>/2020/08/26/20200826_2018%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%85%A8%E7%90%83%E5%8F%98%E6%9A%96(dfs)%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E5%86%99%E6%B3%95/</url>
    <content><![CDATA[<p><strong>这是2018年蓝桥杯C语言省赛B组的第九题</strong></p>
<span id="more"></span>

<p><strong>题目</strong><br>你有一张某海域NxN像素的照片，”.”表示海洋、”#”表示陆地，如下所示：<br><img src="/images/2020-08-13/2.jpg" alt="1"></p>
<p>其中”上下左右”四个方向上连在一起的一片陆地组成一座岛屿。例如上图就有2座岛屿。<br>由于全球变暖导致了海面上升，科学家预测未来几十年，岛屿边缘一个像素的范围会被海水淹没。<br>具体来说如果一块陆地像素与海洋相邻(上下左右四个相邻像素中有海洋)，它就会被淹没。<br>例如上图中的海域未来会变成如下样子：<br><img src="/images/2020-08-13/3.jpg" alt="1"></p>
<p>请你计算：依照科学家的预测，照片中有多少岛屿会被完全淹没。</p>
<p><strong>输入</strong><br>第一行包含一个整数N。  (1 &lt;&#x3D; N &lt;&#x3D; 1000)<br>以下N行N列代表一张海域照片。<br>照片保证第1行、第1列、第N行、第N列的像素都是海洋。  </p>
<p><strong>输出</strong><br>一个整数表示答案。</p>
<p><strong>样例输入</strong><br><img src="/images/2020-08-13/4.jpg" alt="1"><br><strong>样例输出</strong><br>1</p>
<p><a href="http://oj.ecustacm.cn/problem.php?id=1365">OJ链接</a></p>
<p><strong>思路</strong>：在接收初始图之后，<strong>首先</strong>搜索查找初始岛屿数，在找到一个岛屿后，对整个岛屿进行标记，防止重复计数。<strong>随后</strong>再次进行搜索，如果有四周均为陆地的坐标，则标记此坐标未被淹没。<strong>最后</strong>查找所有未被淹没的坐标，并将坐标所处的整个岛标记，防止重复计数。初始岛屿数量减去未被淹没岛的数量，即为被淹没的岛的数量。</p>
<p><strong>AC代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> maps[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(maps[x][y]!=<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	maps[x][y]=<span class="string">&#x27;1&#x27;</span>;<span class="comment">//将#标记为1 </span></span><br><span class="line">	<span class="built_in">dfs1</span>(x<span class="number">+1</span>,y);<span class="comment">//把整个岛都进行标记 防止重复计算 </span></span><br><span class="line">	<span class="built_in">dfs1</span>(x<span class="number">-1</span>,y);</span><br><span class="line">	<span class="built_in">dfs1</span>(x,y<span class="number">+1</span>);</span><br><span class="line">	<span class="built_in">dfs1</span>(x,y<span class="number">-1</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(maps[x][y]==<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(maps[x<span class="number">+1</span>][y]==<span class="string">&#x27;1&#x27;</span>&amp;&amp;maps[x<span class="number">-1</span>][y]==<span class="string">&#x27;1&#x27;</span>&amp;&amp;maps[x][y<span class="number">+1</span>]==<span class="string">&#x27;1&#x27;</span>&amp;&amp;maps[x][y<span class="number">-1</span>]==<span class="string">&#x27;1&#x27;</span>)<span class="comment">//四周都是陆地 则标记为2</span></span><br><span class="line">	&#123;	</span><br><span class="line">		maps[x][y]=<span class="string">&#x27;2&#x27;</span>; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">dfs1</span>(x<span class="number">+1</span>,y);<span class="comment">//找4个方向 </span></span><br><span class="line">	<span class="built_in">dfs1</span>(x<span class="number">-1</span>,y);</span><br><span class="line">	<span class="built_in">dfs1</span>(x,y<span class="number">+1</span>);</span><br><span class="line">	<span class="built_in">dfs1</span>(x,y<span class="number">-1</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs3</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(maps[x][y]==<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	maps[x][y]=<span class="string">&#x27;.&#x27;</span>;<span class="comment">//将#标记为 . </span></span><br><span class="line">	<span class="built_in">dfs3</span>(x<span class="number">+1</span>,y);<span class="comment">//把整个岛都进行沉没操作 防止重复计算 </span></span><br><span class="line">	<span class="built_in">dfs3</span>(x<span class="number">-1</span>,y);</span><br><span class="line">	<span class="built_in">dfs3</span>(x,y<span class="number">+1</span>);</span><br><span class="line">	<span class="built_in">dfs3</span>(x,y<span class="number">-1</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,first_num=<span class="number">0</span>,end_num=<span class="number">0</span>;<span class="comment">//层数 初始岛屿数量 末尾岛屿数量 </span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n); </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">1</span>;a&lt;=n;a++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> b=<span class="number">1</span>;b&lt;=n;b++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;maps[a][b]);</span><br><span class="line">				<span class="keyword">if</span>(maps[a][b]==<span class="string">&#x27;.&#x27;</span>||maps[a][b]==<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//先查找有多少个岛屿 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">1</span>;a&lt;=n;a++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> b=<span class="number">1</span>;b&lt;=n;b++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(maps[a][b]==<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">dfs1</span>(a,b);</span><br><span class="line">				first_num++;<span class="comment">//初始岛屿+1 </span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//再对整个岛屿进行变化</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">1</span>;a&lt;=n;a++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> b=<span class="number">1</span>;b&lt;=n;b++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(maps[a][b]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">dfs2</span>(a,b);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//最后查找剩余多少个岛屿 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">1</span>;a&lt;=n;a++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> b=<span class="number">1</span>;b&lt;=n;b++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(maps[a][b]==<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">dfs3</span>(a,b);</span><br><span class="line">				end_num++;<span class="comment">//最终岛屿+1 </span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;first_num-end_num;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构与算法</tag>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title>2017 蓝桥杯 日期问题</title>
    <url>/2020/08/28/20200828_2017%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%97%A5%E6%9C%9F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><strong>这是2017年蓝桥杯C语言省赛B组的第七题</strong></p>
<span id="more"></span>

<p><strong>题目描述</strong><br>小明正在整理一批历史文献。这些历史文献中出现了很多日期。<br>小明知道这些日期都在1960年1月1日至2059年12月31日。<br>令小明头疼的是，这些日期采用的格式非常不统一，有采用年&#x2F;月&#x2F;日的，有采用月&#x2F;日&#x2F;年的，还有采用日&#x2F;月&#x2F;年的。<br>更加麻烦的是，年份也都省略了前两位，使得文献上的一个日期，存在很多可能的日期与其对应。<br>比如02&#x2F;03&#x2F;04，可能是2002年03月04日、2004年02月03日或2004年03月02日。<br>给出一个文献上的日期，你能帮助小明判断有哪些可能的日期对其对应吗？</p>
<p><strong>输入</strong><br>一个日期，格式是”AA&#x2F;BB&#x2F;CC”。  (0 &lt;&#x3D; A, B, C &lt;&#x3D; 9)  </p>
<p><strong>输出</strong><br>输出若干个不相同的日期，每个日期一行，格式是”yyyy-MM-dd”。<br>多个日期按从早到晚排列。</p>
<p><strong>样例输入</strong><br>02&#x2F;03&#x2F;04</p>
<p><strong>样例输出</strong><br>2002-03-04<br>2004-02-03<br>2004-03-02</p>
<p><a href="http://oj.ecustacm.cn/problem.php?id=1328">OJ链接</a></p>
<p><strong>思路：</strong> </p>
<ul>
<li>本来刚看见这道题，我还觉得很简单。。。但是一写发现情况很复杂，需要判定的东西很多，果然好歹也是偏后面的题，不会太简单。</li>
<li>我的思路就是主函数进行接收数据，然后在主函数里数据排序后，利用一个judge函数进行判定日期是否合法，如果合法就输出。</li>
<li>judge函数判定主要为：<strong>月是否合理</strong>、根据月份判断<strong>日是否合理</strong>（首先要判断是不是30&#x2F;31天的月，如果是2月则要判定是不是闰年，随后看日期是否超限）。</li>
<li>随后需要注意的是，<strong>相同日期只用输出一次</strong>，所以在主函数里我们需要判定judge函数的传参是否相同，如果相同就说明是相同日期，输出一次即可。</li>
</ul>
<p><strong>AC代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">judge</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span><span class="comment">//判断是否合理 合理即输出 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(b&lt;<span class="number">1</span>||b&gt;<span class="number">12</span>)<span class="comment">//月超标 pass</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(c&lt;<span class="number">1</span>||c&gt;<span class="number">31</span>)<span class="comment">//日超标 pass </span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>((b==<span class="number">1</span>||b==<span class="number">3</span>||b==<span class="number">5</span>||b==<span class="number">7</span>||b==<span class="number">8</span>||b==<span class="number">10</span>||b==<span class="number">12</span>)&amp;&amp;c&gt;<span class="number">31</span>)<span class="comment">//如果是 1 3 5 7 8 10 12月 并且日期大于31 pass </span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>((b==<span class="number">4</span>||b==<span class="number">6</span>||b==<span class="number">9</span>||b==<span class="number">11</span>)&amp;&amp;c&gt;<span class="number">30</span>)<span class="comment">//如果是 4 6 9 11 月 并且日期大于30 pass </span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(b==<span class="number">2</span>)<span class="comment">//如果是2月就判断是不是闰年 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(a%<span class="number">400</span>==<span class="number">0</span>||(a%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;a%<span class="number">100</span>!=<span class="number">0</span>))<span class="comment">//是闰年</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(c&gt;<span class="number">29</span>)<span class="comment">//大于29天 pass </span></span><br><span class="line">				<span class="keyword">return</span>; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(c&gt;<span class="number">28</span>)<span class="comment">//大于28天 pass</span></span><br><span class="line">				<span class="keyword">return</span>; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d-%02d-%02d\n&quot;</span>,a,b,c);<span class="comment">//成功输出 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a,b,c,a1,c1;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d/%d/%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">	a1=a;</span><br><span class="line">	c1=c;</span><br><span class="line">	<span class="keyword">if</span>(a&lt;=<span class="number">59</span>)<span class="comment">//加100方便比较 </span></span><br><span class="line">		a1+=<span class="number">100</span>;</span><br><span class="line">	<span class="keyword">if</span>(c&lt;=<span class="number">59</span>)</span><br><span class="line">		c1+=<span class="number">100</span>;	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	三种情况 </span></span><br><span class="line"><span class="comment">	 a  b  c</span></span><br><span class="line"><span class="comment">	年 月 日 （1） </span></span><br><span class="line"><span class="comment">	月 日 年 （2) </span></span><br><span class="line"><span class="comment">	日 月 年  (3)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">if</span>(a1&lt;c1)<span class="comment">//a小于c的话  先输出（1） 再（2）（3） </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">judge</span>(<span class="number">1900</span>+a1,b,c);<span class="comment">//判断是否合理 合理即输出 </span></span><br><span class="line">		<span class="type">int</span> max_temp = <span class="built_in">max</span>(a,b);<span class="comment">//取b,c最大值和最小值 </span></span><br><span class="line">		<span class="type">int</span> min_temp = <span class="built_in">min</span>(a,b);</span><br><span class="line">		<span class="built_in">judge</span>(<span class="number">1900</span>+c1,min_temp,max_temp);<span class="comment">//按从小到大 输出（2）（3） </span></span><br><span class="line">		<span class="keyword">if</span>(max_temp!=min_temp)<span class="comment">//防止重复输出 </span></span><br><span class="line">			<span class="built_in">judge</span>(<span class="number">1900</span>+c1,max_temp,min_temp); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(a1==c1)<span class="comment">//只有一个年份 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(a==b)<span class="comment">//三数相等就只输出一次 </span></span><br><span class="line">			<span class="built_in">judge</span>(<span class="number">1900</span>+a1,b,c);</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//否则按顺序输出 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> max_temp = <span class="built_in">max</span>(a,b);<span class="comment">//取b,c最大值和最小值 </span></span><br><span class="line">			<span class="type">int</span> min_temp = <span class="built_in">min</span>(a,b);</span><br><span class="line">			<span class="built_in">judge</span>(<span class="number">1900</span>+a1,min_temp,max_temp);</span><br><span class="line">			<span class="built_in">judge</span>(<span class="number">1900</span>+c1,max_temp,min_temp); </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span><span class="comment">//先输出（2）（3）再（1） </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> max_temp = <span class="built_in">max</span>(a,b);<span class="comment">//取b,c最大值和最小值 </span></span><br><span class="line">		<span class="type">int</span> min_temp = <span class="built_in">min</span>(a,b);</span><br><span class="line">		<span class="built_in">judge</span>(<span class="number">1900</span>+c1,min_temp,max_temp);<span class="comment">//按从小到大 输出（2）（3） </span></span><br><span class="line">		<span class="keyword">if</span>(max_temp!=min_temp)<span class="comment">//防止重复输出</span></span><br><span class="line">			<span class="built_in">judge</span>(<span class="number">1900</span>+c1,max_temp,min_temp); </span><br><span class="line">		<span class="built_in">judge</span>(<span class="number">1900</span>+a1,b,c);<span class="comment">//判断是否合理 合理即输出 （1） </span></span><br><span class="line">	&#125; 	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构与算法</tag>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title>2016 蓝桥杯 剪邮票 dfs</title>
    <url>/2020/08/31/20200831_2016%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%89%AA%E9%82%AE%E7%A5%A8dfs/</url>
    <content><![CDATA[<p><strong>这是2016年蓝桥杯C语言省赛B组的第七题</strong></p>
<span id="more"></span>

<p><strong>题目：</strong><br>如下图, 有12张连在一起的12生肖的邮票。现在你要从中剪下5张来，要求必须是连着的。（仅仅连接一个角不算相连）<br><img src="/images/2020-08-31/1.jpg#pic_center" alt="图1"></p>
<p>比如，下面两张图中，粉红色所示部分就是合格的剪取。<br><img src="/images/2020-08-31/2.jpg#pic_center" alt="图2"></p>
<p>请你计算，一共有多少种不同的剪取方法。</p>
<p><strong>输出：</strong><br>请填写表示方案数目的整数。</p>
<p><a href="http://oj.ecustacm.cn/problem.php?id=1286">OJ链接</a></p>
<p><strong>思路：</strong> </p>
<ul>
<li>首先，我们将数组储存为<br>1   2   3   4<br>6  7   8   9<br>11 12 13 14<br>这样如果两数相减绝对值是5则是上下相邻关系，绝对值是1则是左右相邻关系。 </li>
<li> <img src="/images/2020-08-31/3.jpg#pic_center" alt="图3"><br> 通过对上图的观察我们可以发现，如果满足题意，则各邮票的相连邮票数量之和一定大于等于8，且每个邮票都有相连邮票。（上面两个图的相连数量之和都为8，如果剪12567的话相连数量就是9）按照这个规律我们就可以用双重循环来搜索答案了。</li>
<li>前面用5层循环来组合出所有可能，防止重复。</li>
</ul>
<p><strong>AC代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> temp[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>&#125;;</span><br><span class="line"><span class="type">int</span> shuzu[<span class="number">5</span>]; </span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1  2  3  4</span></span><br><span class="line"><span class="comment">6  7  8  9</span></span><br><span class="line"><span class="comment">11 12 13 14</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">judge</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;<span class="number">5</span>;now++)<span class="comment">//取前五个 看是否都相连 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> flag=<span class="number">0</span>;<span class="comment">//先假设不相连 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> now1=<span class="number">0</span>;now1&lt;<span class="number">5</span>;now1++)<span class="comment">//挨个判断 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(now==now1)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">abs</span>(shuzu[now1]-shuzu[now])==<span class="number">5</span>||<span class="built_in">abs</span>(shuzu[now1]-shuzu[now])==<span class="number">1</span>)<span class="comment">//上下相连 绝对值为5 或者 左右相连 绝对值为1 </span></span><br><span class="line">			&#123;</span><br><span class="line">				flag+=<span class="number">1</span>;<span class="comment">//相连点位+1 </span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag==<span class="number">0</span>)<span class="comment">//如果是孤立点 没有相连点位 就直接返回false  </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		count+=flag;<span class="comment">//加上连接数 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(count&lt;<span class="number">8</span>)<span class="comment">//如果连接数小于8 则说明5个点位没有相互相邻 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//printf(&quot;%d %d %d %d %d\n&quot;,shuzu[0],shuzu[1],shuzu[2],shuzu[3],shuzu[4]);</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">0</span>;a&lt;<span class="number">12</span>;a++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> b=a<span class="number">+1</span>;b&lt;<span class="number">12</span>;b++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> c=b<span class="number">+1</span>;c&lt;<span class="number">12</span>;c++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> d=c<span class="number">+1</span>;d&lt;<span class="number">12</span>;d++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">for</span>(<span class="type">int</span> e=d<span class="number">+1</span>;e&lt;<span class="number">12</span>;e++)</span><br><span class="line">					&#123;</span><br><span class="line">						shuzu[<span class="number">0</span>]=temp[a],shuzu[<span class="number">1</span>]=temp[b],shuzu[<span class="number">2</span>]=temp[c],shuzu[<span class="number">3</span>]=temp[d],shuzu[<span class="number">4</span>]=temp[e];</span><br><span class="line">						<span class="keyword">if</span>(<span class="built_in">judge</span>())</span><br><span class="line">						&#123;</span><br><span class="line">							ans++;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;	</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构与算法</tag>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title>c/c++算法 基础题 练手汇总</title>
    <url>/2020/09/02/20200902_c++%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E9%A2%98%E7%BB%83%E6%89%8B%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p><strong>因为是基础题所以都不算难，个人把碰见过的感觉比较好的练手基础题在这里做个汇总，方便查阅。</strong></p>
<span id="more"></span>

<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><ul>
<li>一般都是数据量比较小的简单题，难点在于对数据的判断处理。用循环直接对数据区间枚举随后进行判断即可。如果数据量较大，就优化判断条件或者找共性减少运算时间。</li>
</ul>
<h2 id="1-安全区"><a href="#1-安全区" class="headerlink" title="1.安全区"></a>1.安全区</h2><p><strong>题目描述</strong><br>在一个n<em>n的网格图上有m个探测器，第i个探测器位于(xi,yi)位置，探测半径为ri。<br>求出n</em>n个点中有多少个是安全的点，即未被探测的点。</p>
<p><strong>输入</strong><br>第一行为两个整数n,m(1&lt;&#x3D;n&lt;&#x3D;100,1&lt;&#x3D;m&lt;&#x3D;n*n)<br>接下来m行每行3个整数表示xi,yi,ri（1&lt;&#x3D;xi,yi,ri&lt;&#x3D;n）</p>
<p><strong>输出</strong><br>输出一个整数表示答案</p>
<p><strong>样例输入</strong><br>5 2<br>3 3 1<br>4 2 1</p>
<p><strong>样例输出</strong><br>17</p>
<p><a href="http://oj.ecustacm.cn/problem.php?id=1078">OJ链接</a></p>
<p><strong>思路：</strong> 重点是半径判断，我是用<strong>sqrt((x-x1) * (x-x1) + (y-y1) * (y-y1)) &gt; r</strong> 来判断是否在检测半径内，同时用二维数组来储存是否能被探测到。</p>
<p><strong>AC代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> mymap[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> r,<span class="type">int</span> n)</span><span class="comment">//中心点 x y 探测半径 r 地图总长 n</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> a=x-r;a&lt;=x+r;a++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(a&lt;<span class="number">1</span>||a&gt;n)<span class="comment">//x超界</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> b=y-r;b&lt;=y+r;b++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(b&lt;<span class="number">1</span>||b&gt;n)<span class="comment">//y超界</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">sqrt</span>((x-a)*(x-a)+(y-b)*(y-b))&gt;r)<span class="comment">//不在半径内</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="comment">//printf(&quot;%lf %d\n&quot;,sqrt((x-a)*(x-a)+(y-b)*(y-b)),r);</span></span><br><span class="line">			<span class="keyword">if</span>(!mymap[a][b])</span><br><span class="line">				mymap[a][b]=<span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(mymap,<span class="literal">false</span>,<span class="built_in">sizeof</span>(mymap));</span><br><span class="line">	<span class="type">int</span> n,m,xi,yi,ri,ans=<span class="number">0</span>;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="comment">/*for(int a=1;a&lt;=n;a++)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		for(int b=1;b&lt;=n;b++)</span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">			printf(&quot;%d &quot;,mymap[a][b]);</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		printf(&quot;\n&quot;);</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> temp=<span class="number">0</span>;temp&lt;m;temp++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;xi&gt;&gt;yi&gt;&gt;ri;</span><br><span class="line">		<span class="built_in">func</span>(xi,yi,ri,n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">1</span>;a&lt;=n;a++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> b=<span class="number">1</span>;b&lt;=n;b++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//printf(&quot;%d &quot;,mymap[a][b]);</span></span><br><span class="line">			<span class="keyword">if</span>(mymap[a][b]==<span class="literal">false</span>)</span><br><span class="line">				ans++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//printf(&quot;\n&quot;);</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="2-统计方形"><a href="#2-统计方形" class="headerlink" title="2.统计方形"></a>2.统计方形</h2><p><strong>题目描述</strong><br>有一个n*m方格的棋盘，求其方格包含多少正方形、长方形（此处长方形不包含正方形）</p>
<p><strong>输入</strong><br>输入存在多组测试数据。每组测试数据输入两个整数n,m，数字不超过5000</p>
<p><strong>输出</strong><br>对于每组数据输出一行包含两个整数，分别表示正方形数目和长方形数目</p>
<p><strong>样例输入</strong><br>2 3</p>
<p><strong>样例输出</strong><br>8 10</p>
<p><strong>思路：</strong> 就是两层循环，代表当前图形的长和宽，长宽一样就是正方形，不一样就是长方形。然后求出这一行能有多少个这种图形(1+(m-b))，再求这一列有多少种这种图形(1+(n-a))，两者相乘就是这个图里有多少种这种图形。然后加到总数里，等循环跑完就是答案。</p>
<p><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,m;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> ans1=<span class="number">0</span>,ans2=<span class="number">0</span>;<span class="comment">//ans1=正方形 ans2=长方形 </span></span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">1</span>;a&lt;=n;a++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> b=<span class="number">1</span>;b&lt;=m;b++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a==b)</span><br><span class="line">			&#123;</span><br><span class="line">				ans1+=(<span class="number">1</span>+(n-a))*(<span class="number">1</span>+(m-a));	</span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				ans2+=(<span class="number">1</span>+(n-a))*(<span class="number">1</span>+(m-b));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ans2;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>但是这样复杂度会比较高，可能会超时，所以有第二种求法。先求出总的矩形个数，再用一层循环求出正方形个数，总的减去正方形的就是长方形的。</li>
</ul>
<p><strong>AC代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*对于一个n*m的棋盘，共有矩形 (m+m-1+m-2+...+1)*(n+n-1+n-2+...+1)</span></span><br><span class="line"><span class="comment">    即[m*(m+1)/2]*[n*(n+1)/2]个，这一步可知用前一个式子循环道加，也可版用后一个式子直接算；</span></span><br><span class="line"><span class="comment">    共有正方形（假设m&gt;n) m*n+(m-1)*(n-1)+...+(m-n+1)*1 个，这步用循环做就行；</span></span><br><span class="line"><span class="comment">    长方形就用 矩形权数 减去 正方形数 就行了。*/</span></span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m)!=EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">long</span> <span class="type">long</span> sum1=<span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="built_in">min</span>(n,m);i++)</span><br><span class="line">	    &#123;</span><br><span class="line">	        sum1+=(n-i<span class="number">+1</span>)*(m-i<span class="number">+1</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,sum1);</span><br><span class="line">	    <span class="type">long</span> <span class="type">long</span> sum2=<span class="number">1LL</span>*n*(n<span class="number">+1</span>)/<span class="number">2</span>*<span class="number">1LL</span>*m*(m<span class="number">+1</span>)/<span class="number">2</span>;<span class="comment">//1</span></span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,sum2-sum1);</span><br><span class="line">	&#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-连续自然数和（尺取法）"><a href="#3-连续自然数和（尺取法）" class="headerlink" title="3.连续自然数和（尺取法）"></a>3.连续自然数和（尺取法）</h2><p><strong>题目</strong><br>对于给定自然数N，求出存在多少个连续自然数段，长度至少为2，使得这些连续的自然数段之和为N。</p>
<p><strong>输入</strong><br>输入有若干行，每行一个正整数n。(1&lt;&#x3D;n&lt;&#x3D;2000000)</p>
<p><strong>输出</strong><br>对于每组测试数据输出第一个数字表示答案</p>
<p><strong>样例输入</strong><br>9<br>10000</p>
<p><strong>样例输出</strong><br>2<br>4</p>
<p><strong>思路：</strong> 可以用for循环暴力循环出来，但是我下面是用的尺取法，来减少复杂度。</p>
<p><strong>AC代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> ans=<span class="number">0</span>,temp=<span class="number">0</span>,f=<span class="number">1</span>,e=<span class="number">1</span>;<span class="comment">//答案个数 中间值 头 尾</span></span><br><span class="line">		<span class="keyword">while</span>(n!=<span class="number">0</span>)<span class="comment">//尺取</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(temp&lt;n&amp;&amp;e&lt;n)</span><br><span class="line">			&#123;</span><br><span class="line">				temp+=e;</span><br><span class="line">				e++; </span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(temp&lt;n)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(temp==n&amp;&amp;e-f&gt;=<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				ans++;</span><br><span class="line">			&#125;</span><br><span class="line">			temp-=f;</span><br><span class="line">			f++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="4-蓝桥杯-数字分组"><a href="#4-蓝桥杯-数字分组" class="headerlink" title="4.蓝桥杯 数字分组"></a>4.蓝桥杯 数字分组</h2><p><strong>问题描述</strong><br>　　输入任意10个浮点数，根据它们的聚集程度划分为3组，输出每一组的平均值。<br>　　提供老师上课讲的一种思路：将10个数字进行在数轴上排序，然后计算每两个点间的距离，在所有的距离中选取两个最大距离处断开，这样就把10个数字分为了3组。<br>　　本题难度较大，如果深入讨论会比较复杂，大家可以只考虑如下面样例所示的分组情况非常简单的情况，只要简单情况能够成功计算，本题就能得分。<br>　　另外，本题内容有些超前，推荐大家自学一下数组那一章中第一节一维数组，然后使用一维数组来做。排序算法可以参考trustie平台上传的冒泡排序法参考资料。</p>
<p><strong>输入格式</strong><br>　　十个待输入的浮点数，使用空格隔开</p>
<p><strong>输出格式</strong><br>　　三组数的平均数，每输出一个需要换行</p>
<p><strong>样例输入</strong><br>一个满足题目要求的输入范例。<br>例1：<br>50.4 51.3 52.3 9.5 10.4 11.6 19.1 20.8 21.9 49.6<br>例2：<br>8.6 7.4 3.5 17.9 19.1 18.5 37.6 40.4 38.5 40.0</p>
<p><strong>样例输出</strong><br>与上面的样例输入对应的输出。<br>例1：<br>10.5<br>20.6<br>50.9<br>例2:<br>6.5<br>18.5<br>39.125</p>
<p><strong>思路：</strong> 直接循环枚举检测间隔即可。</p>
<p><strong>AC代码：</strong> <a href="http://lx.lanqiao.cn/problem.page?gpid=T774">OJ链接</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> shuzu[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">double</span> max1=<span class="number">0</span>,max2=<span class="number">0</span>,m1,m2;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">0</span>;a&lt;<span class="number">10</span>;a++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;shuzu[a]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(shuzu,shuzu<span class="number">+10</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">0</span>;a&lt;<span class="number">9</span>;a++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">double</span> temp=shuzu[a<span class="number">+1</span>]-shuzu[a];</span><br><span class="line">		<span class="keyword">if</span>(temp&gt;max1)</span><br><span class="line">		&#123;</span><br><span class="line">			max2=max1;</span><br><span class="line">			m2=m1;</span><br><span class="line">			max1=temp;</span><br><span class="line">			m1=a;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(temp&gt;max2)</span><br><span class="line">		&#123;</span><br><span class="line">			max2=temp;</span><br><span class="line">			m2=a;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">double</span> temp=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">0</span>;a&lt;=<span class="built_in">min</span>(m1,m2);a++)</span><br><span class="line">	&#123;</span><br><span class="line">		temp+=shuzu[a];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%g\n&quot;</span>,temp/(<span class="built_in">min</span>(m1,m2)<span class="number">+1</span>));</span><br><span class="line">	temp=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> a=<span class="built_in">min</span>(m1,m2)<span class="number">+1</span>;a&lt;=<span class="built_in">max</span>(m1,m2);a++)</span><br><span class="line">	&#123;</span><br><span class="line">		temp+=shuzu[a];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%g\n&quot;</span>,temp/(<span class="built_in">max</span>(m1,m2)-<span class="built_in">min</span>(m1,m2)));</span><br><span class="line">	temp=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> a=<span class="built_in">max</span>(m1,m2)<span class="number">+1</span>;a&lt;=<span class="number">9</span>;a++)</span><br><span class="line">	&#123;</span><br><span class="line">		temp+=shuzu[a];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%g\n&quot;</span>,temp/(<span class="number">9</span>-<span class="built_in">max</span>(m1,m2)));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 蓝桥杯 C/C++实现 7月C组省赛</title>
    <url>/2020/09/03/20200903_2020%E8%93%9D%E6%A1%A5%E6%9D%AFC-C++%E5%AE%9E%E7%8E%B07%E6%9C%88C%E7%BB%84%E7%9C%81%E8%B5%9B/</url>
    <content><![CDATA[<p><strong>2020蓝桥杯 C&#x2F;C++ 7月C组省赛原题 &amp; 题解</strong></p>
<span id="more"></span>

<h1 id="试题-A-指数计算"><a href="#试题-A-指数计算" class="headerlink" title="试题 A: 指数计算"></a>试题 A: 指数计算</h1><p>本题总分：5 分<br><strong>问题：</strong><br>请计算：7 ^ 2020 mod 1921，其中 A mod B 表示 A 除以 B 的余数。</p>
<p><strong>思路：</strong> 快速幂。</p>
<p><strong>答案：</strong> <strong>480</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">ksm</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(b==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> a*<span class="built_in">ksm</span>(a,b<span class="number">-1</span>,c)%c;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">long</span> <span class="type">long</span> ans=<span class="built_in">ksm</span>(a,b/<span class="number">2</span>,c)%c;</span><br><span class="line">		<span class="keyword">return</span> ans*ans%c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,<span class="built_in">ksm</span>(<span class="number">7</span>,<span class="number">2020</span>,<span class="number">1921</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="试题-B-解密"><a href="#试题-B-解密" class="headerlink" title="试题 B: 解密"></a>试题 B: 解密</h1><p>本题总分：5 分<br><strong>问题:</strong><br>小明设计了一种文章加密的方法：对于每个字母 c，将它变成某个另外的字符 Tc。下表给出了字符变换的规则：<br><img src="/images/2020-09-03/1.jpg#pic_center" alt="rt"><br>例如，将字符串 YeRi 加密可得字符串 EaFn。小明有一个随机的字符串，加密后为<strong>EaFnjISplhFviDhwFbEjRjfIBBkRyY</strong>(由 30 个大小写英文字母组成，不包含换行符），请问原字符串是多少？<br>（如果你把以上字符串和表格复制到文本文件中，请务必检查复制的内容是否与文档中的一致。在试题目录下有一个文件 str.txt，第一行为上面的字符串，后面 52 行依次为表格中的内容。）</p>
<p><strong>思路：</strong> 因为我没有文本形式的这个对照表。。。所以用的最笨的方法。</p>
<p><strong>答案：</strong> <strong>YeRikGSunlRzgDlvRwYkXkrGWWhXaA</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string a=<span class="string">&quot;EaFnjISplhFviDhwFbEjRjfIBBkRyY&quot;</span>;</span><br><span class="line">	<span class="comment">//cin&gt;&gt;a;     //EaFnjISplhFviDhwFbEjRjfIBBkRyY</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;a.<span class="built_in">size</span>();now++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">switch</span>(a[now])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;e&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;w&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;f&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;d&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;y&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;r&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;o&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;l&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;g&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;j&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;k&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;k&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;h&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;n&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;c&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;i&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;p&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;u&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;q&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;m&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;x&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;s&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;j&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;q&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;z&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;v&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;b&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;y&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;a&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;z&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;t&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;E&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;W&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;F&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;D&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;Y&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;F&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;R&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;G&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;O&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;H&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;L&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;G&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;J&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;K&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;K&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;H&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;N&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;C&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;N&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;I&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;O&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;P&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;P&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;U&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;Q&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;M&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;R&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;X&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;S&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;J&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;U&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;Q&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;Z&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;W&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;V&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;B&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;Y&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;A&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;Z&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;T&#x27;</span>;<span class="keyword">break</span>;		</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="试题-C-跑步训练"><a href="#试题-C-跑步训练" class="headerlink" title="试题 C: 跑步训练"></a>试题 C: 跑步训练</h1><p>本题总分：10 分<br><strong>问题：</strong><br>小明要做一个跑步训练。<br>初始时，小明充满体力，体力值计为 10000。如果小明跑步，每分钟损耗600 的体力。如果小明休息，每分钟增加 300 的体力。体力的损耗和增加都是均匀变化的。<br>小明打算跑一分钟、休息一分钟、再跑一分钟、再休息一分钟……如此循环。如果某个时刻小明的体力到达 0，他就停止锻炼。<br>请问小明在多久后停止锻炼。为了使答案为整数，请以秒为单位输出答案。<br>答案中只填写数，不填写单位。</p>
<p><strong>思路：</strong> 简单循环即可。</p>
<p><strong>答案：</strong> <strong>3880</strong> </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> first=<span class="number">10000</span>,ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(first)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(first&gt;=<span class="number">600</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			first-=<span class="number">600</span>;</span><br><span class="line">			ans+=<span class="number">60</span>;</span><br><span class="line">			first+=<span class="number">300</span>;</span><br><span class="line">			ans+=<span class="number">60</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			ans+=first/<span class="number">10</span>;</span><br><span class="line">			first=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="试题-D-合并检测"><a href="#试题-D-合并检测" class="headerlink" title="试题 D: 合并检测"></a>试题 D: 合并检测</h1><p>本题总分：10 分<br><strong>问题：</strong><br>新冠疫情由新冠病毒引起，最近在 A 国蔓延，为了尽快控制疫情，A 国准 备给大量民众进病毒核酸检测。<br>然而，用于检测的试剂盒紧缺。 为了解决这一困难，科学家想了一个办法：合并检测。即将从多个人（k 个）采集的标本放到同一个试剂盒中进行检测。如果结果为阴性，则说明这 k 个人都是阴性，用一个试剂盒完成了 k 个人的检测。如果结果为阳性，则说明 至少有一个人为阳性，需要将这 k 个人的样本全部重新独立检测（从理论上看， 如果检测前 k−1 个人都是阴性可以推断出第 k 个人是阳性，但是在实际操作中 不会利用此推断，而是将 k 个人独立检测），加上最开始的合并检测，一共使用 了 k + 1 个试剂盒完成了 k 个人的检测。<br> A 国估计被测的民众的感染率大概是 **1%**，呈均匀分布。请问 k 取多少能 最节省试剂盒？</p>
<p><strong>思路：</strong> 假设有一共检测m个人，则第一批检测需要m&#x2F;k个试剂盒（向上取整）。由于感染率为1%，且均匀分布，则有0.01 * m个试剂盒会有阳性反应。这时进行第二批挨个检测，检测盒数量即为0.01 * m * k个。<br>则总需求盒子数即为<strong>m&#x2F;k+0.01 * m * k</strong>个（m&#x2F;k向上取整）。</p>
<p><strong>答案：</strong> 10</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> min_=<span class="number">999</span>,min_k=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> m=<span class="number">100</span>;<span class="comment">//假设初始人有100 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">100</span>;k++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> need=m/k<span class="number">+0.01</span>*m*k;</span><br><span class="line">		<span class="keyword">if</span>(m%k!=<span class="number">0</span>)</span><br><span class="line">			need++;</span><br><span class="line">		<span class="keyword">if</span>(need&lt;min_)</span><br><span class="line">		&#123;</span><br><span class="line">			min_=need;</span><br><span class="line">			min_k=k;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;min_k;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="试题-E-REPEAT-程序"><a href="#试题-E-REPEAT-程序" class="headerlink" title="试题 E: REPEAT 程序"></a>试题 E: REPEAT 程序</h1><p>本题总分：15 分<br><strong>问题：</strong><br>附件 prog.txt 中是一个用某种语言写的程序。<br><a href="https://wwa.lanzous.com/i6APvex4r3g">prog.txt 附件下载地址</a><br>其中 REPEAT k 表示一个次数为 k 的循环。循环控制的范围由缩进表达，从次行开始连续的缩进比该行多的（前面的空白更长的）为循环包含的内容。<br>例如如下片段：<br><img src="/images/2020-09-03/2.jpg#pic_center" alt="rt"></p>
<p>A &#x3D; A + 4 所在的行到 A &#x3D; A + 8 所在的行都在第一行的循环两次中。<br>REPEAT 6: 所在的行到 A &#x3D; A + 7 所在的行都在 REPEAT 5: 循环中。<br>A &#x3D; A + 5 实际总共的循环次数是 2 × 5 × 6 &#x3D; 60 次。<br>请问该程序执行完毕之后，A 的值是多少？</p>
<p><strong>思路：</strong> 可以建立一个栈来存放循环的信息，一个变量times存放当前行数被执行的次数。通过对文本的观察我们发现，可以通过每一行前面的空格数量来判断当前行数的“等级”，4个空格代表一个等级。如果当前行等级比上一层循环的等级低则说明退出了上一层循环，对栈和times进行改变即可。随后我们发现整个文本里面，所有数字都为单位数，所以我们直接用循环找到一个数字即可提取出该行的有效数字。</p>
<p><strong>答案：</strong> 241830</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string string_;</span><br><span class="line">	stack&lt;<span class="type">int</span>&gt;stack_; </span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;prog.txt&quot;</span>, <span class="string">&quot;rb&quot;</span>, stdin);</span><br><span class="line">	<span class="built_in">getline</span>(cin, string_);<span class="comment">//读第一行 A=0 </span></span><br><span class="line">	<span class="type">int</span> A=<span class="number">0</span>,times=<span class="number">1</span>,old_counts=<span class="number">0</span>;<span class="comment">//A=0,当前倍数，老的层数 </span></span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">getline</span>(cin, string_))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> counts=<span class="number">0</span>;<span class="comment">//当前的层数，</span></span><br><span class="line">		<span class="keyword">for</span>(counts=<span class="number">0</span>;counts&lt;string_.<span class="built_in">size</span>();counts++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//记录空格数 4个空格是一层 </span></span><br><span class="line">			<span class="keyword">if</span>(string_[counts]!=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		counts/=<span class="number">4</span>;<span class="comment">//这句话的层数 </span></span><br><span class="line">		<span class="keyword">while</span>(counts&lt;old_counts)<span class="comment">//新层数低 则退出一层循环 pop </span></span><br><span class="line">		&#123;</span><br><span class="line">			times/=stack_.<span class="built_in">top</span>();</span><br><span class="line">			stack_.<span class="built_in">pop</span>();</span><br><span class="line">			old_counts--; </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">if</span>(string_[counts*<span class="number">4</span>]==<span class="string">&#x27;R&#x27;</span>)<span class="comment">//R开头就是新增循环</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> now=counts*<span class="number">4</span>;now&lt;string_.<span class="built_in">size</span>();now++)<span class="comment">//找到数字 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(string_[now]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;string_[now]&lt;=<span class="string">&#x27;9&#x27;</span>)<span class="comment">//如果是数字 </span></span><br><span class="line">				&#123;</span><br><span class="line">					stack_.<span class="built_in">push</span>(string_[now]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">					times*=string_[now]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">					old_counts++;</span><br><span class="line">					<span class="keyword">break</span>; </span><br><span class="line">				&#125; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span><span class="comment">//否则就是执行计算操作 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> now=counts*<span class="number">4</span>;now&lt;string_.<span class="built_in">size</span>();now++)<span class="comment">//找到数字 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(string_[now]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;string_[now]&lt;=<span class="string">&#x27;9&#x27;</span>)<span class="comment">//如果是数字 </span></span><br><span class="line">				&#123;</span><br><span class="line">					A+=(string_[now]-<span class="string">&#x27;0&#x27;</span>)*times;</span><br><span class="line">					<span class="keyword">break</span>; </span><br><span class="line">				&#125; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;A; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="试题-F-分类计数"><a href="#试题-F-分类计数" class="headerlink" title="试题 F: 分类计数"></a>试题 F: 分类计数</h1><p>时间限制: 1.0s 内存限制: 512.0MB 本题总分：15 分<br><strong>问题：</strong><br>输入一个字符串，请输出这个字符串包含多少个大写字母，多少个小写字母，多少个数字。</p>
<p><strong>输入：</strong><br>输入一行包含一个字符串。</p>
<p><strong>输出：</strong><br>输出三行，每行一个整数，分别表示大写字母、小写字母和数字的个数。</p>
<p><strong>样例输入：</strong><br>1+a&#x3D;Aab</p>
<p><strong>样例输出：</strong><br>1<br>3<br>1</p>
<p><strong>思路：</strong> 简单循环。</p>
<p><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string string_;</span><br><span class="line">	<span class="built_in">getline</span>(cin,string_);</span><br><span class="line">	<span class="type">int</span> ans_1=<span class="number">0</span>,ans_2=<span class="number">0</span>,ans_3=<span class="number">0</span>;<span class="comment">//大写，小写，数字</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> now=<span class="number">0</span>;now&lt;string_.<span class="built_in">size</span>();now++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(string_[now]&lt;=<span class="string">&#x27;Z&#x27;</span>&amp;&amp;string_[now]&gt;=<span class="string">&#x27;A&#x27;</span>) </span><br><span class="line">		&#123;</span><br><span class="line">			ans_1++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(string_[now]&lt;=<span class="string">&#x27;z&#x27;</span>&amp;&amp;string_[now]&gt;=<span class="string">&#x27;a&#x27;</span>) </span><br><span class="line">		&#123;</span><br><span class="line">			ans_2++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(string_[now]&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;string_[now]&gt;=<span class="string">&#x27;0&#x27;</span>) </span><br><span class="line">		&#123;</span><br><span class="line">			ans_3++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n%d\n%d\n&quot;</span>,ans_1,ans_2,ans_3);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="试题-G-整除序列"><a href="#试题-G-整除序列" class="headerlink" title="试题 G: 整除序列"></a>试题 G: 整除序列</h1><p>时间限制: 1.0s 内存限制: 512.0MB 本题总分：20 分<br><strong>问题：</strong><br>有一个序列，序列的第一个数是 n，后面的每个数是前一个数整除 2，请输出这个序列中值为正数的项。</p>
<p><strong>输入：</strong><br>输入一行包含一个整数 n。</p>
<p><strong>输出：</strong><br>输出一行，包含多个整数，相邻的整数之间用一个空格分隔，表示答案。</p>
<p><strong>样例输入：</strong><br>20</p>
<p><strong>样例输出：</strong><br>20 10 5 2 1</p>
<p><strong>评测用例规模与约定：</strong><br>对于 80% 的评测用例，1 ≤ n ≤ 10的9次方。<br>对于所有评测用例，1 ≤ n ≤ 10的18次方。</p>
<p><strong>思路：</strong> 简单循环即可。</p>
<p><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">while</span>(n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,n);</span><br><span class="line">		n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="试题-H-走方格"><a href="#试题-H-走方格" class="headerlink" title="试题 H: 走方格"></a>试题 H: 走方格</h1><p>时间限制: 1.0s 内存限制: 512.0MB 本题总分：20 分<br><strong>问题：</strong><br>在平面上有一些二维的点阵。这些点的编号就像二维数组的编号一样，从上到下依次为第 1 至第 n 行，从左到右依次为第 1 至第 m 列，每一个点可以用行号和列号来表示。现在有个人站在第 1 行第 1 列，要走到第 n 行第 m 列。只能向右或者向下走。<br><strong>注意</strong>，如果行号和列数都是偶数，不能走入这一格中。问有多少种方案。</p>
<p><strong>输入：</strong><br>输入一行包含两个整数 n, m。</p>
<p><strong>输出：</strong><br>输出一个整数，表示答案。</p>
<p><strong>样例输入1：</strong><br>3 4</p>
<p><strong>样例输出1：</strong><br>2</p>
<p><strong>样例输入2：</strong><br>6 6</p>
<p><strong>样例输出2：</strong><br>0</p>
<p><strong>评测用例规模与约定：</strong><br>对于所有评测用例，1 ≤ n ≤ 30, 1 ≤ m ≤ 30。</p>
<p><strong>思路：</strong> dfs暴力搜索的话，当n&#x3D;29，m&#x3D;30的时候应该会超时。我们可以用dp把结果都记录下来然后直接输出。记得行号列号都是偶数的时候跳过，因为不能走入这种方格。</p>
<p><strong>代码：</strong></p>
<ul>
<li>dfs写法<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fx[<span class="number">2</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;,ans=<span class="number">0</span>;<span class="comment">//右/下 答案 </span></span><br><span class="line"><span class="type">int</span> n,m,a1,b1;<span class="comment">//n,m </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a==n&amp;&amp;b==m)</span><br><span class="line">	&#123;</span><br><span class="line">		ans++;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;<span class="number">2</span>;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		a1=a+fx[now][<span class="number">0</span>];</span><br><span class="line">		b1=b+fx[now][<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(a1&gt;n||b1&gt;m) </span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(!(a1&amp;<span class="number">1</span>)&amp;&amp;!(b1&amp;<span class="number">1</span>)) </span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(a1,b1); </span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">if</span>(!(n&amp;<span class="number">1</span>)&amp;&amp;!(m&amp;<span class="number">1</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
<li>dp写法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> dp[<span class="number">31</span>][<span class="number">31</span>];<span class="comment">//dp</span></span><br><span class="line">	<span class="type">int</span> n,m;<span class="comment">//n,m </span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">	dp[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1</span>;now&lt;=<span class="number">30</span>;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> now1=<span class="number">1</span>;now1&lt;=<span class="number">30</span>;now1++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!(now&amp;<span class="number">1</span>)&amp;&amp;!(now1&amp;<span class="number">1</span>))<span class="comment">//都是偶数就跳过 </span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(now<span class="number">-1</span>&gt;=<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[now][now1]+=dp[now<span class="number">-1</span>][now1];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(now1<span class="number">-1</span>&gt;=<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[now][now1]+=dp[now][now1<span class="number">-1</span>];</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*for(int now=1;now&lt;=30;now++)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		for(int now1=1;now1&lt;=30;now1++)</span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">			printf(&quot;%d &quot;,dp[now][now1]);</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		printf(&quot;\n&quot;);</span></span><br><span class="line"><span class="comment">	&#125;*/</span> </span><br><span class="line">	cout&lt;&lt;dp[n][m];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h1 id="试题-I-字符串编码"><a href="#试题-I-字符串编码" class="headerlink" title="试题 I: 字符串编码"></a>试题 I: 字符串编码</h1><p>时间限制: 1.0s 内存限制: 512.0MB 本题总分：25 分<br><strong>问题：</strong><br>小明发明了一种给由全大写字母组成的字符串编码的方法。对于每一个大写字母，小明将它转换成它在 26 个英文字母中序号，即 A → 1, B → 2, … Z →26。<br>这样一个字符串就能被转化成一个数字序列：<br>比如 ABCXYZ → 123242526。<br>现在给定一个转换后的数字序列，小明想还原出原本的字符串。当然这样的还原有可能存在多个符合条件的字符串。小明希望找出其中字典序最大的字符串。</p>
<p><strong>输入：</strong><br>一个数字序列。</p>
<p><strong>输出：</strong><br>一个只包含大写字母的字符串，代表答案</p>
<p><strong>样例输入：</strong><br>123242526</p>
<p><strong>样例输出：</strong><br>LCXYZ</p>
<p><strong>评测用例规模与约定</strong><br>对于 20% 的评测用例，输入的长度不超过 20。<br>对于所有评测用例，输入的长度不超过 200000。</p>
<p><strong>思路：</strong> 多条件判定，连着两个数和大于26的单个输出，后数第两个值为0的单个输出……大概要点好像就这么多，欢迎补充。</p>
<p><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string string_;</span><br><span class="line">	<span class="built_in">getline</span>(cin,string_);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;string_.<span class="built_in">size</span>();)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(string_[now]==<span class="string">&#x27;1&#x27;</span>)<span class="comment">//开头为1 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(now<span class="number">+2</span>&lt;string_.<span class="built_in">size</span>())<span class="comment">//后两位有数 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(string_[now<span class="number">+2</span>]!=<span class="string">&#x27;0&#x27;</span>)<span class="comment">//后第两位不是0 </span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,(string_[now]-<span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span>+string_[now<span class="number">+1</span>]-<span class="string">&#x27;0&#x27;</span>+<span class="string">&#x27;A&#x27;</span><span class="number">-1</span>);</span><br><span class="line">					now+=<span class="number">2</span>;<span class="comment">//后移两位 </span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,string_[now]-<span class="string">&#x27;0&#x27;</span>+<span class="string">&#x27;A&#x27;</span><span class="number">-1</span>);</span><br><span class="line">					now++;<span class="comment">//后移一位 </span></span><br><span class="line">				&#125; </span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(now<span class="number">+1</span>&lt;string_.<span class="built_in">size</span>())<span class="comment">//后一位有数 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,(string_[now]-<span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span>+string_[now<span class="number">+1</span>]-<span class="string">&#x27;0&#x27;</span>+<span class="string">&#x27;A&#x27;</span><span class="number">-1</span>);</span><br><span class="line">				now+=<span class="number">2</span>;<span class="comment">//后移两位 </span></span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">else</span><span class="comment">//最后一位直接输出 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,string_[now]-<span class="string">&#x27;0&#x27;</span>+<span class="string">&#x27;A&#x27;</span><span class="number">-1</span>);</span><br><span class="line">				now++;<span class="comment">//后移一位 </span></span><br><span class="line">			&#125; </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(string_[now]==<span class="string">&#x27;2&#x27;</span>)<span class="comment">//开头为2 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(now<span class="number">+2</span>&lt;string_.<span class="built_in">size</span>())<span class="comment">//后两位有数 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(string_[now<span class="number">+2</span>]!=<span class="string">&#x27;0&#x27;</span>)<span class="comment">//后第两位不是0 </span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(string_[now<span class="number">+1</span>]&lt;=<span class="string">&#x27;6&#x27;</span>)<span class="comment">//小于26 </span></span><br><span class="line">					&#123;</span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,(string_[now]-<span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span>+string_[now<span class="number">+1</span>]-<span class="string">&#x27;0&#x27;</span>+<span class="string">&#x27;A&#x27;</span><span class="number">-1</span>);</span><br><span class="line">						now+=<span class="number">2</span>;<span class="comment">//后移两位 </span></span><br><span class="line">					&#125; </span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">					&#123;</span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,string_[now]-<span class="string">&#x27;0&#x27;</span>+<span class="string">&#x27;A&#x27;</span><span class="number">-1</span>);</span><br><span class="line">						now++;<span class="comment">//后移一位 </span></span><br><span class="line">					&#125; </span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,string_[now]-<span class="string">&#x27;0&#x27;</span>+<span class="string">&#x27;A&#x27;</span><span class="number">-1</span>);</span><br><span class="line">					now++;<span class="comment">//后移一位 </span></span><br><span class="line">				&#125; </span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(now<span class="number">+1</span>&lt;string_.<span class="built_in">size</span>())<span class="comment">//后一位有数 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(string_[now<span class="number">+1</span>]&lt;=<span class="string">&#x27;6&#x27;</span>)<span class="comment">//小于26 </span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,(string_[now]-<span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span>+string_[now<span class="number">+1</span>]-<span class="string">&#x27;0&#x27;</span>+<span class="string">&#x27;A&#x27;</span><span class="number">-1</span>);</span><br><span class="line">					now+=<span class="number">2</span>;<span class="comment">//后移两位 </span></span><br><span class="line">				&#125; </span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,string_[now]-<span class="string">&#x27;0&#x27;</span>+<span class="string">&#x27;A&#x27;</span><span class="number">-1</span>);</span><br><span class="line">					now++;<span class="comment">//后移一位 </span></span><br><span class="line">				&#125; </span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">else</span><span class="comment">//最后一位直接输出 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,string_[now]-<span class="string">&#x27;0&#x27;</span>+<span class="string">&#x27;A&#x27;</span><span class="number">-1</span>);</span><br><span class="line">				now++;<span class="comment">//后移一位 </span></span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//其余直接输出 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,string_[now]-<span class="string">&#x27;0&#x27;</span>+<span class="string">&#x27;A&#x27;</span><span class="number">-1</span>);</span><br><span class="line">			now++;<span class="comment">//后移一位 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="试题-J-整数小拼接"><a href="#试题-J-整数小拼接" class="headerlink" title="试题 J: 整数小拼接"></a>试题 J: 整数小拼接</h1><p>时间限制: 1.0s 内存限制: 512.0MB 本题总分：25 分<br><strong>问题：</strong><br>给定义个长度为 n 的数组 A1, A2, · · · , An。你可以从中选出两个数 Ai 和 Aj (i不等于 j)，然后将 Ai 和 Aj 一前一后拼成一个新的整数。例如 12 和 345 可以拼成 12345 或 34512 。注意交换 Ai 和 Aj 的顺序总是被视为 2 种拼法，即便是 Ai &#x3D; Aj 时。请你计算有多少种拼法满足拼出的整数小于等于 K。</p>
<p><strong>输入：</strong><br>第一行包含 2 个整数 n 和 K。<br>第二行包含 n 个整数 A1, A2, · · · , An。</p>
<p><strong>输出：</strong><br>一个整数代表答案。</p>
<p><strong>样例输入：</strong><br>4 33<br>1 2 3 4</p>
<p><strong>样例输出：</strong><br>8</p>
<p><strong>评测用例规模与约定：</strong><br>对于 30% 的评测用例，1 ≤ N ≤ 1000, 1 ≤ K ≤ 10的8次方, 1 ≤ Ai ≤ 10的四次方。<br>对于所有评测用例，1 ≤ N ≤ 100000，1 ≤ K ≤ 10的十次方，1 ≤ Ai ≤ 10的九次方。</p>
<p><strong>思路：</strong> 暴力求解应该只能过30%样例。我的思路是在第一次接收数组的时候，直接再次按位数存到二维数组里。在接下来的判断中，两个数的位数相加小于K的位数的话，就是合法值。两个数的位数相加等于K的时候再相加准确计算，由于数据最大为十的十次方，所以用long long存。<br>这样的思路应该能比直接暴力快不少，评测点应该能多过几个，但是能不能AC我也不清楚，毕竟现在也没样例数据。如果大佬们有好的思路，麻烦指导下谢谢。</p>
<p><strong>代码：</strong> </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> array[<span class="number">100001</span>];<span class="comment">//存数据 </span></span><br><span class="line">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;mymap[<span class="number">10</span>];<span class="comment">//存上面数组的每个数的位数 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> n,k,ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;n;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;array[now]);	</span><br><span class="line">		mymap[(<span class="type">int</span>)<span class="built_in">log10</span>(array[now])<span class="number">+1</span>].<span class="built_in">push_back</span>(array[now]);<span class="comment">//按位数存进mymap里</span></span><br><span class="line">	&#125; </span><br><span class="line">	<span class="type">int</span> k_count=(<span class="type">int</span>)<span class="built_in">log10</span>(k)<span class="number">+1</span>,temp,temp1;<span class="comment">//k的位数 中间值（后面用） </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1</span>;now&lt;k_count<span class="number">-1</span>;now++)<span class="comment">//两个数位数相加小于k的位数 说明肯定小于k 直接交叉相乘 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> now1=<span class="number">1</span>;now1+now&lt;k_count;now1++)</span><br><span class="line">		&#123;</span><br><span class="line">			ans+=mymap[now].<span class="built_in">size</span>()*mymap[now1].<span class="built_in">size</span>();</span><br><span class="line">			<span class="keyword">if</span>(now==now1)<span class="comment">//如果位数相同 则有重复计算 </span></span><br><span class="line">			&#123;</span><br><span class="line">				ans-=mymap[now].<span class="built_in">size</span>();<span class="comment">//减去一部分 </span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">sort</span>(array,array+n);<span class="comment">//先排个序 一会循环到位数大于等于k的位数的时候 直接break; </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;n;now++)<span class="comment">//两个数位数相加等于k的情况 挨个判断 </span></span><br><span class="line">	&#123;</span><br><span class="line">		temp=(<span class="type">int</span>)<span class="built_in">log10</span>(array[now])<span class="number">+1</span>;</span><br><span class="line">		<span class="keyword">if</span>(temp&gt;=k_count)</span><br><span class="line">			<span class="keyword">break</span>; </span><br><span class="line">		temp1=mymap[k_count-temp].<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> now1=<span class="number">0</span>;now1&lt;temp1;now1++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//cout&lt;&lt;array[now]*pow(10,k_count-temp)+mymap[k_count-temp][now1]&lt;&lt;&quot; &quot;&lt;&lt;k&lt;&lt;endl;</span></span><br><span class="line">			<span class="keyword">if</span>(array[now]*<span class="built_in">pow</span>(<span class="number">10</span>,k_count-temp)+mymap[k_count-temp][now1]&lt;=k)<span class="comment">//两数相加小于等于k </span></span><br><span class="line">			&#123;</span><br><span class="line">				ans++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">if</span>(temp==k_count-temp&amp;&amp;array[now]*<span class="built_in">pow</span>(<span class="number">10</span>,k_count-temp)+array[now]&lt;=k)<span class="comment">//重复计数 减一个 </span></span><br><span class="line">		&#123;</span><br><span class="line">			ans--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构与算法</tag>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title>2018 蓝桥杯 日志统计 尺取法</title>
    <url>/2020/08/27/20200827_2018%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%97%A5%E5%BF%97%E7%BB%9F%E8%AE%A1%E5%B0%BA%E5%8F%96%E6%B3%95/</url>
    <content><![CDATA[<p><strong>这是2018年蓝桥杯C语言省赛B组的第八题</strong></p>
<span id="more"></span>

<p><strong>题目描述</strong><br>小明维护着一个程序员论坛。现在他收集了一份”点赞”日志，日志共有N行。<br>其中每一行的格式是：ts id。表示在ts时刻编号id的帖子收到一个”赞”。<br>现在小明想统计有哪些帖子曾经是”热帖”。<br>如果一个帖子曾在任意一个长度为D的时间段内收到不少于K个赞，小明就认为这个帖子曾是”热帖”。<br>具体来说，如果存在某个时刻T满足该帖在[T, T+D)这段时间内(注意是左闭右开区间)收到不少于K个赞，该帖就曾是”热帖”。<br>给定日志，请你帮助小明统计出所有曾是”热帖”的帖子编号。  </p>
<p><strong>输入</strong><br>第一行包含三个整数N、D和K。<br>以下N行每行一条日志，包含两个整数ts和id。<br>1 &lt;&#x3D; K &lt;&#x3D; N &lt;&#x3D; 100000 0 &lt;&#x3D; ts &lt;&#x3D; 100000 0 &lt;&#x3D; id &lt;&#x3D; 100000  </p>
<p><strong>输出</strong><br>按从小到大的顺序输出热帖id。每个id一行。</p>
<p><strong>样例输入</strong><br>7 10 2<br>0 1<br>0 10<br>10 10<br>10 1<br>9 1<br>100 3<br>100 3 </p>
<p><strong>样例输出</strong><br>1<br>3</p>
<p><a href="http://oj.ecustacm.cn/problem.php?id=1373">OJ链接</a></p>
<p><strong>思路</strong>：我的思路是一个二维数组储存每个id的点赞时间，即maps[id][]&#x3D;ts。然后根据maps数组对每个id运用尺取法进行条件判定，如果符合要求就是答案。<br>为了减少对数组的搜索，我引入了一个set用来储存出现过的id号，然后对出现过的id号关联的数组进行查询即可。</p>
<p><strong>尺取法：</strong> 我认为就是在一个连续的集合里，设定一个子集的首位位置和末尾位置，然后不断的推进首尾位置，寻找符合条件的子集。因为这题要计算相差的时间，所以数据必须是有序的，所以下面的代码中我使用了sort对maps数组进行排序。</p>
<p><strong>AC代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;maps[<span class="number">100001</span>]; <span class="comment">//二维数组储存每个节点的被点赞的时间 maps[x][0]就是x号帖子第一次被点赞的时间 </span></span><br><span class="line">set&lt;<span class="type">int</span>&gt;alls; <span class="comment">//储存出现的帖子编号  与maps配合 避免不必要的查询 直接maps[alls][]就行 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,d,k,ts,id;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;n,&amp;d,&amp;k);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(n--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;ts,&amp;id);</span><br><span class="line">		alls.<span class="built_in">insert</span>(id); <span class="comment">//储存出现的id号 </span></span><br><span class="line">		maps[id].<span class="built_in">push_back</span>(ts);	<span class="comment">//将点赞时间储存至maps[id][] </span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(set&lt;<span class="type">int</span>&gt;::iterator iter=alls.<span class="built_in">begin</span>();iter!=alls.<span class="built_in">end</span>();iter++) <span class="comment">//对整个maps[alls][]数组进行排序 方便后面的时间统计 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">sort</span>(maps[*iter].<span class="built_in">begin</span>(),maps[*iter].<span class="built_in">end</span>()); <span class="comment">//对有数据的数组进行排序 即 maps[alls][]</span></span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(set&lt;<span class="type">int</span>&gt;::iterator iter=alls.<span class="built_in">begin</span>();iter!=alls.<span class="built_in">end</span>();iter++) <span class="comment">//对有数据的maps数组进行查找  </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> all=<span class="number">0</span>,first=<span class="number">0</span>,end=<span class="number">0</span>; <span class="comment">//点赞数量 第一个赞的位置 最后一个赞的位置 </span></span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>) <span class="comment">//尺取法 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(all&lt;k&amp;&amp;end&lt;maps[*iter].<span class="built_in">size</span>()) <span class="comment">//点赞数小于要求 &amp;&amp; 数组里的数据还没有统计完 </span></span><br><span class="line">			&#123;</span><br><span class="line">				all++; </span><br><span class="line">				end++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(all&lt;k) <span class="comment">//统计完了 赞也不够 </span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">if</span>(maps[*iter][end<span class="number">-1</span>]-maps[*iter][first]&lt;d) <span class="comment">//赞够 并且 第一个赞和末尾赞的时间相隔符合要求 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*iter); <span class="comment">//由于set有序 所以直接输出即可 </span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			all--;</span><br><span class="line">			first++; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构与算法</tag>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 第十一届 蓝桥杯 整数拼接</title>
    <url>/2020/09/07/20200907_2020%E7%AC%AC%E5%8D%81%E4%B8%80%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%95%B4%E6%95%B0%E6%8B%BC%E6%8E%A5/</url>
    <content><![CDATA[<p><strong>此题为2020年第十一届蓝桥杯省赛第一场B组第九题</strong></p>
<span id="more"></span>

<p>时间限制: 1.0s 内存限制: 256.0MB 本题总分：25 分<br><strong>问题：</strong><br>给定义个长度为 n 的数组 A1, A2, · · · , An。你可以从中选出两个数 Ai (i 不等于 j)，然后将 Ai 和 Aj 一前一后拼成一个新的整数。例如 12 和 以拼成 12345 或 34512。注意交换 Ai 和 Aj 的顺序总是被视为 2 种拼法，是 Ai &#x3D; Aj 时。<br>请你计算有多少种拼法满足拼出的整数是 K 的倍数。</p>
<p><strong>输入：</strong><br>第一行包含 2 个整数 n 和 K。<br>第二行包含 n 个整数 A1, A2, · · · , An。</p>
<p><strong>输出：</strong><br>一个整数代表答案。</p>
<p><strong>样例输入：</strong><br>4 2<br>1 2 3 4</p>
<p><strong>样例输出：</strong><br>6</p>
<p><strong>评测用例规模与约定：</strong><br>对于 30% 的评测用例，1 ≤ n ≤ 1000, 1 ≤ K ≤ 20, 1 ≤ Ai ≤ 10的四次方。<br>对于所有评测用例，1 ≤ n ≤ 10的五次方，1 ≤ K ≤ 10的五次方，1 ≤ Ai ≤ 10的九次方。</p>
<p><strong>思路：</strong> 直接暴力肯定超时。我们可以先进行一次操作，对所有数字进行遍历。求出对于每个数，后数为多少时满足题目要求。因为所有数都小于等于十的九次方，即最多为10位数，所以我们只需要求每个数在后数为1位数到10位数时对后数的余数要求即可。然后再遍历一次判定满足要求的后数，总答案加上对该后数的需求即可。数据接收数组选择long long，防止运算中数据超限。答案也选择long long，防止储存不下。</p>
<p>具体思路如下：</p>
<ul>
<li>整式为 <strong>（数一*10^数二的位数^+数二）%k &#x3D;&#x3D; 0</strong> 即<strong>数一数二</strong>满足要求</li>
<li>我们遍历整个数组，按 <strong>（k - 数一*10^1-10^%k）%k</strong> 求出<strong>数一</strong>在1-10次方的情况下对后数余数的要求。这次遍历统计的是<strong>数一对于数二的需求</strong>。</li>
<li>用一个二维数组 <strong>mymap[位数][余数需求]</strong> 来储存对于 <strong>特定数二</strong> 的需求数量。</li>
<li>再次遍历整个数组，对数组元素的位数与余数进行计算，如果位数与余数满足需求，总答案则加上上一步中统计的需求数量。这次遍历是为了寻找<strong>数二</strong>。</li>
<li>在遍历中，我们需要进行去重判定。如果一个数跟自己组合也满足条件，说明上面多加了一次，总答案减去1。</li>
</ul>
<p><strong>AC代码：</strong> <a href="https://www.acwing.com/problem/content/2070/">OJ链接</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> myarray[<span class="number">100001</span>];<span class="comment">//存数 </span></span><br><span class="line"><span class="type">int</span> mymap[<span class="number">11</span>][<span class="number">100001</span>];<span class="comment">//存不同幂情况下对余数的需求 mymap[幂][需求]=数量 </span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;<span class="comment">//答案 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k)</span><span class="comment">//将各个位数可组合数的需求进行统计 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;n;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> temp=<span class="number">1</span>;temp&lt;=<span class="number">10</span>;temp++)</span><br><span class="line">		&#123;</span><br><span class="line">			</span><br><span class="line">			<span class="type">int</span> times=(<span class="type">long</span> <span class="type">long</span>)<span class="built_in">pow</span>(<span class="number">10</span>,temp)%k;</span><br><span class="line">			mymap[temp][(k-myarray[now]*times%k)%k]++;<span class="comment">//在temp次幂的情况下  对后数余数为 k-array[now]*times%k 的需求加一 </span></span><br><span class="line">			<span class="comment">//即后数为temp位数 并且余数为 k-array[now]*times%k 即可成功组合 </span></span><br><span class="line">			<span class="comment">//因为 array[now]*times%k 可能等于0 所以k减它可能等于k 所以需要总体%k一下 </span></span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k)</span><span class="comment">//遍历所有数 答案加上需求数 顺便去重 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;n;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> times=(<span class="type">int</span>)<span class="built_in">log10</span>(myarray[now])<span class="number">+1</span>;<span class="comment">//当前数位数 </span></span><br><span class="line">		ans+=mymap[times][myarray[now]%k];<span class="comment">//加上所有可以组合的 </span></span><br><span class="line">		<span class="keyword">if</span>((myarray[now]*(<span class="type">int</span>)<span class="built_in">pow</span>(<span class="number">10</span>,times)%k+myarray[now]%k)%k==<span class="number">0</span>)<span class="comment">//去重  </span></span><br><span class="line">		&#123;</span><br><span class="line">			ans--;<span class="comment">//如果一个数跟自己组合也满足条件 说明上面多加了一次 减去它 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>       </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,k; </span><br><span class="line">    <span class="built_in">memset</span>(mymap,<span class="number">0</span>,<span class="built_in">sizeof</span>(mymap));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;n;now++)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;myarray[now]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">func1</span>(n,k);</span><br><span class="line">	<span class="built_in">func2</span>(n,k);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构与算法</tag>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 蓝桥杯 C/C++实现 7月B组省赛</title>
    <url>/2020/09/06/20200906_2020%E8%93%9D%E6%A1%A5%E6%9D%AFC-C++%E5%AE%9E%E7%8E%B07%E6%9C%88B%E7%BB%84%E7%9C%81%E8%B5%9B/</url>
    <content><![CDATA[<p><strong>2020蓝桥杯 C&#x2F;C++ 7月B组省赛原题 &amp; 题解</strong></p>
<span id="more"></span>

<p>@<a href="%E9%A2%98%E7%9B%AE%E5%88%97%E8%A1%A8">TOC</a></p>
<h1 id="试题-A-跑步训练"><a href="#试题-A-跑步训练" class="headerlink" title="试题 A: 跑步训练"></a>试题 A: 跑步训练</h1><p>本题总分：5 分<br><strong>问题：</strong><br>小明要做一个跑步训练。<br>初始时，小明充满体力，体力值计为 10000。如果小明跑步，每分钟损耗600 的体力。如果小明休息，每分钟增加 300 的体力。体力的损耗和增加都是均匀变化的。<br>小明打算跑一分钟、休息一分钟、再跑一分钟、再休息一分钟……如此循环。如果某个时刻小明的体力到达 0，他就停止锻炼。<br>请问小明在多久后停止锻炼。为了使答案为整数，请以<strong>秒</strong>为单位输出答案。<br>答案中只填写数，不填写单位。</p>
<p><strong>思路：</strong> 简单循环即可。</p>
<p><strong>答案：</strong> <strong>3880</strong> </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> first=<span class="number">10000</span>,ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(first)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(first&gt;=<span class="number">600</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			first-=<span class="number">600</span>;</span><br><span class="line">			ans+=<span class="number">60</span>;</span><br><span class="line">			first+=<span class="number">300</span>;</span><br><span class="line">			ans+=<span class="number">60</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			ans+=first/<span class="number">10</span>;</span><br><span class="line">			first=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="试题-B-纪念日"><a href="#试题-B-纪念日" class="headerlink" title="试题 B: 纪念日"></a>试题 B: 纪念日</h1><p>本题总分：5 分<br><strong>问题：</strong><br>2020 年 7 月 1 日是中国某党成立 99 周年纪念日。<br>中国某党成立于 1921 年 7 月 23 日。<br>请问从 1921 年 7 月 23 日中午 12 时到 2020 年 7 月 1 日中午 12 时一共含多少分钟？</p>
<p><strong>思路：</strong> 先算多少天，再算多少时，再算多少分钟。</p>
<p><strong>答案：</strong> <strong>52038720</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1922</span>;now&lt;<span class="number">2020</span>;now++)<span class="comment">//1922到2019年共有多少天 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(now%<span class="number">100</span>!=<span class="number">0</span>&amp;&amp;now%<span class="number">4</span>==<span class="number">0</span>||now%<span class="number">400</span>==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			ans+=<span class="number">366</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			ans+=<span class="number">365</span>;	</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	ans=ans<span class="number">+31</span><span class="number">+29</span><span class="number">+31</span><span class="number">+30</span><span class="number">+31</span><span class="number">+30</span>;<span class="comment">//2020年1到6月有多少天 </span></span><br><span class="line">	ans=ans<span class="number">+31</span><span class="number">+30</span><span class="number">+31</span><span class="number">+30</span><span class="number">+31</span>;<span class="comment">//1921年8月到12月有多少天</span></span><br><span class="line">	ans+=<span class="number">9</span>;<span class="comment">//加上多余那几天</span></span><br><span class="line">	ans*=<span class="number">24</span>;<span class="comment">//换算成时 </span></span><br><span class="line">	ans*=<span class="number">60</span>;<span class="comment">//换算成分 </span></span><br><span class="line">	cout&lt;&lt;ans; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="试题-C-合并检测"><a href="#试题-C-合并检测" class="headerlink" title="试题 C: 合并检测"></a>试题 C: 合并检测</h1><p>本题总分：10 分<br><strong>问题：</strong><br>新冠疫情由新冠病毒引起，最近在 A 国蔓延，为了尽快控制疫情，A 国准 备给大量民众进病毒核酸检测。<br>然而，用于检测的试剂盒紧缺。 为了解决这一困难，科学家想了一个办法：合并检测。即将从多个人（k 个）采集的标本放到同一个试剂盒中进行检测。如果结果为阴性，则说明这 k 个人都是阴性，用一个试剂盒完成了 k 个人的检测。如果结果为阳性，则说明 至少有一个人为阳性，需要将这 k 个人的样本全部重新独立检测（从理论上看， 如果检测前 k−1 个人都是阴性可以推断出第 k 个人是阳性，但是在实际操作中 不会利用此推断，而是将 k 个人独立检测），加上最开始的合并检测，一共使用 了 k + 1 个试剂盒完成了 k 个人的检测。<br> A 国估计被测的民众的感染率大概是 **1%**，呈均匀分布。请问 k 取多少能 最节省试剂盒？</p>
<p><strong>思路：</strong> 假设有一共检测m个人，则第一批检测需要m&#x2F;k个试剂盒（向上取整）。由于感染率为1%，且均匀分布，则有0.01 * m个试剂盒会有阳性反应。这时进行第二批挨个检测，检测盒数量即为0.01 * m * k个。<br>则总需求盒子数即为<strong>m&#x2F;k+0.01 * m * k</strong>个（m&#x2F;k向上取整）。</p>
<p><strong>答案：</strong> 10</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> min_=<span class="number">999</span>,min_k=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> m=<span class="number">100</span>;<span class="comment">//假设初始人有100 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">100</span>;k++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> need=m/k<span class="number">+0.01</span>*m*k;</span><br><span class="line">		<span class="keyword">if</span>(m%k!=<span class="number">0</span>)</span><br><span class="line">			need++;</span><br><span class="line">		<span class="keyword">if</span>(need&lt;min_)</span><br><span class="line">		&#123;</span><br><span class="line">			min_=need;</span><br><span class="line">			min_k=k;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;min_k;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="试题-D-REPEAT-程序"><a href="#试题-D-REPEAT-程序" class="headerlink" title="试题 D: REPEAT 程序"></a>试题 D: REPEAT 程序</h1><p>本题总分：15 分<br><strong>问题：</strong><br>附件 prog.txt 中是一个用某种语言写的程序。<br><a href="https://wwa.lanzous.com/i6APvex4r3g">prog.txt 附件下载地址</a><br>其中 REPEAT k 表示一个次数为 k 的循环。循环控制的范围由缩进表达，从次行开始连续的缩进比该行多的（前面的空白更长的）为循环包含的内容。<br>例如如下片段：<br><img src="/images/2020-09-06/1.jpg#pic_center" alt="rt"></p>
<p>A &#x3D; A + 4 所在的行到 A &#x3D; A + 8 所在的行都在第一行的循环两次中。<br>REPEAT 6: 所在的行到 A &#x3D; A + 7 所在的行都在 REPEAT 5: 循环中。<br>A &#x3D; A + 5 实际总共的循环次数是 2 × 5 × 6 &#x3D; 60 次。<br>请问该程序执行完毕之后，A 的值是多少？</p>
<p><strong>思路：</strong> 可以建立一个栈来存放循环的信息，一个变量times存放当前行数被执行的次数。通过对文本的观察我们发现，可以通过每一行前面的空格数量来判断当前行数的“等级”，4个空格代表一个等级。如果当前行等级比上一层循环的等级低则说明退出了上一层循环，对栈和times进行改变即可。随后我们发现整个文本里面，所有数字都为单位数，所以我们直接用循环找到一个数字即可提取出该行的有效数字。</p>
<p><strong>答案：</strong> <strong>241830</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string string_;</span><br><span class="line">	stack&lt;<span class="type">int</span>&gt;stack_; </span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;prog.txt&quot;</span>, <span class="string">&quot;rb&quot;</span>, stdin);</span><br><span class="line">	<span class="built_in">getline</span>(cin, string_);<span class="comment">//读第一行 A=0 </span></span><br><span class="line">	<span class="type">int</span> A=<span class="number">0</span>,times=<span class="number">1</span>,old_counts=<span class="number">0</span>;<span class="comment">//A=0,当前倍数，老的层数 </span></span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">getline</span>(cin, string_))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> counts=<span class="number">0</span>;<span class="comment">//当前的层数，</span></span><br><span class="line">		<span class="keyword">for</span>(counts=<span class="number">0</span>;counts&lt;string_.<span class="built_in">size</span>();counts++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//记录空格数 4个空格是一层 </span></span><br><span class="line">			<span class="keyword">if</span>(string_[counts]!=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		counts/=<span class="number">4</span>;<span class="comment">//这句话的层数 </span></span><br><span class="line">		<span class="keyword">while</span>(counts&lt;old_counts)<span class="comment">//新层数低 则退出一层循环 pop </span></span><br><span class="line">		&#123;</span><br><span class="line">			times/=stack_.<span class="built_in">top</span>();</span><br><span class="line">			stack_.<span class="built_in">pop</span>();</span><br><span class="line">			old_counts--; </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">if</span>(string_[counts*<span class="number">4</span>]==<span class="string">&#x27;R&#x27;</span>)<span class="comment">//R开头就是新增循环</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> now=counts*<span class="number">4</span>;now&lt;string_.<span class="built_in">size</span>();now++)<span class="comment">//找到数字 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(string_[now]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;string_[now]&lt;=<span class="string">&#x27;9&#x27;</span>)<span class="comment">//如果是数字 </span></span><br><span class="line">				&#123;</span><br><span class="line">					stack_.<span class="built_in">push</span>(string_[now]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">					times*=string_[now]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">					old_counts++;</span><br><span class="line">					<span class="keyword">break</span>; </span><br><span class="line">				&#125; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span><span class="comment">//否则就是执行计算操作 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> now=counts*<span class="number">4</span>;now&lt;string_.<span class="built_in">size</span>();now++)<span class="comment">//找到数字 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(string_[now]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;string_[now]&lt;=<span class="string">&#x27;9&#x27;</span>)<span class="comment">//如果是数字 </span></span><br><span class="line">				&#123;</span><br><span class="line">					A+=(string_[now]-<span class="string">&#x27;0&#x27;</span>)*times;</span><br><span class="line">					<span class="keyword">break</span>; </span><br><span class="line">				&#125; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;A; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="试题-E-矩阵"><a href="#试题-E-矩阵" class="headerlink" title="试题 E: 矩阵"></a>试题 E: 矩阵</h1><p>本题总分：15 分<br><strong>问题：</strong><br>把 1 ∼ 2020 放在 2 × 1010 的矩阵里。要求同一行中右边的比左边大，列中下边的比上边的大。一共有多少种方案？<br>答案很大，你只需要给出方案数除以 2020 的余数即可。</p>
<p><strong>思路：</strong> 动态规划。</p>
<p><strong>答案：</strong> <strong>1340</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[<span class="number">1020</span>][<span class="number">1020</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;                                   <span class="comment">// 两行一个数字都不放，也是一种方案</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1010</span>; i ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">1010</span>; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i - <span class="number">1</span> &gt;= j)                         <span class="comment">// 转移前的状态也要合法，即第一行的数量不小于第二行的数量</span></span><br><span class="line">            	f[i][j] += f[i - <span class="number">1</span>][j] % <span class="number">2020</span>;</span><br><span class="line">            <span class="keyword">if</span>(j)</span><br><span class="line">            	f[i][j] += f[i][j - <span class="number">1</span>] % <span class="number">2020</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    cout &lt;&lt; f[<span class="number">1010</span>][<span class="number">1010</span>] &lt;&lt; endl;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>以下五题均能通过<a href="https://www.acwing.com/problem/">AcWing</a>的数据测试</li>
</ul>
<h1 id="试题-F-整除序列"><a href="#试题-F-整除序列" class="headerlink" title="试题 F: 整除序列"></a>试题 F: 整除序列</h1><p>时间限制: 1.0s 内存限制: 256.0MB 本题总分：15<br><strong>问题：</strong><br>有一个序列，序列的第一个数是 n，后面的每个数是前一个数整除 2，出这个序列中值为正数的项。</p>
<p><strong>输入:</strong><br>输入一行包含一个整数 n。</p>
<p><strong>输出：</strong><br>输出一行，包含多个整数，相邻的整数之间用一个空格分隔，表示答案。</p>
<p><strong>样例输入：</strong><br>20</p>
<p><strong>样例输出：</strong><br>20 10 5 2 1</p>
<p><strong>评测用例规模与约定：</strong><br>对于 80% 的评测用例，1 ≤ n ≤ 10的9次方。<br>对于所有评测用例，1 ≤ n ≤ 10的18次方。</p>
<p><strong>思路：</strong> 直接循环除就好。</p>
<p><strong>AC代码：</strong> <a href="https://www.acwing.com/problem/content/2067/">OJ链接</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> n=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">while</span>(n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,n);</span><br><span class="line">		n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="试题-G-解码"><a href="#试题-G-解码" class="headerlink" title="试题 G: 解码"></a>试题 G: 解码</h1><p>时间限制: 1.0s 内存限制: 256.0MB 本题总分：20 分<br><strong>问题：</strong><br>小明有一串很长的英文字母，可能包含大写和小写。<br>在这串字母中，有很多连续的是重复的。小明想了一个办法将这串字达得更短：将连续的几个相同字母写成字母 + 出现次数的形式。<br>例如，连续的 5 个 a，即 aaaaa，小明可以简写成 a5（也可能简写aa3a 等）。对于这个例子：HHHellllloo，小明可以简写成 H3el5o2。为了方便表达，小明不会将连续的超过 9 个相同的字符写成简写的形式。<br>现在给出简写后的字符串，请帮助小明还原成原来的串。</p>
<p><strong>输入：</strong><br>输入一行包含一个字符串。</p>
<p><strong>输出：</strong><br>输出一个字符串，表示还原后的串。</p>
<p><strong>样例输入：</strong><br>H3el5o2</p>
<p><strong>样例输出：</strong><br>HHHellllloo</p>
<p><strong>评测用例规模与约定：</strong><br>对于所有评测用例，字符串由大小写英文字母和数字组成，长度不100。<br>请注意原来的串长度可能超过 100。</p>
<p><strong>思路：</strong> 对字符串进行循环判断即可。</p>
<p><strong>AC代码：</strong> <a href="https://www.acwing.com/problem/content/description/2068/">OJ链接</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string string_;</span><br><span class="line">	<span class="type">char</span> old_letter;<span class="comment">//老字母 </span></span><br><span class="line">	<span class="built_in">getline</span>(cin,string_);</span><br><span class="line">	old_letter=string_[<span class="number">0</span>];<span class="comment">//指向第一个字母 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1</span>;now&lt;string_.<span class="built_in">size</span>();now++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(string_[now]&gt;=<span class="string">&#x27;1&#x27;</span>&amp;&amp;string_[now]&lt;=<span class="string">&#x27;9&#x27;</span>)<span class="comment">//数字就循环输出</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> temp=<span class="number">0</span>;temp&lt;string_[now]-<span class="string">&#x27;0&#x27;</span><span class="number">-1</span>;temp++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,old_letter);</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//否则输出一次 换新字</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,old_letter);</span><br><span class="line">			old_letter=string_[now];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,old_letter);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="试题-H-走方格"><a href="#试题-H-走方格" class="headerlink" title="试题 H: 走方格"></a>试题 H: 走方格</h1><p>时间限制: 1.0s 内存限制: 256.0MB 本题总分：20 分<br><strong>问题：</strong><br>在平面上有一些二维的点阵。这些点的编号就像二维数组的编号一样，从上到下依次为第 1 至第 n 行，从左到右依次为第 1 至第 m 列，每一个点可以用行号和列号来表示。现在有个人站在第 1 行第 1 列，要走到第 n 行第 m 列。只能向右或者向下走。<br><strong>注意</strong>，如果行号和列数都是偶数，不能走入这一格中。问有多少种方案。</p>
<p><strong>输入：</strong><br>输入一行包含两个整数 n, m。</p>
<p><strong>输出：</strong><br>输出一个整数，表示答案。</p>
<p><strong>样例输入1：</strong><br>3 4</p>
<p><strong>样例输出1：</strong><br>2</p>
<p><strong>样例输入2：</strong><br>6 6</p>
<p><strong>样例输出2：</strong><br>0</p>
<p><strong>评测用例规模与约定：</strong><br>对于所有评测用例，1 ≤ n ≤ 30, 1 ≤ m ≤ 30。</p>
<p><strong>思路：</strong> dfs暴力搜索的话，当n&#x3D;29，m&#x3D;30的时候会超时。我们可以用dp把结果都记录下来然后直接输出。记得行号列号都是偶数的时候跳过，因为不能走入这种方格。</p>
<p><strong>AC代码：</strong> <a href="https://www.acwing.com/problem/content/submission/2069/">OJ链接</a></p>
<ul>
<li>1.dfs写法（超时）<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fx[<span class="number">2</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;,ans=<span class="number">0</span>;<span class="comment">//右/下 答案 </span></span><br><span class="line"><span class="type">int</span> n,m,a1,b1;<span class="comment">//n,m </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a==n&amp;&amp;b==m)</span><br><span class="line">	&#123;</span><br><span class="line">		ans++;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;<span class="number">2</span>;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		a1=a+fx[now][<span class="number">0</span>];</span><br><span class="line">		b1=b+fx[now][<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(a1&gt;n||b1&gt;m) </span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(!(a1&amp;<span class="number">1</span>)&amp;&amp;!(b1&amp;<span class="number">1</span>)) </span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(a1,b1); </span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">if</span>(!(n&amp;<span class="number">1</span>)&amp;&amp;!(m&amp;<span class="number">1</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
<li>2.dp写法（可AC）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> dp[<span class="number">31</span>][<span class="number">31</span>];<span class="comment">//dp</span></span><br><span class="line">	<span class="type">int</span> n,m;<span class="comment">//n,m </span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">	dp[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1</span>;now&lt;=<span class="number">30</span>;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> now1=<span class="number">1</span>;now1&lt;=<span class="number">30</span>;now1++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!(now&amp;<span class="number">1</span>)&amp;&amp;!(now1&amp;<span class="number">1</span>))<span class="comment">//都是偶数就跳过 </span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(now<span class="number">-1</span>&gt;=<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[now][now1]+=dp[now<span class="number">-1</span>][now1];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(now1<span class="number">-1</span>&gt;=<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[now][now1]+=dp[now][now1<span class="number">-1</span>];</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*for(int now=1;now&lt;=30;now++)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		for(int now1=1;now1&lt;=30;now1++)</span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">			printf(&quot;%d &quot;,dp[now][now1]);</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		printf(&quot;\n&quot;);</span></span><br><span class="line"><span class="comment">	&#125;*/</span> </span><br><span class="line">	cout&lt;&lt;dp[n][m];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="试题-I-整数拼接"><a href="#试题-I-整数拼接" class="headerlink" title="试题 I: 整数拼接"></a>试题 I: 整数拼接</h1><p>时间限制: 1.0s 内存限制: 256.0MB 本题总分：25 分<br><strong>问题：</strong><br>给定义个长度为 n 的数组 A1, A2, · · · , An。你可以从中选出两个数 Ai (i 不等于 j)，然后将 Ai 和 Aj 一前一后拼成一个新的整数。例如 12 和 以拼成 12345 或 34512。注意交换 Ai 和 Aj 的顺序总是被视为 2 种拼法，是 Ai &#x3D; Aj 时。<br>请你计算有多少种拼法满足拼出的整数是 K 的倍数。</p>
<p><strong>输入：</strong><br>第一行包含 2 个整数 n 和 K。<br>第二行包含 n 个整数 A1, A2, · · · , An。</p>
<p><strong>输出：</strong><br>一个整数代表答案。</p>
<p><strong>样例输入：</strong><br>4 2<br>1 2 3 4</p>
<p><strong>样例输出：</strong><br>6</p>
<p><strong>评测用例规模与约定：</strong><br>对于 30% 的评测用例，1 ≤ n ≤ 1000, 1 ≤ K ≤ 20, 1 ≤ Ai ≤ 10的四次方。<br>对于所有评测用例，1 ≤ n ≤ 10的五次方，1 ≤ K ≤ 10的五次方，1 ≤ Ai ≤ 10的九次方。</p>
<p><strong>思路：</strong> 直接暴力肯定超时。我们可以先进行一次操作，对所有数字进行遍历。求出对于每个数，后数为多少时满足题目要求。因为所有数都小于等于十的九次方，即最多为10位数，所以我们只需要求每个数在后数为1位数到10位数时对后数的余数要求即可。然后再遍历一次判定满足要求的后数，总答案加上对该后数的需求即可。数据接收数组选择long long，防止运算中数据超限。答案也选择long long，防止储存不下。</p>
<p>具体思路如下：</p>
<ul>
<li>整式为 <strong>（数一*10^数二的位数^+数二）%k &#x3D;&#x3D; 0</strong> 即<strong>数一数二</strong>满足要求</li>
<li>我们遍历整个数组，按 <strong>（k - 数一*10^1-10^%k）%k</strong> 求出<strong>数一</strong>在1-10次方的情况下对后数余数的要求。这次遍历统计的是<strong>数一对于数二的需求</strong>。</li>
<li>用一个二维数组 <strong>mymap[位数][余数需求]</strong> 来储存对于 <strong>特定数二</strong> 的需求数量。</li>
<li>再次遍历整个数组，对数组元素的位数与余数进行计算，如果位数与余数满足需求，总答案则加上上一步中统计的需求数量。这次遍历是为了寻找<strong>数二</strong>。</li>
<li>在遍历中，我们需要进行去重判定。如果一个数跟自己组合也满足条件，说明上面多加了一次，总答案减去1。</li>
</ul>
<p><strong>AC代码：</strong> <a href="https://www.acwing.com/problem/content/2070/">OJ链接</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> myarray[<span class="number">100001</span>];<span class="comment">//存数 </span></span><br><span class="line"><span class="type">int</span> mymap[<span class="number">11</span>][<span class="number">100001</span>];<span class="comment">//存不同幂情况下对余数的需求 mymap[幂][需求]=数量 </span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;<span class="comment">//答案 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k)</span><span class="comment">//将各个位数可组合数的需求进行统计 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;n;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> temp=<span class="number">1</span>;temp&lt;=<span class="number">10</span>;temp++)</span><br><span class="line">		&#123;</span><br><span class="line">			</span><br><span class="line">			<span class="type">int</span> times=(<span class="type">long</span> <span class="type">long</span>)<span class="built_in">pow</span>(<span class="number">10</span>,temp)%k;</span><br><span class="line">			mymap[temp][(k-myarray[now]*times%k)%k]++;<span class="comment">//在temp次幂的情况下  对后数余数为 k-array[now]*times%k 的需求加一 </span></span><br><span class="line">			<span class="comment">//即后数为temp位数 并且余数为 k-array[now]*times%k 即可成功组合 </span></span><br><span class="line">			<span class="comment">//因为 array[now]*times%k 可能等于0 所以k减它可能等于k 所以需要总体%k一下 </span></span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k)</span><span class="comment">//遍历所有数 答案加上需求数 顺便去重 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;n;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> times=(<span class="type">int</span>)<span class="built_in">log10</span>(myarray[now])<span class="number">+1</span>;<span class="comment">//当前数位数 </span></span><br><span class="line">		ans+=mymap[times][myarray[now]%k];<span class="comment">//加上所有可以组合的 </span></span><br><span class="line">		<span class="keyword">if</span>((myarray[now]*(<span class="type">int</span>)<span class="built_in">pow</span>(<span class="number">10</span>,times)%k+myarray[now]%k)%k==<span class="number">0</span>)<span class="comment">//去重  </span></span><br><span class="line">		&#123;</span><br><span class="line">			ans--;<span class="comment">//如果一个数跟自己组合也满足条件 说明上面多加了一次 减去它 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>       </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,k; </span><br><span class="line">    <span class="built_in">memset</span>(mymap,<span class="number">0</span>,<span class="built_in">sizeof</span>(mymap));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;n;now++)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;myarray[now]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">func1</span>(n,k);</span><br><span class="line">	<span class="built_in">func2</span>(n,k);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="试题-J-网络分析"><a href="#试题-J-网络分析" class="headerlink" title="试题 J: 网络分析"></a>试题 J: 网络分析</h1><p>时间限制: 1.0s 内存限制: 256.0MB 本题总分：25 分<br><strong>问题：</strong><br>小明正在做一个网络实验。<br>他设置了 n 台电脑，称为节点，用于收发和存储数据。<br>初始时，所有节点都是独立的，不存在任何连接。<br>小明可以通过网线将两个节点连接起来，连接后两个节点就可以互相了。两个节点如果存在网线连接，称为相邻。<br>小明有时会测试当时的网络，他会在某个节点发送一条信息，信息会到每个相邻的节点，之后这些节点又会转发到自己相邻的节点，直到所有或间接相邻的节点都收到了信息。所有发送和接收的节点都会将信息存储一条信息只存储一次。<br>给出小明连接和测试的过程，请计算出每个节点存储信息的大小。</p>
<p><strong>输入：</strong><br>输入的第一行包含两个整数 n, m，分别表示节点数量和操作数量。节1 至 n 编号。<br>接下来 m 行，每行三个整数，表示一个操作。<br>如果操作为 1 a b，表示将节点 a 和节点 b 通过网线连接起来。当 时，表示连接了一个自环，对网络没有实质影响。<br>如果操作为 2 p t，表示在节点 p 上发送一条大小为 t 的信息。</p>
<p><strong>输出：</strong><br>输出一行，包含 n 个整数，相邻整数之间用一个空格分割，依次表示完上述操作后节点 1 至节点 n 上存储信息的大小。</p>
<p><strong>样例输入：</strong><br>4 8<br>1 1 2<br>2 1 10<br>2 3 5<br>1 4 1<br>2 2 2<br>1 1 2<br>1 2 4<br>2 2 1</p>
<p><strong>样例输出：</strong><br>13 13 5 3</p>
<p><strong>评测用例规模与约定：</strong><br>对于 30% 的评测用例，1 ≤ n ≤ 20，1 ≤ m ≤ 100。<br>对于 50% 的评测用例，1 ≤ n ≤ 100，1 ≤ m ≤ 1000。<br>对于 70% 的评测用例，1 ≤ n ≤ 1000，1 ≤ m ≤ 10000。<br>对于所有评测用例，1 ≤ n ≤ 10000，1 ≤ m ≤ 100000，1 ≤ t ≤ 100。</p>
<p><strong>思路：</strong> 核心思路是并查集。一个数组用来存旧值，一个数组用来存根结点权值，一个数组是并查集的father数组。执行2操作时，查集寻找到操作值的根结点并加权。执行1操作时，若两数在一个集内则不操作；若两数不在一个集内，则对所有节点进行遍历，使他们的旧值数组加上其根节点的权值，随后进行并集操作。记得对权值数组进行清零，防止后面重复计算。</p>
<p><strong>AC代码：</strong> <a href="https://www.acwing.com/problem/content/description/2071/">OJ链接</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> old_[<span class="number">10001</span>],new_[<span class="number">10001</span>],father[<span class="number">10001</span>],n,m;<span class="comment">//存老值 存根节点新值 父节点数组 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> father[a]==a ? a : father[a]=<span class="built_in">find</span>(father[a]);<span class="comment">//路径压缩</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">union_</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp_a=<span class="built_in">find</span>(a),temp_b=<span class="built_in">find</span>(b);</span><br><span class="line">	<span class="keyword">if</span>(temp_a!=temp_b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> now=<span class="number">1</span>;now&lt;=n;now++)</span><br><span class="line">		&#123;</span><br><span class="line">			old_[now]+=new_[<span class="built_in">find</span>(now)];<span class="comment">//旧值数组遍历加上权值</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">memset</span>(new_,<span class="number">0</span>,<span class="built_in">sizeof</span>(new_));<span class="comment">//重置权值数组，防止重复计算</span></span><br><span class="line">		father[temp_a]=temp_b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a,b,c;</span><br><span class="line">	<span class="built_in">memset</span>(new_,<span class="number">0</span>,<span class="built_in">sizeof</span>(new_));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> now=<span class="number">1</span>;now&lt;=<span class="number">10000</span>;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		father[now]=now;<span class="comment">//father数组初始化 </span></span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">while</span>(m--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">		<span class="keyword">if</span>(a==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">union_</span>(b,c);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			new_[<span class="built_in">find</span>(b)]+=c;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> now=<span class="number">1</span>;now&lt;=n;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,old_[now]+new_[<span class="built_in">find</span>(now)]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构与算法</tag>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title>bfs学习记录：模板/思路汇总</title>
    <url>/2020/08/14/20200814_bfs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%80%9D%E8%B7%AF%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p><strong>HB小咸鱼学习记录</strong></p>
<h1 id="一点看法"><a href="#一点看法" class="headerlink" title="一点看法"></a>一点看法</h1><p>蓝桥杯刷了不少的搜索题，但是bfs的题很少，大部分都是dfs的题。<br>但是去年蓝桥杯就考了bfs，所以还是得好好刷题。<br>bfs由于是一个循环进行搜索，所以没法回溯，因而每个点位只能被走一次。这样加快了搜索速度，但是由于每个点只能走一次导致无法列举出所有的可走路径。而这样的好处是避免了绕远路，搜索到结果时一定是最短路。所以大部分的求最短路的题都用bfs.</p>
<span id="more"></span>

<h1 id="自我对于“广度优先搜索”的理解"><a href="#自我对于“广度优先搜索”的理解" class="headerlink" title="自我对于“广度优先搜索”的理解"></a>自我对于“广度优先搜索”的理解</h1><p>bfs,字面来看就是以广度为优先的搜索方式。搜索时以原点向四周扩散。如果说dfs是“搜完一个屋子再搜另一个屋子”，那bfs就是“把每个屋子的柜子搜了再搜每个屋子的桌子……”这样层层深入的搜索。这样可以优先搜索物品可能在的地方，从而减少搜索的时间。<br>就像我们规定以“前左右”的顺序走迷宫，而在寻找迷宫的出口时就可以看成进行了一次搜索。我们首先记录下来第一个路口能前往哪几个路口，随后再按照规定的顺序（前左右）查看这几个路口的又能前往哪几个路口。途中前往过的路口要进行标记，防止重复的查看。直到查看一个路口，它可以前往到终点或者它就是终点，此时搜索结束。我们查看的轮数就是前往该终点的最小步数。而在搜索过程中，我们可以使用适当的数据结构来储存前往终点所经过的路口，这就是最短路径。<br>这样进行搜索的范围大，查找到终点的路径始终是最短路径。但缺点是我们没办法迭代出所有的可前往终点的路径。</p>
<h1 id="bfs的大致思路"><a href="#bfs的大致思路" class="headerlink" title="bfs的大致思路"></a>bfs的大致思路</h1><p><strong>首先</strong>，如上个片段所说，我们首先需要一个二维数组，来对迷宫进行标记，标记出可以走的点和障碍（不可以走的点）。<br><strong>其次</strong>，我们建立一个队列，把起点加入到队列中。<br><strong>接着</strong>，我们建立一个while循环，设定在队列不为空的时候执行循环。<br>循环中，我们首先获取队列的头结点坐标，随后我们需要对移动的规则进行规定。例如上文的例子规定的“上左右”，我们可以用一个二维数组来储存移动后坐标的变化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> direction[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;; </span><br></pre></td></tr></table></figure>
<p>这个数组里面的四组数据就分别代表“上左右下”，在对坐标变换时进行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x1=x+direction[a][<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span> y1=y+direction[a][<span class="number">1</span>]; </span><br></pre></td></tr></table></figure>
<p>即可实现对坐标的变化。我们按照这个顺序，对头结点的周围进行判断，如果可以前往的话，就将变换后的数据点加入队列。然后将新点（x1,y1）的状态进行更改，代表你已经来过这里了。防止重复的搜索。<br><strong>最后</strong>，我们需要设定上一步循环的中止条件，从而在找到出口时停止或者返回一些信息。我们常常在循环中获取头结点后进行判定，如果头结点数据是我们想要搜索到的信息，我们就中止循环。</p>
<h1 id="bfs的大致模板"><a href="#bfs的大致模板" class="headerlink" title="bfs的大致模板"></a>bfs的大致模板</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(传入的数据)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt;q; <span class="comment">//建立一个队列</span></span><br><span class="line">	q.<span class="built_in">push</span>(初始坐标); <span class="comment">//把头结点（初始点）加入队列</span></span><br><span class="line">	<span class="keyword">while</span>(队列不为空) </span><br><span class="line">	&#123;</span><br><span class="line">		top = q.<span class="built_in">front</span>(); <span class="comment">//取出队首元素top</span></span><br><span class="line">		<span class="keyword">if</span>(队首元素top就是你要搜索的目标) </span><br><span class="line">		&#123;</span><br><span class="line">			执行一些操作</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		top.<span class="built_in">pop</span>(); <span class="comment">//将队首元素出队；</span></span><br><span class="line">		<span class="keyword">for</span>(按顺序寻找top的所有子节点)</span><br><span class="line">		&#123;</span><br><span class="line">			把可以前往的子节点入队</span><br><span class="line">			标记入队的子节点，防止下次重复入队</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h1 id="bfs例题"><a href="#bfs例题" class="headerlink" title="bfs例题"></a>bfs例题</h1><h2 id="蓝桥杯-学霸的迷宫"><a href="#蓝桥杯-学霸的迷宫" class="headerlink" title="蓝桥杯 学霸的迷宫"></a>蓝桥杯 学霸的迷宫</h2><p><img src="/images/2020-08-14/1.jpg#pic_center" alt="题干"><br><strong>样例输入</strong><br>Input Sample 1:<br>3 3<br>001<br>100<br>110<br><strong>样例输出</strong><br>Output Sample 1:<br>4<br>RDRD</p>
<p><a href="http://lx.lanqiao.cn/problem.page?gpid=T291"><strong>题目链接</strong></a></p>
<p>这一题算是bfs的经典例题，题目不止让求了最短的步数，还让输出了最短的路径。<br>所以我们在队列结点的数据结构中添加了一个string字符串，用来储存到达某个点的最短路径。<br>在找到终点时，输出最短步数和最短路径即可。<br><strong>ac代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">data</span>	<span class="comment">//队列里的数据结构 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x;	<span class="comment">//坐标x </span></span><br><span class="line">	<span class="type">int</span> y;	<span class="comment">//坐标y </span></span><br><span class="line">	<span class="type">int</span> times;	<span class="comment">//步数 </span></span><br><span class="line">	string road;	<span class="comment">//走过的路径</span></span><br><span class="line">	<span class="built_in">data</span>(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> d,string c)	<span class="comment">//构造函数 </span></span><br><span class="line">	&#123;</span><br><span class="line">		x=a;</span><br><span class="line">		y=b;</span><br><span class="line">		times=d;</span><br><span class="line">		road = c;	</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;;</span><br><span class="line">queue&lt;data&gt;datas;	<span class="comment">//队列用来存放点位数据 </span></span><br><span class="line"><span class="type">bool</span> maps[<span class="number">501</span>][<span class="number">501</span>];	<span class="comment">//存放迷宫地图的点位 false代表可前往 true代表不可前往 </span></span><br><span class="line"><span class="type">char</span> fx[] = &#123;<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;L&#x27;</span>,<span class="string">&#x27;R&#x27;</span>,<span class="string">&#x27;U&#x27;</span>&#125;;	<span class="comment">//方向ascii码从小到大排列 </span></span><br><span class="line"><span class="type">int</span> site[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;	<span class="comment">//下 左 右 上的坐标变化 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span>	<span class="comment">//传参为迷宫的大小 n为宽 m为长 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	datas.<span class="built_in">push</span>(<span class="built_in">data</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="string">&quot;&quot;</span>));	<span class="comment">//把起始点压入队列 </span></span><br><span class="line">	maps[<span class="number">1</span>][<span class="number">1</span>]=<span class="literal">true</span>;	<span class="comment">//标记初始点已走过 </span></span><br><span class="line">	<span class="keyword">while</span>(!datas.<span class="built_in">empty</span>())	<span class="comment">//如果队列不为空 </span></span><br><span class="line">	&#123;</span><br><span class="line">		data now = datas.<span class="built_in">front</span>();	<span class="comment">//声明一个结构体变量 让now变量指向队列的头结点</span></span><br><span class="line">		datas.<span class="built_in">pop</span>();	<span class="comment">//弹出头结点 </span></span><br><span class="line">		<span class="comment">//cout&lt;&lt;now.x&lt;&lt;&quot; &quot;&lt;&lt;now.y&lt;&lt;endl; </span></span><br><span class="line">		<span class="keyword">if</span>(now.x==n&amp;&amp;now.y==m)	<span class="comment">//如果头结点就是要找的点 就搜索结束 </span></span><br><span class="line">		&#123;</span><br><span class="line">			cout&lt;&lt;now.times&lt;&lt;endl&lt;&lt;now.road&lt;&lt;endl;	<span class="comment">//输出走过的路径 和步数 </span></span><br><span class="line">			<span class="keyword">return</span>; </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> temp=<span class="number">0</span>;temp&lt;<span class="number">4</span>;temp++)	<span class="comment">//开始查找该点的四周点位 （因为只有上下左右4个走法 所以循4次 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> x1=now.x+site[temp][<span class="number">0</span>];	<span class="comment">//变换过的x坐标 </span></span><br><span class="line">			<span class="type">int</span> y1=now.y+site[temp][<span class="number">1</span>]; <span class="comment">//变换过的y坐标 </span></span><br><span class="line">			<span class="keyword">if</span>(maps[y1][x1])	<span class="comment">//如果该点已经走过或者有障碍 跳过 </span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(x1&lt;<span class="number">1</span>||y1&lt;<span class="number">1</span>||x1&gt;n||y1&gt;m) 	<span class="comment">//如果坐标超出范围 就跳过此循环</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			datas.<span class="built_in">push</span>(<span class="built_in">data</span>(x1,y1,now.times<span class="number">+1</span>,now.road+fx[temp]));	<span class="comment">//把新点位压入队列 路径加上新选择的fx[temp] </span></span><br><span class="line">			maps[y1][x1] = <span class="literal">true</span>;	<span class="comment">//标记已走过 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(maps,<span class="literal">false</span>,<span class="built_in">sizeof</span>(maps));		<span class="comment">//初始化 </span></span><br><span class="line">	<span class="type">int</span> x,y;	<span class="comment">//接收迷宫大小</span></span><br><span class="line">	<span class="type">char</span> input;	</span><br><span class="line">	cin&gt;&gt;y&gt;&gt;x;</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> y1=<span class="number">1</span>;y1&lt;=y;y1++) 	<span class="comment">//迷宫长 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> x1=<span class="number">1</span>;x1&lt;=x;x1++)	<span class="comment">//迷宫宽 </span></span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;input;</span><br><span class="line">			<span class="keyword">if</span>(input==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">				maps[y1][x1]=<span class="literal">true</span>;	<span class="comment">//如果输入是1就标记不可走</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="built_in">bfs</span>(x,y);	<span class="comment">//bfs 迷宫长宽 与 xy坐标是相反的 所以传反着的坐标 </span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p><strong>在使用bfs中，要根据题目数据选择合适的数据类型。</strong><br>bfs的题中往往不会只让你输出最短路径的长度，一般还会带点别的东西，所以要建立合适的结构来储存数据。<br><strong>bfs的常用环境</strong><br>一般是用来寻找不带权值的图的最短路。问题关键词常为“能否到达”、“最短路径”。<br>目前来看蓝桥杯中对bfs的考察度往往低于dfs，但是蓝桥杯最近几年对bfs的考察也在变多，所以还得好好练。<br><strong>总之，还是得多刷题，多积累经验。</strong></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言实现大整数加减 数组实现</title>
    <url>/2020/10/13/20201013_C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p><strong>C语言通过数组实现大整数加减法</strong></p>
<span id="more"></span>

<h1 id="思路导图"><a href="#思路导图" class="headerlink" title="思路导图"></a>思路导图</h1><p><img src="/images/2020-10-13/1.jpg#pic_center" alt="在这里插入图片描述"><br><img src="/images/2020-10-13/2.jpg#pic_center" alt="在这里插入图片描述"><br><img src="/images/2020-10-13/3.jpg#pic_center" alt="在这里插入图片描述"><br><img src="/images/2020-10-13/4.jpg#pic_center" alt="在这里插入图片描述"><br><img src="/images/2020-10-13/5.jpg#pic_center" alt="在这里插入图片描述"><br><img src="/images/2020-10-13/6.jpg#pic_center" alt="在这里插入图片描述"><br><img src="/images/2020-10-13/7.jpg#pic_center" alt="在这里插入图片描述"><br><img src="/images/2020-10-13/8.jpg#pic_center" alt="在这里插入图片描述"><br><img src="/images/2020-10-13/9.jpg#pic_center" alt="在这里插入图片描述"><br><img src="/images/2020-10-13/10.jpg#pic_center" alt="在这里插入图片描述"><br><img src="/images/2020-10-13/11.jpg#pic_center" alt="在这里插入图片描述"><br><img src="/images/2020-10-13/12.jpg#pic_center" alt="在这里插入图片描述"><br><img src="/images/2020-10-13/13.jpg#pic_center" alt="在这里插入图片描述"></p>
<h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span>* count_1,<span class="type">int</span> *count_2,<span class="type">int</span> *ans,<span class="type">int</span> max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;max;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		ans[now]+=count_1[now]+count_2[now];<span class="comment">//这一位的值加上第一个数组的该位值 再加上第二个数组的该位值 </span></span><br><span class="line">		<span class="keyword">if</span>(ans[now]&gt;=<span class="number">10</span>)<span class="comment">//大于10就进位 </span></span><br><span class="line">		&#123;</span><br><span class="line">			ans[now<span class="number">+1</span>]+=<span class="number">1</span>;<span class="comment">//进一位</span></span><br><span class="line">			ans[now]%=<span class="number">10</span>;<span class="comment">//留下个位 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sub</span><span class="params">(<span class="type">int</span>* count_1,<span class="type">int</span> *count_2,<span class="type">int</span> *ans,<span class="type">int</span> max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;max;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		ans[now]+=count_1[now]-count_2[now];<span class="comment">//这一位的值等于第一个数组的该位值 减去第二个数组的该位值 </span></span><br><span class="line">		<span class="keyword">if</span>(ans[now]&lt;<span class="number">0</span>)<span class="comment">//如果该位数字小于0 </span></span><br><span class="line">		&#123;</span><br><span class="line">			ans[now]+=<span class="number">10</span>;<span class="comment">//借一位 加10 </span></span><br><span class="line">			ans[now<span class="number">+1</span>]--;<span class="comment">//前一位-1; </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> *ans,<span class="type">int</span> max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">bool</span> kg=<span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=max<span class="number">-1</span>;now&gt;=<span class="number">0</span>;now--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(ans[now]!=<span class="number">0</span>||kg==<span class="literal">true</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans[now]);	</span><br><span class="line">			kg=<span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> string0[<span class="number">1000</span>],*front,*after,sign;<span class="comment">//输入的字符串 切割后的第一个字符串front 第二个字符串after 符号 </span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,string0);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(string0[now]==<span class="string">&#x27;+&#x27;</span>)<span class="comment">//找到加号 </span></span><br><span class="line">		&#123;</span><br><span class="line">			sign=<span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">			front=<span class="built_in">strtok_r</span>(string0,<span class="string">&quot;+&quot;</span>,&amp;after);<span class="comment">//切割 </span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(string0[now]==<span class="string">&#x27;-&#x27;</span>)<span class="comment">//找到减号 </span></span><br><span class="line">		&#123;</span><br><span class="line">			sign=<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">			front=<span class="built_in">strtok_r</span>(string0,<span class="string">&quot;-&quot;</span>,&amp;after);<span class="comment">//切割 </span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> n=<span class="built_in">strlen</span>(front),m=<span class="built_in">strlen</span>(after);<span class="comment">//两个数的位数 用于下一行的最大位数的选择 </span></span><br><span class="line">	<span class="type">int</span> max;<span class="comment">//最大位数 不超过两个数最大位数+1 </span></span><br><span class="line">	<span class="keyword">if</span>(n&gt;m)<span class="comment">//n比m大 </span></span><br><span class="line">	&#123;</span><br><span class="line">		max=n<span class="number">+1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		max=m<span class="number">+1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> count_1[max], count_2[max], ans[max];<span class="comment">//第一个数的数组 第二个数的数组 答案 </span></span><br><span class="line">	<span class="built_in">memset</span>(count_1,<span class="number">0</span>,<span class="built_in">sizeof</span>(count_1));</span><br><span class="line">	<span class="built_in">memset</span>(count_2,<span class="number">0</span>,<span class="built_in">sizeof</span>(count_2));</span><br><span class="line">	<span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="built_in">sizeof</span>(ans));<span class="comment">//每一位都初始化为0  </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;n;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		count_1[now]=front[n-now<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;m;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		count_2[now]=after[m-now<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot; = &quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(sign==<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">add</span>(count_1,count_2,ans,max);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(n&gt;m)<span class="comment">// 1 比 2 长 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">sub</span>(count_1,count_2,ans,max);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(n==m)<span class="comment">//一样长 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">bool</span> state=<span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> a=max<span class="number">-1</span>;a&gt;=<span class="number">0</span>&amp;&amp;state==<span class="literal">false</span>;a--)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(count_1[a]&gt;count_2[a])</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">sub</span>(count_1,count_2,ans,max);</span><br><span class="line">					state=<span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(count_1[a]&lt;count_2[a])</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">					<span class="built_in">sub</span>(count_2,count_1,ans,max);</span><br><span class="line">					state=<span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(state==<span class="literal">false</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//1 比 2 短 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">			<span class="built_in">sub</span>(count_2,count_1,ans,max);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> 	<span class="built_in">print</span>(ans,max);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言读取csv文件数据并分组</title>
    <url>/2020/09/11/20200911_C%E8%AF%AD%E8%A8%80%E8%AF%BB%E5%8F%96csv%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%88%86%E7%BB%84/</url>
    <content><![CDATA[<p><strong>核心就是.csv文件各组数据之间用‘,’逗号来分割，我们使用C语言的strtok函数对.csv文件的每一行数据进行分割即可。</strong></p>
<span id="more"></span>

<p><strong>代码如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cut</span><span class="params">(<span class="type">char</span> *line,<span class="type">int</span> num)</span><span class="comment">//读入这一行的数据 / 数据的组数-1（逗号的个数） </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> *temp;</span><br><span class="line">    temp=<span class="built_in">strtok</span>(line,<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(temp)</span><br><span class="line">	&#123;</span><br><span class="line">   		<span class="built_in">printf</span>(<span class="string">&quot;第1组数据：%6s\t&quot;</span>,temp);<span class="comment">//第一组数据 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;num<span class="number">-1</span>;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		temp = <span class="built_in">strtok</span>(<span class="literal">NULL</span>,<span class="string">&quot;,&quot;</span>);</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">&quot;第%d组数据：%6s\t&quot;</span>,now<span class="number">+2</span>,temp);<span class="comment">//中间的数据 </span></span><br><span class="line">  	&#125;</span><br><span class="line">  	temp = <span class="built_in">strtok</span>(<span class="literal">NULL</span>,<span class="string">&quot;,&quot;</span>);</span><br><span class="line">  	temp[<span class="built_in">strlen</span>(temp)<span class="number">-1</span>]=<span class="string">&#x27;\0&#x27;</span>;<span class="comment">//把fgets读取的回车去掉 </span></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">&quot;第%d组数据：%6s\n&quot;</span>,num<span class="number">+1</span>, temp);<span class="comment">//最后一组数据 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*if(argc!=3)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        return 0;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    </span><br><span class="line">    FILE *file = <span class="built_in">fopen</span>(<span class="string">&quot;minute.csv&quot;</span>,<span class="string">&quot;r&quot;</span>);<span class="comment">//读文件 </span></span><br><span class="line">    <span class="keyword">if</span>(!file)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;file error&quot;</span>);</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">char</span> line[<span class="number">1024</span>];</span><br><span class="line">	<span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fgets</span>(line,<span class="number">1024</span>,file);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;line[now]!=<span class="string">&#x27;\n&#x27;</span>;now++)<span class="comment">//通过统计分割的逗号 来统计数据的组数 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(line[now]==<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			num++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;一共有%d组数据\n&quot;</span>,num<span class="number">+1</span>);<span class="comment">//有num个逗号 就是有num+1组数据 </span></span><br><span class="line">	<span class="built_in">cut</span>(line,num);<span class="comment">//分割输出第一行 </span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">fgets</span>(line,<span class="number">1024</span>,file)!=<span class="literal">NULL</span>)<span class="comment">//对之后行进行分割 </span></span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">cut</span>(line,num);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>2019 蓝桥杯 C/C++实现 B组国赛</title>
    <url>/2020/11/12/20201112_2019%E8%93%9D%E6%A1%A5%E6%9D%AFC-C++%E5%AE%9E%E7%8E%B0B%E7%BB%84%E5%9B%BD%E8%B5%9B/</url>
    <content><![CDATA[<p><strong>2019 蓝桥杯 C&#x2F;C++实现 B组国赛 题目 &amp; 题解</strong></p>
<span id="more"></span>

<h1 id="A：平方序列"><a href="#A：平方序列" class="headerlink" title="A：平方序列"></a>A：平方序列</h1><p>请找到两个正整数X和Y满足下列条件：<br>1、2019&lt;X&lt;Y<br>2、2019^2^、X^2^、Y^2^构成等差数列<br>满足条件的X和Y可能有多种情况，请给出X+Y的值，并且令X+Y尽可能的小。</p>
<p><strong>思路：</strong> 两层暴力循环。</p>
<p><strong>答案：</strong> 7020</p>
<p><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> t=<span class="number">2019</span>*<span class="number">2019</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">2020</span>;x&lt;<span class="number">10000</span>;x++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> y=x<span class="number">+1</span>;y&lt;<span class="number">10000</span>;y++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl;</span></span><br><span class="line">			<span class="keyword">if</span>(y*y-x*x==x*x-t)</span><br><span class="line">			&#123;</span><br><span class="line">				cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;y&lt;&lt;endl;</span><br><span class="line">				cout&lt;&lt;x+y;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B：质数拆分"><a href="#B：质数拆分" class="headerlink" title="B：质数拆分"></a>B：质数拆分</h1><p>2019可以被分解成若干个两两不同的素数，请问不同的分解方案有多少种？<br>注意：分解方案不考虑顺序，如2+2017&#x3D;2019和2017+2&#x3D;2019属于同一种方案。</p>
<p><strong>思路：</strong> 动态规划。dp[a][b]表示数字a拆成若干份，最大值为b的方法数。<br>可知，状态转移方程为</p>
<ul>
<li>dp[a][b] &#x3D; (dp[a-b][2]+dp[a-b][3]+dp[a-b][5]+…+dp[a-b][b下的最大素数]);</li>
</ul>
<p>用双层循环对a和b进行遍历，其中b均为素数，最后对dp[2019]进行统计即可。</p>
<p><strong>答案：</strong> 55965365465060</p>
<p><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">2020</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;ps;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dp[M][M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shai</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">bool</span> kg=<span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">2</span>;now&lt;M;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		kg=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">2</span>;t&lt;=<span class="built_in">sqrt</span>(now);t++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(now%t==<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				kg=<span class="literal">false</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(kg==<span class="literal">true</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			ps.<span class="built_in">push_back</span>(now);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">shai</span>();</span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;ps.<span class="built_in">size</span>();now++)</span><br><span class="line">	&#123;</span><br><span class="line">		dp[ps[now]][ps[now]] = <span class="number">1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">2</span>;now&lt;M;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> count=<span class="number">0</span>;ps[count]&lt;now;count++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;count&amp;&amp;ps[t]&lt;=now-ps[count];t++)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[now][ps[count]] += dp[now-ps[count]][ps[t]];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;ps.<span class="built_in">size</span>();now++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,dp[M<span class="number">-1</span>][ps[now]]);</span><br><span class="line">		ans+=dp[M<span class="number">-1</span>][ps[now]];	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n最终答案：%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C：拼接"><a href="#C：拼接" class="headerlink" title="C：拼接"></a>C：拼接</h1><p>小明要把一根木头切成两段，然后拼接成一个直角。</p>
<p>如下图所示，他把中间部分分成了 n × n 的小正方形，他标记了每个小正方形属于左边还是右边。<br><img src="/images/2020-11-12/1.jpg#pic_center" alt="1"></p>
<p>然后沿两边的分界线将木头切断，将右边旋转向上后拼接在一起。<br>要求每个小正方形都正好属于左边或右边，而且同一边的必须是连通的。<br>在拼接时，拼接的部位必须保持在原来大正方形里面。<br>请问，对于 7 × 7 的小正方形，有多少种合法的划分小正方形的方式。</p>
<h1 id="D：求值"><a href="#D：求值" class="headerlink" title="D：求值"></a>D：求值</h1><p>有一个7X7的方格。方格左上角顶点坐标为(0,0)，右下角坐标为(7,7)。<br>求满足下列条件的路径条数：<br>1、起点和终点都是(0,0)<br>2、路径不自交<br>3、路径长度不大于12<br>4、对于每一个顶点，有上下左右四个方向可以走，但是不能越界。<br>例如，图中路线，左上角顶点（0，0），路线长度为10<br><img src="/images/2020-11-12/2.jpg#pic_center" alt="图1"><br><strong>思路：</strong> dfs暴力搜索，为了防止路径重复，即(0,0) &gt; (0,1) &gt; (0,0)，(0,0) &gt; (1,0) &gt; (0,0)，我把初始点(0,0)进行标记，在坐标即将改变时进行判定。</p>
<p><strong>答案：</strong> 206</p>
<p><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> m[<span class="number">8</span>][<span class="number">8</span>];</span><br><span class="line"><span class="type">int</span> fx[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> nnn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(nnn&gt;=<span class="number">12</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;<span class="number">4</span>;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> tx = x + fx[now][<span class="number">0</span>];</span><br><span class="line">		<span class="type">int</span> ty = y + fx[now][<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(tx&lt;<span class="number">0</span>||ty&lt;<span class="number">0</span>||tx&gt;<span class="number">7</span>||ty&gt;<span class="number">7</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(tx==<span class="number">0</span>&amp;&amp;ty==<span class="number">0</span>&amp;&amp;nnn!=<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			ans++;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(m[tx][ty]==<span class="literal">true</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		m[tx][ty]=<span class="literal">true</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(tx,ty,nnn<span class="number">+1</span>);</span><br><span class="line">		m[tx][ty]=<span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(m,<span class="literal">false</span>,<span class="built_in">sizeof</span>(m));</span><br><span class="line">	m[<span class="number">0</span>][<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="E：路径计数"><a href="#E：路径计数" class="headerlink" title="E：路径计数"></a>E：路径计数</h1><p>有1个约数的最小数为1（1），有两个约数的最小数为2（1，2）……<br>有n个约数的最小数为Sn<br>S1&#x3D;1 （1）<br>S2&#x3D;2 （1 2）<br>S3&#x3D;4 （1 2 4）<br>S4&#x3D;6 （1 2 3 6）<br>求S100</p>
<p><strong>思路：</strong> 两层暴力循环。</p>
<p><strong>答案：</strong> 45360</p>
<p><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">100</span>;;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		ans=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">2</span>;t&lt;=now;t++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(now%t==<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				ans++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(ans==<span class="number">100</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout&lt;&lt;now;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="F：最优包含"><a href="#F：最优包含" class="headerlink" title="F：最优包含"></a>F：最优包含</h1><p>我们称一个字符串 S 包含字符串 T 是指 T 是 S 的一个子序列，即可以从字符串 S 中抽出若干个字符，它们按原来的顺序组合成一个新的字符串与 T 完全一样。</p>
<p>给定两个字符串 S 和 T，请问最少修改 S 中的多少个字符，能使 S 包含 T？</p>
<p><strong>输入格式：</strong><br>输入两行，每行一个字符串。<br>第一行的字符串为 S，第二行的字符串为 T。<br>两个字符串均非空而且只包含大写英文字母。</p>
<p><strong>输出格式：</strong><br>输出一个整数，表示答案。</p>
<p><strong>数据范围：</strong><br>1≤|T|≤|S|≤1000</p>
<p><strong>输入样例：</strong><br>ABCDEABCD<br>XAABZ</p>
<p><strong>输出样例：</strong><br>3</p>
<p><a href="https://www.acwing.com/problem/content/2555/">OJ链接</a></p>
<p><strong>AC代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">	string s1,s2;</span><br><span class="line">	cin&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;=s<span class="number">2.</span><span class="built_in">size</span>();x++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> y=x;y&lt;=s<span class="number">1.</span><span class="built_in">size</span>();y++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(s1[y<span class="number">-1</span>]!=s2[x<span class="number">-1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(y&gt;x)</span><br><span class="line">					dp[x][y] = <span class="built_in">min</span>(dp[x<span class="number">-1</span>][y<span class="number">-1</span>]<span class="number">+1</span>,dp[x][y<span class="number">-1</span>]);</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					dp[x][y] = dp[x<span class="number">-1</span>][y<span class="number">-1</span>]<span class="number">+1</span>; </span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				dp[x][y] = dp[x<span class="number">-1</span>][y<span class="number">-1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;dp[s<span class="number">2.</span><span class="built_in">size</span>()][s<span class="number">1.</span><span class="built_in">size</span>()];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="G：排列数"><a href="#G：排列数" class="headerlink" title="G：排列数"></a>G：排列数</h1><p>在一个排列中，一个折点是指排列中的一个元素，它同时小于两边的元素，或者同时大于两边的元素。<br>对于一个 1 ∼ n 的排列，如果可以将这个排列中包含 t 个折点，则它称为一个 t + 1 单调序列。<br>例如，排列 (1, 4, 2, 3) 是一个 3 单调序列，其中 4 和 2 都是折点。</p>
<p>给定 n 和 k，请问 1 ∼ n 的所有排列中有多少个 k 单调队列？</p>
<p><strong>输入格式：</strong><br>输入一行包含两个整数 n, k。</p>
<p><strong>输出格式：</strong><br>输出一个整数，表示答案。答案可能很大，你可需要输出满足条件的排列数量除以 123456 的余数即可。</p>
<p><strong>样例输入：</strong><br>4 2</p>
<p><strong>样例输出：</strong><br>12</p>
<p><strong>数据范围：</strong><br>对于 20% 的评测用例，1 ≤ k ≤ n ≤ 10；<br>对于 40% 的评测用例，1 ≤ k ≤ n ≤ 20；<br>对于 60% 的评测用例，1 ≤ k ≤ n ≤ 100；<br>对于所有评测用例，1 ≤ k ≤ n ≤ 500。</p>
<h1 id="H：解谜游戏"><a href="#H：解谜游戏" class="headerlink" title="H：解谜游戏"></a>H：解谜游戏</h1><p><img src="/images/2020-11-12/3.jpg#pic_center" alt="2"></p>
<p>小明正在玩一款解谜游戏，谜题由 24 根塑料棒组成，</p>
<p>其中黄色塑料棒 4 根，红色 8 根，绿色 12 根 (后面用 Y 表示黄色、R 表示红色、G 表示绿色)。</p>
<p>初始时这些塑料棒排成三圈，如上图所示，外圈 12 根，中圈 8 根，内圈 4 根。</p>
<p>小明可以进行三种操作：</p>
<p>将三圈塑料棒都顺时针旋转一个单位。<br>例如当前外圈从 0 点位置开始，顺时针依次是 YRYGRYGRGGGG，中圈是 RGRGGRRY，内圈是 GGGR。<br>那么顺时针旋转一次之后，外圈、中圈、内圈依次变为：GYRYGRYGRGGG、YRGRGGRR 和 RGGG。<br>将三圈塑料棒都逆时针旋转一个单位。<br>例如当前外圈从 0 点位置开始，顺时针依次是 YRYGRYGRGGGG，中圈是 RGRGGRRY，内圈是 GGGR。<br>那么逆时针旋转一次之后，外圈、中圈、内圈依次变为：RYGRYGRGGGGY、GRGGRRYR 和 GGRG<br>将三圈 0 点位置的塑料棒做一个轮换。<br>具体来说：外圈 0 点塑料棒移动到内圈 0 点，内圈 0 点移动到中圈 0 点，中圈 0 点移动到外圈 0 点。<br>例如当前外圈从 0 点位置开始顺时针依次是 YRYGRYGRGGGG，中圈是RGRGGRRY，内圈是 GGGR。<br>那么轮换一次之后，外圈、中圈、内圈依次变为：RRYGRYGRGGGG、GGRGGRRY 和 YGGR。<br>小明的目标是把所有绿色移动到外圈、所有红色移动中圈、所有黄色移动到内圈。给定初始状态，请你判断小明是否可以达成目标？</p>
<p><strong>输入格式：</strong><br>第一行包含一个整数 T，代表询问的组数。(1 ≤ T ≤ 100)。<br>每组询问包含 3 行：<br>第一行包含 12 个大写字母，代表外圈从 0 点位置开始顺时针每个塑料棒的颜色。<br>第二行包含 8 个大写字母，代表中圈从 0 点位置开始顺时针每个塑料棒的颜色。<br>第三行包含 4 个大写字母，代表内圈从 0 点位置开始顺时针每个塑料棒的颜色。</p>
<p><strong>输出格式：</strong><br>对于每组询问，输出一行 YES 或者 NO，代表小明是否可以达成目标。</p>
<p><strong>样例输入：</strong><br>2<br>GYGGGGGGGGGG<br>RGRRRRRR<br>YRYY<br>YGGGRRRRGGGY<br>YGGGRRRR<br>YGGG</p>
<p><strong>样例输出：</strong><br>YES<br>NO</p>
<h1 id="I：第八大奇迹"><a href="#I：第八大奇迹" class="headerlink" title="I：第八大奇迹"></a>I：第八大奇迹</h1><p>在一条 R 河流域，繁衍着一个古老的名族 Z，他们世代沿河而居，也在河边发展出了璀璨的文明。</p>
<p>Z 族在 R 河沿岸修建了很多建筑，最近，他们热衷攀比起来，他们总是在比谁的建筑建得最奇特。</p>
<p>幸好 Z 族人对奇特的理解都差不多，他们很快给每栋建筑都打了分，这样评选谁最奇特就轻而易举了。</p>
<p>于是，根据分值，大家很快评出了最奇特的建筑，称为大奇迹。</p>
<p>后来他们又陆续评选了第二奇特、第二奇特、……、第七奇特的建筑，依次称为第二大奇迹、第三大奇迹、……、第七大奇迹。</p>
<p>最近，他们开始评选第八奇特的建筑，准备命名为第八大奇迹，在评选中，他们遇到了一些问题。</p>
<p>首先，Z 族一直在发展，有的建筑被拆除又建了新的建筑，新建筑的奇特值和原建筑不一样，这使得评选不那么容易了。</p>
<p>其次，Z 族的每个人所生活的范围可能不一样，他们见过的建筑并不是所有的建筑，他们坚持他们自己所看到的第八奇特的建筑就是第八大奇迹。</p>
<p>Z 族首领最近很头疼这个问题，他害怕因为意见不一致导致 Z 族发生分歧。他找到你，他想先了解一下，民众自己认为的奇迹是怎样的。</p>
<p>现在告诉在 R 河周边的建筑的变化情况，以及在变化过程中一些人的生活范围，请编程求出每个人认为的第八大奇迹的奇特值是多少。</p>
<p><strong>输入格式：</strong><br>输入的第一行包含两个整数 L, N，分别表示河流的长度和要你处理的信息的数量。开始时河流沿岸没有建筑，或者说所有的奇特值为 0。<br>接下来 N 行，每行一条你要处理的信息。<br>如果信息为 C p x，表示流域中第 p 个位置 (1 ≤ p ≤ L) 建立了一个建筑，其奇特值为 x。如果这个位置原来有建筑，原来的建筑会被拆除。<br>如果信息为 Q a b，表示有个人生活的范围是河流的第 a 到 b 个位置（包含 a 和 b，a ≤ b），这时你要算出这个区间的第八大奇迹的奇特值，并输出。如果找不到第八大奇迹，输出 0。</p>
<p><strong>输出格式：</strong><br>对于每个为 Q 的信息，你需要输出一个整数，表示区间中第八大奇迹的奇特值。</p>
<p><strong>样例输入：</strong><br>10 15<br>C 1 10<br>C 2 20<br>C 3 30<br>C 4 40<br>C 5 50<br>C 6 60<br>C 7 70<br>C 8 80<br>C 9 90<br>C 10 100<br>Q 1 2<br>Q 1 10<br>Q 1 8<br>C 10 1<br>Q 1 10</p>
<p><strong>样例输出：</strong><br>0<br>30<br>10<br>20</p>
<p><strong>数据范围：</strong><br>对于 20% 的评测用例，1 ≤ L ≤ 1000, 1 ≤ N ≤ 1000。<br>对于 40% 的评测用例，1 ≤ L ≤ 10000, 1 ≤ N ≤ 10000。<br>对于 100% 的评测用例，1 ≤ L ≤ 100000，1 ≤ N ≤ 100000。<br>所有奇特值为不超过 10^9^ 的非负整数。</p>
<h1 id="J：燃烧权杖"><a href="#J：燃烧权杖" class="headerlink" title="J：燃烧权杖"></a>J：燃烧权杖</h1><p>小 C 最近迷上了一款游戏。现在，在游戏中，小 C 有一个英雄，生命值为 x；敌人也有一个英雄，生命值为 y。</p>
<p>除此以外，还有 k 个士兵，生命值分别为a1 、a2 、……、ak，现在小 C 打算使用一个叫做“燃烧权杖”的技能。</p>
<p>“燃烧权杖”会每次等概率随机选择一个活着的角色（英雄或士兵），扣减其 10 点生命值，</p>
<p>然后如果该角色的生命值小于或等于 0，则该角色死亡，不会再被“燃烧权杖”选中。</p>
<p>“燃烧权杖”会重复做上述操作，直至任意一名英雄死亡。</p>
<p>小 C 想知道使用“燃烧权杖”后敌方英雄死亡（即，小 C 的英雄存活）的概率。</p>
<p>为了避免精度误差，你只需要输出答案模一个质数 p 的结果，具体见输出格式。</p>
<p><strong>输入格式：</strong><br>输入包含多组数据。<br>输入第一行包含一个正整数 T，表示数据组数。<br>接下来 T 组，每组数据第一行包含四个非负整数 x, y, p, k，分别表示小C的英雄的生命值、敌方英雄的生命值，模数和士兵个数。<br>第二行包含 k 个正整数 a1 、a2 、……、ak ，分别表示每个士兵的生命值。</p>
<p><strong>输出格式：</strong><br>对于每组数据，输出一行一个非负整数，表示答案模质数 p 的余数。可以证明，答案一定为有理数。<br>设答案为 a &#x2F; b（a 和 b 为互质的正整数），你输出的数为 x，则你需要保证 a 与 bx 模 p 同余；<br>也即，x &#x3D; (a·b−1 ) mod p，其中 b−1 表示 b 模 p 的逆元， mod 为取模运算。</p>
<p><strong>样例输入：</strong><br>6<br>1 10 101 0<br>100 1 101 0<br>50 30 4903 2<br>1 1<br>987 654 233 1<br>321<br>1000000000 999999999 233 3<br>1 2 3<br>1000000000 999999999 3 3<br>1 2 3</p>
<p><strong>样例输出：</strong><br>51<br>37<br>1035<br>118<br>117<br>2</p>
<p><strong>样例说明：</strong><br>对于第一组数据，所求概率即为“燃烧权杖”第一次就扣减敌方英雄 10 点生命值的概率，即 1&#x2F;2。2 × 51 模 101 余 1。<br>对于第二组数据，答案为 1023&#x2F;1024，1024 × 37 与 1023 模 101 同余。<br>对于第三组数据，答案为 99&#x2F;128。</p>
<p><strong>数据范围：</strong><br>对于 10% 的评测用例，x, y, a1 ,··· , ak ≤ 10。<br>对于 20% 的评测用例，x, y, a1,··· , ak ≤ 100。<br>对于 50% 的评测用例，x, y, a1 ,··· , ak ≤ 1000。<br>另有 10% 的评测用例，p &#x3D; 3。<br>另有 20% 的评测用例，p ≤ 100。<br>对于全部评测用例，1 ≤ x, y, a1 ,··· , ak ≤ 10^9^ ，3 ≤ p ≤ 10000 且 p 为质数，0 ≤ k ≤ 10。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构与算法</tag>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习记录：基于C++的快速学习</title>
    <url>/2021/01/08/20210108_Java%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E5%9F%BA%E4%BA%8EC++%E7%9A%84%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><strong>HB小咸鱼学习记录</strong></p>
<ul>
<li>初中的时候曾经学过一点java，算是程序的敲门砖，但是没想到上了大学最先深入学习的是C语言和C++。21年初这个寒假决定在家系统学习Java和网络编程，发个帖子记录过程，方便今后查看。</li>
</ul>
<span id="more"></span>

<h1 id="【前期准备】"><a href="#【前期准备】" class="headerlink" title="【前期准备】"></a>【前期准备】</h1><ul>
<li>Java JDK版本选择的是： <strong>“1.8.0_181”</strong></li>
<li>编译器我选择的是： <strong>Eclipse</strong></li>
<li>具体环境搭建方法由网络上查询得知，不多说了。</li>
<li>学习地址：（B站永远滴神）<br>[video(video-zPI8bhtB-1610116863147)(type-bilibili)(url-<a href="https://player.bilibili.com/player.html?aid=797299458)(image-https://ss.csdn.net/p?http://i2.hdslb.com/bfs/archive/73b9c56133cf2defc06255ca50a219156917272e.png)(title-%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98Java%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A-%E3%80%90%E5%9F%BA%E7%A1%80+%E9%AB%98%E7%BA%A7%E3%80%91-%E9%99%84%E5%85%A8%E5%A5%97%E8%B5%84%E6%96%99(IDEA%E7%89%88))%5D">https://player.bilibili.com/player.html?aid=797299458)(image-https://ss.csdn.net/p?http://i2.hdslb.com/bfs/archive/73b9c56133cf2defc06255ca50a219156917272e.png)(title-黑马程序员Java语言入门到精通-【基础+高级】-附全套资料(IDEA版))]</a></li>
</ul>
<h1 id="【笔记一】-1-基本语法"><a href="#【笔记一】-1-基本语法" class="headerlink" title="【笔记一】 1- 基本语法"></a>【笔记一】 1- 基本语法</h1><ol>
<li>C++里的include头文件和Java里的import包机制相似。</li>
<li>C++和Java代码执行的起点都是main函数。</li>
<li>变量关键字与C++基本一致。<strong>值得一提的是，由于Java里没有指针，所以Java中的字符串由字符串变量String储存。使用方法与C++&#x2F;STL里的string大同小异，记得Java里的String首字母要大写。</strong></li>
<li><strong>Java中申请数组时，分为动态分配和静态分配。动态分配为new申请内存后不设置各初始值，静态分配为new申请内存后直接设置各初始值。</strong><br> <code>int[] array1 = new int[3];//动态分配  int[] array2 = new int[]&#123;1,2,3&#125;;//静态分配</code></li>
<li><strong>Java中的数组和字符串都自带类似C++&#x2F;STL里的方法，例如length()就是获取长度。</strong></li>
<li>变量类型强制转换和C++一致都可以使用(int)double这样的格式进行转换。</li>
<li>字符类型与C++一致也是用的ASCII码。</li>
<li>if&#x2F;else条件判定语句与C++一致。</li>
<li>switch关键字的使用方法与C++一致。</li>
<li>for循环、while循环、do…while循环的使用方法与C++一致。</li>
<li>break和continue的使用方法与C++一致。</li>
<li><strong>Java中类的思路与C++中基本一致。注意Java类中的公&#x2F;私有标识符不用加 ‘:’ 。</strong></li>
<li>Java中类和方法的声明&#x2F;使用方法与C++基本一致。</li>
<li>对于只使用一次的对象，可以使用匿名对象，直接new就行。</li>
<li><strong>final</strong>关键字代表最终的，不可改变的。</li>
<li><strong>外部类名称.内部类名称 对象名 &#x3D; new 外部类名称().new 内部类名称();</strong> 直接声明内部类。</li>
<li>现在的编译器支持自动装箱和自动拆箱。</li>
<li>包装类除了<strong>int–Integer</strong>，<strong>char–Character</strong>，其余都是首字母大写。</li>
<li><strong>泛型省去了类型转换的麻烦，更加安全，但是只能储存一种数据。</strong></li>
<li><strong>native</strong>关键字，代表该方法调用的是本地操作系统的方法。</li>
<li>当方法的参数类型已经确定，但是参数个数不确定时，可以使用可变参数。<br><strong>修饰符 返回值类型 方法名(数据类型…变量名){}</strong> 底层为一个数组。</li>
</ol>
<h1 id="【笔记二】-115-118P-Scanner接收类"><a href="#【笔记二】-115-118P-Scanner接收类" class="headerlink" title="【笔记二】 115-118P  Scanner接收类"></a>【笔记二】 115-118P  Scanner接收类</h1><ol>
<li>Java接收输入的方式为调用Scanner类。需要导包：import java.util.Scanner;</li>
<li>接收数据的方法为:<br>字符串-<strong>Scanner.next()&#x2F;Scanner.nextLine();</strong><br>其余类型-<strong>Scanner.next类型();</strong>  如：int-Scanner.nextInt(); double-Scanner.nextDouble();</li>
</ol>
<h1 id="【笔记三】-121-124P-Random随机数类"><a href="#【笔记三】-121-124P-Random随机数类" class="headerlink" title="【笔记三】 121-124P  Random随机数类"></a>【笔记三】 121-124P  Random随机数类</h1><ol>
<li>Java生成随机数的方式为调用Random类。需要导包：import java.util.Random;</li>
<li>Random类生成随机数的方法和Scanner的方法类似，如<strong>Random.nextInt(100);</strong> 范围左闭右开，即[0,100)，0~99。</li>
</ol>
<h1 id="【笔记四】-133-142P-String字符串类"><a href="#【笔记四】-133-142P-String字符串类" class="headerlink" title="【笔记四】 133-142P  String字符串类"></a>【笔记四】 133-142P  String字符串类</h1><ol>
<li>不需要导包。</li>
<li>字符串比较方法：<strong>str1.equals(str2);</strong> 相同返回true。**.equalsIgnoreCase()** 忽略大小写。</li>
<li>字符串长度：<strong>str1.length();</strong> 返回字符串长度。</li>
<li>拼接字符串：<strong>str3 &#x3D; str1.concat(str2);</strong> 返回值为新的字符串地址。</li>
<li>获取字符串指定位置字符：<strong>char ch &#x3D; str1.charAt(1);</strong> 返回值为一个char。 </li>
<li>查找子串在主串中第一次出现的位置：<strong>int a &#x3D; str1.indexOf(“abc”);</strong> 返回值为第一次出现的索引位置。没有的话返回-1。</li>
<li>字符串截取方法：<br><strong>str2 &#x3D; str1.substring(5);</strong>&#x2F;&#x2F;从第5号截取到末尾<br><strong>str2 &#x3D; str1.substring(4,7);</strong>&#x2F;&#x2F;从4号截取到6号，左闭右开[4,7)</li>
<li>字符串转为char数组：<strong>char[] chars &#x3D; “hello”.toCharArray();</strong></li>
<li>字符串转为byte数组：<strong>byte[] bytes &#x3D; “hello”.getBytes();</strong></li>
<li>替换字符串内指定内容：<strong>String str1 &#x3D; “how do you do?”.replace(“o”,”*”);</strong>&#x2F;&#x2F;h*w d* y*u d*?</li>
<li>分割字符串：<strong>String[] array1 &#x3D; “aaa.bbb.ccc”.split(“\\.”);</strong>&#x2F;&#x2F;切成aaa,bbb,ccc三个字符串</li>
</ol>
<h1 id="【笔记五】-143-147P-static静态关键字"><a href="#【笔记五】-143-147P-static静态关键字" class="headerlink" title="【笔记五】 143-147P  static静态关键字"></a>【笔记五】 143-147P  static静态关键字</h1><ol>
<li><strong>当使用static进行修饰后，被修饰的方法&#x2F;变量不再属于对象，而是属于类。</strong></li>
<li>由于不再属于对象，所以带static的方法&#x2F;变量可以<strong>直接被调用</strong>。<br>静态方法：类名称.静态方法();<br>静态变量：类名称.静态变量;</li>
<li>静态不能直接访问非静态，例如静态方法访问非静态变量。</li>
<li>静态方法里也不能用this。</li>
<li><strong>对于静态变量初始化，我们可以使用静态代码块。静态代码块只在类第一次被声明时，执行一次。</strong></li>
<li>静态内容总是优先于非静态。</li>
</ol>
<h1 id="【笔记六】-148-149P-Arrays数组工具类"><a href="#【笔记六】-148-149P-Arrays数组工具类" class="headerlink" title="【笔记六】 148-149P  Arrays数组工具类"></a>【笔记六】 148-149P  Arrays数组工具类</h1><ol>
<li>需要导包：import java.util.Arrays;</li>
<li>将数组变为字符串：<strong>Arrays.toString();</strong><br>int[] a1 &#x3D; {10,20,30};<br>String s1 &#x3D; Arrays.toString(a1);&#x2F;&#x2F;[10, 20, 30]</li>
<li>数组排序：<strong>Arrays.sort();</strong><br>int[] a1 &#x3D; {20,10,30};<br>Arrays.sort(a1);&#x2F;&#x2F;10,20,30 默认为升序</li>
</ol>
<h1 id="【笔记七】-150-151P-Math数学工具类"><a href="#【笔记七】-150-151P-Math数学工具类" class="headerlink" title="【笔记七】 150-151P  Math数学工具类"></a>【笔记七】 150-151P  Math数学工具类</h1><ol>
<li>不需要导包。</li>
<li>取绝对值：<strong>Math.abs();</strong> 与C++一致，但是浮点数类型也是abs()，不是fabs()。</li>
<li>取平方根：<strong>Math.sqrt();</strong> 与C++一致。</li>
<li>求n次方：<strong>Math.pow(a,b);</strong> 求a的b次方，与C++一致。</li>
<li>比大小：<strong>Math.max(a,b) &#x2F; Math.min(a,b);</strong> a和b比大小，与C++一致。</li>
<li>向上取整：<strong>Math.ceil();</strong></li>
<li>向下取整：<strong>Math.floor();</strong></li>
<li>四舍五入：<strong>Math.round();</strong></li>
<li>Math包里还有常见的数学值，比如<strong>Math.PI</strong>是圆周率，<strong>Math.E</strong>是e值。</li>
</ol>
<h1 id="【笔记八】-171-184P-接口相关"><a href="#【笔记八】-171-184P-接口相关" class="headerlink" title="【笔记八】  171-184P  接口相关"></a>【笔记八】  171-184P  接口相关</h1><ol>
<li>接口<strong>没有</strong>静态代码块和构造方法。</li>
<li>一个类的父类只有一个，但是一个类可以同时实现<strong>多个</strong>接口。<br>当父类的方法与接口的默认方法冲突，<strong>优先父类</strong>。<br>当实现多个接口时存在<strong>默认方法冲突</strong>，需要对默认方法进行重写。<br>当实现多个接口时存在<strong>抽象方法冲突</strong>，只需要覆盖重写一次即可。</li>
<li>使用接口首先要定义接口类。<br><strong>定义接口类</strong>的格式如：<strong>public interface 接口名称 { 接口内容 }</strong></li>
<li>使用接口需要创建接口实现类对接口进行实现。<br><strong>接口实现类</strong>的格式如：<strong>public class 实现类名称 implements 接口名称 { … }</strong></li>
<li>接口中定义的变量均为常量。<br><strong>常量</strong>格式如：<strong>public static final 数据类型 常量名称 &#x3D; 数值;</strong> 前方三个关键词可省略。</li>
<li>接口中均为抽象方法，且实现类必须覆盖重写接口所有的抽象方法，除非实现类也是抽象类。(必须覆盖)<br><strong>抽象方法</strong>格式如：<strong>public abstract 返回值类型 方法名称(参数列表);</strong></li>
<li>Java8后，接口中可以定义默认方法。(可覆盖可不覆盖)<br><strong>默认方法</strong>格式如：<strong>public default 返回值类型 方法名称(参数列表) { 方法体 }</strong></li>
<li>Java8后，接口中可以定义静态方法。<br><strong>静态方法</strong>格式如：<strong>public static 返回值类型 方法名称(参数列表) { 方法体 }</strong></li>
<li>Java9后，接口中可以定义私有方法。(我的Java版本是1.8.0也就是Java8，所以不支持)<br><strong>普通私有方法</strong>格式如：<strong>private 返回值类型 方法名称(参数列表) { 方法体 }</strong><br><strong>静态私有方法</strong>格式如：<strong>private static 返回值类型 方法名称(参数列表) { 方法体 }</strong></li>
</ol>
<h1 id="【笔记九】-185-194P-继承与多态相关"><a href="#【笔记九】-185-194P-继承与多态相关" class="headerlink" title="【笔记九】  185-194P  继承与多态相关"></a>【笔记九】  185-194P  继承与多态相关</h1><ol>
<li><strong>C++继承用冒号，Java继承用关键字extends。</strong></li>
<li>@Override检测是否重写，总体来说，Java的类继承与C++的类继承很相似。</li>
<li><strong>Java不支持多重继承，所以有super关键字，用来找父类。</strong></li>
<li><strong>abstract为抽象关键字。抽象类&#x2F;抽象方法。</strong></li>
<li>访问成员变量的规则：<br>通过<strong>对象名称</strong>访问：看声明对象时对象的类型(等号左边)，没有就向上找。<br>通过<strong>成员方法</strong>访问：看方法属于谁，就优先用谁的成员变量，没有就向上找。</li>
<li>实现多态性：父类引用指向子类对象。<br>多态格式：<br><strong>父类名称 对象名 &#x3D; new 子类名称();<br>接口名称 对象名 &#x3D; new 实现类名称();</strong></li>
<li>根据第6条和第7条可知，多态中成员方法优先用子类的成员方法；通过对象名称访问成员变量，优先用父类的成员变量。</li>
<li><strong>“编译看左，运行看右”，即编译前把对象看为父类类型(左边)，运行时成员变量看左边，成员方法看右边。</strong></li>
<li>个人感觉，多态的存在使代码更加有逻辑性。</li>
<li><strong>向上转型</strong>：右侧new一个子类对象，把它当父类来看待。 (无法调用子类特有方法)</li>
<li><strong>向下转型</strong>：将父类对象，<strong>还原</strong>成为本来的子类对象。<br>格式：子类名称 对象名 &#x3D; (子类名称)父类对象；（有点像强制类型转换）</li>
<li><strong>对象 instanceof 类名称</strong> ：如果对象属于该类，则返回true。使用这个即可根据对象类型，来进行向下转型，使用子类特有方法。</li>
</ol>
<h1 id="【笔记十】-215-218P-Object-Objects根类"><a href="#【笔记十】-215-218P-Object-Objects根类" class="headerlink" title="【笔记十】  215-218P  Object&#x2F;Objects根类"></a>【笔记十】  215-218P  Object&#x2F;Objects根类</h1><ol>
<li>不需要导包。</li>
<li>**Object.toString()**：转换为字符串，默认转换对象的地址值，需重写。</li>
<li>**Object.equals(对象)**：比较对象是否相等，默认比较对象的地址值，需重写。</li>
<li>**Objects.equals(对象1,对象2)**：第二条的equals方法存在空指针异常可能，Objects的equals方法更加完善。</li>
</ol>
<h1 id="【笔记十一】-219-225P-日期时间类"><a href="#【笔记十一】-219-225P-日期时间类" class="headerlink" title="【笔记十一】  219-225P  日期时间类"></a>【笔记十一】  219-225P  日期时间类</h1><ul>
<li>Date类</li>
</ul>
<ol>
<li>需要导包：import java.util.Date;</li>
<li>Date类的空参构造函数为获取当前日期。</li>
<li>Date类的带参构造函数为传入一个long类型的毫秒值，根据毫秒值计算日期。0L为1970年1月1日0点。(中国是东八区加8个小时)</li>
<li>**Date.getTime()**：将日期转换为毫秒值，返回值为long类型。</li>
</ol>
<ul>
<li>DateFormat类</li>
</ul>
<ol start="5">
<li>需要导包：import java.text.DateFormat;</li>
<li>DateFomat类是一个抽象类，无法直接创建对象，可以使用其子类<strong>SimpleDateFormat(String pattern)</strong> </li>
<li>SimpleDateFormat类需要导包：import java.text.SimpleDateFormat;</li>
<li><strong>SimpleDateFormat s1 &#x3D; new SimpleDateFormat(“yyyy年MM月dd日 HH时mm分ss秒”);</strong> 构造函数传参按这个格式即可，字母不能变，其余可变。</li>
<li><strong>String str1 &#x3D; s1.format(Date对象);</strong> 将一个Date对象转换为SimpleDateFormat对象中指定格式的字符串。</li>
<li><strong>Date date &#x3D; s1.parse(“2020年01月04日 20时00分00秒”);</strong> 按照SimpleDateFormat对象的格式，转换为一个Date格式对象。</li>
</ol>
<ul>
<li>Calendar类</li>
</ul>
<ol start="11">
<li>需要导包：import java.util.Calendar; </li>
<li>Calendar类为抽象类，无法直接创建对象。</li>
<li><strong>Calendar c1 &#x3D; Calendar.getInstance();</strong> 使用多态方法，获取一个Calendar的子类。等号右边方法为获取Calendar的子类。</li>
<li>**Calendar.get(字段)**：返回日历指定字段的数值。例：c1.get(Calendar.YEAR);</li>
<li>**Calendar.set(字段,值)**：设置日历指定字段的数值。例：c1.set(Calendar.YEAR, 2020);</li>
<li>**Calendar.add(字段,值)**：使指定字段增加给定值，可以为负数。例：c1.add(Calendar.YEAR, -2);</li>
<li>**Calendar.getTime()**：将Calendar类转为Date类。例：Date date &#x3D; c1.getTime();</li>
</ol>
<h1 id="【笔记十二】-226-226P-System系统类"><a href="#【笔记十二】-226-226P-System系统类" class="headerlink" title="【笔记十二】 226-226P  System系统类"></a>【笔记十二】 226-226P  System系统类</h1><ol>
<li>不需要导包。 </li>
<li><strong>System.currentTimeMillis()：</strong> 返回以毫秒为单位的当前时间，可以用来计算程序的运行时间。</li>
<li><strong>System.arraycopy(参数1,参数2,参数3,参数4,参数5)：</strong> 将数组中指定的数据copy到另一个数组。<br><strong>参数1 &#x2F; 参数3</strong>：源数组 <strong>&#x2F;</strong> 目标数组。<br><strong>参数2 &#x2F; 参数4</strong>：源数组中的起始位置 <strong>&#x2F;</strong> 目标数组中的起始位置。<br><strong>参数5</strong>：要复制的数组元素的数量。</li>
</ol>
<h1 id="【笔记十三】-227-229P-StringBuilder字符串缓冲区类"><a href="#【笔记十三】-227-229P-StringBuilder字符串缓冲区类" class="headerlink" title="【笔记十三】  227-229P  StringBuilder字符串缓冲区类"></a>【笔记十三】  227-229P  StringBuilder字符串缓冲区类</h1><ol>
<li>不需要导包。</li>
<li><strong>字符串缓冲区，可以提高字符串的操作效率。</strong></li>
<li>String底层为final修饰的数组，而StringBuilder底层是没有被final修饰的数组，可以改变长度。</li>
<li><strong>StringBuilder()：</strong> 无参构造函数，默认建议一个空字符串。</li>
<li><strong>StringBuilder(String str)：</strong> 带参构造函数，建立一个内容为str的字符串。</li>
<li><strong>append(参数)：</strong> 向对象里添加指定参数内容。返回值为”this”，故不用接收返回值。</li>
<li><strong>toString()：</strong> 将一个StringBuilder对象转为String对象，返回一个String对象，需要接收。</li>
</ol>
<h1 id="【笔记十四】-234-281P-容器及其相关"><a href="#【笔记十四】-234-281P-容器及其相关" class="headerlink" title="【笔记十四】  234-281P  容器及其相关*"></a>【笔记十四】  234-281P  容器及其相关*</h1><p> &emsp;<strong>详情请看我的另一篇文章</strong>：<a href="https://blog.csdn.net/qq_45698148/article/details/112799775">链接点我</a><br> &emsp;<strong>其中介绍了Java容器及其相关内容。</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java容器及其相关学习记录</title>
    <url>/2021/01/19/20210119_Java%E5%AE%B9%E5%99%A8%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p><strong>本文主要记录Java容器相关的内容。</strong><br><strong>更多详细Java学习记录，请看我的另一篇文章：</strong><a href="https://zgg2001.github.io/2021/01/08/20210108_Java%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E5%9F%BA%E4%BA%8EC++%E7%9A%84%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0/#more">链接点我</a></p>
<span id="more"></span>

<h1 id="1-容器关系图"><a href="#1-容器关系图" class="headerlink" title="1.容器关系图"></a>1.容器关系图</h1><p>如图所示：<br><img src="/images/2021-01-19/1.jpg" alt="Java容器关系图"></p>
<h1 id="2-Iterator迭代器"><a href="#2-Iterator迭代器" class="headerlink" title="2.Iterator迭代器"></a>2.Iterator迭代器</h1><p>主要用于遍历Collection中的元素。由于Java没有指针，所以迭代器的使用相比C++更复杂一点。</p>
<h2 id="2-1-常用方法"><a href="#2-1-常用方法" class="headerlink" title="2.1 常用方法"></a>2.1 常用方法</h2><ul>
<li><strong>import java.util.Iterator;</strong></li>
<li><strong>public E next()</strong> ：返回迭代的下一个元素。</li>
<li><strong>public boolean hasNext()</strong> ：如果仍有元素可以迭代，返回true。</li>
<li><strong>public void remove()：</strong> 删除当前指针所指向的元素，一般和next方法一起用，这时候的作用就是删除next方法返回的元素。</li>
</ul>
<h2 id="2-2-使用实例"><a href="#2-2-使用实例" class="headerlink" title="2.2 使用实例"></a>2.2 使用实例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		Collection&lt;Integer&gt; t1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		t1.add(<span class="number">1</span>);</span><br><span class="line">		t1.add(<span class="number">2</span>);</span><br><span class="line">		t1.add(<span class="number">3</span>);</span><br><span class="line">		t1.add(<span class="number">4</span>);</span><br><span class="line">		t1.add(<span class="number">5</span>);</span><br><span class="line">		<span class="comment">//while循环遍历</span></span><br><span class="line">		Iterator&lt;Integer&gt; iter1 = t1.iterator();</span><br><span class="line">		<span class="keyword">while</span>(iter1.hasNext())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> iter1.next();</span><br><span class="line">			System.out.println(temp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//for循环遍历</span></span><br><span class="line">		<span class="keyword">for</span>(Iterator&lt;Integer&gt; iter2 = t1.iterator();iter2.hasNext();)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> iter2.next();</span><br><span class="line">			System.out.println(temp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-增强for循环"><a href="#2-3-增强for循环" class="headerlink" title="2.3 增强for循环"></a>2.3 增强for循环</h2><p>增强for循环，用来遍历集合和数组。<br>是JDK1.5之后出现的新特性，底层使用的也是迭代器，但是简化了使用方法。(不用导Iterator包)</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(集合/数组的数据类型 变量名 : 集合名/数组名)</span><br><span class="line">&#123;</span><br><span class="line">	System.out.println(变量名);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		Collection&lt;Integer&gt; t1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		t1.add(<span class="number">1</span>);</span><br><span class="line">		t1.add(<span class="number">2</span>);</span><br><span class="line">		t1.add(<span class="number">3</span>);</span><br><span class="line">		t1.add(<span class="number">4</span>);</span><br><span class="line">		t1.add(<span class="number">5</span>);</span><br><span class="line">		<span class="comment">//增强for循环</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i : t1)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-Collection（单列集合）"><a href="#3-Collection（单列集合）" class="headerlink" title="3.Collection（单列集合）"></a>3.Collection（单列集合）</h1><p>Collection是所有单列集合的父接口，其中定义了单列集合(List和Set)通用的一些方法，<strong>这些方法可以用于操作所有的单列集合</strong>。</p>
<ul>
<li><strong>import java.util.Collection;</strong></li>
<li><strong>public boolean add(E e)</strong> ：把给定的对象添加到当前集合中。</li>
<li><strong>public void clear()</strong> ：清空集合中的所有元素。</li>
<li><strong>public boolean remove(E e)</strong> ：把给定的对象在当前集合中删除。</li>
<li><strong>public boolean contains(E e)</strong> ：判断当前集合中是否包含给定的对象。</li>
<li><strong>public boolean isEmpty()</strong> ：判断当前集合是否为空。</li>
<li><strong>public int size()</strong> ：返回集合中元素的个数。</li>
<li><strong>public Object[] toarray()</strong> ：把集合中的元素，储存到数组中。</li>
<li><strong>public Iterator iterator()</strong> ： 获取集合所依赖的迭代器对象。</li>
</ul>
<h2 id="3-1-List（列表）"><a href="#3-1-List（列表）" class="headerlink" title="3.1 List（列表）"></a>3.1 List（列表）</h2><p>List接口为有序的集合，并且存在索引，**包含了一些带索引的方法(特有)**。List接口中允许存储重复的元素。</p>
<ul>
<li><strong>import java.util.List;</strong></li>
<li><strong>public void add(int index, E element)</strong> ：将指定的元素，添加到该集合指定的位置上。</li>
<li><strong>public E get(int index)</strong> ：返回集合中指定位置的元素。</li>
<li><strong>public E remove(int index)</strong> ：移除列表中指定的元素，返回的为被移除的元素。</li>
<li><strong>public E set(int index, E element)</strong> ：用指定的元素替换集合中指定位置的元素，返回值为更新前的元素。</li>
</ul>
<h3 id="3-1-1-ArrayList"><a href="#3-1-1-ArrayList" class="headerlink" title="3.1.1 ArrayList"></a>3.1.1 ArrayList</h3><p>ArrayList储存结构为<strong>数组</strong>结构，通过List接口实现大小可变的数组。<strong>元素增删慢，查找快。</strong><br>ArrayList的实现是多线程的，也就是<strong>实现不是同步的</strong>，效率高，但是存在线程安全问题。</p>
<ul>
<li><strong>import java.util.ArrayList;</strong></li>
</ul>
<h3 id="3-1-2-LinkedList"><a href="#3-1-2-LinkedList" class="headerlink" title="3.1.2 LinkedList"></a>3.1.2 LinkedList</h3><p>LinkedList储存结构为<strong>链表</strong>结构，通过List接口实现双向链表。<strong>元素增删快，查找慢。</strong><br>LinkedList提供了大量首尾操作的<strong>特有</strong>方法，跟C++的STL<strong>队列</strong>方法思路都差不多。</p>
<ul>
<li><strong>import java.util.LinkedList;</strong></li>
<li><strong>public void addFirst(E e)</strong> ：将指定元素添加到列表的开头。</li>
<li><strong>public void addLast(E e)</strong> ：将指定元素添加到列表的结尾。</li>
<li><strong>public E getFirst()</strong> ：返回此列表的第一个元素。</li>
<li><strong>public E getLast()</strong> ：返回此列表的最后一个元素。</li>
<li><strong>public E removeFirst()</strong> ：移除并返回列表的第一个元素。</li>
<li><strong>public E removeLast()</strong> ：移除并返回列表的最后一个元素。</li>
<li><strong>public E pop()</strong> ：从此列表的堆栈处弹出一个元素。<strong>此处等效于removeFirst();</strong></li>
<li><strong>public void push(E e)</strong> ：将元素推入列表的堆栈。<strong>此处等效于addFirst();</strong></li>
<li><strong>public boolean isEmpty()</strong> ：如果列表不包含元素，返回true。</li>
</ul>
<h3 id="3-1-3-Vector"><a href="#3-1-3-Vector" class="headerlink" title="3.1.3 Vector"></a>3.1.3 Vector</h3><p>Vector储存结构为<strong>数组</strong>结构，通过List接口实现大小可变的数组。<strong>元素增删慢，查找快。</strong><br>Vector的实现是单线程的，即<strong>实现是同步的</strong>，所以效率比ArrayList要低，但是不存在线程安全问题。</p>
<ul>
<li><strong>import java.util.Vector;</strong></li>
</ul>
<h2 id="3-2-Set（集合）"><a href="#3-2-Set（集合）" class="headerlink" title="3.2 Set（集合）"></a>3.2 Set（集合）</h2><p>Set接口与Collection接口中的方法基本一致，没有对Collection进行功能上的扩充，但是比Collection接口更加严格。<br><strong>Set接口中元素无序，且都会以某种规则保证存入的元素不出现重复。也不能通过普通的for循环进行遍历。</strong> (参考C++中的set即可)</p>
<ul>
<li><strong>import java.util.Set;</strong></li>
</ul>
<h3 id="3-2-1-HashSet"><a href="#3-2-1-HashSet" class="headerlink" title="3.2.1 HashSet"></a>3.2.1 HashSet</h3><p>底层为一个哈希表(数组加红黑树)，查询的速度非常快。且为一个<strong>无序</strong>的集合，存储和取出元素的顺序不一定一样。<br>在进行数据add存储时，首先使用hashCode()方法获取哈希值进行比较，如果无重复则直接填入。如果存在哈希冲突，则使用equals()方法进行判重，如果不存在重复则填入。</p>
<ul>
<li><strong>import java.util.HashSet;</strong></li>
<li><strong>在HashSet存储自定义类型元素时，需重写对象的hashCode方法和equals方法，建立自己的比较方式，从而保证集合中对象唯一。</strong></li>
</ul>
<h3 id="3-2-2-LinkedHashSet"><a href="#3-2-2-LinkedHashSet" class="headerlink" title="3.2.2 LinkedHashSet"></a>3.2.2 LinkedHashSet</h3><p>底层为一个哈希表+链表，多的这条链表用来记录元素的存储顺序，保证元素<strong>有序</strong>，即存储和取出元素的顺序一样。</p>
<ul>
<li><strong>import java.util.LinkedHashSet;</strong></li>
</ul>
<h1 id="4-Map（双列集合-图）"><a href="#4-Map（双列集合-图）" class="headerlink" title="4.Map（双列集合&#x2F;图）"></a>4.Map（双列集合&#x2F;图）</h1><p>Map为双列集合，一个元素里有两个值(key和value)。key不可重复，value可重复。</p>
<ul>
<li><strong>import java.util.Map;</strong></li>
<li><strong>public V put(K key, V value)</strong> ：把指定的键与指定的值添加到Map集合中。</li>
<li><strong>public V remove(Object key)</strong> ：把指定的键 所对应的键值对元素  在Map集合中删除，返回被删除元素的值。</li>
<li><strong>public V get(Object key)</strong> ：根据指定的键，在Map集合中获取对应的值。</li>
<li><strong>boolean containsKey(Object key)</strong> ：判断集合中是否包含指定的键。</li>
<li><strong>public Set&lt;K&gt; keySet()</strong> ：获取Map集合中所有的键，存储到Set集合中。</li>
<li><strong>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</strong> ：获取到Map集合中所有的 键值对 对象的集合(Set集合)。</li>
</ul>
<p><strong>实例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		Integer temp;</span><br><span class="line">		Map&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">		<span class="comment">//put添加元素 如果key不重复返回值为null;如果key重复,替换value,返回值是老value</span></span><br><span class="line">		temp = map.put(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>);<span class="comment">//temp = null</span></span><br><span class="line">		temp = map.put(<span class="string">&quot;张三&quot;</span>, <span class="number">19</span>);<span class="comment">//temp = 18</span></span><br><span class="line">		System.out.println(temp);</span><br><span class="line">		<span class="comment">//remove删除元素 key存在,返回value值;key不存在,返回null</span></span><br><span class="line">		map.put(<span class="string">&quot;李四&quot;</span>, <span class="number">20</span>);</span><br><span class="line">		temp = map.remove(<span class="string">&quot;李四&quot;</span>);<span class="comment">//temp = 20</span></span><br><span class="line">		temp = map.remove(<span class="string">&quot;王五&quot;</span>);<span class="comment">//temp = null</span></span><br><span class="line">		System.out.println(temp);</span><br><span class="line">		<span class="comment">//get获取元素 key存在,返回value值;key不存在,返回null</span></span><br><span class="line">		temp = map.get(<span class="string">&quot;张三&quot;</span>);<span class="comment">//temp = 19</span></span><br><span class="line">		temp = map.get(<span class="string">&quot;赵六&quot;</span>);<span class="comment">//temp = null</span></span><br><span class="line">		System.out.println(temp);</span><br><span class="line">		<span class="comment">//containsKey通过key判断集合中是否包含指定元素 存在返回true</span></span><br><span class="line">		<span class="type">boolean</span> <span class="variable">bool</span> <span class="operator">=</span> map.containsKey(<span class="string">&quot;张三&quot;</span>);<span class="comment">//true</span></span><br><span class="line">		bool = map.containsKey(<span class="string">&quot;赵六&quot;</span>);<span class="comment">//false</span></span><br><span class="line">		System.out.println(bool);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//keySet 获取一个set,其中储存了map的所有key值</span></span><br><span class="line">		Set&lt;String&gt; set = map.keySet();</span><br><span class="line">		<span class="keyword">for</span>(String i : set)<span class="comment">//随后就可以根据set使用增强for或者迭代器进行遍历</span></span><br><span class="line">		&#123;</span><br><span class="line">			temp = map.get(i);</span><br><span class="line">			System.out.println(i+<span class="string">&quot; &quot;</span>+temp);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//entrySet 返回一个set,其中储存了map中的所有Entry对象</span></span><br><span class="line">		Set&lt;Map.Entry&lt;String,Integer&gt;&gt; set1 = map.entrySet();</span><br><span class="line">		<span class="keyword">for</span>(Map.Entry&lt;String,Integer&gt; i : set1)<span class="comment">//遍历set集合,获取每一个Entry对象</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//通过Entry对象中的方法获取key和value</span></span><br><span class="line">			<span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> i.getKey();</span><br><span class="line">			<span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> i.getValue();</span><br><span class="line">			System.out.println(key+<span class="string">&quot; &quot;</span>+value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="4-1-HashMap"><a href="#4-1-HashMap" class="headerlink" title="4.1 HashMap"></a>4.1 HashMap</h2><p>底层为哈希表(数组+链表&#x2F;红黑树)，查询速度很快。且为一个<strong>无序</strong>的集合，存储和取出元素的顺序不一定一样。</p>
<ul>
<li><strong>import java.util.HashMap;</strong></li>
<li><strong>在HashMap存储自定义类型元素时，需重写key元素的hashCode方法和equals方法，从而保证key唯一。</strong></li>
</ul>
<h2 id="4-2-LinkedHashMap"><a href="#4-2-LinkedHashMap" class="headerlink" title="4.2 LinkedHashMap"></a>4.2 LinkedHashMap</h2><p>底层为哈希表+链表，多的这条链表用来记录元素的存储顺序，保证元素<strong>有序</strong>，即存储和取出元素的顺序一样。</p>
<ul>
<li><strong>import java.util.LinkedHashMap;</strong></li>
</ul>
<h2 id="4-3-Hashtable"><a href="#4-3-Hashtable" class="headerlink" title="4.3 Hashtable"></a>4.3 Hashtable</h2><p>底层为哈希表，与HashMap基本一致。其与HashMap的关系，类似Vector与ArrayList的关系。</p>
<p><strong>区别：</strong></p>
<ol>
<li>HashMap键值<strong>可以为null</strong>，但是Hashtable的键值都不能为空。</li>
<li>Hashtable为单线程，线程安全但是速度慢。</li>
</ol>
<ul>
<li><strong>import java.util.Hashtable;</strong></li>
</ul>
<h1 id="5-Collections集合工具类"><a href="#5-Collections集合工具类" class="headerlink" title="5.Collections集合工具类"></a>5.Collections集合工具类</h1><ul>
<li><strong>import java.util.Collections;</strong></li>
<li><strong>public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T…elements)</strong> ：往集合中添加一些元素。</li>
<li><strong>public static void shuffle(List&lt;?&gt; list)</strong> ：打乱集合顺序。</li>
<li><strong>public static &lt;T&gt; void sort(List&lt;T&gt; list)</strong> ：将集合中元素按照默认规则排序。(默认为升序)</li>
<li><strong>public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; )</strong> ：将集合中元素按照指定规则排序。</li>
</ul>
<p><strong>实例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		ArrayList&lt;Integer&gt; t1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		<span class="comment">//addAll 添加1，2，3，4，5</span></span><br><span class="line">		Collections.addAll(t1,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">		<span class="comment">//shuffle 打乱顺序 每次执行顺序都不一样</span></span><br><span class="line">		Collections.shuffle(t1);</span><br><span class="line">		<span class="comment">//sort默认排序 默认为升序</span></span><br><span class="line">		Collections.sort(t1);</span><br><span class="line">		<span class="comment">//sort自定义排序 降序</span></span><br><span class="line">		Collections.sort(t1,<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;()</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="meta">@Override</span><span class="comment">//重写compare方法</span></span><br><span class="line">			<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1,Integer o2)</span>/</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//后减前为降序 前减后为升序</span></span><br><span class="line">				<span class="keyword">return</span> o2-o1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="comment">//增强for循环</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i : t1)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(i);<span class="comment">//5 4 3 2 1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>C++网络编程学习：建立基础TCP服务端/客户端</title>
    <url>/2021/01/21/20210121_C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%BB%BA%E7%AB%8B%E5%9F%BA%E7%A1%80TCP%E6%9C%8D%E5%8A%A1%E7%AB%AF-%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
    <content><![CDATA[<ul>
<li>使用的语言为C&#x2F;C++</li>
<li>源码支持的平台为：Windows</li>
</ul>
<h1 id="一、建立简易TCP服务端"><a href="#一、建立简易TCP服务端" class="headerlink" title="一、建立简易TCP服务端"></a>一、建立简易TCP服务端</h1><h2 id="1-建立服务端大致流程"><a href="#1-建立服务端大致流程" class="headerlink" title="1.建立服务端大致流程"></a>1.建立服务端大致流程</h2><ol>
<li>建立一个套接字 <strong>（socket）</strong></li>
<li>绑定客户端连接的端口 <strong>（bind）</strong></li>
<li>监听网络端口 <strong>（listen）</strong></li>
<li>等待接受客户端连接 <strong>（accept）</strong></li>
<li>接收客户端发送的数据 <strong>（recv）</strong></li>
<li>向客户端发送数据 <strong>（send）</strong></li>
<li>关闭套接字 <strong>（closesocket）</strong></li>
</ol>
<span id="more"></span>

<h2 id="2-代码实现以及详细注释"><a href="#2-代码实现以及详细注释" class="headerlink" title="2.代码实现以及详细注释"></a>2.代码实现以及详细注释</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN<span class="comment">//消除下面两个头文件存在的冲突</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;winSock2.h&gt;</span><span class="comment">//此头文件应在windows.h头文件的上面，否则会有冲突</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//链接此动态链接库 windows特有 </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//启动windows socket 2,x环境 windows特有 </span></span><br><span class="line">	WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>);<span class="comment">//WinSock库版本号 </span></span><br><span class="line">	WSADATA dat;<span class="comment">//网络结构体 储存WSAStartup函数调用后返回的Socket数据 </span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span> != <span class="built_in">WSAStartup</span>(ver,&amp;dat))<span class="comment">//正确初始化后返回0 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//建立一个socket </span></span><br><span class="line">	SOCKET _mysocket = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,IPPROTO_TCP);<span class="comment">//IPV4 数据流类型 TCP类型 </span></span><br><span class="line">	<span class="keyword">if</span>(INVALID_SOCKET == _mysocket)<span class="comment">//建立失败 </span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">	<span class="comment">//绑定网络端口和IP地址 </span></span><br><span class="line">	sockaddr_in _myaddr = &#123;&#125;;<span class="comment">//建立sockaddr结构体  sockaddr_in结构体方便填写 但是下面要进行类型转换 </span></span><br><span class="line">	_myaddr.sin_family = AF_INET;<span class="comment">//IPV4</span></span><br><span class="line">	_myaddr.sin_port = <span class="built_in">htons</span>(<span class="number">8888</span>);<span class="comment">//端口 host to net unsigned short</span></span><br><span class="line">	_myaddr.sin_addr.S_un.S_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);<span class="comment">//网络地址 INADDR_ANY监听所有网卡的端口 </span></span><br><span class="line">	<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">bind</span>(_mysocket,(sockaddr*)&amp;_myaddr,<span class="built_in">sizeof</span>(sockaddr_in)))<span class="comment">//socket (强制转换)sockaddr结构体 结构体大小 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;绑定不成功&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;&quot;绑定成功&quot;&lt;&lt;endl; </span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//监听网络端口</span></span><br><span class="line">	<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">listen</span>(_mysocket,<span class="number">5</span>))<span class="comment">//套接字 最大多少人连接 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;监听失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;&quot;监听成功&quot;&lt;&lt;endl; </span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//等待接收客户端连接</span></span><br><span class="line">	sockaddr_in _clientAddr = &#123;&#125;;<span class="comment">//新建sockadd结构体接收客户端数据 </span></span><br><span class="line">	<span class="type">int</span> _addr_len = <span class="built_in">sizeof</span>(sockaddr_in);<span class="comment">//获取sockadd结构体长度 </span></span><br><span class="line">	SOCKET _temp_socket = INVALID_SOCKET;<span class="comment">//声明客户端套接字 </span></span><br><span class="line">	<span class="type">char</span> _buf[<span class="number">256</span>] = &#123;&#125;;<span class="comment">//接收客户端发送的消息 </span></span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		_temp_socket = <span class="built_in">accept</span>(_mysocket,(sockaddr*)&amp;_clientAddr,&amp;_addr_len);<span class="comment">//自身套接字 客户端结构体 结构体大小 </span></span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET == _temp_socket)<span class="comment">//接收失败 </span></span><br><span class="line">		&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;接收到无效客户端Socket&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;新客户端加入&quot;</span>&lt;&lt;endl; </span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;IP地址为：%s \n&quot;</span>, <span class="built_in">inet_ntoa</span>(_clientAddr.sin_addr));  </span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//接收客户端发送的数据 </span></span><br><span class="line">		<span class="type">char</span> _buf[<span class="number">256</span>] = &#123;&#125;;</span><br><span class="line">		<span class="type">int</span> _buf_len = <span class="built_in">recv</span>(_temp_socket,_buf,<span class="number">256</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(_buf_len&gt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,_buf);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//向客户端发送数据</span></span><br><span class="line">		<span class="type">char</span> _msg[] = <span class="string">&quot;HelloWorld&quot;</span>;</span><br><span class="line">		<span class="built_in">send</span>(_temp_socket,_msg,<span class="built_in">strlen</span>(_msg)<span class="number">+1</span>,<span class="number">0</span>);<span class="comment">//客户端套接字 数据 数据长短 flag </span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//关闭客户端socket</span></span><br><span class="line">		<span class="built_in">closesocket</span>(_temp_socket); </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//关闭socket </span></span><br><span class="line">	<span class="built_in">closesocket</span>(_mysocket); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//清除windows socket 环境 </span></span><br><span class="line">	<span class="built_in">WSACleanup</span>(); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="二、建立简易TCP客户端"><a href="#二、建立简易TCP客户端" class="headerlink" title="二、建立简易TCP客户端"></a>二、建立简易TCP客户端</h1><h2 id="1-建立客户端大致流程"><a href="#1-建立客户端大致流程" class="headerlink" title="1.建立客户端大致流程"></a>1.建立客户端大致流程</h2><ol>
<li>建立一个套接字 <strong>（socket）</strong></li>
<li>连接服务器 <strong>（connect）</strong></li>
<li>向客户端发送数据 <strong>（send）</strong></li>
<li>接收客户端发送的数据 <strong>（recv）</strong></li>
<li>关闭套接字 <strong>（closesocket）</strong></li>
</ol>
<h2 id="2-代码实现以及详细注释-1"><a href="#2-代码实现以及详细注释-1" class="headerlink" title="2.代码实现以及详细注释"></a>2.代码实现以及详细注释</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;winSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//链接此动态链接库 windows特有 </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//启动windows socket 2,x环境 windows特有 </span></span><br><span class="line">	WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>);<span class="comment">//WinSock库版本号 </span></span><br><span class="line">	WSADATA dat;<span class="comment">//网络结构体 储存WSAStartup函数调用后返回的Socket数据 </span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span> != <span class="built_in">WSAStartup</span>(ver,&amp;dat))<span class="comment">//正确初始化后返回0 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//建立一个socket </span></span><br><span class="line">	SOCKET _mysocket = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);<span class="comment">//IPV4 数据流类型 类型可以不用写 </span></span><br><span class="line">	<span class="keyword">if</span>(INVALID_SOCKET == _mysocket)<span class="comment">//建立失败 </span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//连接服务器</span></span><br><span class="line">    sockaddr_in _sin = &#123;&#125;;<span class="comment">//sockaddr结构体 </span></span><br><span class="line">    _sin.sin_family = AF_INET;<span class="comment">//IPV4</span></span><br><span class="line">    _sin.sin_port = <span class="built_in">htons</span>(<span class="number">8888</span>);<span class="comment">//想要连接的端口号 </span></span><br><span class="line">	_sin.sin_addr.S_un.S_addr =  <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);<span class="comment">//想要连接的IP </span></span><br><span class="line">	<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">connect</span>(_mysocket,(sockaddr*)&amp;_sin,<span class="built_in">sizeof</span>(sockaddr_in)))</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;连接失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">		<span class="built_in">closesocket</span>(_mysocket);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;连接成功&quot;</span>&lt;&lt;endl; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//向客户端发送数据</span></span><br><span class="line">	<span class="type">char</span> _msg[] = <span class="string">&quot;HelloServer&quot;</span>;</span><br><span class="line">	<span class="built_in">send</span>(_mysocket,_msg,<span class="built_in">strlen</span>(_msg)<span class="number">+1</span>,<span class="number">0</span>);<span class="comment">//客户端套接字 数据 数据长短 flag </span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//接收服务器信息 </span></span><br><span class="line">	<span class="type">char</span> _buf[<span class="number">256</span>] = &#123;&#125;;</span><br><span class="line">	<span class="type">int</span> _buf_len = <span class="built_in">recv</span>(_mysocket,_buf,<span class="number">256</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(_buf_len&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,_buf);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//关闭socket</span></span><br><span class="line">	<span class="built_in">closesocket</span>(_mysocket); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//清除windows socket 环境 </span></span><br><span class="line">	<span class="built_in">WSACleanup</span>(); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>


<h1 id="三、建立可持续处理请求的网络程序"><a href="#三、建立可持续处理请求的网络程序" class="headerlink" title="三、建立可持续处理请求的网络程序"></a>三、建立可持续处理请求的网络程序</h1><h2 id="1-思路"><a href="#1-思路" class="headerlink" title="1.思路"></a>1.思路</h2><p>&emsp;&emsp;在进行socket连接后，即服务端进行<strong>accept</strong>操作、客户端进行<strong>connect</strong>操作后，使用循环，在此循环中进行<strong>send&#x2F;recv</strong>操作传输数据，即可实现持续处理请求。</p>
<h2 id="2-代码实现以及详细注释-2"><a href="#2-代码实现以及详细注释-2" class="headerlink" title="2.代码实现以及详细注释"></a>2.代码实现以及详细注释</h2><h3 id="2-1-服务端代码"><a href="#2-1-服务端代码" class="headerlink" title="2.1 服务端代码"></a>2.1 服务端代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;winSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//链接此动态链接库 windows特有 </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//启动windows socket 2,x环境 windows特有 </span></span><br><span class="line">	WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>);<span class="comment">//WinSock库版本号 </span></span><br><span class="line">	WSADATA dat;<span class="comment">//网络结构体 储存WSAStartup函数调用后返回的Socket数据 </span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span> != <span class="built_in">WSAStartup</span>(ver,&amp;dat))<span class="comment">//正确初始化后返回0 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//建立一个socket </span></span><br><span class="line">	SOCKET _mysocket = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,IPPROTO_TCP);<span class="comment">//IPV4 数据流类型 TCP类型 </span></span><br><span class="line">	<span class="keyword">if</span>(INVALID_SOCKET == _mysocket)<span class="comment">//建立失败 </span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">	<span class="comment">//绑定网络端口和IP地址 </span></span><br><span class="line">	sockaddr_in _myaddr = &#123;&#125;;<span class="comment">//建立sockaddr结构体  sockaddr_in结构体方便填写 但是下面要进行类型转换 </span></span><br><span class="line">	_myaddr.sin_family = AF_INET;<span class="comment">//IPV4</span></span><br><span class="line">	_myaddr.sin_port = <span class="built_in">htons</span>(<span class="number">8888</span>);<span class="comment">//端口 host to net unsigned short</span></span><br><span class="line">	_myaddr.sin_addr.S_un.S_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);<span class="comment">//网络地址 INADDR_ANY监听所有网卡的端口 </span></span><br><span class="line">	<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">bind</span>(_mysocket,(sockaddr*)&amp;_myaddr,<span class="built_in">sizeof</span>(sockaddr_in)))<span class="comment">//socket (强制转换)sockaddr结构体 结构体大小 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;绑定不成功&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;&quot;绑定成功&quot;&lt;&lt;endl; </span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//监听网络端口</span></span><br><span class="line">	<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">listen</span>(_mysocket,<span class="number">5</span>))<span class="comment">//套接字 最大多少人连接 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;监听失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;&quot;监听成功&quot;&lt;&lt;endl; </span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//等待接收客户端连接</span></span><br><span class="line">	sockaddr_in _clientAddr = &#123;&#125;;<span class="comment">//新建sockadd结构体接收客户端数据 </span></span><br><span class="line">	<span class="type">int</span> _addr_len = <span class="built_in">sizeof</span>(sockaddr_in);<span class="comment">//获取sockadd结构体长度 </span></span><br><span class="line">	SOCKET _temp_socket = INVALID_SOCKET;<span class="comment">//声明客户端套接字 </span></span><br><span class="line">	<span class="type">char</span> _buf[<span class="number">256</span>] = &#123;&#125;;<span class="comment">//接收客户端发送的消息 </span></span><br><span class="line">	</span><br><span class="line">	_temp_socket = <span class="built_in">accept</span>(_mysocket,(sockaddr*)&amp;_clientAddr,&amp;_addr_len);<span class="comment">//自身套接字 客户端结构体 结构体大小 </span></span><br><span class="line">	<span class="keyword">if</span>(INVALID_SOCKET == _temp_socket)<span class="comment">//接收失败 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;接收到无效客户端Socket&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;新客户端加入&quot;</span>&lt;&lt;endl; </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;IP地址为：%s \n&quot;</span>, <span class="built_in">inet_ntoa</span>(_clientAddr.sin_addr));  </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)<span class="comment">//循环</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//接收客户端发送的数据 </span></span><br><span class="line">		<span class="type">int</span> _buf_len = <span class="built_in">recv</span>(_temp_socket,_buf,<span class="number">256</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(_buf_len&lt;=<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;客户端已退出\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(_buf,<span class="string">&quot;getname&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//向客户端发送数据</span></span><br><span class="line">			<span class="type">char</span> _msg[] = <span class="string">&quot;My name is Mr.Zhao&quot;</span>;</span><br><span class="line">			<span class="built_in">send</span>(_temp_socket,_msg,<span class="built_in">strlen</span>(_msg)<span class="number">+1</span>,<span class="number">0</span>);<span class="comment">//客户端套接字 数据 数据长短 flag </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(_buf,<span class="string">&quot;getage&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//向客户端发送数据</span></span><br><span class="line">			<span class="type">char</span> _msg[] = <span class="string">&quot;My age is 19&quot;</span>;</span><br><span class="line">			<span class="built_in">send</span>(_temp_socket,_msg,<span class="built_in">strlen</span>(_msg)<span class="number">+1</span>,<span class="number">0</span>);<span class="comment">//客户端套接字 数据 数据长短 flag </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//向客户端发送数据</span></span><br><span class="line">			<span class="type">char</span> _msg[] = <span class="string">&quot;???&quot;</span>;</span><br><span class="line">			<span class="built_in">send</span>(_temp_socket,_msg,<span class="built_in">strlen</span>(_msg)<span class="number">+1</span>,<span class="number">0</span>);<span class="comment">//客户端套接字 数据 数据长短 flag </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭客户端socket</span></span><br><span class="line">	<span class="built_in">closesocket</span>(_temp_socket);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭socket </span></span><br><span class="line">	<span class="built_in">closesocket</span>(_mysocket); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//清除windows socket 环境 </span></span><br><span class="line">	<span class="built_in">WSACleanup</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;任务结束，程序已退出&quot;</span>); </span><br><span class="line">	 </span><br><span class="line">	<span class="built_in">getchar</span>(); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="2-2-客户端代码"><a href="#2-2-客户端代码" class="headerlink" title="2.2 客户端代码"></a>2.2 客户端代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;winSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//链接此动态链接库 windows特有 </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//启动windows socket 2,x环境 windows特有 </span></span><br><span class="line">	WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>);<span class="comment">//WinSock库版本号 </span></span><br><span class="line">	WSADATA dat;<span class="comment">//网络结构体 储存WSAStartup函数调用后返回的Socket数据 </span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span> != <span class="built_in">WSAStartup</span>(ver,&amp;dat))<span class="comment">//正确初始化后返回0 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//建立一个socket </span></span><br><span class="line">	SOCKET _mysocket = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);<span class="comment">//IPV4 数据流类型 类型可以不用写 </span></span><br><span class="line">	<span class="keyword">if</span>(INVALID_SOCKET == _mysocket)<span class="comment">//建立失败 </span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//连接服务器</span></span><br><span class="line">    sockaddr_in _sin = &#123;&#125;;<span class="comment">//sockaddr结构体 </span></span><br><span class="line">    _sin.sin_family = AF_INET;<span class="comment">//IPV4</span></span><br><span class="line">    _sin.sin_port = <span class="built_in">htons</span>(<span class="number">8888</span>);<span class="comment">//想要连接的端口号 </span></span><br><span class="line">	_sin.sin_addr.S_un.S_addr =  <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);<span class="comment">//想要连接的IP </span></span><br><span class="line">	<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">connect</span>(_mysocket,(sockaddr*)&amp;_sin,<span class="built_in">sizeof</span>(sockaddr_in)))</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;连接失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">		<span class="built_in">closesocket</span>(_mysocket);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;连接成功&quot;</span>&lt;&lt;endl; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)<span class="comment">//循环</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//输入请求 </span></span><br><span class="line">		<span class="type">char</span> _msg[<span class="number">256</span>] = &#123;&#125;;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,_msg);</span><br><span class="line">		<span class="comment">//处理请求 </span></span><br><span class="line">		<span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(_msg,<span class="string">&quot;exit&quot;</span>))<span class="comment">//退出</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//向客户端发送数据</span></span><br><span class="line">			<span class="built_in">send</span>(_mysocket,_msg,<span class="built_in">strlen</span>(_msg)<span class="number">+1</span>,<span class="number">0</span>);<span class="comment">//客户端套接字 数据 数据长短 flag</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//接收服务器信息 </span></span><br><span class="line">		<span class="type">char</span> _buf[<span class="number">256</span>] = &#123;&#125;;</span><br><span class="line">		<span class="type">int</span> _buf_len = <span class="built_in">recv</span>(_mysocket,_buf,<span class="number">256</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(_buf_len&gt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,_buf);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭socket</span></span><br><span class="line">	<span class="built_in">closesocket</span>(_mysocket); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//清除windows socket 环境 </span></span><br><span class="line">	<span class="built_in">WSACleanup</span>(); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划学习记录：题型/思路汇总</title>
    <url>/2020/11/05/20201105_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E9%A2%98%E5%9E%8B%E6%80%9D%E8%B7%AF%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p><strong>动态规划学习记录</strong></p>
<p>记录了常见的一维与二维动态规划题目 &amp; 题解。</p>
<span id="more"></span>
<h1 id="一维数组动态规划"><a href="#一维数组动态规划" class="headerlink" title="一维数组动态规划"></a>一维数组动态规划</h1><ul>
<li>一般来说这类题数据都是一维的。例如只受价格影响，如果像01背包问题那样的受价格和大小两个数据影响，就是二维的动态规划。一维动态规划的状态转移方程一般都是平级移动，受之前状态的影响，相对较简单。</li>
</ul>
<h2 id="1-爬楼梯"><a href="#1-爬楼梯" class="headerlink" title="1.爬楼梯"></a>1.爬楼梯</h2><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？<br>注意：给定 n 是一个正整数。</p>
<p><strong>示例 1：</strong><br>输入： 2<br>输出： 2<br>解释： 有两种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶</li>
<li>2 阶</li>
</ol>
<p><strong>示例 2：</strong><br>输入： 3<br>输出： 3<br>解释： 有三种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶 + 1 阶</li>
<li>1 阶 + 2 阶</li>
<li>2 阶 + 1 阶</li>
</ol>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/climbing-stairs">https://leetcode-cn.com/problems/climbing-stairs</a> <a href="https://leetcode-cn.com/problems/climbing-stairs/">OJ链接</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p><strong>思路：</strong><br>思路很简单，因为一次只能跳一格或者两格，所以当前阶数可前往的方法数等于前两阶的方法数之和。</p>
<p><strong>状态转移方程为：</strong><br><strong>dp[now] &#x3D; dp[now-1] + dp[now-2];</strong></p>
<p><strong>AC代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> *dp = <span class="keyword">new</span> <span class="type">int</span>[n<span class="number">+10</span>],t;</span><br><span class="line">		dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">		dp[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">3</span>;now&lt;=n;now++)</span><br><span class="line">		&#123;</span><br><span class="line">			dp[now] = dp[now<span class="number">-1</span>]+dp[now<span class="number">-2</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		t = dp[n];</span><br><span class="line">		<span class="keyword">delete</span>[] dp;</span><br><span class="line">		<span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	Solution s;</span><br><span class="line">	cout&lt;&lt;s.<span class="built_in">climbStairs</span>(n);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-数硬币"><a href="#2-数硬币" class="headerlink" title="2.数硬币"></a>2.数硬币</h2><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。<br>你可以认为每种硬币的数量是无限的。</p>
<p><strong>示例 1：</strong><br>输入：coins &#x3D; [1, 2, 5], amount &#x3D; 11<br>输出：3<br>解释：11 &#x3D; 5 + 5 + 1</p>
<p><strong>示例 2：</strong><br>输入：coins &#x3D; [2], amount &#x3D; 3<br>输出：-1</p>
<p><strong>示例 3：</strong><br>输入：coins &#x3D; [1], amount &#x3D; 0<br>输出：0</p>
<p><strong>示例 4：</strong><br>输入：coins &#x3D; [1], amount &#x3D; 1<br>输出：1</p>
<p><strong>示例 5：</strong><br>输入：coins &#x3D; [1], amount &#x3D; 2<br>输出：2</p>
<p><strong>提示：</strong><br>1 &lt;&#x3D; coins.length &lt;&#x3D; 12<br>1 &lt;&#x3D; coins[i] &lt;&#x3D; 231 - 1<br>0 &lt;&#x3D; amount &lt;&#x3D; 104</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/coin-change">https://leetcode-cn.com/problems/coin-change</a> <a href="https://leetcode-cn.com/problems/coin-change/">OJ链接</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p><strong>思路：</strong> </p>
<p>当前金额的最小需要硬币数，等于当前金额分别减去硬币面额的所需最小硬币数的最小值加一。例如求2,5,7面额硬币凑27块钱所需的最少硬币，就得求20块钱、22块钱、25块钱的最少硬币(27-7 27-5 27-2)，找到其中的最小值加一就是27块钱所需的最小硬币数。而20块钱，22块钱，25块钱的最少硬币数就按这个倒推，最终可以求出所有金额所需的最小硬币数。</p>
<p><strong>状态转移方程为：</strong><br>dp[x] &#x3D; x金额的所需最少硬币数;<br><strong>dp[now] &#x3D; min( (now-coin[0])+1, (now-coin[1])+1, …… (now-coin[end])+1 );</strong><br><strong>最终结果为: dp[amount];</strong></p>
<p><strong>AC代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> *z,vector&lt;<span class="type">int</span>&gt;&amp; coins,<span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> temp=<span class="number">9999999</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;coins.<span class="built_in">size</span>();now++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(d-coins[now]&gt;=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                temp=<span class="built_in">min</span>(temp,z[d-coins[now]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp<span class="number">+1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> *count=<span class="keyword">new</span> <span class="type">int</span>[amount<span class="number">+1</span>];</span><br><span class="line">	</span><br><span class="line">        count[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1</span>;now&lt;amount<span class="number">+1</span>;now++)</span><br><span class="line">        &#123;</span><br><span class="line">            count[now]=<span class="built_in">func</span>(count,coins,now);</span><br><span class="line">            <span class="comment">//printf(&quot;%d\n&quot;,count[now]);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count[amount]==<span class="number">10000000</span> ? <span class="number">-1</span> : count[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="3-最大子序和"><a href="#3-最大子序和" class="headerlink" title="3.最大子序和"></a>3.最大子序和</h2><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>示例:</strong><br>输入: [-2,1,-3,4,-1,2,1,-5,4]<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximum-subarray">https://leetcode-cn.com/problems/maximum-subarray</a> <a href="https://leetcode-cn.com/problems/maximum-subarray/">OJ链接</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p><strong>思路：</strong><br>加一个max变量，储存最大值，dp数组储存当前连续的最大值。</p>
<p><strong>状态转移方程为：</strong><br><strong>dp[now] &#x3D; max(nums[now],dp[now-1]+nums[now];</strong> </p>
<p><strong>AC代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> *dp = <span class="keyword">new</span> <span class="type">int</span>[nums.<span class="built_in">size</span>()<span class="number">+1</span>],max_=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        max_=dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1</span>;now&lt;nums.<span class="built_in">size</span>();now++)</span><br><span class="line">        &#123;</span><br><span class="line">        	</span><br><span class="line">            dp[now]=<span class="built_in">max</span>(nums[now],dp[now<span class="number">-1</span>]+nums[now]);</span><br><span class="line">            max_=<span class="built_in">max</span>(max_,dp[now]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a[] = &#123;<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>&#125;;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;<span class="built_in">n</span>(a,a<span class="number">+9</span>);</span><br><span class="line">	Solution s;</span><br><span class="line">	cout&lt;&lt;s.<span class="built_in">maxSubArray</span>(n);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-区域和检索-数组不可变"><a href="#4-区域和检索-数组不可变" class="headerlink" title="4.区域和检索 - 数组不可变"></a>4.区域和检索 - 数组不可变</h2><p>给定一个整数数组  nums，求出数组从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点。<br>实现 NumArray 类：<br>NumArray(int[] nums) 使用数组 nums 初始化对象<br>int sumRange(int i, int j) 返回数组 nums 从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点（也就是 sum(nums[i], nums[i + 1], … , nums[j])）</p>
<p><strong>示例：</strong></p>
<ul>
<li>输入：<br>[“NumArray”, “sumRange”, “sumRange”, “sumRange”]<br>[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]</li>
<li>输出：<br>[null, 1, -1, -3]</li>
</ul>
<p><strong>解释：</strong><br>NumArray numArray &#x3D; new NumArray([-2, 0, 3, -5, 2, -1]);<br>numArray.sumRange(0, 2); &#x2F;&#x2F; return 1 ((-2) + 0 + 3)<br>numArray.sumRange(2, 5); &#x2F;&#x2F; return -1 (3 + (-5) + 2 + (-1))<br>numArray.sumRange(0, 5); &#x2F;&#x2F; return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))</p>
<p><strong>提示：</strong><br>0 &lt;&#x3D; nums.length &lt;&#x3D; 104<br>-105 &lt;&#x3D; nums[i] &lt;&#x3D; 105<br>0 &lt;&#x3D; i &lt;&#x3D; j &lt; nums.length<br>最多调用 104 次 sumRange 方法</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/range-sum-query-immutable">https://leetcode-cn.com/problems/range-sum-query-immutable</a> <a href="https://leetcode-cn.com/problems/range-sum-query-immutable/">OJ链接</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p><strong>思路：</strong><br>用dp数组记录前x个数的和，求i ~ j区间的值的和即为dp[j+1] - dp[i];</p>
<p><strong>状态转移方程：</strong><br>dp[now]代表前now个数字的和；<br><strong>dp[now] &#x3D; dp[now-1] + nums[now-1];</strong></p>
<p><strong>AC代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) </span><br><span class="line">    &#123;</span><br><span class="line">        dp.<span class="built_in">resize</span>(nums.<span class="built_in">size</span>()<span class="number">+10</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=dp[i<span class="number">-1</span>]+nums[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRange</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dp[j<span class="number">+1</span>]-dp[i];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; dp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="5-整数拆分"><a href="#5-整数拆分" class="headerlink" title="5.整数拆分"></a>5.整数拆分</h2><p>定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p>
<p><strong>示例 1:</strong><br>输入: 2<br>输出: 1<br>解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1。</p>
<p><strong>示例 2:</strong><br>输入: 10<br>输出: 36<br>解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36。<br>说明: 你可以假设 n 不小于 2 且不大于 58。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/integer-break">https://leetcode-cn.com/problems/integer-break</a>  <a href="https://leetcode-cn.com/problems/integer-break/">OJ地址</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p><strong>思路：</strong> 遍历所有可能的分割结果。</p>
<p><strong>状态转移方程为：</strong><br>dp[x] &#x3D; 整数为x时的最大组合乘积;<br>初始dp[1]&#x3D;1;即1的整数最大乘积是1;<br><strong>dp[x] &#x3D; max( max( dp[x-1] * 1, (x-1) * 1 ), max( dp[x-2] * 2, (x-2) * 2 ), max( dp[x-3] * 3, (x-3) * 3 ), …… max( dp[1] * (x-1), 1 * (x-1)  );</strong><br><strong>最终结果为: dp[n];</strong></p>
<p><strong>AC代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> *count = <span class="keyword">new</span> <span class="type">int</span>[n<span class="number">+1</span>],temp=<span class="number">0</span>; </span><br><span class="line">		count[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">2</span>;now&lt;n<span class="number">+1</span>;now++)</span><br><span class="line">		&#123;</span><br><span class="line">			temp=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> t1=<span class="number">1</span>;t1&lt;now;t1++)</span><br><span class="line">			&#123;</span><br><span class="line">				temp=<span class="built_in">max</span>(temp,count[now-t1]*t1);</span><br><span class="line">				temp=<span class="built_in">max</span>(temp,(now-t1)*t1);</span><br><span class="line">			&#125;</span><br><span class="line">			count[now]=temp;</span><br><span class="line">			<span class="comment">//cout&lt;&lt;count[now]&lt;&lt;endl;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> count[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	</span><br><span class="line">	Solution s;</span><br><span class="line">	cout&lt;&lt;s.<span class="built_in">integerBreak</span>(n);</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="6-打家劫舍"><a href="#6-打家劫舍" class="headerlink" title="6.打家劫舍"></a>6.打家劫舍</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<p><strong>示例 1：</strong><br>输入：[1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。<br>     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</p>
<p><strong>示例 2：</strong><br>输入：[2,7,9,3,1]<br>输出：12<br>解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。<br>     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</p>
<p><strong>提示：</strong><br>0 &lt;&#x3D; nums.length &lt;&#x3D; 100<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 400</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/house-robber">https://leetcode-cn.com/problems/house-robber</a> <a href="https://leetcode-cn.com/problems/house-robber/">OJ链接</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p><strong>思路：</strong> 可简单看出最大值是在不偷前一个屋子加上偷当前屋子和不偷当前屋子和偷前一个屋子之间做选择。</p>
<p><strong>状态转移方程为：</strong><br>dp[x] &#x3D; 偷到x号房子时的最大可偷最大价值;<br>初始dp[0]&#x3D;0,dp[1]&#x3D;nums[0];<br>即不偷的时候价值为0，只偷一个屋子时价值最大为第一个屋子;<br><strong>dp[x] &#x3D; max( dp[x-2]+nums[x], dp[x-1] );</strong><br><strong>最终结果为: dp[nums.size()];</strong></p>
<p><strong>AC代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> *dp = <span class="keyword">new</span> <span class="type">int</span>[nums.<span class="built_in">size</span>()<span class="number">+1</span>];</span><br><span class="line">		<span class="keyword">if</span>(nums.<span class="built_in">size</span>()&gt;=<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			dp[<span class="number">0</span>]=<span class="number">0</span>,dp[<span class="number">1</span>]=nums[<span class="number">0</span>];</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">2</span>;now&lt;=nums.<span class="built_in">size</span>();now++)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[now] = <span class="built_in">max</span>(dp[now<span class="number">-2</span>]+nums[now<span class="number">-1</span>],dp[now<span class="number">-1</span>]);</span><br><span class="line">				<span class="comment">//cout&lt;&lt;dp[now]&lt;&lt;endl;</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> dp[nums.<span class="built_in">size</span>()];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;n; </span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t)!=EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		n.<span class="built_in">push_back</span>(t);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	Solution s;</span><br><span class="line">	cout&lt;&lt;s.<span class="built_in">rob</span>(n);</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="7-打家劫舍II"><a href="#7-打家劫舍II" class="headerlink" title="7.打家劫舍II"></a>7.打家劫舍II</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下 ，能够偷窃到的最高金额。</p>
<p><strong>示例 1：</strong><br>输入：nums &#x3D; [2,3,2]<br>输出：3<br>解释：你不能先偷窃 1 号房屋（金额 &#x3D; 2），然后偷窃 3 号房屋（金额 &#x3D; 2）, 因为他们是相邻的。</p>
<p><strong>示例 2：</strong><br>输入：nums &#x3D; [1,2,3,1]<br>输出：4<br>解释：你可以先偷窃 1 号房屋（金额 &#x3D; 1），然后偷窃 3 号房屋（金额 &#x3D; 3）。<br>偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</p>
<p><strong>示例 3：</strong><br>输入：nums &#x3D; [0]<br>输出：0</p>
<p><strong>提示：</strong><br>1 &lt;&#x3D; nums.length &lt;&#x3D; 100<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 1000</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/house-robber-ii">https://leetcode-cn.com/problems/house-robber-ii</a> <a href="https://leetcode-cn.com/problems/house-robber-ii/">OJ链接</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p><strong>思路：</strong> 在上一题的基础上，增加了环的概念。大致就是有首不能有尾，有尾不能有首。我们可以先求{1，n-1}这个区间的最大值，再求{2，n}这个区间的最大值，然后取这两个值中的最大值，即为本题答案。</p>
<p><strong>AC代码：</strong> </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> *dp = <span class="keyword">new</span> <span class="type">int</span>[nums.<span class="built_in">size</span>()<span class="number">+1</span>];</span><br><span class="line">		<span class="type">int</span> *dp2 = <span class="keyword">new</span> <span class="type">int</span>[nums.<span class="built_in">size</span>()<span class="number">+1</span>];</span><br><span class="line">		<span class="keyword">if</span>(nums.<span class="built_in">size</span>()&gt;=<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			dp[<span class="number">0</span>]=<span class="number">0</span>,dp[<span class="number">1</span>]=nums[<span class="number">0</span>];<span class="comment">// 0 ~ n-1</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">2</span>;now&lt;=nums.<span class="built_in">size</span>()<span class="number">-1</span>;now++)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[now] = <span class="built_in">max</span>(dp[now<span class="number">-2</span>]+nums[now<span class="number">-1</span>],dp[now<span class="number">-1</span>]);</span><br><span class="line">				<span class="comment">//cout&lt;&lt;dp[now]&lt;&lt;endl;</span></span><br><span class="line">			&#125;</span><br><span class="line">			dp2[<span class="number">0</span>]=<span class="number">0</span>,dp2[<span class="number">1</span>]=<span class="number">0</span>;<span class="comment">// 1 ~ n</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">2</span>;now&lt;=nums.<span class="built_in">size</span>();now++)</span><br><span class="line">			&#123;</span><br><span class="line">				dp2[now] = <span class="built_in">max</span>(dp2[now<span class="number">-2</span>]+nums[now<span class="number">-1</span>],dp2[now<span class="number">-1</span>]);</span><br><span class="line">				<span class="comment">//cout&lt;&lt;dp[now]&lt;&lt;endl;</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(nums.<span class="built_in">size</span>()&gt;<span class="number">1</span>)</span><br><span class="line">				dp[nums.<span class="built_in">size</span>()]=<span class="built_in">max</span>(dp[nums.<span class="built_in">size</span>()<span class="number">-1</span>],dp2[nums.<span class="built_in">size</span>()]);</span><br><span class="line">			<span class="keyword">return</span> dp[nums.<span class="built_in">size</span>()];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;n; </span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t)!=EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		n.<span class="built_in">push_back</span>(t);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	Solution s;</span><br><span class="line">	cout&lt;&lt;s.<span class="built_in">rob</span>(n);</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="8-解码方法"><a href="#8-解码方法" class="headerlink" title="8.解码方法"></a>8.解码方法</h2><p>一条包含字母 A-Z 的消息通过以下方式进行了编码：<br>‘A’ -&gt; 1<br>‘B’ -&gt; 2<br>…<br>‘Z’ -&gt; 26<br>给定一个只包含数字的非空字符串，请计算解码方法的总数。<br>题目数据保证答案肯定是一个 32 位的整数。</p>
<p><strong>示例 1：</strong><br>输入：”12”<br>输出：2<br>解释：它可以解码为 “AB”（1 2）或者 “L”（12）。</p>
<p><strong>示例 2：</strong><br>输入：”226”<br>输出：3<br>解释：它可以解码为 “BZ” (2 26), “VF” (22 6), 或者 “BBF” (2 2 6) 。</p>
<p><strong>示例 3：</strong><br>输入：s &#x3D; “0”<br>输出：0</p>
<p><strong>示例 4：</strong><br>输入：s &#x3D; “1”<br>输出：1</p>
<p><strong>示例 5：</strong><br>输入：s &#x3D; “2”<br>输出：1</p>
<p><strong>提示：</strong><br>1 &lt;&#x3D; s.length &lt;&#x3D; 100<br>s 只包含数字，并且可以包含前导零。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/decode-ways">https://leetcode-cn.com/problems/decode-ways</a> <a href="https://leetcode-cn.com/problems/decode-ways/">OJ链接</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p><strong>AC代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numDecodings</span><span class="params">(string s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> *dp = <span class="keyword">new</span> <span class="type">int</span>[s.<span class="built_in">size</span>()<span class="number">+1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        s[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span> ? dp[<span class="number">1</span>]=<span class="number">0</span> : dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">2</span>;now&lt;=s.<span class="built_in">size</span>();now++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(s[now<span class="number">-1</span>]!=<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        	&#123;</span><br><span class="line">        		<span class="keyword">if</span>(s[now<span class="number">-2</span>]==<span class="string">&#x27;1&#x27;</span>||(s[now<span class="number">-2</span>]==<span class="string">&#x27;2&#x27;</span>&amp;&amp;s[now<span class="number">-1</span>]&lt;=<span class="string">&#x27;6&#x27;</span>))</span><br><span class="line">        		&#123;</span><br><span class="line">        			dp[now]=dp[now<span class="number">-1</span>]+dp[now<span class="number">-2</span>];</span><br><span class="line">        			</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					dp[now]=dp[now<span class="number">-1</span>];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(s[now<span class="number">-2</span>]==<span class="string">&#x27;2&#x27;</span>||s[now<span class="number">-2</span>]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					dp[now]=dp[now<span class="number">-2</span>];</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dp[s.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="9-乘积最大字数组"><a href="#9-乘积最大字数组" class="headerlink" title="9.乘积最大字数组"></a>9.乘积最大字数组</h2><p>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<p><strong>示例 1:</strong><br>输入: [2,3,-2,4]<br>输出: 6<br>解释: 子数组 [2,3] 有最大乘积 6。</p>
<p><strong>示例 2:</strong><br>输入: [-2,0,-1]<br>输出: 0<br>解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximum-product-subarray">https://leetcode-cn.com/problems/maximum-product-subarray</a> <a href="https://leetcode-cn.com/problems/maximum-product-subarray/">OJ链接</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p><strong>AC代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> dp_max[nums.<span class="built_in">size</span>()<span class="number">+10</span>],dp_min[nums.<span class="built_in">size</span>()<span class="number">+10</span>];</span><br><span class="line">        dp_max[<span class="number">1</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        dp_min[<span class="number">1</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">2</span>;now&lt;=nums.<span class="built_in">size</span>();now++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp_max[now] = <span class="built_in">max</span>(dp_min[now<span class="number">-1</span>]*nums[now<span class="number">-1</span>], dp_max[now<span class="number">-1</span>]*nums[now<span class="number">-1</span>]);</span><br><span class="line">            dp_max[now] = <span class="built_in">max</span>(dp_max[now], nums[now<span class="number">-1</span>]);</span><br><span class="line">            dp_min[now] = <span class="built_in">min</span>(dp_max[now<span class="number">-1</span>]*nums[now<span class="number">-1</span>], dp_min[now<span class="number">-1</span>]*nums[now<span class="number">-1</span>]);</span><br><span class="line">            dp_min[now] = <span class="built_in">min</span>(dp_min[now], nums[now<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> max_ = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1</span>;now&lt;=nums.<span class="built_in">size</span>();now++)</span><br><span class="line">        &#123;</span><br><span class="line">            max_ = <span class="built_in">max</span>(max_,dp_max[now]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="10-完全平方数"><a href="#10-完全平方数" class="headerlink" title="10.完全平方数"></a>10.完全平方数</h2><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p>
<p><strong>示例 1:</strong><br>输入: n &#x3D; 12<br>输出: 3<br>解释: 12 &#x3D; 4 + 4 + 4.</p>
<p><strong>示例 2:</strong><br>输入: n &#x3D; 13<br>输出: 2<br>解释: 13 &#x3D; 4 + 9.</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/perfect-squares">https://leetcode-cn.com/problems/perfect-squares</a> <a href="https://leetcode-cn.com/problems/perfect-squares/">OJ链接</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p><strong>AC代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> dp[n<span class="number">+1</span>],t=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">9999</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1</span>;now&lt;=n;now++)</span><br><span class="line">        &#123;</span><br><span class="line">            t=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(t*t&lt;=now)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[now] = <span class="built_in">min</span>(dp[now],dp[now-t*t]<span class="number">+1</span>);</span><br><span class="line">                t++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="二维数组动态规划"><a href="#二维数组动态规划" class="headerlink" title="二维数组动态规划"></a>二维数组动态规划</h1><ul>
<li>这类的dp题有两个影响结果的数值，例如01背包问题里的价值和大小、空间问题里的x,y坐标等等都是二维的数据。这种题建立dp数组的时候，就需要构建二维的dp数组，并且状态转移方程的变化情况也更加多样，相对较难一点。</li>
</ul>
<h2 id="1-不同路径"><a href="#1-不同路径" class="headerlink" title="1.不同路径"></a>1.不同路径</h2><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。<br>问总共有多少条不同的路径？</p>
<p><img src="/images/2020-11-05/1.jpg#pic_center" alt="图1"></p>
<p>例如，上图是一个7 x 3 的网格。有多少可能的路径？</p>
<p><strong>示例 1:</strong></p>
<ul>
<li>输入: m &#x3D; 3, n &#x3D; 2</li>
<li>输出: 3<br><strong>解释:</strong><br>从左上角开始，总共有 3 条路径可以到达右下角。</li>
</ul>
<ol>
<li>向右 -&gt; 向右 -&gt; 向下</li>
<li>向右 -&gt; 向下 -&gt; 向右</li>
<li>向下 -&gt; 向右 -&gt; 向右</li>
</ol>
<p><strong>示例 2:</strong></p>
<ul>
<li>输入: m &#x3D; 7, n &#x3D; 3</li>
<li>输出: 28</li>
</ul>
<p><strong>提示：</strong><br>1 &lt;&#x3D; m, n &lt;&#x3D; 100<br>题目数据保证答案小于等于 2 * 10 ^ 9</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/unique-paths">https://leetcode-cn.com/problems/unique-paths</a> <a href="https://leetcode-cn.com/problems/unique-paths/">OJ链接</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p><strong>思路：</strong> dp构建表格，dp[x][y]代表在x,y坐标时的可前往路程数。由于方格只能向下或者向右走，所以前往某一格的方案数，就是前往上一格和左一格的方案数之和。</p>
<p><strong>状态转移方程：</strong><br><strong>dp[x][y] &#x3D; dp[x-1][y]+dp[x][y-1];</strong><br><strong>最终结果为: dp[X][Y];</strong></p>
<p><strong>AC代码：</strong> <a href="https://www.acwing.com/problem/content/submission/2069/">OJ链接</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="type">int</span> dp[<span class="number">101</span>][<span class="number">101</span>];   </span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1</span>;now&lt;=m;now++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> now1=<span class="number">1</span>;now1&lt;=n;now1++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(now<span class="number">-1</span>&gt;=<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[now][now1]+=dp[now<span class="number">-1</span>][now1];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(now1<span class="number">-1</span>&gt;=<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[now][now1]+=dp[now][now1<span class="number">-1</span>];</span><br><span class="line">                &#125;	</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Solution s;</span><br><span class="line">	cout&lt;&lt;s.<span class="built_in">uniquePaths</span>(<span class="number">7</span>,<span class="number">3</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-不同路径II"><a href="#2-不同路径II" class="headerlink" title="2.不同路径II"></a>2.不同路径II</h2><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。<br>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？<br><img src="/images/2020-11-05/2.jpg#pic_center" alt="图2"></p>
<p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p>
<p><strong>示例 1：</strong></p>
<ul>
<li>输入：obstacleGrid &#x3D; [[0,0,0],[0,1,0],[0,0,0]]</li>
<li>输出：2<br><strong>解释：</strong><br>3x3 网格的正中间有一个障碍物。<br>从左上角到右下角一共有 2 条不同的路径：</li>
</ul>
<ol>
<li>向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</li>
<li>向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</li>
</ol>
<p><strong>示例 2：</strong></p>
<ul>
<li>输入：obstacleGrid &#x3D; [[0,1],[0,0]]</li>
<li>输出：1</li>
</ul>
<p><strong>提示：</strong><br>m &#x3D;&#x3D; obstacleGrid.length<br> n &#x3D;&#x3D; obstacleGrid[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 100<br>obstacleGrid[i][j] 为 0 或 1</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/unique-paths-ii">https://leetcode-cn.com/problems/unique-paths-ii</a> <a href="https://leetcode-cn.com/problems/unique-paths-ii/">OJ链接</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p><strong>思路：</strong><br>在上一题的基础上，增加一个判断即可，当遍历到障碍格时，直接跳过不计数即可。令障碍格的可到达方法为0。</p>
<p><strong>状态转移方程：</strong><br><strong>dp[x][y] &#x3D; dp[x-1][y]+dp[x][y-1];</strong><br><strong>最终结果为: dp[X][Y];</strong></p>
<p><strong>AC代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; obstacleGrid)</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="type">int</span> dp[<span class="number">101</span>][<span class="number">101</span>];   </span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1</span>;now&lt;=obstacleGrid.<span class="built_in">size</span>();now++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> now1=<span class="number">1</span>;now1&lt;=obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>();now1++)</span><br><span class="line">            &#123;</span><br><span class="line">            	<span class="keyword">if</span>(obstacleGrid[now<span class="number">-1</span>][now1<span class="number">-1</span>]==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                	<span class="keyword">if</span>(now<span class="number">-1</span>&gt;=<span class="number">1</span>)</span><br><span class="line">	                &#123;</span><br><span class="line">	                    dp[now][now1]+=dp[now<span class="number">-1</span>][now1];</span><br><span class="line">	                &#125;</span><br><span class="line">	                <span class="keyword">if</span>(now1<span class="number">-1</span>&gt;=<span class="number">1</span>)</span><br><span class="line">	                &#123;</span><br><span class="line">	                    dp[now][now1]+=dp[now][now1<span class="number">-1</span>];</span><br><span class="line">	                &#125;	</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					dp[now][now1]=<span class="number">0</span>;	</span><br><span class="line">				&#125;	</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[obstacleGrid.<span class="built_in">size</span>()][obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="3-最小路径和"><a href="#3-最小路径和" class="headerlink" title="3.最小路径和"></a>3.最小路径和</h2><p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。<br>说明：每次只能向下或者向右移动一步。</p>
<p><strong>示例 1：</strong></p>
<ul>
<li>输入：grid &#x3D; [[1,3,1],[1,5,1],[4,2,1]]</li>
<li>输出：7<br><strong>解释：</strong> 因为路径 1→3→1→1→1 的总和最小。</li>
</ul>
<p><strong>示例 2：</strong></p>
<ul>
<li>输入：grid &#x3D; [[1,2,3],[4,5,6]]</li>
<li>输出：12</li>
</ul>
<p><strong>提示：</strong><br>m &#x3D;&#x3D; grid.length<br>n &#x3D;&#x3D; grid[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 200<br>0 &lt;&#x3D; grid[i][j] &lt;&#x3D; 100</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/minimum-path-sum">https://leetcode-cn.com/problems/minimum-path-sum</a> <a href="https://leetcode-cn.com/problems/minimum-path-sum/solution/">OJ链接</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p><strong>思路：</strong><br>由于只能向下或者向右移动，所以前往一个格子的最小路径，就是其上一个格子和左一个格子的较小路径和加上这个格子的权值。</p>
<p><strong>状态转移方程：</strong><br><strong>dp[x][y] &#x3D; min(dp[x-1][y], dp[x][y-1]) + grid[x][y];</strong></p>
<p><strong>AC代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> dp[<span class="number">201</span>][<span class="number">201</span>];   </span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;grid.<span class="built_in">size</span>();now++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> now1=<span class="number">0</span>;now1&lt;grid[now].<span class="built_in">size</span>();now1++)</span><br><span class="line">            &#123;</span><br><span class="line">            	<span class="keyword">if</span>(now!=<span class="number">0</span>&amp;&amp;now1!=<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[now][now1] = <span class="built_in">min</span>(dp[now<span class="number">-1</span>][now1],dp[now][now1<span class="number">-1</span>]) + grid[now][now1];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(now==<span class="number">0</span>&amp;&amp;now1!=<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[now][now1] = dp[now][now1<span class="number">-1</span>] + grid[now][now1];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(now!=<span class="number">0</span>&amp;&amp;now1==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[now][now1] = dp[now<span class="number">-1</span>][now1] + grid[now][now1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[grid.<span class="built_in">size</span>()<span class="number">-1</span>][grid[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="4-三角形最小路径和"><a href="#4-三角形最小路径和" class="headerlink" title="4.三角形最小路径和"></a>4.三角形最小路径和</h2><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。<br>相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。</p>
<p>例如，给定三角形：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">     [<span class="number">2</span>],</span><br><span class="line">    [<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">   [<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>],</span><br><span class="line">  [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">3</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 &#x3D; 11）。</p>
<p><strong>说明：</strong><br>如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/triangle">https://leetcode-cn.com/problems/triangle</a> <a href="https://leetcode-cn.com/problems/triangle/">OJ链接</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p><strong>思路：</strong><br>建立二维数组，储存到达每一个坐标的最小路径值。最后遍历最后一行的最小值，即为最终答案。</p>
<p><strong>状态转移方程：</strong><br>对于行首元素：<br><strong>dp[x][0] &#x3D; dp[x-1][0] + triangle[x][0];</strong><br>对于行尾元素：<br><strong>dp[x][x] &#x3D; dp[x-1][x-1] + triangle[x][x];</strong><br>对于行中元素：<br><strong>dp[x][y] &#x3D; min(dp[x-1][y-1], dp[x-1][y]) + triangle[x][y];</strong></p>
<p><strong>AC代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumTotal</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; triangle)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> dp[triangle.<span class="built_in">size</span>()][triangle.<span class="built_in">size</span>()];</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1</span>;now&lt;triangle.<span class="built_in">size</span>();now++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[now][<span class="number">0</span>]=dp[now<span class="number">-1</span>][<span class="number">0</span>]+triangle[now][<span class="number">0</span>];</span><br><span class="line">            dp[now][now]=dp[now<span class="number">-1</span>][now<span class="number">-1</span>]+triangle[now][now];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=now<span class="number">-1</span>;t++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[now][t] = <span class="built_in">min</span>(dp[now<span class="number">-1</span>][t<span class="number">-1</span>],dp[now<span class="number">-1</span>][t]) + triangle[now][t]; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> min_=INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;triangle.<span class="built_in">size</span>();now++)</span><br><span class="line">        &#123;</span><br><span class="line">            min_=<span class="built_in">min</span>(dp[triangle.<span class="built_in">size</span>()<span class="number">-1</span>][now],min_);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="5-最大正方形"><a href="#5-最大正方形" class="headerlink" title="5.最大正方形"></a>5.最大正方形</h2><p>在一个由 ‘0’ 和 ‘1’ 组成的二维矩阵内，找到只包含 ‘1’ 的最大正方形，并返回其面积。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">matrix = [[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>],</span><br><span class="line">          [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>],</span><br><span class="line">          [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>],</span><br><span class="line">          [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>]]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximal-square">https://leetcode-cn.com/problems/maximal-square</a> <a href="https://leetcode-cn.com/problems/maximal-square/">OJ链接</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p><strong>AC代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximalSquare</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; matrix)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> dp[matrix.<span class="built_in">size</span>()<span class="number">+1</span>][matrix[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">+1</span>];</span><br><span class="line">        <span class="type">int</span> max_=<span class="number">0</span>,temp;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;=matrix.<span class="built_in">size</span>();x++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">1</span>;y&lt;=matrix[<span class="number">0</span>].<span class="built_in">size</span>();y++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[x<span class="number">-1</span>][y<span class="number">-1</span>]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp = <span class="built_in">min</span>(dp[x<span class="number">-1</span>][y<span class="number">-1</span>],dp[x<span class="number">-1</span>][y]);</span><br><span class="line">                    temp = <span class="built_in">min</span>(temp,dp[x][y<span class="number">-1</span>]);</span><br><span class="line">                    dp[x][y] = temp<span class="number">+1</span>;</span><br><span class="line">                    max_ = <span class="built_in">max</span>(max_,dp[x][y]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[x][y] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_*max_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++网络编程学习：网络数据报文的收发</title>
    <url>/2021/01/22/20210122_C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%96%87%E7%9A%84%E6%94%B6%E5%8F%91/</url>
    <content><![CDATA[<ul>
<li>使用的语言为C&#x2F;C++</li>
<li>源码支持的平台为：Windows</li>
</ul>
<h1 id="一、网络数据报文的格式定义"><a href="#一、网络数据报文的格式定义" class="headerlink" title="一、网络数据报文的格式定义"></a>一、网络数据报文的格式定义</h1><ul>
<li>报文有两个部分，<strong>包头</strong>和<strong>包体</strong>，是网络消息的基本单元。</li>
<li><strong>包头：</strong> 描述本次消息包的大小，描述包体数据的作用。</li>
<li><strong>包体：</strong> 其中包含了需要传输的数据。</li>
</ul>
<span id="more"></span>

<p>&emsp;&emsp;根据此数据结构，我们可以根据包头的内容，来灵活的对包体的数据进行处理。</p>
<h1 id="二、将包头与包体数据分开收发"><a href="#二、将包头与包体数据分开收发" class="headerlink" title="二、将包头与包体数据分开收发"></a>二、将包头与包体数据分开收发</h1><h2 id="1-概括"><a href="#1-概括" class="headerlink" title="1.概括"></a>1.概括</h2><p>&emsp;&emsp;通过上文对网络数据报文的定义，我们可以很轻易的想到：</p>
<ol>
<li>发送端进行两次<strong>send</strong>操作，第一次<strong>send</strong>发送包头，第二次<strong>send</strong>发送包体，即可实现网络数据报文的发送。</li>
<li>接收端进行两次<strong>recv</strong>操作，第一次<strong>recv</strong>接收包头，第二次<strong>recv</strong>接收包体并根据包头的内容进行数据处理，即可实现网络数据报文的接收。</li>
</ol>
<p>&emsp;&emsp;按以上操作，即可实现网络数据报文的收发。</p>
<h2 id="2-代码及其详细注释"><a href="#2-代码及其详细注释" class="headerlink" title="2.代码及其详细注释"></a>2.代码及其详细注释</h2><h3 id="2-1-服务端代码"><a href="#2-1-服务端代码" class="headerlink" title="2.1 服务端代码"></a>2.1 服务端代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;winSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//链接此动态链接库 windows特有 </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//枚举类型记录命令 </span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">cmd</span> </span><br><span class="line">&#123;</span><br><span class="line">	CMD_LOGIN,<span class="comment">//登录 </span></span><br><span class="line">	CMD_LOGOUT,<span class="comment">//登出 </span></span><br><span class="line">	CMD_ERROR<span class="comment">//错误 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义数据包头 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DateHeader</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">short</span> cmd;<span class="comment">//命令</span></span><br><span class="line">	<span class="type">short</span> date_length;<span class="comment">//数据的长短	</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包体1 登录 传输账号与密码</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Login</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">	<span class="type">char</span> PassWord[<span class="number">32</span>];<span class="comment">//密码 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包体2 登录结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoginResult</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包体3 登出 传输用户名 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Logout</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包体4 登出结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LogoutResult</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//启动windows socket 2,x环境 windows特有 </span></span><br><span class="line">	WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>);<span class="comment">//WinSock库版本号 </span></span><br><span class="line">	WSADATA dat;<span class="comment">//网络结构体 储存WSAStartup函数调用后返回的Socket数据 </span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span> != <span class="built_in">WSAStartup</span>(ver,&amp;dat))<span class="comment">//正确初始化后返回0 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//建立一个socket </span></span><br><span class="line">	SOCKET _mysocket = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,IPPROTO_TCP);<span class="comment">//IPV4 数据流类型 TCP类型 </span></span><br><span class="line">	<span class="keyword">if</span>(INVALID_SOCKET == _mysocket)<span class="comment">//建立失败 </span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">	<span class="comment">//绑定网络端口和IP地址 </span></span><br><span class="line">	sockaddr_in _myaddr = &#123;&#125;;<span class="comment">//建立sockaddr结构体  sockaddr_in结构体方便填写 但是下面要进行类型转换 </span></span><br><span class="line">	_myaddr.sin_family = AF_INET;<span class="comment">//IPV4</span></span><br><span class="line">	_myaddr.sin_port = <span class="built_in">htons</span>(<span class="number">8888</span>);<span class="comment">//端口 host to net unsigned short</span></span><br><span class="line">	_myaddr.sin_addr.S_un.S_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);<span class="comment">//网络地址 INADDR_ANY监听所有网卡的端口 </span></span><br><span class="line">	<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">bind</span>(_mysocket,(sockaddr*)&amp;_myaddr,<span class="built_in">sizeof</span>(sockaddr_in)))<span class="comment">//socket (强制转换)sockaddr结构体 结构体大小 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;绑定不成功&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;&quot;绑定成功&quot;&lt;&lt;endl; </span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//监听网络端口</span></span><br><span class="line">	<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">listen</span>(_mysocket,<span class="number">5</span>))<span class="comment">//套接字 最大多少人连接 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;监听失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;&quot;监听成功&quot;&lt;&lt;endl; </span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//等待接收客户端连接</span></span><br><span class="line">	sockaddr_in _clientAddr = &#123;&#125;;<span class="comment">//新建sockadd结构体接收客户端数据 </span></span><br><span class="line">	<span class="type">int</span> _addr_len = <span class="built_in">sizeof</span>(sockaddr_in);<span class="comment">//获取sockadd结构体长度 </span></span><br><span class="line">	SOCKET _temp_socket = INVALID_SOCKET;<span class="comment">//声明客户端套接字 </span></span><br><span class="line">	</span><br><span class="line">	_temp_socket = <span class="built_in">accept</span>(_mysocket,(sockaddr*)&amp;_clientAddr,&amp;_addr_len);<span class="comment">//自身套接字 客户端结构体 结构体大小 </span></span><br><span class="line">	<span class="keyword">if</span>(INVALID_SOCKET == _temp_socket)<span class="comment">//接收失败 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;接收到无效客户端Socket&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;新客户端加入&quot;</span>&lt;&lt;endl; </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;IP地址为：%s \n&quot;</span>, <span class="built_in">inet_ntoa</span>(_clientAddr.sin_addr));  </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//接收客户端发送的数据 </span></span><br><span class="line">		DateHeader _head = &#123;&#125;; </span><br><span class="line">		<span class="type">int</span> _buf_len = <span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_head,<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(_buf_len&lt;=<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;客户端已退出\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;接收到包头，命令：%d，数据长度：%d\n&quot;</span>,_head.cmd,_head.date_length);</span><br><span class="line">		<span class="keyword">switch</span>(_head.cmd)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> CMD_LOGIN:<span class="comment">//登录 接收登录包体 </span></span><br><span class="line">			&#123;</span><br><span class="line">				Login _login = &#123;&#125;;</span><br><span class="line">				<span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_login,<span class="built_in">sizeof</span>(Login),<span class="number">0</span>);</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				进行判断操作 </span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%s已登录\n&quot;</span>,_login.UserName); </span><br><span class="line">				<span class="built_in">send</span>(_temp_socket,(<span class="type">char</span>*)&amp;_head,<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);<span class="comment">//发包头 </span></span><br><span class="line">				LoginResult _result = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">				<span class="built_in">send</span>(_temp_socket,(<span class="type">char</span>*)&amp;_result,<span class="built_in">sizeof</span>(LoginResult),<span class="number">0</span>);<span class="comment">//发包体 </span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> CMD_LOGOUT:<span class="comment">//登出 接收登出包体 </span></span><br><span class="line">			&#123;</span><br><span class="line">				Logout _logout = &#123;&#125;;</span><br><span class="line">				<span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_logout,<span class="built_in">sizeof</span>(Logout),<span class="number">0</span>);</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				进行判断操作 </span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%s已登出\n&quot;</span>,_logout.UserName); </span><br><span class="line">				<span class="built_in">send</span>(_temp_socket,(<span class="type">char</span>*)&amp;_head,<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);<span class="comment">//发包头 </span></span><br><span class="line">				LogoutResult _result = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">				<span class="built_in">send</span>(_temp_socket,(<span class="type">char</span>*)&amp;_result,<span class="built_in">sizeof</span>(LogoutResult),<span class="number">0</span>);<span class="comment">//发包体</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:<span class="comment">//错误 </span></span><br><span class="line">			&#123;</span><br><span class="line">				_head.cmd = CMD_ERROR; </span><br><span class="line">				_head.date_length = <span class="number">0</span>; </span><br><span class="line">				<span class="built_in">send</span>(_temp_socket,(<span class="type">char</span>*)&amp;_head,<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);<span class="comment">//发包头 </span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭客户端socket</span></span><br><span class="line">	<span class="built_in">closesocket</span>(_temp_socket);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭socket </span></span><br><span class="line">	<span class="built_in">closesocket</span>(_mysocket); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//清除windows socket 环境 </span></span><br><span class="line">	<span class="built_in">WSACleanup</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;任务结束，程序已退出&quot;</span>); </span><br><span class="line">	 </span><br><span class="line">	<span class="built_in">getchar</span>(); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="2-2-客户端代码"><a href="#2-2-客户端代码" class="headerlink" title="2.2 客户端代码"></a>2.2 客户端代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;winSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//链接此动态链接库 windows特有 </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//枚举类型记录命令 </span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">cmd</span> </span><br><span class="line">&#123;</span><br><span class="line">	CMD_LOGIN,<span class="comment">//登录 </span></span><br><span class="line">	CMD_LOGOUT,<span class="comment">//登出 </span></span><br><span class="line">	CMD_ERROR<span class="comment">//错误 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义数据包头 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DateHeader</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">short</span> cmd;<span class="comment">//命令</span></span><br><span class="line">	<span class="type">short</span> date_length;<span class="comment">//数据的长短	</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包体1 登录 传输账号与密码</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Login</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">	<span class="type">char</span> PassWord[<span class="number">32</span>];<span class="comment">//密码 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包体2 登录结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoginResult</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包体3 登出 传输用户名 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Logout</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包体4 登出结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LogoutResult</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//启动windows socket 2,x环境 windows特有 </span></span><br><span class="line">	WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>);<span class="comment">//WinSock库版本号 </span></span><br><span class="line">	WSADATA dat;<span class="comment">//网络结构体 储存WSAStartup函数调用后返回的Socket数据 </span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span> != <span class="built_in">WSAStartup</span>(ver,&amp;dat))<span class="comment">//正确初始化后返回0 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//建立一个socket </span></span><br><span class="line">	SOCKET _mysocket = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);<span class="comment">//IPV4 数据流类型 类型可以不用写 </span></span><br><span class="line">	<span class="keyword">if</span>(INVALID_SOCKET == _mysocket)<span class="comment">//建立失败 </span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//连接服务器</span></span><br><span class="line">    sockaddr_in _sin = &#123;&#125;;<span class="comment">//sockaddr结构体 </span></span><br><span class="line">    _sin.sin_family = AF_INET;<span class="comment">//IPV4</span></span><br><span class="line">    _sin.sin_port = <span class="built_in">htons</span>(<span class="number">8888</span>);<span class="comment">//想要连接的端口号 </span></span><br><span class="line">	_sin.sin_addr.S_un.S_addr =  <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);<span class="comment">//想要连接的IP </span></span><br><span class="line">	<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">connect</span>(_mysocket,(sockaddr*)&amp;_sin,<span class="built_in">sizeof</span>(sockaddr_in)))</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;连接失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">		<span class="built_in">closesocket</span>(_mysocket);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;连接成功&quot;</span>&lt;&lt;endl; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//输入请求 </span></span><br><span class="line">		<span class="type">char</span> _msg[<span class="number">256</span>] = &#123;&#125;;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,_msg);</span><br><span class="line">		<span class="comment">//处理请求 </span></span><br><span class="line">		<span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(_msg,<span class="string">&quot;exit&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(_msg,<span class="string">&quot;login&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//发送 </span></span><br><span class="line">			Login _login = &#123;<span class="string">&quot;河边小咸鱼&quot;</span>,<span class="string">&quot;123456&quot;</span>&#125;;</span><br><span class="line">			DateHeader _head = &#123;CMD_LOGIN,<span class="built_in">sizeof</span>(_login)&#125;;</span><br><span class="line">			<span class="built_in">send</span>(_mysocket,(<span class="type">const</span> <span class="type">char</span>*)&amp;_head,<span class="built_in">sizeof</span>(_head),<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">send</span>(_mysocket,(<span class="type">const</span> <span class="type">char</span>*)&amp;_login,<span class="built_in">sizeof</span>(_login),<span class="number">0</span>);</span><br><span class="line">			<span class="comment">//接收 </span></span><br><span class="line">			DateHeader _head2 = &#123;&#125;; </span><br><span class="line">			LoginResult _result= &#123;&#125;; </span><br><span class="line">			<span class="built_in">recv</span>(_mysocket,(<span class="type">char</span>*)&amp;_head2,<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">recv</span>(_mysocket,(<span class="type">char</span>*)&amp;_result,<span class="built_in">sizeof</span>(LoginResult),<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;result:%d\n&quot;</span>,_result.Result);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(_msg,<span class="string">&quot;logout&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//发送 </span></span><br><span class="line">			Logout _logout = &#123;<span class="string">&quot;河边小咸鱼&quot;</span>&#125;;</span><br><span class="line">			DateHeader _head = &#123;CMD_LOGOUT,<span class="built_in">sizeof</span>(_logout)&#125;;</span><br><span class="line">			<span class="built_in">send</span>(_mysocket,(<span class="type">const</span> <span class="type">char</span>*)&amp;_head,<span class="built_in">sizeof</span>(_head),<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">send</span>(_mysocket,(<span class="type">const</span> <span class="type">char</span>*)&amp;_logout,<span class="built_in">sizeof</span>(_logout),<span class="number">0</span>);</span><br><span class="line">			<span class="comment">//接收 </span></span><br><span class="line">			DateHeader _head2 = &#123;&#125;; </span><br><span class="line">			LogoutResult _result= &#123;&#125;; </span><br><span class="line">			<span class="built_in">recv</span>(_mysocket,(<span class="type">char</span>*)&amp;_head2,<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">recv</span>(_mysocket,(<span class="type">char</span>*)&amp;_result,<span class="built_in">sizeof</span>(LogoutResult),<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;result:%d\n&quot;</span>,_result.Result);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;不存在的命令\n&quot;</span>);</span><br><span class="line">		&#125; 	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭socket</span></span><br><span class="line">	<span class="built_in">closesocket</span>(_mysocket); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//清除windows socket 环境 </span></span><br><span class="line">	<span class="built_in">WSACleanup</span>(); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>


<h1 id="三、将分开收发报文数据改为一次收发"><a href="#三、将分开收发报文数据改为一次收发" class="headerlink" title="三、将分开收发报文数据改为一次收发"></a>三、将分开收发报文数据改为一次收发</h1><h2 id="1-思路"><a href="#1-思路" class="headerlink" title="1.思路"></a>1.思路</h2><p>&emsp;&emsp;由上文，我们可以知道，可以通过两次send和两次recv进行报文的收发，但是其中操作较为麻烦，需要多次声明DateHeader包头结构体，不仅消耗时间资源，也容易出错。<br>&emsp;&emsp;因此，我们可以尝试将分开收发改为一次收发。大致思路为完善报文的结构体，使<strong>包体继承包头结构体</strong>，或者使<strong>包体结构体中包含一个包头结构体</strong>。由此完善报文的结构体，只进行一次send操作，即可发送所有报文数据。<br>&emsp;&emsp;在进行数据接收时，我们先接收包头大小的数据，随后根据包头的内容，来确定接下来接收数据的大小，即接收 总数据大小 减去 包头数据大小 的数据。而在接下来使用recv接收剩下数据时，要使用指针偏移，跳过结构体包头的接收(因为接收过了)，直接接收到包体数据位置上。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">因为包头已经接收过了 所以进行指针偏移：&amp;_login+sizeof(DateHeader)</span></span><br><span class="line"><span class="comment">接收数据长短为：sizeof(Login)-sizeof(DateHeader) 减去包头的大小</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_login+<span class="built_in">sizeof</span>(DateHeader),<span class="built_in">sizeof</span>(Login)-<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br></pre></td></tr></table></figure>


<h2 id="2-代码及其详细注释-1"><a href="#2-代码及其详细注释-1" class="headerlink" title="2.代码及其详细注释"></a>2.代码及其详细注释</h2><h3 id="2-1-服务端代码-1"><a href="#2-1-服务端代码-1" class="headerlink" title="2.1 服务端代码"></a>2.1 服务端代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;winSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//链接此动态链接库 windows特有 </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//枚举类型记录命令 </span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">cmd</span> </span><br><span class="line">&#123;</span><br><span class="line">	CMD_LOGIN,<span class="comment">//登录 </span></span><br><span class="line">	CMD_LOGINRESULT,<span class="comment">//登录结果 </span></span><br><span class="line">	CMD_LOGOUT,<span class="comment">//登出 </span></span><br><span class="line">	CMD_LOGOUTRESULT,<span class="comment">//登出结果 </span></span><br><span class="line">	CMD_ERROR<span class="comment">//错误 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义数据包头 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DateHeader</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">short</span> cmd;<span class="comment">//命令</span></span><br><span class="line">	<span class="type">short</span> date_length;<span class="comment">//数据的长短	</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包1 登录 传输账号与密码</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Login</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Login</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGIN;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Login); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">	<span class="type">char</span> PassWord[<span class="number">32</span>];<span class="comment">//密码 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包2 登录结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoginResult</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LoginResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGINRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LoginResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包3 登出 传输用户名 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Logout</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Logout</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Logout); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包4 登出结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LogoutResult</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LogoutResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUTRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LogoutResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//启动windows socket 2,x环境 windows特有 </span></span><br><span class="line">	WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>);<span class="comment">//WinSock库版本号 </span></span><br><span class="line">	WSADATA dat;<span class="comment">//网络结构体 储存WSAStartup函数调用后返回的Socket数据 </span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span> != <span class="built_in">WSAStartup</span>(ver,&amp;dat))<span class="comment">//正确初始化后返回0 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//建立一个socket </span></span><br><span class="line">	SOCKET _mysocket = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,IPPROTO_TCP);<span class="comment">//IPV4 数据流类型 TCP类型 </span></span><br><span class="line">	<span class="keyword">if</span>(INVALID_SOCKET == _mysocket)<span class="comment">//建立失败 </span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">	<span class="comment">//绑定网络端口和IP地址 </span></span><br><span class="line">	sockaddr_in _myaddr = &#123;&#125;;<span class="comment">//建立sockaddr结构体  sockaddr_in结构体方便填写 但是下面要进行类型转换 </span></span><br><span class="line">	_myaddr.sin_family = AF_INET;<span class="comment">//IPV4</span></span><br><span class="line">	_myaddr.sin_port = <span class="built_in">htons</span>(<span class="number">8888</span>);<span class="comment">//端口 host to net unsigned short</span></span><br><span class="line">	_myaddr.sin_addr.S_un.S_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);<span class="comment">//网络地址 INADDR_ANY监听所有网卡的端口 </span></span><br><span class="line">	<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">bind</span>(_mysocket,(sockaddr*)&amp;_myaddr,<span class="built_in">sizeof</span>(sockaddr_in)))<span class="comment">//socket (强制转换)sockaddr结构体 结构体大小 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;绑定不成功&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;&quot;绑定成功&quot;&lt;&lt;endl; </span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//监听网络端口</span></span><br><span class="line">	<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">listen</span>(_mysocket,<span class="number">5</span>))<span class="comment">//套接字 最大多少人连接 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;监听失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;&quot;监听成功&quot;&lt;&lt;endl; </span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//等待接收客户端连接</span></span><br><span class="line">	sockaddr_in _clientAddr = &#123;&#125;;<span class="comment">//新建sockadd结构体接收客户端数据 </span></span><br><span class="line">	<span class="type">int</span> _addr_len = <span class="built_in">sizeof</span>(sockaddr_in);<span class="comment">//获取sockadd结构体长度 </span></span><br><span class="line">	SOCKET _temp_socket = INVALID_SOCKET;<span class="comment">//声明客户端套接字 </span></span><br><span class="line">	</span><br><span class="line">	_temp_socket = <span class="built_in">accept</span>(_mysocket,(sockaddr*)&amp;_clientAddr,&amp;_addr_len);<span class="comment">//自身套接字 客户端结构体 结构体大小 </span></span><br><span class="line">	<span class="keyword">if</span>(INVALID_SOCKET == _temp_socket)<span class="comment">//接收失败 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;接收到无效客户端Socket&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;新客户端加入&quot;</span>&lt;&lt;endl; </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;IP地址为：%s \n&quot;</span>, <span class="built_in">inet_ntoa</span>(_clientAddr.sin_addr));  </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//接收客户端发送的数据 </span></span><br><span class="line">		DateHeader _head = &#123;&#125;; </span><br><span class="line">		<span class="type">int</span> _buf_len = <span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_head,<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(_buf_len&lt;=<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;客户端已退出\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;接收到包头，命令：%d，数据长度：%d\n&quot;</span>,_head.cmd,_head.date_length);</span><br><span class="line">		<span class="keyword">switch</span>(_head.cmd)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> CMD_LOGIN:<span class="comment">//登录 接收登录包体 </span></span><br><span class="line">			&#123;</span><br><span class="line">				Login _login;</span><br><span class="line">				<span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_login+<span class="built_in">sizeof</span>(DateHeader),<span class="built_in">sizeof</span>(Login)-<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				进行判断操作 </span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%s已登录\n密码：%s\n&quot;</span>,_login.UserName,_login.PassWord); </span><br><span class="line">				LoginResult _result;</span><br><span class="line">				_result.Result = <span class="number">1</span>;</span><br><span class="line">				<span class="built_in">send</span>(_temp_socket,(<span class="type">char</span>*)&amp;_result,<span class="built_in">sizeof</span>(LoginResult),<span class="number">0</span>);<span class="comment">//发包体 </span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> CMD_LOGOUT:<span class="comment">//登出 接收登出包体 </span></span><br><span class="line">			&#123;</span><br><span class="line">				Logout _logout;</span><br><span class="line">				<span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_logout+<span class="built_in">sizeof</span>(DateHeader),<span class="built_in">sizeof</span>(Logout)-<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				进行判断操作 </span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%s已登出\n&quot;</span>,_logout.UserName); </span><br><span class="line">				LogoutResult _result;</span><br><span class="line">				_result.Result = <span class="number">1</span>;</span><br><span class="line">				<span class="built_in">send</span>(_temp_socket,(<span class="type">char</span>*)&amp;_result,<span class="built_in">sizeof</span>(LogoutResult),<span class="number">0</span>);<span class="comment">//发包体</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:<span class="comment">//错误 </span></span><br><span class="line">			&#123;</span><br><span class="line">				_head.cmd = CMD_ERROR; </span><br><span class="line">				_head.date_length = <span class="number">0</span>; </span><br><span class="line">				<span class="built_in">send</span>(_temp_socket,(<span class="type">char</span>*)&amp;_head,<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);<span class="comment">//发包头 </span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭客户端socket</span></span><br><span class="line">	<span class="built_in">closesocket</span>(_temp_socket);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭socket </span></span><br><span class="line">	<span class="built_in">closesocket</span>(_mysocket); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//清除windows socket 环境 </span></span><br><span class="line">	<span class="built_in">WSACleanup</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;任务结束，程序已退出&quot;</span>); </span><br><span class="line">	 </span><br><span class="line">	<span class="built_in">getchar</span>(); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-2-客户端代码-1"><a href="#2-2-客户端代码-1" class="headerlink" title="2.2 客户端代码"></a>2.2 客户端代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;winSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//链接此动态链接库 windows特有 </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//枚举类型记录命令 </span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">cmd</span> </span><br><span class="line">&#123;</span><br><span class="line">	CMD_LOGIN,<span class="comment">//登录 </span></span><br><span class="line">	CMD_LOGINRESULT,<span class="comment">//登录结果 </span></span><br><span class="line">	CMD_LOGOUT,<span class="comment">//登出 </span></span><br><span class="line">	CMD_LOGOUTRESULT,<span class="comment">//登出结果 </span></span><br><span class="line">	CMD_ERROR<span class="comment">//错误 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义数据包头 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DateHeader</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">short</span> cmd;<span class="comment">//命令</span></span><br><span class="line">	<span class="type">short</span> date_length;<span class="comment">//数据的长短	</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包1 登录 传输账号与密码</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Login</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Login</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGIN;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Login); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">	<span class="type">char</span> PassWord[<span class="number">32</span>];<span class="comment">//密码 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包2 登录结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoginResult</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LoginResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGINRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LoginResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包3 登出 传输用户名 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Logout</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Logout</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Logout); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包4 登出结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LogoutResult</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LogoutResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUTRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LogoutResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//启动windows socket 2,x环境 windows特有 </span></span><br><span class="line">	WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>);<span class="comment">//WinSock库版本号 </span></span><br><span class="line">	WSADATA dat;<span class="comment">//网络结构体 储存WSAStartup函数调用后返回的Socket数据 </span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span> != <span class="built_in">WSAStartup</span>(ver,&amp;dat))<span class="comment">//正确初始化后返回0 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//建立一个socket </span></span><br><span class="line">	SOCKET _mysocket = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);<span class="comment">//IPV4 数据流类型 类型可以不用写 </span></span><br><span class="line">	<span class="keyword">if</span>(INVALID_SOCKET == _mysocket)<span class="comment">//建立失败 </span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//连接服务器</span></span><br><span class="line">    sockaddr_in _sin = &#123;&#125;;<span class="comment">//sockaddr结构体 </span></span><br><span class="line">    _sin.sin_family = AF_INET;<span class="comment">//IPV4</span></span><br><span class="line">    _sin.sin_port = <span class="built_in">htons</span>(<span class="number">8888</span>);<span class="comment">//想要连接的端口号 </span></span><br><span class="line">	_sin.sin_addr.S_un.S_addr =  <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);<span class="comment">//想要连接的IP </span></span><br><span class="line">	<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">connect</span>(_mysocket,(sockaddr*)&amp;_sin,<span class="built_in">sizeof</span>(sockaddr_in)))</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;连接失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">		<span class="built_in">closesocket</span>(_mysocket);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;连接成功&quot;</span>&lt;&lt;endl; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//输入请求 </span></span><br><span class="line">		<span class="type">char</span> _msg[<span class="number">256</span>] = &#123;&#125;;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,_msg);</span><br><span class="line">		<span class="comment">//处理请求 </span></span><br><span class="line">		<span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(_msg,<span class="string">&quot;exit&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(_msg,<span class="string">&quot;login&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//发送 </span></span><br><span class="line">			Login _login;</span><br><span class="line">			<span class="built_in">strcpy</span>(_login.UserName,<span class="string">&quot;河边小咸鱼&quot;</span>);</span><br><span class="line">			<span class="built_in">strcpy</span>(_login.PassWord,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">			<span class="built_in">send</span>(_mysocket,(<span class="type">const</span> <span class="type">char</span>*)&amp;_login,<span class="built_in">sizeof</span>(_login),<span class="number">0</span>);</span><br><span class="line">			<span class="comment">//接收 </span></span><br><span class="line">			LoginResult _result; </span><br><span class="line">			<span class="built_in">recv</span>(_mysocket,(<span class="type">char</span>*)&amp;_result,<span class="built_in">sizeof</span>(LoginResult),<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;result:%d\n&quot;</span>,_result.Result);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(_msg,<span class="string">&quot;logout&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//发送 </span></span><br><span class="line">			Logout _logout;</span><br><span class="line">			<span class="built_in">strcpy</span>(_logout.UserName,<span class="string">&quot;河边小咸鱼&quot;</span>);</span><br><span class="line">			<span class="built_in">send</span>(_mysocket,(<span class="type">const</span> <span class="type">char</span>*)&amp;_logout,<span class="built_in">sizeof</span>(_logout),<span class="number">0</span>);</span><br><span class="line">			<span class="comment">//接收 </span></span><br><span class="line">			LogoutResult _result; </span><br><span class="line">			<span class="built_in">recv</span>(_mysocket,(<span class="type">char</span>*)&amp;_result,<span class="built_in">sizeof</span>(LogoutResult),<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;result:%d\n&quot;</span>,_result.Result);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;不存在的命令\n&quot;</span>);</span><br><span class="line">		&#125; 	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭socket</span></span><br><span class="line">	<span class="built_in">closesocket</span>(_mysocket); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//清除windows socket 环境 </span></span><br><span class="line">	<span class="built_in">WSACleanup</span>(); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>


<h1 id="网络编程学习记录"><a href="#网络编程学习记录" class="headerlink" title="网络编程学习记录"></a>网络编程学习记录</h1><ul>
<li>使用的语言为C&#x2F;C++</li>
<li>源码支持的平台为：Windows</li>
</ul>
<p>笔记一：建立基础TCP服务端&#x2F;客户端 &emsp;<a href="https://blog.csdn.net/qq_45698148/article/details/112967657">点我跳转</a><br>笔记二：网络数据报文的收发 &emsp;<a href="https://blog.csdn.net/qq_45698148/article/details/112981662">点我跳转</a><br>笔记三：升级为select网络模型 &emsp;<a href="&emsp;https://blog.csdn.net/qq_45698148/article/details/113061122">点我跳转</a><br>笔记四：跨平台支持Windows、Linux系统 &emsp;<a href="https://blog.csdn.net/qq_45698148/article/details/113095420">点我跳转</a><br>笔记五：源码的封装 &emsp;<a href="https://blog.csdn.net/qq_45698148/article/details/113191673">点我跳转</a><br>笔记六：缓冲区溢出与粘包分包 &emsp;<a href="https://blog.csdn.net/qq_45698148/article/details/113307959">点我跳转</a><br>笔记七：服务端多线程分离业务处理高负载 &emsp;<a href="https://blog.csdn.net/qq_45698148/article/details/113704768">点我跳转</a><br>笔记八：对socket select网络模型的优化 &emsp;<a href="https://blog.csdn.net/qq_45698148/article/details/113895569">点我跳转</a><br>笔记九：消息接收与发送分离 &emsp;<a href="https://blog.csdn.net/qq_45698148/article/details/113899184">点我跳转</a><br>笔记十：项目化 (加入内存池静态库 &#x2F; 报文动态库) &emsp;<a href="https://blog.csdn.net/qq_45698148/article/details/116137196">更多笔记请点我</a></p>
<p>@<a href="%E7%AC%94%E8%AE%B0%E4%BA%8C">TOC</a></p>
<h1 id="一、网络数据报文的格式定义-1"><a href="#一、网络数据报文的格式定义-1" class="headerlink" title="一、网络数据报文的格式定义"></a>一、网络数据报文的格式定义</h1><ul>
<li>报文有两个部分，<strong>包头</strong>和<strong>包体</strong>，是网络消息的基本单元。</li>
<li><strong>包头：</strong> 描述本次消息包的大小，描述包体数据的作用。</li>
<li><strong>包体：</strong> 其中包含了需要传输的数据。</li>
</ul>
<p>&emsp;&emsp;根据此数据结构，我们可以根据包头的内容，来灵活的对包体的数据进行处理。</p>
<h1 id="二、将包头与包体数据分开收发-1"><a href="#二、将包头与包体数据分开收发-1" class="headerlink" title="二、将包头与包体数据分开收发"></a>二、将包头与包体数据分开收发</h1><h2 id="1-概括-1"><a href="#1-概括-1" class="headerlink" title="1.概括"></a>1.概括</h2><p>&emsp;&emsp;通过上文对网络数据报文的定义，我们可以很轻易的想到：</p>
<ol>
<li>发送端进行两次<strong>send</strong>操作，第一次<strong>send</strong>发送包头，第二次<strong>send</strong>发送包体，即可实现网络数据报文的发送。</li>
<li>接收端进行两次<strong>recv</strong>操作，第一次<strong>recv</strong>接收包头，第二次<strong>recv</strong>接收包体并根据包头的内容进行数据处理，即可实现网络数据报文的接收。</li>
</ol>
<p>&emsp;&emsp;按以上操作，即可实现网络数据报文的收发。</p>
<h2 id="2-代码及其详细注释-2"><a href="#2-代码及其详细注释-2" class="headerlink" title="2.代码及其详细注释"></a>2.代码及其详细注释</h2><h3 id="2-1-服务端代码-2"><a href="#2-1-服务端代码-2" class="headerlink" title="2.1 服务端代码"></a>2.1 服务端代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;winSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//链接此动态链接库 windows特有 </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//枚举类型记录命令 </span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">cmd</span> </span><br><span class="line">&#123;</span><br><span class="line">	CMD_LOGIN,<span class="comment">//登录 </span></span><br><span class="line">	CMD_LOGOUT,<span class="comment">//登出 </span></span><br><span class="line">	CMD_ERROR<span class="comment">//错误 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义数据包头 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DateHeader</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">short</span> cmd;<span class="comment">//命令</span></span><br><span class="line">	<span class="type">short</span> date_length;<span class="comment">//数据的长短	</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包体1 登录 传输账号与密码</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Login</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">	<span class="type">char</span> PassWord[<span class="number">32</span>];<span class="comment">//密码 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包体2 登录结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoginResult</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包体3 登出 传输用户名 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Logout</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包体4 登出结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LogoutResult</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//启动windows socket 2,x环境 windows特有 </span></span><br><span class="line">	WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>);<span class="comment">//WinSock库版本号 </span></span><br><span class="line">	WSADATA dat;<span class="comment">//网络结构体 储存WSAStartup函数调用后返回的Socket数据 </span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span> != <span class="built_in">WSAStartup</span>(ver,&amp;dat))<span class="comment">//正确初始化后返回0 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//建立一个socket </span></span><br><span class="line">	SOCKET _mysocket = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,IPPROTO_TCP);<span class="comment">//IPV4 数据流类型 TCP类型 </span></span><br><span class="line">	<span class="keyword">if</span>(INVALID_SOCKET == _mysocket)<span class="comment">//建立失败 </span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">	<span class="comment">//绑定网络端口和IP地址 </span></span><br><span class="line">	sockaddr_in _myaddr = &#123;&#125;;<span class="comment">//建立sockaddr结构体  sockaddr_in结构体方便填写 但是下面要进行类型转换 </span></span><br><span class="line">	_myaddr.sin_family = AF_INET;<span class="comment">//IPV4</span></span><br><span class="line">	_myaddr.sin_port = <span class="built_in">htons</span>(<span class="number">8888</span>);<span class="comment">//端口 host to net unsigned short</span></span><br><span class="line">	_myaddr.sin_addr.S_un.S_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);<span class="comment">//网络地址 INADDR_ANY监听所有网卡的端口 </span></span><br><span class="line">	<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">bind</span>(_mysocket,(sockaddr*)&amp;_myaddr,<span class="built_in">sizeof</span>(sockaddr_in)))<span class="comment">//socket (强制转换)sockaddr结构体 结构体大小 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;绑定不成功&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;&quot;绑定成功&quot;&lt;&lt;endl; </span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//监听网络端口</span></span><br><span class="line">	<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">listen</span>(_mysocket,<span class="number">5</span>))<span class="comment">//套接字 最大多少人连接 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;监听失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;&quot;监听成功&quot;&lt;&lt;endl; </span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//等待接收客户端连接</span></span><br><span class="line">	sockaddr_in _clientAddr = &#123;&#125;;<span class="comment">//新建sockadd结构体接收客户端数据 </span></span><br><span class="line">	<span class="type">int</span> _addr_len = <span class="built_in">sizeof</span>(sockaddr_in);<span class="comment">//获取sockadd结构体长度 </span></span><br><span class="line">	SOCKET _temp_socket = INVALID_SOCKET;<span class="comment">//声明客户端套接字 </span></span><br><span class="line">	</span><br><span class="line">	_temp_socket = <span class="built_in">accept</span>(_mysocket,(sockaddr*)&amp;_clientAddr,&amp;_addr_len);<span class="comment">//自身套接字 客户端结构体 结构体大小 </span></span><br><span class="line">	<span class="keyword">if</span>(INVALID_SOCKET == _temp_socket)<span class="comment">//接收失败 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;接收到无效客户端Socket&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;新客户端加入&quot;</span>&lt;&lt;endl; </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;IP地址为：%s \n&quot;</span>, <span class="built_in">inet_ntoa</span>(_clientAddr.sin_addr));  </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//接收客户端发送的数据 </span></span><br><span class="line">		DateHeader _head = &#123;&#125;; </span><br><span class="line">		<span class="type">int</span> _buf_len = <span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_head,<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(_buf_len&lt;=<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;客户端已退出\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;接收到包头，命令：%d，数据长度：%d\n&quot;</span>,_head.cmd,_head.date_length);</span><br><span class="line">		<span class="keyword">switch</span>(_head.cmd)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> CMD_LOGIN:<span class="comment">//登录 接收登录包体 </span></span><br><span class="line">			&#123;</span><br><span class="line">				Login _login = &#123;&#125;;</span><br><span class="line">				<span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_login,<span class="built_in">sizeof</span>(Login),<span class="number">0</span>);</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				进行判断操作 </span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%s已登录\n&quot;</span>,_login.UserName); </span><br><span class="line">				<span class="built_in">send</span>(_temp_socket,(<span class="type">char</span>*)&amp;_head,<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);<span class="comment">//发包头 </span></span><br><span class="line">				LoginResult _result = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">				<span class="built_in">send</span>(_temp_socket,(<span class="type">char</span>*)&amp;_result,<span class="built_in">sizeof</span>(LoginResult),<span class="number">0</span>);<span class="comment">//发包体 </span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> CMD_LOGOUT:<span class="comment">//登出 接收登出包体 </span></span><br><span class="line">			&#123;</span><br><span class="line">				Logout _logout = &#123;&#125;;</span><br><span class="line">				<span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_logout,<span class="built_in">sizeof</span>(Logout),<span class="number">0</span>);</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				进行判断操作 </span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%s已登出\n&quot;</span>,_logout.UserName); </span><br><span class="line">				<span class="built_in">send</span>(_temp_socket,(<span class="type">char</span>*)&amp;_head,<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);<span class="comment">//发包头 </span></span><br><span class="line">				LogoutResult _result = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">				<span class="built_in">send</span>(_temp_socket,(<span class="type">char</span>*)&amp;_result,<span class="built_in">sizeof</span>(LogoutResult),<span class="number">0</span>);<span class="comment">//发包体</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:<span class="comment">//错误 </span></span><br><span class="line">			&#123;</span><br><span class="line">				_head.cmd = CMD_ERROR; </span><br><span class="line">				_head.date_length = <span class="number">0</span>; </span><br><span class="line">				<span class="built_in">send</span>(_temp_socket,(<span class="type">char</span>*)&amp;_head,<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);<span class="comment">//发包头 </span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭客户端socket</span></span><br><span class="line">	<span class="built_in">closesocket</span>(_temp_socket);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭socket </span></span><br><span class="line">	<span class="built_in">closesocket</span>(_mysocket); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//清除windows socket 环境 </span></span><br><span class="line">	<span class="built_in">WSACleanup</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;任务结束，程序已退出&quot;</span>); </span><br><span class="line">	 </span><br><span class="line">	<span class="built_in">getchar</span>(); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="2-2-客户端代码-2"><a href="#2-2-客户端代码-2" class="headerlink" title="2.2 客户端代码"></a>2.2 客户端代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;winSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//链接此动态链接库 windows特有 </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//枚举类型记录命令 </span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">cmd</span> </span><br><span class="line">&#123;</span><br><span class="line">	CMD_LOGIN,<span class="comment">//登录 </span></span><br><span class="line">	CMD_LOGOUT,<span class="comment">//登出 </span></span><br><span class="line">	CMD_ERROR<span class="comment">//错误 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义数据包头 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DateHeader</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">short</span> cmd;<span class="comment">//命令</span></span><br><span class="line">	<span class="type">short</span> date_length;<span class="comment">//数据的长短	</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包体1 登录 传输账号与密码</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Login</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">	<span class="type">char</span> PassWord[<span class="number">32</span>];<span class="comment">//密码 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包体2 登录结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoginResult</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包体3 登出 传输用户名 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Logout</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包体4 登出结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LogoutResult</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//启动windows socket 2,x环境 windows特有 </span></span><br><span class="line">	WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>);<span class="comment">//WinSock库版本号 </span></span><br><span class="line">	WSADATA dat;<span class="comment">//网络结构体 储存WSAStartup函数调用后返回的Socket数据 </span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span> != <span class="built_in">WSAStartup</span>(ver,&amp;dat))<span class="comment">//正确初始化后返回0 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//建立一个socket </span></span><br><span class="line">	SOCKET _mysocket = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);<span class="comment">//IPV4 数据流类型 类型可以不用写 </span></span><br><span class="line">	<span class="keyword">if</span>(INVALID_SOCKET == _mysocket)<span class="comment">//建立失败 </span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//连接服务器</span></span><br><span class="line">    sockaddr_in _sin = &#123;&#125;;<span class="comment">//sockaddr结构体 </span></span><br><span class="line">    _sin.sin_family = AF_INET;<span class="comment">//IPV4</span></span><br><span class="line">    _sin.sin_port = <span class="built_in">htons</span>(<span class="number">8888</span>);<span class="comment">//想要连接的端口号 </span></span><br><span class="line">	_sin.sin_addr.S_un.S_addr =  <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);<span class="comment">//想要连接的IP </span></span><br><span class="line">	<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">connect</span>(_mysocket,(sockaddr*)&amp;_sin,<span class="built_in">sizeof</span>(sockaddr_in)))</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;连接失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">		<span class="built_in">closesocket</span>(_mysocket);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;连接成功&quot;</span>&lt;&lt;endl; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//输入请求 </span></span><br><span class="line">		<span class="type">char</span> _msg[<span class="number">256</span>] = &#123;&#125;;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,_msg);</span><br><span class="line">		<span class="comment">//处理请求 </span></span><br><span class="line">		<span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(_msg,<span class="string">&quot;exit&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(_msg,<span class="string">&quot;login&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//发送 </span></span><br><span class="line">			Login _login = &#123;<span class="string">&quot;河边小咸鱼&quot;</span>,<span class="string">&quot;123456&quot;</span>&#125;;</span><br><span class="line">			DateHeader _head = &#123;CMD_LOGIN,<span class="built_in">sizeof</span>(_login)&#125;;</span><br><span class="line">			<span class="built_in">send</span>(_mysocket,(<span class="type">const</span> <span class="type">char</span>*)&amp;_head,<span class="built_in">sizeof</span>(_head),<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">send</span>(_mysocket,(<span class="type">const</span> <span class="type">char</span>*)&amp;_login,<span class="built_in">sizeof</span>(_login),<span class="number">0</span>);</span><br><span class="line">			<span class="comment">//接收 </span></span><br><span class="line">			DateHeader _head2 = &#123;&#125;; </span><br><span class="line">			LoginResult _result= &#123;&#125;; </span><br><span class="line">			<span class="built_in">recv</span>(_mysocket,(<span class="type">char</span>*)&amp;_head2,<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">recv</span>(_mysocket,(<span class="type">char</span>*)&amp;_result,<span class="built_in">sizeof</span>(LoginResult),<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;result:%d\n&quot;</span>,_result.Result);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(_msg,<span class="string">&quot;logout&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//发送 </span></span><br><span class="line">			Logout _logout = &#123;<span class="string">&quot;河边小咸鱼&quot;</span>&#125;;</span><br><span class="line">			DateHeader _head = &#123;CMD_LOGOUT,<span class="built_in">sizeof</span>(_logout)&#125;;</span><br><span class="line">			<span class="built_in">send</span>(_mysocket,(<span class="type">const</span> <span class="type">char</span>*)&amp;_head,<span class="built_in">sizeof</span>(_head),<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">send</span>(_mysocket,(<span class="type">const</span> <span class="type">char</span>*)&amp;_logout,<span class="built_in">sizeof</span>(_logout),<span class="number">0</span>);</span><br><span class="line">			<span class="comment">//接收 </span></span><br><span class="line">			DateHeader _head2 = &#123;&#125;; </span><br><span class="line">			LogoutResult _result= &#123;&#125;; </span><br><span class="line">			<span class="built_in">recv</span>(_mysocket,(<span class="type">char</span>*)&amp;_head2,<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">recv</span>(_mysocket,(<span class="type">char</span>*)&amp;_result,<span class="built_in">sizeof</span>(LogoutResult),<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;result:%d\n&quot;</span>,_result.Result);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;不存在的命令\n&quot;</span>);</span><br><span class="line">		&#125; 	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭socket</span></span><br><span class="line">	<span class="built_in">closesocket</span>(_mysocket); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//清除windows socket 环境 </span></span><br><span class="line">	<span class="built_in">WSACleanup</span>(); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>


<h1 id="三、将分开收发报文数据改为一次收发-1"><a href="#三、将分开收发报文数据改为一次收发-1" class="headerlink" title="三、将分开收发报文数据改为一次收发"></a>三、将分开收发报文数据改为一次收发</h1><h2 id="1-思路-1"><a href="#1-思路-1" class="headerlink" title="1.思路"></a>1.思路</h2><p>&emsp;&emsp;由上文，我们可以知道，可以通过两次send和两次recv进行报文的收发，但是其中操作较为麻烦，需要多次声明DateHeader包头结构体，不仅消耗时间资源，也容易出错。<br>&emsp;&emsp;因此，我们可以尝试将分开收发改为一次收发。大致思路为完善报文的结构体，使<strong>包体继承包头结构体</strong>，或者使<strong>包体结构体中包含一个包头结构体</strong>。由此完善报文的结构体，只进行一次send操作，即可发送所有报文数据。<br>&emsp;&emsp;在进行数据接收时，我们先接收包头大小的数据，随后根据包头的内容，来确定接下来接收数据的大小，即接收 总数据大小 减去 包头数据大小 的数据。而在接下来使用recv接收剩下数据时，要使用指针偏移，跳过结构体包头的接收(因为接收过了)，直接接收到包体数据位置上。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">因为包头已经接收过了 所以进行指针偏移：&amp;_login+sizeof(DateHeader)</span></span><br><span class="line"><span class="comment">接收数据长短为：sizeof(Login)-sizeof(DateHeader) 减去包头的大小</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_login+<span class="built_in">sizeof</span>(DateHeader),<span class="built_in">sizeof</span>(Login)-<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br></pre></td></tr></table></figure>


<h2 id="2-代码及其详细注释-3"><a href="#2-代码及其详细注释-3" class="headerlink" title="2.代码及其详细注释"></a>2.代码及其详细注释</h2><h3 id="2-1-服务端代码-3"><a href="#2-1-服务端代码-3" class="headerlink" title="2.1 服务端代码"></a>2.1 服务端代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;winSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//链接此动态链接库 windows特有 </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//枚举类型记录命令 </span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">cmd</span> </span><br><span class="line">&#123;</span><br><span class="line">	CMD_LOGIN,<span class="comment">//登录 </span></span><br><span class="line">	CMD_LOGINRESULT,<span class="comment">//登录结果 </span></span><br><span class="line">	CMD_LOGOUT,<span class="comment">//登出 </span></span><br><span class="line">	CMD_LOGOUTRESULT,<span class="comment">//登出结果 </span></span><br><span class="line">	CMD_ERROR<span class="comment">//错误 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义数据包头 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DateHeader</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">short</span> cmd;<span class="comment">//命令</span></span><br><span class="line">	<span class="type">short</span> date_length;<span class="comment">//数据的长短	</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包1 登录 传输账号与密码</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Login</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Login</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGIN;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Login); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">	<span class="type">char</span> PassWord[<span class="number">32</span>];<span class="comment">//密码 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包2 登录结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoginResult</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LoginResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGINRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LoginResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包3 登出 传输用户名 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Logout</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Logout</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Logout); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包4 登出结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LogoutResult</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LogoutResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUTRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LogoutResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//启动windows socket 2,x环境 windows特有 </span></span><br><span class="line">	WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>);<span class="comment">//WinSock库版本号 </span></span><br><span class="line">	WSADATA dat;<span class="comment">//网络结构体 储存WSAStartup函数调用后返回的Socket数据 </span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span> != <span class="built_in">WSAStartup</span>(ver,&amp;dat))<span class="comment">//正确初始化后返回0 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//建立一个socket </span></span><br><span class="line">	SOCKET _mysocket = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,IPPROTO_TCP);<span class="comment">//IPV4 数据流类型 TCP类型 </span></span><br><span class="line">	<span class="keyword">if</span>(INVALID_SOCKET == _mysocket)<span class="comment">//建立失败 </span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">	<span class="comment">//绑定网络端口和IP地址 </span></span><br><span class="line">	sockaddr_in _myaddr = &#123;&#125;;<span class="comment">//建立sockaddr结构体  sockaddr_in结构体方便填写 但是下面要进行类型转换 </span></span><br><span class="line">	_myaddr.sin_family = AF_INET;<span class="comment">//IPV4</span></span><br><span class="line">	_myaddr.sin_port = <span class="built_in">htons</span>(<span class="number">8888</span>);<span class="comment">//端口 host to net unsigned short</span></span><br><span class="line">	_myaddr.sin_addr.S_un.S_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);<span class="comment">//网络地址 INADDR_ANY监听所有网卡的端口 </span></span><br><span class="line">	<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">bind</span>(_mysocket,(sockaddr*)&amp;_myaddr,<span class="built_in">sizeof</span>(sockaddr_in)))<span class="comment">//socket (强制转换)sockaddr结构体 结构体大小 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;绑定不成功&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;&quot;绑定成功&quot;&lt;&lt;endl; </span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//监听网络端口</span></span><br><span class="line">	<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">listen</span>(_mysocket,<span class="number">5</span>))<span class="comment">//套接字 最大多少人连接 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;监听失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;&quot;监听成功&quot;&lt;&lt;endl; </span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//等待接收客户端连接</span></span><br><span class="line">	sockaddr_in _clientAddr = &#123;&#125;;<span class="comment">//新建sockadd结构体接收客户端数据 </span></span><br><span class="line">	<span class="type">int</span> _addr_len = <span class="built_in">sizeof</span>(sockaddr_in);<span class="comment">//获取sockadd结构体长度 </span></span><br><span class="line">	SOCKET _temp_socket = INVALID_SOCKET;<span class="comment">//声明客户端套接字 </span></span><br><span class="line">	</span><br><span class="line">	_temp_socket = <span class="built_in">accept</span>(_mysocket,(sockaddr*)&amp;_clientAddr,&amp;_addr_len);<span class="comment">//自身套接字 客户端结构体 结构体大小 </span></span><br><span class="line">	<span class="keyword">if</span>(INVALID_SOCKET == _temp_socket)<span class="comment">//接收失败 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;接收到无效客户端Socket&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;新客户端加入&quot;</span>&lt;&lt;endl; </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;IP地址为：%s \n&quot;</span>, <span class="built_in">inet_ntoa</span>(_clientAddr.sin_addr));  </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//接收客户端发送的数据 </span></span><br><span class="line">		DateHeader _head = &#123;&#125;; </span><br><span class="line">		<span class="type">int</span> _buf_len = <span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_head,<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(_buf_len&lt;=<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;客户端已退出\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;接收到包头，命令：%d，数据长度：%d\n&quot;</span>,_head.cmd,_head.date_length);</span><br><span class="line">		<span class="keyword">switch</span>(_head.cmd)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> CMD_LOGIN:<span class="comment">//登录 接收登录包体 </span></span><br><span class="line">			&#123;</span><br><span class="line">				Login _login;</span><br><span class="line">				<span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_login+<span class="built_in">sizeof</span>(DateHeader),<span class="built_in">sizeof</span>(Login)-<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				进行判断操作 </span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%s已登录\n密码：%s\n&quot;</span>,_login.UserName,_login.PassWord); </span><br><span class="line">				LoginResult _result;</span><br><span class="line">				_result.Result = <span class="number">1</span>;</span><br><span class="line">				<span class="built_in">send</span>(_temp_socket,(<span class="type">char</span>*)&amp;_result,<span class="built_in">sizeof</span>(LoginResult),<span class="number">0</span>);<span class="comment">//发包体 </span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> CMD_LOGOUT:<span class="comment">//登出 接收登出包体 </span></span><br><span class="line">			&#123;</span><br><span class="line">				Logout _logout;</span><br><span class="line">				<span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_logout+<span class="built_in">sizeof</span>(DateHeader),<span class="built_in">sizeof</span>(Logout)-<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				进行判断操作 </span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%s已登出\n&quot;</span>,_logout.UserName); </span><br><span class="line">				LogoutResult _result;</span><br><span class="line">				_result.Result = <span class="number">1</span>;</span><br><span class="line">				<span class="built_in">send</span>(_temp_socket,(<span class="type">char</span>*)&amp;_result,<span class="built_in">sizeof</span>(LogoutResult),<span class="number">0</span>);<span class="comment">//发包体</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:<span class="comment">//错误 </span></span><br><span class="line">			&#123;</span><br><span class="line">				_head.cmd = CMD_ERROR; </span><br><span class="line">				_head.date_length = <span class="number">0</span>; </span><br><span class="line">				<span class="built_in">send</span>(_temp_socket,(<span class="type">char</span>*)&amp;_head,<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);<span class="comment">//发包头 </span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭客户端socket</span></span><br><span class="line">	<span class="built_in">closesocket</span>(_temp_socket);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭socket </span></span><br><span class="line">	<span class="built_in">closesocket</span>(_mysocket); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//清除windows socket 环境 </span></span><br><span class="line">	<span class="built_in">WSACleanup</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;任务结束，程序已退出&quot;</span>); </span><br><span class="line">	 </span><br><span class="line">	<span class="built_in">getchar</span>(); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-2-客户端代码-3"><a href="#2-2-客户端代码-3" class="headerlink" title="2.2 客户端代码"></a>2.2 客户端代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;winSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//链接此动态链接库 windows特有 </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//枚举类型记录命令 </span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">cmd</span> </span><br><span class="line">&#123;</span><br><span class="line">	CMD_LOGIN,<span class="comment">//登录 </span></span><br><span class="line">	CMD_LOGINRESULT,<span class="comment">//登录结果 </span></span><br><span class="line">	CMD_LOGOUT,<span class="comment">//登出 </span></span><br><span class="line">	CMD_LOGOUTRESULT,<span class="comment">//登出结果 </span></span><br><span class="line">	CMD_ERROR<span class="comment">//错误 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义数据包头 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DateHeader</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">short</span> cmd;<span class="comment">//命令</span></span><br><span class="line">	<span class="type">short</span> date_length;<span class="comment">//数据的长短	</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包1 登录 传输账号与密码</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Login</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Login</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGIN;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Login); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">	<span class="type">char</span> PassWord[<span class="number">32</span>];<span class="comment">//密码 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包2 登录结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoginResult</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LoginResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGINRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LoginResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包3 登出 传输用户名 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Logout</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Logout</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Logout); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包4 登出结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LogoutResult</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LogoutResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUTRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LogoutResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//启动windows socket 2,x环境 windows特有 </span></span><br><span class="line">	WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>);<span class="comment">//WinSock库版本号 </span></span><br><span class="line">	WSADATA dat;<span class="comment">//网络结构体 储存WSAStartup函数调用后返回的Socket数据 </span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span> != <span class="built_in">WSAStartup</span>(ver,&amp;dat))<span class="comment">//正确初始化后返回0 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//建立一个socket </span></span><br><span class="line">	SOCKET _mysocket = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);<span class="comment">//IPV4 数据流类型 类型可以不用写 </span></span><br><span class="line">	<span class="keyword">if</span>(INVALID_SOCKET == _mysocket)<span class="comment">//建立失败 </span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//连接服务器</span></span><br><span class="line">    sockaddr_in _sin = &#123;&#125;;<span class="comment">//sockaddr结构体 </span></span><br><span class="line">    _sin.sin_family = AF_INET;<span class="comment">//IPV4</span></span><br><span class="line">    _sin.sin_port = <span class="built_in">htons</span>(<span class="number">8888</span>);<span class="comment">//想要连接的端口号 </span></span><br><span class="line">	_sin.sin_addr.S_un.S_addr =  <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);<span class="comment">//想要连接的IP </span></span><br><span class="line">	<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">connect</span>(_mysocket,(sockaddr*)&amp;_sin,<span class="built_in">sizeof</span>(sockaddr_in)))</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;连接失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">		<span class="built_in">closesocket</span>(_mysocket);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;连接成功&quot;</span>&lt;&lt;endl; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//输入请求 </span></span><br><span class="line">		<span class="type">char</span> _msg[<span class="number">256</span>] = &#123;&#125;;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,_msg);</span><br><span class="line">		<span class="comment">//处理请求 </span></span><br><span class="line">		<span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(_msg,<span class="string">&quot;exit&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(_msg,<span class="string">&quot;login&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//发送 </span></span><br><span class="line">			Login _login;</span><br><span class="line">			<span class="built_in">strcpy</span>(_login.UserName,<span class="string">&quot;河边小咸鱼&quot;</span>);</span><br><span class="line">			<span class="built_in">strcpy</span>(_login.PassWord,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">			<span class="built_in">send</span>(_mysocket,(<span class="type">const</span> <span class="type">char</span>*)&amp;_login,<span class="built_in">sizeof</span>(_login),<span class="number">0</span>);</span><br><span class="line">			<span class="comment">//接收 </span></span><br><span class="line">			LoginResult _result; </span><br><span class="line">			<span class="built_in">recv</span>(_mysocket,(<span class="type">char</span>*)&amp;_result,<span class="built_in">sizeof</span>(LoginResult),<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;result:%d\n&quot;</span>,_result.Result);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(_msg,<span class="string">&quot;logout&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//发送 </span></span><br><span class="line">			Logout _logout;</span><br><span class="line">			<span class="built_in">strcpy</span>(_logout.UserName,<span class="string">&quot;河边小咸鱼&quot;</span>);</span><br><span class="line">			<span class="built_in">send</span>(_mysocket,(<span class="type">const</span> <span class="type">char</span>*)&amp;_logout,<span class="built_in">sizeof</span>(_logout),<span class="number">0</span>);</span><br><span class="line">			<span class="comment">//接收 </span></span><br><span class="line">			LogoutResult _result; </span><br><span class="line">			<span class="built_in">recv</span>(_mysocket,(<span class="type">char</span>*)&amp;_result,<span class="built_in">sizeof</span>(LogoutResult),<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;result:%d\n&quot;</span>,_result.Result);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;不存在的命令\n&quot;</span>);</span><br><span class="line">		&#125; 	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭socket</span></span><br><span class="line">	<span class="built_in">closesocket</span>(_mysocket); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//清除windows socket 环境 </span></span><br><span class="line">	<span class="built_in">WSACleanup</span>(); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++网络编程学习：跨平台支持Windows、Linux系统</title>
    <url>/2021/01/24/20210124_C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%94%AF%E6%8C%81Windows%E3%80%81Linux%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<ul>
<li>使用的语言为C&#x2F;C++</li>
<li>源码支持的平台为：Windows &#x2F; Linux</li>
</ul>
<h1 id="一、为何要进行跨平台操作"><a href="#一、为何要进行跨平台操作" class="headerlink" title="一、为何要进行跨平台操作"></a>一、为何要进行跨平台操作</h1><p>&emsp;&emsp;首先，我是想在网络编程学习渐入佳境后，自己尝试做一个网络方面的项目，其中就必须用到服务器。Linux服务器相比Windows服务器更加稳定且高效，所以对于我来说，学会如何编写出可以在Linux系统下运行的网络程序是必不可少的。<br>&emsp;&emsp;其次，就目前来说，企业中的高性能网络编程都是基于Linux的，学会跨平台的网络编程技能，可以在未来就业方面等有很大的好处。<br>&emsp;&emsp;由此，我决定在网络编程学习的第四小阶段，学习如何进行跨平台的网络编程。</p>
<span id="more"></span>

<h1 id="二、关于Win与Linux系统下网络编程的差异"><a href="#二、关于Win与Linux系统下网络编程的差异" class="headerlink" title="二、关于Win与Linux系统下网络编程的差异"></a>二、关于Win与Linux系统下网络编程的差异</h1><p><font size="5"><strong>差异一</strong></font></p>
<p>在Linux环境下，程序的头文件与定义与Win环境下存在差异。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;winSock2.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//链接此动态链接库 windows特有 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span><span class="comment">//selcet</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span><span class="comment">//uni std</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SOCKET int</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> INVALID_SOCKET (SOCKET)(~0)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SOCKET_ERROR (-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>这是更改后的程序部分。<br>可以看出：</p>
<ul>
<li>Win环境下的特有头文件 <strong>&lt;windows.h&gt;</strong> 对应Linux环境下的特有头文件 **&lt;unistd.h&gt;**。</li>
<li>Win环境下的网络头文件 <strong>&lt;winSock2.h&gt;</strong> 对应Linux环境下的特有头文件 **&lt;arpa&#x2F;inet.h&gt;**。</li>
<li>SOCKET为Win环境下的特有数据类型，其原型为<strong>unsigned __int64</strong>，所以我们在Linux下，需要简单对SOCKET进行定义。</li>
<li>Linux中同样对<strong>INVALID_SOCKET</strong>与<strong>SOCKET_ERROR</strong>也没有定义，所以我们参考Win中的定义，在Linux系统下对其定义。<br> <img src="/images/2021-01-24/1.jpg" alt="图1"> (此图为Win环境下_socket_types.h头文件中的相关定义)</li>
</ul>
<p><font size="5"><strong>差异二</strong></font></p>
<p>在Linux环境下不需要使用<strong>WSAStartup</strong>与<strong>WSACleanup</strong>搭建网络环境，这是Win环境特有的。</p>
<ul>
<li>所以我们只需要加上判断即可，当检测到系统环境为Win时执行即可：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">	<span class="comment">//启动windows socket 2,x环境 windows特有 </span></span><br><span class="line">	WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>);<span class="comment">//WinSock库版本号 </span></span><br><span class="line">	WSADATA dat;<span class="comment">//网络结构体 储存WSAStartup函数调用后返回的Socket数据 </span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span> != <span class="built_in">WSAStartup</span>(ver,&amp;dat))<span class="comment">//正确初始化后返回0 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">	<span class="comment">//清除windows socket 环境 </span></span><br><span class="line">	<span class="built_in">WSACleanup</span>(); </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><font size="5"><strong>差异三</strong></font></p>
<p>Linux环境与Win环境下，网络通信相关结构体 <strong>sockaddr_in</strong>和<strong>sockaddr</strong> 存在差异。<br>最明显的差异为存储IP的结构不太一样。</p>
<ul>
<li>所以我们这样更改即可：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">	_sin.sin_addr.S_un.S_addr =  <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);<span class="comment">//想要连接的IP </span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	_sin.sin_addr.s_addr =  <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);<span class="comment">//想要连接的IP </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><font size="5"><strong>差异四</strong></font></p>
<p>Linux环境与Win环境下，关闭套接字的函数存在差异。<br>Win下为**closesocket()<strong>，Linux下则简单粗暴为</strong>close()**。</p>
<ul>
<li>所以我们这样更改即可：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">	<span class="comment">//关闭socket</span></span><br><span class="line">	<span class="built_in">closesocket</span>(_mysocket);  </span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="comment">//关闭socket/LINUX</span></span><br><span class="line">	<span class="built_in">close</span>(_mysocket);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><font size="5"><strong>差异五</strong></font></p>
<p>Linux环境与Win环境下，服务器的accept连接函数参数存在差异。<br>Win下的最后一个参数为<strong>int</strong>型地址，Linux下则为<strong>socklen_t</strong>型地址。进行一次强制转换即可。</p>
<ul>
<li>所以我们这样更改即可：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32	</span></span><br><span class="line">	_temp_socket = <span class="built_in">accept</span>(_mysocket,(sockaddr*)&amp;_clientAddr,&amp;_addr_len);<span class="comment">//自身套接字 客户端结构体 结构体大小 </span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	_temp_socket = <span class="built_in">accept</span>(_mysocket,(sockaddr*)&amp;_clientAddr,(<span class="type">socklen_t</span>*)&amp;_addr_len);<span class="comment">//自身套接字 客户端结构体 结构体大小 </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<font size="5"><strong>差异六</strong></font></li>
</ul>
<p>Linux环境与Win环境下，<strong>fd_set</strong>结构体中的参数出现了变化，不再有储存socket数量的<strong>fd_count</strong>变量，所以我们需要对源码下<strong>select</strong>函数的第一个参数进行准确的数据传入。</p>
<p>select函数的第一个参数实际为 <strong>所有socket的最大值+1</strong>，所以我们新建一个变量，用于储存最大值。在每次对fdread集合进行导入时，找到socket的最大值，随后传入select函数即可。</p>
<ul>
<li>所以我们这样更改即可：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SOCKET _maxSock = _mysocket;<span class="comment">//最大socket</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> n=_clients.<span class="built_in">size</span>()<span class="number">-1</span>; n&gt;=<span class="number">0</span>; --n)<span class="comment">//把连接的客户端 放入read集合 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">FD_SET</span>(_clients[n],&amp;_fdRead);</span><br><span class="line">	<span class="keyword">if</span>(_maxSock &lt; _clients[n])</span><br><span class="line">	&#123;</span><br><span class="line">		_maxSock = _clients[n];<span class="comment">//找最大</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//select函数筛选select </span></span><br><span class="line"><span class="type">int</span> _ret = <span class="built_in">select</span>(_maxSock<span class="number">+1</span>,&amp;_fdRead,&amp;_fdWrite,&amp;_fdExcept,&amp;<span class="type">_t</span>);</span><br></pre></td></tr></table></figure>
<font size="5"><strong>差异七</strong></font></li>
</ul>
<p>Linux环境与Win环境下，<strong>fd_set</strong>结构体中的参数出现了变化，不再有储存socket数量的<strong>fd_count</strong>变量，所以我们需要对源码下面关于遍历socket的逻辑进行改变。</p>
<p>首先遍历 <strong>_clients</strong> 数组中的所有socket，随后使用<strong>FD_ISSET</strong>函数判定其是否存在待处理事件，如果有，即可按逻辑进行处理。</p>
<ul>
<li>所以我们这样更改即可：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;_clients.<span class="built_in">size</span>(); ++n)<span class="comment">//遍历所有socket</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(_clients[n],&amp;_fdRead))<span class="comment">//看一下是否在待处理事件列表中</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="number">-1</span> == _handle(_clients[n]))<span class="comment">//处理请求 客户端退出的话 </span></span><br><span class="line">		&#123;</span><br><span class="line">			vector&lt;SOCKET&gt;::iterator iter = _clients.<span class="built_in">begin</span>()+n;<span class="comment">//找到退出客户端的地址</span></span><br><span class="line">			<span class="keyword">if</span>(iter != _clients.<span class="built_in">end</span>())<span class="comment">//如果是合理值</span></span><br><span class="line">			&#123;</span><br><span class="line">				_clients.<span class="built_in">erase</span>(iter);<span class="comment">//移除</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="三、基于笔记三源码进行-跨平台化升级"><a href="#三、基于笔记三源码进行-跨平台化升级" class="headerlink" title="三、基于笔记三源码进行 跨平台化升级"></a>三、基于笔记三源码进行 跨平台化升级</h1><h2 id="1-客户端源码"><a href="#1-客户端源码" class="headerlink" title="1.客户端源码"></a>1.客户端源码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;winSock2.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//链接此动态链接库 windows特有 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span><span class="comment">//selcet</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span><span class="comment">//uni std</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SOCKET int</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> INVALID_SOCKET (SOCKET)(~0)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SOCKET_ERROR (-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//枚举类型记录命令 </span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">cmd</span> </span><br><span class="line">&#123;</span><br><span class="line">	CMD_LOGIN,<span class="comment">//登录 </span></span><br><span class="line">	CMD_LOGINRESULT,<span class="comment">//登录结果 </span></span><br><span class="line">	CMD_LOGOUT,<span class="comment">//登出 </span></span><br><span class="line">	CMD_LOGOUTRESULT,<span class="comment">//登出结果 </span></span><br><span class="line">	CMD_NEW_USER_JOIN,<span class="comment">//新用户登入 </span></span><br><span class="line">	CMD_ERROR<span class="comment">//错误 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义数据包头 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DateHeader</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">short</span> cmd;<span class="comment">//命令</span></span><br><span class="line">	<span class="type">short</span> date_length;<span class="comment">//数据的长短	</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包1 登录 传输账号与密码</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Login</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Login</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGIN;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Login); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">	<span class="type">char</span> PassWord[<span class="number">32</span>];<span class="comment">//密码 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包2 登录结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoginResult</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LoginResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGINRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LoginResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包3 登出 传输用户名 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Logout</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Logout</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Logout); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包4 登出结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LogoutResult</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LogoutResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUTRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LogoutResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包5 新用户登入 传输通告 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NewUserJoin</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">NewUserJoin</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_NEW_USER_JOIN;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(NewUserJoin); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> _handle(SOCKET _temp_socket)<span class="comment">//处理数据 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//接收客户端发送的数据 </span></span><br><span class="line">	DateHeader _head = &#123;&#125;; </span><br><span class="line">	<span class="type">int</span> _buf_len = <span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_head,<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(_buf_len&lt;=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;与服务器断开连接,任务结束\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;接收到包头，命令：%d，数据长度：%d\n&quot;</span>,_head.cmd,_head.date_length);</span><br><span class="line">	<span class="keyword">switch</span>(_head.cmd)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> CMD_LOGINRESULT:<span class="comment">//登录结果 接收登录包体 </span></span><br><span class="line">		&#123;</span><br><span class="line">			LoginResult _result; </span><br><span class="line">			<span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_result+<span class="built_in">sizeof</span>(DateHeader),<span class="built_in">sizeof</span>(LoginResult)-<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;登录结果:%d\n&quot;</span>,_result.Result);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> CMD_LOGOUTRESULT:<span class="comment">//登出结果 接收登出包体 </span></span><br><span class="line">		&#123;</span><br><span class="line">			LogoutResult _result; </span><br><span class="line">			<span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_result+<span class="built_in">sizeof</span>(DateHeader),<span class="built_in">sizeof</span>(LogoutResult)-<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;登录结果:%d\n&quot;</span>,_result.Result);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> CMD_NEW_USER_JOIN:<span class="comment">//新用户登录通知 </span></span><br><span class="line">		&#123;</span><br><span class="line">			NewUserJoin _result; </span><br><span class="line">			<span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_result+<span class="built_in">sizeof</span>(DateHeader),<span class="built_in">sizeof</span>(NewUserJoin)-<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;用户:%s已登录\n&quot;</span>,_result.UserName);</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> _run = <span class="literal">true</span>;<span class="comment">//当前程序是否还在运行中 </span></span><br><span class="line"><span class="type">void</span> _cmdThread(SOCKET _mysocket)<span class="comment">//命令线程 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(_run)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//输入请求 </span></span><br><span class="line">		<span class="type">char</span> _msg[<span class="number">256</span>] = &#123;&#125;;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,_msg);</span><br><span class="line">		<span class="comment">//处理请求 </span></span><br><span class="line">		<span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(_msg,<span class="string">&quot;exit&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			_run = <span class="literal">false</span>; </span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;程序退出\n&quot;</span>); </span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(_msg,<span class="string">&quot;login&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//发送 </span></span><br><span class="line">			Login _login;</span><br><span class="line">			<span class="built_in">strcpy</span>(_login.UserName,<span class="string">&quot;hbxxy&quot;</span>);</span><br><span class="line">			<span class="built_in">strcpy</span>(_login.PassWord,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">			<span class="built_in">send</span>(_mysocket,(<span class="type">const</span> <span class="type">char</span>*)&amp;_login,<span class="built_in">sizeof</span>(_login),<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(_msg,<span class="string">&quot;logout&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//发送 </span></span><br><span class="line">			Logout _logout;</span><br><span class="line">			<span class="built_in">strcpy</span>(_logout.UserName,<span class="string">&quot;hbxxy&quot;</span>);</span><br><span class="line">			<span class="built_in">send</span>(_mysocket,(<span class="type">const</span> <span class="type">char</span>*)&amp;_logout,<span class="built_in">sizeof</span>(_logout),<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;不存在的命令\n&quot;</span>);</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Welcome\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">	<span class="comment">//启动windows socket 2,x环境 windows特有 </span></span><br><span class="line">	WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>);<span class="comment">//WinSock库版本号 </span></span><br><span class="line">	WSADATA dat;<span class="comment">//网络结构体 储存WSAStartup函数调用后返回的Socket数据 </span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span> != <span class="built_in">WSAStartup</span>(ver,&amp;dat))<span class="comment">//正确初始化后返回0 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//建立一个socket </span></span><br><span class="line">	SOCKET _mysocket = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);<span class="comment">//IPV4 数据流类型 类型可以不用写 </span></span><br><span class="line">	<span class="keyword">if</span>(INVALID_SOCKET == _mysocket)<span class="comment">//建立失败 </span></span><br><span class="line">	&#123;   </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">	&#125; </span><br><span class="line">    </span><br><span class="line">   	<span class="comment">//连接服务器</span></span><br><span class="line">   	sockaddr_in _sin = &#123;&#125;;<span class="comment">//sockaddr结构体 </span></span><br><span class="line">   	_sin.sin_family = AF_INET;<span class="comment">//IPV4</span></span><br><span class="line">   	_sin.sin_port = <span class="built_in">htons</span>(<span class="number">8888</span>);<span class="comment">//想要连接的端口号 </span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">		_sin.sin_addr.S_un.S_addr =  <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);<span class="comment">//想要连接的IP </span></span><br><span class="line">	<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		_sin.sin_addr.s_addr =  <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);<span class="comment">//想要连接的IP </span></span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">connect</span>(_mysocket,(sockaddr*)&amp;_sin,<span class="built_in">sizeof</span>(sockaddr_in)))</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;连接失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">		<span class="comment">//关闭socket</span></span><br><span class="line">		<span class="built_in">closesocket</span>(_mysocket);  </span><br><span class="line">	<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		<span class="comment">//关闭socket/LINUX</span></span><br><span class="line">		<span class="built_in">close</span>(_mysocket);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;连接成功&quot;</span>&lt;&lt;endl; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//创建新线程</span></span><br><span class="line">	<span class="function">thread <span class="title">t1</span><span class="params">(_cmdThread,_mysocket)</span></span>;</span><br><span class="line">	t<span class="number">1.</span><span class="built_in">detach</span>();<span class="comment">//线程分离 </span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(_run)</span><br><span class="line">	&#123;</span><br><span class="line">		fd_set _fdRead;<span class="comment">//建立集合 </span></span><br><span class="line">		<span class="built_in">FD_ZERO</span>(&amp;_fdRead);<span class="comment">//清空集合  </span></span><br><span class="line">		<span class="built_in">FD_SET</span>(_mysocket,&amp;_fdRead);<span class="comment">//放入集合 </span></span><br><span class="line">		timeval <span class="type">_t</span> = &#123;<span class="number">1</span>,<span class="number">0</span>&#125;;<span class="comment">//select最大响应时间 </span></span><br><span class="line">		<span class="comment">//新建seclect </span></span><br><span class="line">		<span class="type">int</span> _ret = <span class="built_in">select</span>(_mysocket<span class="number">+1</span>,&amp;_fdRead,<span class="literal">NULL</span>,<span class="literal">NULL</span>,&amp;<span class="type">_t</span>);</span><br><span class="line">		<span class="keyword">if</span>(_ret&lt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;seclect任务结束\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(_mysocket,&amp;_fdRead))<span class="comment">//获取是否有可读socket </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">FD_CLR</span>(_mysocket,&amp;_fdRead);<span class="comment">//清理计数器 </span></span><br><span class="line">			<span class="keyword">if</span>(<span class="number">-1</span> == _handle(_mysocket))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;seclect任务结束\n&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">	<span class="comment">//关闭socket</span></span><br><span class="line">	<span class="built_in">closesocket</span>(_mysocket); </span><br><span class="line">	<span class="comment">//清除windows socket 环境 </span></span><br><span class="line">	<span class="built_in">WSACleanup</span>(); </span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="comment">//关闭socket/LINUX</span></span><br><span class="line">	<span class="built_in">close</span>(_mysocket);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="2-服务端源码"><a href="#2-服务端源码" class="headerlink" title="2.服务端源码"></a>2.服务端源码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;winSock2.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//链接此动态链接库 windows特有 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span><span class="comment">//selcet</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span><span class="comment">//uni std</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SOCKET int</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> INVALID_SOCKET (SOCKET)(~0)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SOCKET_ERROR (-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//枚举类型记录命令 </span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">cmd</span> </span><br><span class="line">&#123;</span><br><span class="line">	CMD_LOGIN,<span class="comment">//登录 </span></span><br><span class="line">	CMD_LOGINRESULT,<span class="comment">//登录结果 </span></span><br><span class="line">	CMD_LOGOUT,<span class="comment">//登出 </span></span><br><span class="line">	CMD_LOGOUTRESULT,<span class="comment">//登出结果 </span></span><br><span class="line">	CMD_NEW_USER_JOIN,<span class="comment">//新用户登入 </span></span><br><span class="line">	CMD_ERROR<span class="comment">//错误 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义数据包头 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DateHeader</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">short</span> cmd;<span class="comment">//命令</span></span><br><span class="line">	<span class="type">short</span> date_length;<span class="comment">//数据的长短	</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包1 登录 传输账号与密码</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Login</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Login</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGIN;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Login); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">	<span class="type">char</span> PassWord[<span class="number">32</span>];<span class="comment">//密码 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包2 登录结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoginResult</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LoginResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGINRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LoginResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包3 登出 传输用户名 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Logout</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Logout</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Logout); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包4 登出结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LogoutResult</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LogoutResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUTRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LogoutResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包5 新用户登入 传输通告 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NewUserJoin</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">NewUserJoin</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_NEW_USER_JOIN;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(NewUserJoin); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">vector&lt;SOCKET&gt; _clients;<span class="comment">//储存客户端socket </span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> _handle(SOCKET _temp_socket)<span class="comment">//处理数据 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//接收客户端发送的数据 </span></span><br><span class="line">	DateHeader _head = &#123;&#125;; </span><br><span class="line">	<span class="type">int</span> _buf_len = <span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_head,<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(_buf_len&lt;=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;客户端已退出\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;接收到包头，命令：%d，数据长度：%d\n&quot;</span>,_head.cmd,_head.date_length);</span><br><span class="line">	<span class="keyword">switch</span>(_head.cmd)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> CMD_LOGIN:<span class="comment">//登录 接收登录包体 </span></span><br><span class="line">		&#123;</span><br><span class="line">			Login _login;</span><br><span class="line">			<span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_login+<span class="built_in">sizeof</span>(DateHeader),<span class="built_in">sizeof</span>(Login)-<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			进行判断操作 </span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s已登录\n密码：%s\n&quot;</span>,_login.UserName,_login.PassWord); </span><br><span class="line">			LoginResult _result;	</span><br><span class="line">			_result.Result = <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">send</span>(_temp_socket,(<span class="type">char</span>*)&amp;_result,<span class="built_in">sizeof</span>(LoginResult),<span class="number">0</span>);<span class="comment">//发包体 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> CMD_LOGOUT:<span class="comment">//登出 接收登出包体 </span></span><br><span class="line">		&#123;</span><br><span class="line">			Logout _logout;</span><br><span class="line">			<span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_logout+<span class="built_in">sizeof</span>(DateHeader),<span class="built_in">sizeof</span>(Logout)-<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			进行判断操作 </span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s已登出\n&quot;</span>,_logout.UserName); </span><br><span class="line">			LogoutResult _result;</span><br><span class="line">			_result.Result = <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">send</span>(_temp_socket,(<span class="type">char</span>*)&amp;_result,<span class="built_in">sizeof</span>(LogoutResult),<span class="number">0</span>);<span class="comment">//发包体</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:<span class="comment">//错误 </span></span><br><span class="line">		&#123;</span><br><span class="line">			_head.cmd = CMD_ERROR; </span><br><span class="line">			_head.date_length = <span class="number">0</span>; </span><br><span class="line">			<span class="built_in">send</span>(_temp_socket,(<span class="type">char</span>*)&amp;_head,<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);<span class="comment">//发包头 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">	<span class="comment">//启动windows socket 2,x环境 windows特有 </span></span><br><span class="line">	WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>);<span class="comment">//WinSock库版本号 </span></span><br><span class="line">	WSADATA dat;<span class="comment">//网络结构体 储存WSAStartup函数调用后返回的Socket数据 </span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span> != <span class="built_in">WSAStartup</span>(ver,&amp;dat))<span class="comment">//正确初始化后返回0 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//建立一个socket </span></span><br><span class="line">	SOCKET _mysocket = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,IPPROTO_TCP);<span class="comment">//IPV4 数据流类型 TCP类型 </span></span><br><span class="line">	<span class="keyword">if</span>(INVALID_SOCKET == _mysocket)<span class="comment">//建立失败 </span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">	<span class="comment">//绑定网络端口和IP地址 </span></span><br><span class="line">	sockaddr_in _myaddr = &#123;&#125;;<span class="comment">//建立sockaddr结构体  sockaddr_in结构体方便填写 但是下面要进行类型转换 </span></span><br><span class="line">	_myaddr.sin_family = AF_INET;<span class="comment">//IPV4</span></span><br><span class="line">	_myaddr.sin_port = <span class="built_in">htons</span>(<span class="number">8888</span>);<span class="comment">//端口 host to net unsigned short</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">	_myaddr.sin_addr.S_un.S_addr = INADDR_ANY;<span class="comment">//inet_addr(&quot;127.0.0.1&quot;);</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	_myaddr.sin_addr.s_addr = INADDR_ANY;<span class="comment">//想要监听的ip </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">bind</span>(_mysocket,(sockaddr*)&amp;_myaddr,<span class="built_in">sizeof</span>(sockaddr_in)))<span class="comment">//socket (强制转换)sockaddr结构体 结构体大小 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;绑定不成功&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;&quot;绑定成功&quot;&lt;&lt;endl; </span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//监听网络端口</span></span><br><span class="line">	<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">listen</span>(_mysocket,<span class="number">5</span>))<span class="comment">//套接字 最大多少人连接 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;监听失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;&quot;监听成功&quot;&lt;&lt;endl; </span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		fd_set _fdRead;<span class="comment">//建立集合 </span></span><br><span class="line">		fd_set _fdWrite;</span><br><span class="line">		fd_set _fdExcept;</span><br><span class="line">		<span class="built_in">FD_ZERO</span>(&amp;_fdRead);<span class="comment">//清空集合 </span></span><br><span class="line">		<span class="built_in">FD_ZERO</span>(&amp;_fdWrite); </span><br><span class="line">		<span class="built_in">FD_ZERO</span>(&amp;_fdExcept); </span><br><span class="line">		<span class="built_in">FD_SET</span>(_mysocket,&amp;_fdRead);<span class="comment">//放入集合 </span></span><br><span class="line">		<span class="built_in">FD_SET</span>(_mysocket,&amp;_fdWrite); </span><br><span class="line">		<span class="built_in">FD_SET</span>(_mysocket,&amp;_fdExcept);</span><br><span class="line">		timeval <span class="type">_t</span> = &#123;<span class="number">2</span>,<span class="number">0</span>&#125;;<span class="comment">//select最大响应时间 </span></span><br><span class="line">		SOCKET _maxSock = _mysocket;<span class="comment">//最大socket</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> n=_clients.<span class="built_in">size</span>()<span class="number">-1</span>; n&gt;=<span class="number">0</span>; --n)<span class="comment">//把连接的客户端 放入read集合 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">FD_SET</span>(_clients[n],&amp;_fdRead);</span><br><span class="line">			<span class="keyword">if</span>(_maxSock &lt; _clients[n])</span><br><span class="line">			&#123;</span><br><span class="line">				_maxSock = _clients[n];<span class="comment">//找最大</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//select函数筛选select </span></span><br><span class="line">		<span class="type">int</span> _ret = <span class="built_in">select</span>(_maxSock<span class="number">+1</span>,&amp;_fdRead,&amp;_fdWrite,&amp;_fdExcept,&amp;<span class="type">_t</span>); </span><br><span class="line">		<span class="keyword">if</span>(_ret&lt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;select任务结束\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(_mysocket,&amp;_fdRead))<span class="comment">//获取是否有新socket连接 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">FD_CLR</span>(_mysocket,&amp;_fdRead);<span class="comment">//清理</span></span><br><span class="line">			<span class="comment">//等待接收客户端连接</span></span><br><span class="line">			sockaddr_in _clientAddr = &#123;&#125;;<span class="comment">//新建sockadd结构体接收客户端数据 </span></span><br><span class="line">			<span class="type">int</span> _addr_len = <span class="built_in">sizeof</span>(sockaddr_in);<span class="comment">//获取sockadd结构体长度 </span></span><br><span class="line">			SOCKET _temp_socket = INVALID_SOCKET;<span class="comment">//声明客户端套接字 </span></span><br><span class="line">		<span class="meta">#<span class="keyword">ifdef</span> _WIN32	</span></span><br><span class="line">			_temp_socket = <span class="built_in">accept</span>(_mysocket,(sockaddr*)&amp;_clientAddr,&amp;_addr_len);<span class="comment">//自身套接字 客户端结构体 结构体大小 </span></span><br><span class="line">		<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">			_temp_socket = <span class="built_in">accept</span>(_mysocket,(sockaddr*)&amp;_clientAddr,(<span class="type">socklen_t</span>*)&amp;_addr_len);<span class="comment">//自身套接字 客户端结构体 结构体大小 </span></span><br><span class="line">		<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">			<span class="keyword">if</span>(INVALID_SOCKET == _temp_socket)<span class="comment">//接收失败 </span></span><br><span class="line">			&#123;</span><br><span class="line">				cout&lt;&lt;<span class="string">&quot;接收到无效客户端Socket&quot;</span>&lt;&lt;endl;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				cout&lt;&lt;<span class="string">&quot;新客户端加入&quot;</span>&lt;&lt;endl; </span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;IP地址为：%s \n&quot;</span>, <span class="built_in">inet_ntoa</span>(_clientAddr.sin_addr));  </span><br><span class="line">				<span class="comment">//群发所有客户端 通知新用户登录 </span></span><br><span class="line">				NewUserJoin _user_join; </span><br><span class="line">				<span class="built_in">strcpy</span>(_user_join.UserName,<span class="built_in">inet_ntoa</span>(_clientAddr.sin_addr));</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>;n&lt;_clients.<span class="built_in">size</span>();++n)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">send</span>(_clients[n],(<span class="type">const</span> <span class="type">char</span>*)&amp;_user_join,<span class="built_in">sizeof</span>(NewUserJoin),<span class="number">0</span>);	</span><br><span class="line">				&#125; </span><br><span class="line">				<span class="comment">//将新的客户端加入动态数组</span></span><br><span class="line">				_clients.<span class="built_in">push_back</span>(_temp_socket); </span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;_clients.<span class="built_in">size</span>(); ++n)<span class="comment">//遍历所有socket</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(_clients[n],&amp;_fdRead))<span class="comment">//看一下是否在待处理事件列表中</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="number">-1</span> == _handle(_clients[n]))<span class="comment">//处理请求 客户端退出的话 </span></span><br><span class="line">				&#123;</span><br><span class="line">					vector&lt;SOCKET&gt;::iterator iter = _clients.<span class="built_in">begin</span>()+n;<span class="comment">//找到退出客户端的地址</span></span><br><span class="line">					<span class="keyword">if</span>(iter != _clients.<span class="built_in">end</span>())<span class="comment">//如果是合理值</span></span><br><span class="line">					&#123;</span><br><span class="line">						_clients.<span class="built_in">erase</span>(iter);<span class="comment">//移除</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;空闲时间处理其他业务\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">	<span class="comment">//关闭客户端socket</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;_clients.<span class="built_in">size</span>(); ++n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">closesocket</span>(_clients[n]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//关闭socket</span></span><br><span class="line">	<span class="built_in">closesocket</span>(_mysocket); </span><br><span class="line">	<span class="comment">//清除windows socket 环境 </span></span><br><span class="line">	<span class="built_in">WSACleanup</span>(); </span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="comment">//关闭客户端socket</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;_clients.<span class="built_in">size</span>(); ++n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">close</span>(_clients[n]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//关闭socket/LINUX</span></span><br><span class="line">	<span class="built_in">close</span>(_mysocket);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;任务结束，程序已退出&quot;</span>); </span><br><span class="line">	 </span><br><span class="line">	<span class="built_in">getchar</span>(); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、移植过程中遇到的一些小问题"><a href="#四、移植过程中遇到的一些小问题" class="headerlink" title="四、移植过程中遇到的一些小问题"></a>四、移植过程中遇到的一些小问题</h1><h2 id="1-关于IP的问题"><a href="#1-关于IP的问题" class="headerlink" title="1.关于IP的问题"></a>1.关于IP的问题</h2><p>&emsp;&emsp;如果服务端在本机Windows环境下运行，客户端在VM虚拟机Linux环境下运行，则在Windows命令行上输入<strong>ipconfig</strong>命令。下面这一块数据下的IPv4地址即为客户端需要连接的IP。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">以太网适配器 VMware Network Adapter VMnet8:</span><br><span class="line"></span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">   本地链接 IPv6 地址. . . . . . . . : </span><br><span class="line">   IPv4 地址 . . . . . . . . . . . . : </span><br><span class="line">   子网掩码  . . . . . . . . . . . . : </span><br><span class="line">   默认网关. . . . . . . . . . . . . :</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果服务端在VM虚拟机Linux环境下运行，客户端在本机Windows环境下运行，则在Linux命令行上输入<strong>ifconfig</strong>命令。显示出来的数据中网卡的IP即为客户端需要连接的IP。</p>
<h2 id="2-关于端口的问题"><a href="#2-关于端口的问题" class="headerlink" title="2.关于端口的问题"></a>2.关于端口的问题</h2><p>&emsp;&emsp;如果你的服务端运行正常，客户端运行正常，本机双开客户端和服务端也运行正常，但本机与虚拟机各开一个却连接不上时，可能是服务端的端口未开放导致的。</p>
<ul>
<li>Windows环境下会主动提示，点击允许即可，如果还是不行就去网上搜。</li>
<li>Linux环境下相关命令如下：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">systemctl status firewalld 查看防火墙状态</span><br><span class="line"></span><br><span class="line">systemctl start firewalld 开启防火墙 </span><br><span class="line"></span><br><span class="line">systemctl stop firewalld 关闭防火墙 </span><br><span class="line"></span><br><span class="line">service firewalld start 开启防火墙 </span><br><span class="line"></span><br><span class="line">查看对外开放的<span class="number">8888</span>端口状态 yes/no</span><br><span class="line">firewall-cmd --query-port=<span class="number">8888</span>/tcp</span><br><span class="line"></span><br><span class="line">打开<span class="number">8888</span>端口</span><br><span class="line">firewall-cmd --add-port=<span class="number">8888</span>/tcp --permanent</span><br><span class="line"></span><br><span class="line">重载端口</span><br><span class="line">firewall-cmd --reload</span><br><span class="line"></span><br><span class="line">移除指定的<span class="number">8888</span>端口：</span><br><span class="line">firewall-cmd --permanent --remove-port=<span class="number">8888</span>/tcp</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++网络编程学习：升级为select网络模型</title>
    <url>/2021/01/23/20210123_C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%8D%87%E7%BA%A7%E4%B8%BAselect%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<ul>
<li>使用的语言为C&#x2F;C++</li>
<li>源码支持的平台为：Windows</li>
</ul>
<h1 id="一、为何要使用select网络模型？"><a href="#一、为何要使用select网络模型？" class="headerlink" title="一、为何要使用select网络模型？"></a>一、为何要使用select网络模型？</h1><p>&emsp;&emsp;通过前面的学习，已经实现了简单的网络报文收发。但是可以很明显的看出其中的缺点，那就是整个程序的运行是<strong>阻塞模式</strong>的。即服务端在与一个客户端进行socket连接时，只要连接不中断，那么就无法接收新的客户端的消息。而客户端在未输入命令时，是阻塞状态，也无法接收服务端发来的消息。<br>&emsp;&emsp;在之前碰到这个问题时，我的想法是通过多线程来解决程序运行中的阻塞问题，但是在最近的学习中，我了解到可以使用select网络模型来方便快捷的解决小型网络程序运行中的阻塞问题。<strong>（I&#x2F;O多路复用模型相关内容）</strong></p>
<span id="more"></span>

<h1 id="二、select系统及其相关"><a href="#二、select系统及其相关" class="headerlink" title="二、select系统及其相关"></a>二、select系统及其相关</h1><p>select函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">WINSOCK_API_LINKAGE <span class="type">int</span> WSAAPI <span class="title">select</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">int</span> nfds,<span class="comment">//是指待监听集合里的范围 即待监听数量最大值+1</span></span></span></span><br><span class="line"><span class="params"><span class="function">	fd_set *readfds,<span class="comment">//待监听的可读文件集合 </span></span></span></span><br><span class="line"><span class="params"><span class="function">	fd_set *writefds,<span class="comment">//待监听的可写文件集合  </span></span></span></span><br><span class="line"><span class="params"><span class="function">	fd_set *exceptfds,<span class="comment">//待监听的异常文件集合  </span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">const</span> PTIMEVAL timeout)</span></span>;<span class="comment">//超时设置 传入NULL为阻塞模式 传入timeval结构体为非阻塞模式</span></span><br><span class="line"></span><br><span class="line">返回值为满足条件的待监听socket数量和，如果出错返回<span class="number">-1</span>，如果超时返回<span class="number">0</span>。</span><br></pre></td></tr></table></figure>

<p>通过上面select函数的参数可以发现存在两个特殊的结构体 <strong>fd_set</strong> 和 <strong>timeval</strong>，其相关内容如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">fd_set</span><span class="comment">//可以存放多个socket </span></span><br><span class="line">&#123;</span><br><span class="line">	u_int	fd_count;<span class="comment">//记录放了多少个socket</span></span><br><span class="line">	SOCKET	fd_array[FD_SETSIZE];<span class="comment">//socket数组</span></span><br><span class="line">&#125; fd_set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timeval</span><span class="comment">//时间结构体 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">long</span> tv_sec;<span class="comment">//秒</span></span><br><span class="line">	<span class="type">long</span> tv_usec;<span class="comment">//毫秒</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来为select的相关函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>;<span class="comment">//将fd加入set集合</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *set)</span></span>;<span class="comment">//使set集合清零 不包含任何socket</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>;<span class="comment">//将fd从set集合中清除</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>;<span class="comment">//测试fd是否在集合中 0是不在 1是在</span></span><br></pre></td></tr></table></figure>

<h2 id="★-select相关使用总结与心得"><a href="#★-select相关使用总结与心得" class="headerlink" title="★ select相关使用总结与心得"></a>★ select相关使用总结与心得</h2><p>&emsp;&emsp;在一开始的select使用中，我以为向select函数中传入fd_set地址，select会把待处理事件的socket放在set集合中，但是发现并不是这样。<br>&emsp;&emsp;经过网络上资料的查询以及我个人的测试，可以发现，用户首先需要把一份socket数组传入到此set中，select函数的作用是移除该set中没有待处理事件的socket，则剩下的socket都存在待处理事件(未决I&#x2F;O操作)。这个过程可以说是一种“选择”的过程，select函数“选择”出需要操作的socket，这或许就是select(选择)的意思吧。<br>&emsp;&emsp;在接下来的源码中，对于需要存储所有已连接socket的服务端，我使用动态数组vector进行socket的储存。在进行select筛选前，先把vector中的socket导入到set中，随后set中筛选剩下的即为有待处理事件的socket。<br>&emsp;&emsp;如果服务端自己的socket提示有待处理事件，则说明有新的客户端尝试进行连接，此时进行accept操作即可。<br>&emsp;&emsp;对于客户端的多线程问题，需要注意使用detach()方法使主线程与新线程分类，否则可能会出现主线程先结束的情况，导致程序出错。<br>&emsp;&emsp;在线程中，我们可以引入一个bool变量，用来记录客户端是否仍在连接中，当输入exit命令退出客户端时，通过此bool变量使主线程停止，跳出循环。</p>
<h1 id="三、升级为select网络模型的思路"><a href="#三、升级为select网络模型的思路" class="headerlink" title="三、升级为select网络模型的思路"></a>三、升级为select网络模型的思路</h1><h2 id="1-服务端升级（select）"><a href="#1-服务端升级（select）" class="headerlink" title="1.服务端升级（select）"></a>1.服务端升级（select）</h2><p>在之前，我们的思路是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>建立socket</span><br><span class="line"><span class="number">2.</span>绑定端口IP</span><br><span class="line"><span class="number">3.</span>监听端口</span><br><span class="line"><span class="number">4.</span>与客户端连接</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="number">5.</span>接收数据</span><br><span class="line">	<span class="number">6.</span>发送数据</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">7.</span>关闭socket</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这就导致我们只能与一个客户端进行连接，随后便进入循环，只能接收这一个客户端的消息。且由于send与recv函数都是阻塞函数，所以程序也是阻塞模式的。</p>
<p>接下来，我们需要根据select网络模型，对服务端进行升级。<br>思路大致如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>建立socket</span><br><span class="line"><span class="number">2.</span>绑定端口IP</span><br><span class="line"><span class="number">3.</span>监听端口</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="number">4.</span>使用select函数获取存在待监听事件的socket</span><br><span class="line">	<span class="number">5.</span>如果有新的连接则与新的客户端连接</span><br><span class="line">	<span class="number">6.</span>如果有待监听事件，则对其进行处理(接受与发送)</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">7.</span>关闭socket</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;按如上思路，即可将程序升级为select网络模型。实现非阻塞模式，可以实现多客户端信息接收。对于select相关的细节与总结，请看上文中的总结。相关代码在下文。</p>
<h2 id="2-客户端升级（select-多线程）"><a href="#2-客户端升级（select-多线程）" class="headerlink" title="2.客户端升级（select+多线程）"></a>2.客户端升级（select+多线程）</h2><p>在之前，我们的思路是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>建立socket</span><br><span class="line"><span class="number">2.</span>连接服务器</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="number">3.</span>发送数据</span><br><span class="line">	<span class="number">4.</span>接收数据</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">5.</span>关闭socket</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这就导致我们在与一个服务端连接后，无法被动的接收服务器端发来的消息。因为send与recv函数都是阻塞函数，程序也为阻塞模式。如果我们想要客户端能接收服务端发来的消息，那么就可以使用select模型。</p>
<p>接下来，我们需要根据select网络模型，对客户端进行升级。<br>思路大致如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>建立socket</span><br><span class="line"><span class="number">2.</span>连接服务器</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="number">3.</span>使用select函数获取服务器端是否有待处理事件</span><br><span class="line">	<span class="number">4.</span>如果有，就处理它(接收/发送)</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">5.</span>关闭socket</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;按如上思路，即可将程序升级为select网络模型。实现非阻塞模式，可以实现服务器端数据的被动接收。</p>
<p>但是，这样的程序结构也有很明显的缺点，因为scanf等数据接收函数也为阻塞函数，如果我们想要主动输入一些命令发送给服务端，就会阻塞程序运行。对此，我们可以引入多线程解决问题。<br>思路大致如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>建立socket</span><br><span class="line"><span class="number">2.</span>连接服务器</span><br><span class="line"><span class="number">3.</span>建立新线程 用于发送命令</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="number">4.</span>使用select函数获取服务器端是否有待处理事件</span><br><span class="line">	<span class="number">5.</span>如果有，就处理它(接收/发送)</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">5.</span>关闭socket</span><br><span class="line"></span><br><span class="line">新线程：</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="number">1.</span>键入数据</span><br><span class="line">	<span class="number">2.</span>发送数据</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;按如上思路，即可将程序变得更加完善。可以被动接受数据且可以主动向服务端发送键入命令。对于select相关的细节与总结以及线程方面的注意事项，请看上文中的总结。相关代码在下文。</p>
<h1 id="四、代码及其详细注释"><a href="#四、代码及其详细注释" class="headerlink" title="四、代码及其详细注释"></a>四、代码及其详细注释</h1><h2 id="1-服务端代码"><a href="#1-服务端代码" class="headerlink" title="1.服务端代码"></a>1.服务端代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;winSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//链接此动态链接库 windows特有 </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//枚举类型记录命令 </span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">cmd</span> </span><br><span class="line">&#123;</span><br><span class="line">	CMD_LOGIN,<span class="comment">//登录 </span></span><br><span class="line">	CMD_LOGINRESULT,<span class="comment">//登录结果 </span></span><br><span class="line">	CMD_LOGOUT,<span class="comment">//登出 </span></span><br><span class="line">	CMD_LOGOUTRESULT,<span class="comment">//登出结果 </span></span><br><span class="line">	CMD_NEW_USER_JOIN,<span class="comment">//新用户登入 </span></span><br><span class="line">	CMD_ERROR<span class="comment">//错误 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义数据包头 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DateHeader</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">short</span> cmd;<span class="comment">//命令</span></span><br><span class="line">	<span class="type">short</span> date_length;<span class="comment">//数据的长短	</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包1 登录 传输账号与密码</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Login</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Login</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGIN;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Login); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">	<span class="type">char</span> PassWord[<span class="number">32</span>];<span class="comment">//密码 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包2 登录结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoginResult</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LoginResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGINRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LoginResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包3 登出 传输用户名 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Logout</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Logout</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Logout); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包4 登出结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LogoutResult</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LogoutResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUTRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LogoutResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包5 新用户登入 传输通告 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NewUserJoin</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">NewUserJoin</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_NEW_USER_JOIN;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(NewUserJoin); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">vector&lt;SOCKET&gt; _clients;<span class="comment">//储存客户端socket </span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> _handle(SOCKET _temp_socket)<span class="comment">//处理数据 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//接收客户端发送的数据 </span></span><br><span class="line">	DateHeader _head = &#123;&#125;; </span><br><span class="line">	<span class="type">int</span> _buf_len = <span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_head,<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(_buf_len&lt;=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;客户端已退出\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;接收到包头，命令：%d，数据长度：%d\n&quot;</span>,_head.cmd,_head.date_length);</span><br><span class="line">	<span class="keyword">switch</span>(_head.cmd)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> CMD_LOGIN:<span class="comment">//登录 接收登录包体 </span></span><br><span class="line">		&#123;</span><br><span class="line">			Login _login;</span><br><span class="line">			<span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_login+<span class="built_in">sizeof</span>(DateHeader),<span class="built_in">sizeof</span>(Login)-<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			进行判断操作 </span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s已登录\n密码：%s\n&quot;</span>,_login.UserName,_login.PassWord); </span><br><span class="line">			LoginResult _result;	</span><br><span class="line">			_result.Result = <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">send</span>(_temp_socket,(<span class="type">char</span>*)&amp;_result,<span class="built_in">sizeof</span>(LoginResult),<span class="number">0</span>);<span class="comment">//发包体 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> CMD_LOGOUT:<span class="comment">//登出 接收登出包体 </span></span><br><span class="line">		&#123;</span><br><span class="line">			Logout _logout;</span><br><span class="line">			<span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_logout+<span class="built_in">sizeof</span>(DateHeader),<span class="built_in">sizeof</span>(Logout)-<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			进行判断操作 </span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s已登出\n&quot;</span>,_logout.UserName); </span><br><span class="line">			LogoutResult _result;</span><br><span class="line">			_result.Result = <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">send</span>(_temp_socket,(<span class="type">char</span>*)&amp;_result,<span class="built_in">sizeof</span>(LogoutResult),<span class="number">0</span>);<span class="comment">//发包体</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:<span class="comment">//错误 </span></span><br><span class="line">		&#123;</span><br><span class="line">			_head.cmd = CMD_ERROR; </span><br><span class="line">			_head.date_length = <span class="number">0</span>; </span><br><span class="line">			<span class="built_in">send</span>(_temp_socket,(<span class="type">char</span>*)&amp;_head,<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);<span class="comment">//发包头 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//启动windows socket 2,x环境 windows特有 </span></span><br><span class="line">	WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>);<span class="comment">//WinSock库版本号 </span></span><br><span class="line">	WSADATA dat;<span class="comment">//网络结构体 储存WSAStartup函数调用后返回的Socket数据 </span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span> != <span class="built_in">WSAStartup</span>(ver,&amp;dat))<span class="comment">//正确初始化后返回0 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//建立一个socket </span></span><br><span class="line">	SOCKET _mysocket = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,IPPROTO_TCP);<span class="comment">//IPV4 数据流类型 TCP类型 </span></span><br><span class="line">	<span class="keyword">if</span>(INVALID_SOCKET == _mysocket)<span class="comment">//建立失败 </span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">	<span class="comment">//绑定网络端口和IP地址 </span></span><br><span class="line">	sockaddr_in _myaddr = &#123;&#125;;<span class="comment">//建立sockaddr结构体  sockaddr_in结构体方便填写 但是下面要进行类型转换 </span></span><br><span class="line">	_myaddr.sin_family = AF_INET;<span class="comment">//IPV4</span></span><br><span class="line">	_myaddr.sin_port = <span class="built_in">htons</span>(<span class="number">8888</span>);<span class="comment">//端口 host to net unsigned short</span></span><br><span class="line">	_myaddr.sin_addr.S_un.S_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);<span class="comment">//网络地址 INADDR_ANY监听所有网卡的端口 </span></span><br><span class="line">	<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">bind</span>(_mysocket,(sockaddr*)&amp;_myaddr,<span class="built_in">sizeof</span>(sockaddr_in)))<span class="comment">//socket (强制转换)sockaddr结构体 结构体大小 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;绑定不成功&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;&quot;绑定成功&quot;&lt;&lt;endl; </span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//监听网络端口</span></span><br><span class="line">	<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">listen</span>(_mysocket,<span class="number">5</span>))<span class="comment">//套接字 最大多少人连接 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;监听失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;&quot;监听成功&quot;&lt;&lt;endl; </span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//select相关 </span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		WINSOCK_API_LINKAGE int WSAAPI select(</span></span><br><span class="line"><span class="comment">		int nfds,//是指待监听集合里的范围 即待监听数量最大值+1</span></span><br><span class="line"><span class="comment">		fd_set *readfds,//待监听的可读文件集合 </span></span><br><span class="line"><span class="comment">		fd_set *writefds,//待监听的可写文件集合  </span></span><br><span class="line"><span class="comment">		fd_set *exceptfds,//待监听的异常文件集合  </span></span><br><span class="line"><span class="comment">		const PTIMEVAL timeout);//超时设置 传入NULL为阻塞模式 传入timeval结构体为非阻塞模式</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		typedef struct fd_set//可以存放多个socket </span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">			u_int	fd_count;//记录放了多少个socket</span></span><br><span class="line"><span class="comment">			SOCKET	fd_array[FD_SETSIZE];//socket数组</span></span><br><span class="line"><span class="comment">		&#125; fd_set;</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		struct timeval//时间结构体 </span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">			long tv_sec;//秒</span></span><br><span class="line"><span class="comment">			long tv_usec;//毫秒</span></span><br><span class="line"><span class="comment">		&#125;;</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		fd_set _fdRead;<span class="comment">//建立集合 </span></span><br><span class="line">		fd_set _fdWrite;</span><br><span class="line">		fd_set _fdExcept;</span><br><span class="line">		<span class="built_in">FD_ZERO</span>(&amp;_fdRead);<span class="comment">//清空集合 </span></span><br><span class="line">		<span class="built_in">FD_ZERO</span>(&amp;_fdWrite); </span><br><span class="line">		<span class="built_in">FD_ZERO</span>(&amp;_fdExcept); </span><br><span class="line">		<span class="built_in">FD_SET</span>(_mysocket,&amp;_fdRead);<span class="comment">//放入集合 </span></span><br><span class="line">		<span class="built_in">FD_SET</span>(_mysocket,&amp;_fdWrite); </span><br><span class="line">		<span class="built_in">FD_SET</span>(_mysocket,&amp;_fdExcept);</span><br><span class="line">		timeval <span class="type">_t</span> = &#123;<span class="number">1</span>,<span class="number">0</span>&#125;;<span class="comment">//select最大响应时间 </span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> n=_clients.<span class="built_in">size</span>()<span class="number">-1</span>; n&gt;=<span class="number">0</span>; --n)<span class="comment">//把连接的客户端 放入read集合 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">FD_SET</span>(_clients[n],&amp;_fdRead);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//select函数筛选select </span></span><br><span class="line">		<span class="type">int</span> _ret = <span class="built_in">select</span>(_mysocket<span class="number">+1</span>,&amp;_fdRead,&amp;_fdWrite,&amp;_fdExcept,&amp;<span class="type">_t</span>); </span><br><span class="line">		<span class="keyword">if</span>(_ret&lt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;select任务结束\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(_mysocket,&amp;_fdRead))<span class="comment">//获取是否有新socket连接 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">FD_CLR</span>(_mysocket,&amp;_fdRead);<span class="comment">//清理</span></span><br><span class="line">			<span class="comment">//等待接收客户端连接</span></span><br><span class="line">			sockaddr_in _clientAddr = &#123;&#125;;<span class="comment">//新建sockadd结构体接收客户端数据 </span></span><br><span class="line">			<span class="type">int</span> _addr_len = <span class="built_in">sizeof</span>(sockaddr_in);<span class="comment">//获取sockadd结构体长度 </span></span><br><span class="line">			SOCKET _temp_socket = INVALID_SOCKET;<span class="comment">//声明客户端套接字 </span></span><br><span class="line">			</span><br><span class="line">			_temp_socket = <span class="built_in">accept</span>(_mysocket,(sockaddr*)&amp;_clientAddr,&amp;_addr_len);<span class="comment">//自身套接字 客户端结构体 结构体大小 </span></span><br><span class="line">			<span class="keyword">if</span>(INVALID_SOCKET == _temp_socket)<span class="comment">//接收失败 </span></span><br><span class="line">			&#123;</span><br><span class="line">				cout&lt;&lt;<span class="string">&quot;接收到无效客户端Socket&quot;</span>&lt;&lt;endl;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				cout&lt;&lt;<span class="string">&quot;新客户端加入&quot;</span>&lt;&lt;endl; </span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;IP地址为：%s \n&quot;</span>, <span class="built_in">inet_ntoa</span>(_clientAddr.sin_addr));  </span><br><span class="line">				<span class="comment">//群发所有客户端 通知新用户登录 </span></span><br><span class="line">				NewUserJoin _user_join; </span><br><span class="line">				<span class="built_in">strcpy</span>(_user_join.UserName,<span class="built_in">inet_ntoa</span>(_clientAddr.sin_addr));</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>;n&lt;_clients.<span class="built_in">size</span>();n++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">send</span>(_clients[n],(<span class="type">const</span> <span class="type">char</span>*)&amp;_user_join,<span class="built_in">sizeof</span>(NewUserJoin),<span class="number">0</span>);	</span><br><span class="line">				&#125; </span><br><span class="line">				<span class="comment">//将新的客户端加入动态数组</span></span><br><span class="line">				_clients.<span class="built_in">push_back</span>(_temp_socket); </span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;_fdRead.fd_count; ++n)<span class="comment">//在read数组里挨个处理 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="number">-1</span> == _handle(_fdRead.fd_array[n]))<span class="comment">//处理请求 客户端退出的话 </span></span><br><span class="line">			&#123;</span><br><span class="line">				vector&lt;SOCKET&gt;::iterator iter = <span class="built_in">find</span>(_clients.<span class="built_in">begin</span>(),_clients.<span class="built_in">end</span>(),_fdRead.fd_array[n]);</span><br><span class="line">				<span class="keyword">if</span>(iter != _clients.<span class="built_in">end</span>())<span class="comment">//如果找到了的话 就在动态数组里删除掉 </span></span><br><span class="line">				&#123;</span><br><span class="line">					_clients.<span class="built_in">erase</span>(iter);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;空闲时间处理其他业务\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	 </span><br><span class="line">	<span class="comment">//关闭客户端socket</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;_clients.<span class="built_in">size</span>(); ++n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">closesocket</span>(_clients[n]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭socket </span></span><br><span class="line">	<span class="built_in">closesocket</span>(_mysocket); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//清除windows socket 环境 </span></span><br><span class="line">	<span class="built_in">WSACleanup</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;任务结束，程序已退出&quot;</span>); </span><br><span class="line">	 </span><br><span class="line">	<span class="built_in">getchar</span>(); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-客户端代码"><a href="#2-客户端代码" class="headerlink" title="2.客户端代码"></a>2.客户端代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;winSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//链接此动态链接库 windows特有 </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//枚举类型记录命令 </span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">cmd</span> </span><br><span class="line">&#123;</span><br><span class="line">	CMD_LOGIN,<span class="comment">//登录 </span></span><br><span class="line">	CMD_LOGINRESULT,<span class="comment">//登录结果 </span></span><br><span class="line">	CMD_LOGOUT,<span class="comment">//登出 </span></span><br><span class="line">	CMD_LOGOUTRESULT,<span class="comment">//登出结果 </span></span><br><span class="line">	CMD_NEW_USER_JOIN,<span class="comment">//新用户登入 </span></span><br><span class="line">	CMD_ERROR<span class="comment">//错误 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义数据包头 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DateHeader</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">short</span> cmd;<span class="comment">//命令</span></span><br><span class="line">	<span class="type">short</span> date_length;<span class="comment">//数据的长短	</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包1 登录 传输账号与密码</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Login</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Login</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGIN;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Login); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">	<span class="type">char</span> PassWord[<span class="number">32</span>];<span class="comment">//密码 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包2 登录结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoginResult</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LoginResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGINRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LoginResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包3 登出 传输用户名 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Logout</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Logout</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Logout); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包4 登出结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LogoutResult</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LogoutResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUTRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LogoutResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包5 新用户登入 传输通告 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NewUserJoin</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">NewUserJoin</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_NEW_USER_JOIN;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(NewUserJoin); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> _handle(SOCKET _temp_socket)<span class="comment">//处理数据 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//接收客户端发送的数据 </span></span><br><span class="line">	DateHeader _head = &#123;&#125;; </span><br><span class="line">	<span class="type">int</span> _buf_len = <span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_head,<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(_buf_len&lt;=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;与服务器断开连接,任务结束\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;接收到包头，命令：%d，数据长度：%d\n&quot;</span>,_head.cmd,_head.date_length);</span><br><span class="line">	<span class="keyword">switch</span>(_head.cmd)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> CMD_LOGINRESULT:<span class="comment">//登录结果 接收登录包体 </span></span><br><span class="line">		&#123;</span><br><span class="line">			LoginResult _result; </span><br><span class="line">			<span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_result+<span class="built_in">sizeof</span>(DateHeader),<span class="built_in">sizeof</span>(LoginResult)-<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;登录结果:%d\n&quot;</span>,_result.Result);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> CMD_LOGOUTRESULT:<span class="comment">//登出结果 接收登出包体 </span></span><br><span class="line">		&#123;</span><br><span class="line">			LogoutResult _result; </span><br><span class="line">			<span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_result+<span class="built_in">sizeof</span>(DateHeader),<span class="built_in">sizeof</span>(LogoutResult)-<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;登录结果:%d\n&quot;</span>,_result.Result);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> CMD_NEW_USER_JOIN:<span class="comment">//新用户登录通知 </span></span><br><span class="line">		&#123;</span><br><span class="line">			NewUserJoin _result; </span><br><span class="line">			<span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_result+<span class="built_in">sizeof</span>(DateHeader),<span class="built_in">sizeof</span>(NewUserJoin)-<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;用户:%s已登录\n&quot;</span>,_result.UserName);</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> _run = <span class="literal">true</span>;<span class="comment">//当前程序是否还在运行中 </span></span><br><span class="line"><span class="type">void</span> _cmdThread(SOCKET _mysocket)<span class="comment">//命令线程 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//输入请求 </span></span><br><span class="line">		<span class="type">char</span> _msg[<span class="number">256</span>] = &#123;&#125;;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,_msg);</span><br><span class="line">		<span class="comment">//处理请求 </span></span><br><span class="line">		<span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(_msg,<span class="string">&quot;exit&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			_run = <span class="literal">false</span>; </span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;程序退出\n&quot;</span>); </span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(_msg,<span class="string">&quot;login&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//发送 </span></span><br><span class="line">			Login _login;</span><br><span class="line">			<span class="built_in">strcpy</span>(_login.UserName,<span class="string">&quot;河边小咸鱼&quot;</span>);</span><br><span class="line">			<span class="built_in">strcpy</span>(_login.PassWord,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">			<span class="built_in">send</span>(_mysocket,(<span class="type">const</span> <span class="type">char</span>*)&amp;_login,<span class="built_in">sizeof</span>(_login),<span class="number">0</span>);</span><br><span class="line">			<span class="comment">//这里就不用接收了 由select用来检测接收</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(_msg,<span class="string">&quot;logout&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//发送 </span></span><br><span class="line">			Logout _logout;</span><br><span class="line">			<span class="built_in">strcpy</span>(_logout.UserName,<span class="string">&quot;河边小咸鱼&quot;</span>);</span><br><span class="line">			<span class="built_in">send</span>(_mysocket,(<span class="type">const</span> <span class="type">char</span>*)&amp;_logout,<span class="built_in">sizeof</span>(_logout),<span class="number">0</span>);</span><br><span class="line">			<span class="comment">//这里就不用接收了 由select用来检测接收</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;不存在的命令\n&quot;</span>);</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//启动windows socket 2,x环境 windows特有 </span></span><br><span class="line">	WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>);<span class="comment">//WinSock库版本号 </span></span><br><span class="line">	WSADATA dat;<span class="comment">//网络结构体 储存WSAStartup函数调用后返回的Socket数据 </span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span> != <span class="built_in">WSAStartup</span>(ver,&amp;dat))<span class="comment">//正确初始化后返回0 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//建立一个socket </span></span><br><span class="line">	SOCKET _mysocket = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);<span class="comment">//IPV4 数据流类型 类型可以不用写 </span></span><br><span class="line">	<span class="keyword">if</span>(INVALID_SOCKET == _mysocket)<span class="comment">//建立失败 </span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//连接服务器</span></span><br><span class="line">    sockaddr_in _sin = &#123;&#125;;<span class="comment">//sockaddr结构体 </span></span><br><span class="line">    _sin.sin_family = AF_INET;<span class="comment">//IPV4</span></span><br><span class="line">    _sin.sin_port = <span class="built_in">htons</span>(<span class="number">8888</span>);<span class="comment">//想要连接的端口号 </span></span><br><span class="line">	_sin.sin_addr.S_un.S_addr =  <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);<span class="comment">//想要连接的IP </span></span><br><span class="line">	<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">connect</span>(_mysocket,(sockaddr*)&amp;_sin,<span class="built_in">sizeof</span>(sockaddr_in)))</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;连接失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">		<span class="built_in">closesocket</span>(_mysocket);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;连接成功&quot;</span>&lt;&lt;endl; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//创建新线程</span></span><br><span class="line">	<span class="function">thread <span class="title">t1</span><span class="params">(_cmdThread,_mysocket)</span></span>;</span><br><span class="line">	t<span class="number">1.</span><span class="built_in">detach</span>();<span class="comment">//线程分离 </span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(_run)</span><br><span class="line">	&#123;</span><br><span class="line">		fd_set _fdRead;<span class="comment">//建立集合 </span></span><br><span class="line">		<span class="built_in">FD_ZERO</span>(&amp;_fdRead);<span class="comment">//清空集合  </span></span><br><span class="line">		<span class="built_in">FD_SET</span>(_mysocket,&amp;_fdRead);<span class="comment">//放入集合 </span></span><br><span class="line">		timeval <span class="type">_t</span> = &#123;<span class="number">1</span>,<span class="number">0</span>&#125;;<span class="comment">//select最大响应时间 </span></span><br><span class="line">		<span class="comment">//新建seclect </span></span><br><span class="line">		<span class="type">int</span> _ret = <span class="built_in">select</span>(_mysocket<span class="number">+1</span>,&amp;_fdRead,<span class="literal">NULL</span>,<span class="literal">NULL</span>,&amp;<span class="type">_t</span>);</span><br><span class="line">		<span class="keyword">if</span>(_ret&lt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;seclect任务结束\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(_mysocket,&amp;_fdRead))<span class="comment">//获取是否有可读socket </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">FD_CLR</span>(_mysocket,&amp;_fdRead);<span class="comment">//清理计数器 </span></span><br><span class="line">			<span class="keyword">if</span>(<span class="number">-1</span> == _handle(_mysocket))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;seclect任务结束\n&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭socket</span></span><br><span class="line">	<span class="built_in">closesocket</span>(_mysocket); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//清除windows socket 环境 </span></span><br><span class="line">	<span class="built_in">WSACleanup</span>(); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>使用g++创建动态库和静态库及其相关探索</title>
    <url>/2020/12/07/20201207_%E4%BD%BF%E7%94%A8g++%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81%E5%BA%93%E5%92%8C%E9%9D%99%E6%80%81%E5%BA%93%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E6%8E%A2%E7%B4%A2/</url>
    <content><![CDATA[<p><strong>使用g++创建动态库和静态库及其相关探索</strong></p>
<span id="more"></span>

<h2 id="0-前期准备"><a href="#0-前期准备" class="headerlink" title="0.前期准备"></a>0.前期准备</h2><ul>
<li><p><strong>首先我们建立头文件 “hello.h”</strong></p>
</li>
<li><p>内容如图：<img src="/images/2020-12-07/1.jpg#pic_center" alt="hello.h"></p>
</li>
<li><p><strong>随后我们建立源文件 “hello.cpp”</strong></p>
</li>
<li><p>内容如图：<img src="/images/2020-12-07/2.png#pic_center" alt="hello.cpp"></p>
</li>
<li><p><strong>最后我们建立源文件 “main.cpp”</strong></p>
</li>
<li><p>内容如图：<img src="/images/2020-12-07/3.png#pic_center" alt="main.cpp"></p>
</li>
<li><p><strong>我们使用 g++ -c 编译出.o文件。<br>无论是动态库还是静态库，都得由.o文件创建，所以我们先编译出.o文件。</strong></p>
</li>
<li><p>结果如图：可以看到有 hello.o 文件<img src="/images/2020-12-07/4.png#pic_center" alt="图1"></p>
</li>
</ul>
<h2 id="1-静态库创建及链接"><a href="#1-静态库创建及链接" class="headerlink" title="1.静态库创建及链接"></a>1.静态库创建及链接</h2><ul>
<li><strong>使用 ar crv 命令创立静态库。</strong></li>
<li>结果如图：建立出了静态库文件 libmyhello.a ，静态库文件后缀为.a 。<img src="/images/2020-12-07/5.png#pic_center" alt="图2"></li>
<li><strong>使用 g++ 命令链接静态库</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">g++ main.cpp libmyhello.a -o main</span><br></pre></td></tr></table></figure>

<ul>
<li>结果如图：生成了可执行文件main，且可以正常运行。<img src="/images/2020-12-07/6.png#pic_center" alt="图3"></li>
<li><strong>删除静态库libmyhello.a，程序仍能运行，说明链接成功。</strong></li>
<li>结果如图：<br><img src="/images/2020-12-07/7.png#pic_center" alt="图4"></li>
</ul>
<h2 id="2-动态库创建及链接"><a href="#2-动态库创建及链接" class="headerlink" title="2.动态库创建及链接"></a>2.动态库创建及链接</h2><ul>
<li><strong>使用 -shared -fPCI 命令创立动态库。</strong></li>
<li>结果如图：建立出了动态库文件 libtest.so ，动态库文件后缀为.so 。<br><img src="/images/2020-12-07/8.png#pic_center" alt="图1"></li>
<li><strong>使用 g++ 命令链接动态库</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">g++ main.cpp -L. -ltest -o main</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">-L代表so库目录，“-L.” 是当前目录， -I代表引用文件目录。main即为可执行文件</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>结果如图： 生成可执行文件main<br> <img src="/images/2020-12-07/9.png#pic_center" alt="图2"></li>
<li><strong>运行程序</strong></li>
<li>直接运行会报错：缺少文件。我们将动态库移动到&#x2F;usr&#x2F;lib 中即可</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mv libtest.so /usr/lib</span><br></pre></td></tr></table></figure>
<ul>
<li>随后即可正常运行（如果移动后仍不能运行，请看下文）<img src="/images/2020-12-07/2.png#pic_center" alt="图3"></li>
</ul>
<h2 id="3-相关问题"><a href="#3-相关问题" class="headerlink" title="3.相关问题"></a>3.相关问题</h2><h3 id="移动动态库后仍不能运行"><a href="#移动动态库后仍不能运行" class="headerlink" title="移动动态库后仍不能运行"></a>移动动态库后仍不能运行</h3><p>1.首先进入 &#x2F;etc&#x2F;ld.so.conf 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/ld.so.conf</span><br></pre></td></tr></table></figure>
<p>2.修改内容为如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include /etc/ld.so.conf.d/*.conf</span><br></pre></td></tr></table></figure>
<p>3.进入目录，创建任意*.conf文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /etc/ld.so.conf.d</span><br><span class="line">vim mylib.conf</span><br></pre></td></tr></table></figure>
<p>4.在其中添加so的路径即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/lib</span><br></pre></td></tr></table></figure>
<p>5.执行命令使其生效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure>
<p>随后程序即可正常运行</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++网络编程学习：源码的封装</title>
    <url>/2021/01/26/20210126_C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%BA%90%E7%A0%81%E7%9A%84%E5%B0%81%E8%A3%85/</url>
    <content><![CDATA[<ul>
<li>使用的语言为C&#x2F;C++</li>
<li>源码支持的平台为：Windows &#x2F; Linux</li>
</ul>
<h1 id="一、为何要进行封装操作"><a href="#一、为何要进行封装操作" class="headerlink" title="一、为何要进行封装操作"></a>一、为何要进行封装操作</h1><p>&emsp;&emsp;C++为面向对象编程语言，我们要以面向对象的思路进行源码的编写。<br>&emsp;&emsp;在对主要源码进行封装后，客户端与服务端的代码编写更加清晰明了，逻辑性更强，便于开发维护。且在今后的服务端高并发测试中，便于新建多个连接进行测试。<br>&emsp;&emsp;在本篇笔记中，我会<strong>基于笔记四的源码进行封装</strong>，并将记录我对客户端与服务端源码进行封装时的思路与步骤。最终源码为客户端封装类文件<strong>TcpClient.hpp</strong>与服务端封装类文件<strong>TcpServer.hpp</strong>，以及客户端源码<strong>client_test.cpp</strong>与服务端源码<strong>server_test.cpp</strong>。</p>
<span id="more"></span>

<h1 id="二、封装的思路与相关"><a href="#二、封装的思路与相关" class="headerlink" title="二、封装的思路与相关"></a>二、封装的思路与相关</h1><h2 id="1-封装的头文件选择"><a href="#1-封装的头文件选择" class="headerlink" title="1.封装的头文件选择"></a>1.封装的头文件选择</h2><p>&emsp;&emsp;封装类首先要在头文件中以体现封装性。在本次的封装中，为了能更方便的储存，我选择了<strong>hpp头文件</strong>。即类声明与类定义都在此文件中。</p>
<h2 id="2-客户端类的封装"><a href="#2-客户端类的封装" class="headerlink" title="2.客户端类的封装"></a>2.客户端类的封装</h2><p>&emsp;&emsp;首先，客户端的大致流程如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>建立socket</span><br><span class="line"><span class="number">2.</span>连接服务器</span><br><span class="line"><span class="number">3.</span>建立新线程 用于发送命令</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="number">4.</span>使用select函数获取服务器端是否有待处理事件</span><br><span class="line">	<span class="number">5.</span>如果有，就处理它(接收/发送)</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">6.</span>关闭socket</span><br><span class="line"></span><br><span class="line">新线程：</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="number">1.</span>键入数据</span><br><span class="line">	<span class="number">2.</span>发送数据</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;所以，我们需要封装的方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化socket</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">InitSocket</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//连接服务器 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Connect</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ip,<span class="type">unsigned</span> <span class="type">short</span> port)</span></span>;</span><br><span class="line"><span class="comment">//关闭socket</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CloseSocket</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//查询是否有待处理消息 </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">OnRun</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//判断是否工作中 </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsRun</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//发送数据 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SendData</span><span class="params">(DataHeader *_head)</span></span>;</span><br><span class="line"><span class="comment">//接收数据</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">RecvData</span><span class="params">(SOCKET _temp_socket)</span></span>;</span><br><span class="line"><span class="comment">//响应数据</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">NetMsg</span><span class="params">(DataHeader *_head)</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;按照此思路，客户端的源码思路为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span><span class="built_in">InitSocket</span>();<span class="comment">//建立socket</span></span><br><span class="line"><span class="number">2.</span><span class="built_in">Connect</span>(<span class="type">const</span> <span class="type">char</span> *ip,<span class="type">unsigned</span> <span class="type">short</span> port);<span class="comment">//连接服务器 传入IP与端口</span></span><br><span class="line"><span class="number">3.</span>建立新线程 用于发送命令</span><br><span class="line"><span class="keyword">while</span>(<span class="number">4.</span><span class="built_in">IsRun</span>())<span class="comment">//检测是否工作中</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="number">5.</span><span class="built_in">OnRun</span>();<span class="comment">//查询是否有待处理消息</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">6.</span><span class="built_in">CloseSocket</span>();<span class="comment">//关闭socket</span></span><br><span class="line"></span><br><span class="line">新线程：</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1.</span><span class="built_in">IsRun</span>())<span class="comment">//检测是否工作中</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="number">2.</span>键入数据</span><br><span class="line">	<span class="number">3.</span><span class="built_in">SendData</span>(DataHeader *_head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;其中，<strong>OnRun()</strong> 方法中使用的是select网络结构，在select筛选出待处理事件后，使用<strong>RecvData()</strong> 方法进行包头与包体的接收，随后调用<strong>NetMsg()</strong> 方法，依据包头的报文类型对包体数据进行处理。<strong>NetMsg()</strong> 方法为虚方法，在之后调用此封装类时，可以进行继承重载操作，便于对数据响应的操作进行变更。</p>
<ul>
<li>相关源码如下：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询是否有待处理消息 </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">OnRun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">IsRun</span>())<span class="comment">//如果有连接则监听事件 </span></span><br><span class="line">	&#123;</span><br><span class="line">		fd_set _fdRead;<span class="comment">//建立集合 </span></span><br><span class="line">		<span class="built_in">FD_ZERO</span>(&amp;_fdRead);<span class="comment">//清空集合  </span></span><br><span class="line">		<span class="built_in">FD_SET</span>(_sock,&amp;_fdRead);<span class="comment">//放入集合 </span></span><br><span class="line">		timeval <span class="type">_t</span> = &#123;<span class="number">1</span>,<span class="number">0</span>&#125;;<span class="comment">//select最大响应时间 </span></span><br><span class="line">		<span class="comment">//新建seclect </span></span><br><span class="line">		<span class="type">int</span> _ret = <span class="built_in">select</span>(_sock<span class="number">+1</span>,&amp;_fdRead,<span class="literal">NULL</span>,<span class="literal">NULL</span>,&amp;<span class="type">_t</span>);</span><br><span class="line">		<span class="keyword">if</span>(_ret&lt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;seclect任务结束\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(_sock,&amp;_fdRead))<span class="comment">//获取是否有可读socket </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">FD_CLR</span>(_sock,&amp;_fdRead);<span class="comment">//清理计数器 </span></span><br><span class="line">			<span class="keyword">if</span>(<span class="number">-1</span> == <span class="built_in">RecvData</span>(_sock))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">CloseSocket</span>();</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//接收数据</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">RecvData</span><span class="params">(SOCKET _temp_socket)</span><span class="comment">//处理数据 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//缓冲区 </span></span><br><span class="line">	<span class="type">char</span> buffer[<span class="number">4096</span>] = &#123;&#125;; </span><br><span class="line">	<span class="comment">//接收客户端发送的数据 </span></span><br><span class="line">	<span class="type">int</span> _buf_len = <span class="built_in">recv</span>(_temp_socket,buffer,<span class="built_in">sizeof</span>(DataHeader),<span class="number">0</span>);</span><br><span class="line">	DataHeader *_head = (DataHeader*)buffer; </span><br><span class="line">	<span class="keyword">if</span>(_buf_len&lt;=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;与服务器断开连接,任务结束\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">recv</span>(_temp_socket,buffer+<span class="built_in">sizeof</span>(DataHeader),_head-&gt;date_length-<span class="built_in">sizeof</span>(DataHeader),<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//响应数据 </span></span><br><span class="line">	<span class="built_in">NetMsg</span>(_head);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//响应数据</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">NetMsg</span><span class="params">(DataHeader *_head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;接收到包头，命令：%d，数据长度：%d\n&quot;</span>,_head-&gt;cmd,_head-&gt;date_length);</span><br><span class="line">	<span class="keyword">switch</span>(_head-&gt;cmd)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> CMD_LOGINRESULT:<span class="comment">//登录结果 接收登录包体 </span></span><br><span class="line">		&#123;</span><br><span class="line">			LoginResult *_result = (LoginResult*)_head; </span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;登录结果:%d\n&quot;</span>,_result-&gt;Result);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> CMD_LOGOUTRESULT:<span class="comment">//登出结果 接收登出包体 </span></span><br><span class="line">		&#123;</span><br><span class="line">			LogoutResult *_result = (LogoutResult*)_head; </span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;登录结果:%d\n&quot;</span>,_result-&gt;Result);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> CMD_NEW_USER_JOIN:<span class="comment">//新用户登录通知 </span></span><br><span class="line">		&#123;</span><br><span class="line">			NewUserJoin *_result = (NewUserJoin*)_head; </span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;用户:%s已登录\n&quot;</span>,_result-&gt;UserName);</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
&emsp;&emsp;另外，由于已经被封装，所以在调用方法时，可能会出现步骤错误的情况。例如还没进行新建套接字就进行connect连接操作或是关闭套接字操作、传入数据有误等等，此时就会出现问题。<br>&emsp;&emsp;我解决此类问题的方法是多加判定。例如判定套接字是否已经被建立，或是传入数据是否有误等等，随后根据情况进行处理。详细源码请看下文。</li>
</ul>
<h2 id="3-服务端类的封装"><a href="#3-服务端类的封装" class="headerlink" title="3.服务端类的封装"></a>3.服务端类的封装</h2><p>&emsp;&emsp;首先，客户端的大致流程如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>建立socket</span><br><span class="line"><span class="number">2.</span>绑定端口IP</span><br><span class="line"><span class="number">3.</span>监听端口</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="number">4.</span>使用select函数获取存在待监听事件的socket</span><br><span class="line">	<span class="number">5.</span>如果有新的连接则与新的客户端连接</span><br><span class="line">	<span class="number">6.</span>如果有待监听事件，则对其进行处理(接受与发送)</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">7.</span>关闭socket</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;所以，我们需要封装的方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化socket </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">InitSocket</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//绑定IP/端口</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Bind</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* ip,<span class="type">unsigned</span> <span class="type">short</span> port)</span></span>;</span><br><span class="line"><span class="comment">//监听端口</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Listen</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">//接受连接</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Accept</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//关闭socket </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CloseSocket</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//查询是否有待处理消息 </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">OnRun</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//判断是否工作中 </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsRun</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//发送数据 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SendData</span><span class="params">(DataHeader *_head,SOCKET _temp_socket)</span></span>;</span><br><span class="line"><span class="comment">//接收数据</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">RecvData</span><span class="params">(SOCKET _temp_socket)</span></span>;</span><br><span class="line"><span class="comment">//响应数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NetMsg</span><span class="params">(DataHeader *_head,SOCKET _temp_socket)</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;按照此思路，客户端的源码思路为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span><span class="built_in">InitSocket</span>();<span class="comment">//建立socket</span></span><br><span class="line"><span class="number">2.</span><span class="built_in">Bind</span>(<span class="type">const</span> <span class="type">char</span>* ip,<span class="type">unsigned</span> <span class="type">short</span> port);<span class="comment">//绑定端口IP</span></span><br><span class="line"><span class="number">3.L</span>isten(<span class="type">int</span> n);<span class="comment">//监听端口</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">4.</span><span class="built_in">IsRun</span>())<span class="comment">//是否工作中</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="number">5.</span><span class="built_in">OnRun</span>();<span class="comment">//查看是否有待处理消息</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">6.</span><span class="built_in">CloseSocket</span>();<span class="comment">//关闭socket</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;其中，<strong>OnRun()</strong> 方法中使用的是select网络结构。在select筛选出待处理事件后，如果为新连接，则使用<strong>Accept()</strong> 方法进行新客户端连接操作；如果为已连接客户端的待接受事件，则使用<strong>RecvData()</strong> 方法进行包头与包体的接收，随后调用<strong>NetMsg()</strong> 方法，依据包头的报文类型对包体数据进行处理。<strong>NetMsg()</strong> 方法为虚方法，在之后调用此封装类时，可以进行继承重载操作，便于对数据响应的操作进行变更。</p>
<ul>
<li>相关源码如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询是否有待处理消息 </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">OnRun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">IsRun</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		fd_set _fdRead;<span class="comment">//建立集合 </span></span><br><span class="line">		fd_set _fdWrite;</span><br><span class="line">		fd_set _fdExcept;</span><br><span class="line">		<span class="built_in">FD_ZERO</span>(&amp;_fdRead);<span class="comment">//清空集合 </span></span><br><span class="line">		<span class="built_in">FD_ZERO</span>(&amp;_fdWrite); </span><br><span class="line">		<span class="built_in">FD_ZERO</span>(&amp;_fdExcept); </span><br><span class="line">		<span class="built_in">FD_SET</span>(_sock,&amp;_fdRead);<span class="comment">//放入集合 </span></span><br><span class="line">		<span class="built_in">FD_SET</span>(_sock,&amp;_fdWrite); </span><br><span class="line">		<span class="built_in">FD_SET</span>(_sock,&amp;_fdExcept);</span><br><span class="line">		timeval <span class="type">_t</span> = &#123;<span class="number">2</span>,<span class="number">0</span>&#125;;<span class="comment">//select最大响应时间 </span></span><br><span class="line">		SOCKET _maxSock = _sock;<span class="comment">//最大socket </span></span><br><span class="line">		<span class="comment">//把连接的客户端 放入read集合 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> n=_clients.<span class="built_in">size</span>()<span class="number">-1</span>; n&gt;=<span class="number">0</span>; --n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">FD_SET</span>(_clients[n],&amp;_fdRead);</span><br><span class="line">			<span class="keyword">if</span>(_maxSock &lt; _clients[n])</span><br><span class="line">			&#123;</span><br><span class="line">				_maxSock = _clients[n];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//select函数筛选select </span></span><br><span class="line">		<span class="type">int</span> _ret = <span class="built_in">select</span>(_maxSock<span class="number">+1</span>,&amp;_fdRead,&amp;_fdWrite,&amp;_fdExcept,&amp;<span class="type">_t</span>); </span><br><span class="line">		<span class="keyword">if</span>(_ret&lt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;select任务结束\n&quot;</span>);</span><br><span class="line">			<span class="built_in">CloseSocket</span>();</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(_sock,&amp;_fdRead))<span class="comment">//获取是否有新socket连接 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">FD_CLR</span>(_sock,&amp;_fdRead);<span class="comment">//清理</span></span><br><span class="line">			<span class="built_in">Accept</span>();<span class="comment">//连接 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//遍历所有socket 查看是否有待处理事件 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;_clients.<span class="built_in">size</span>(); ++n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(_clients[n],&amp;_fdRead))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="number">-1</span> == <span class="built_in">RecvData</span>(_clients[n]))<span class="comment">//处理请求 客户端退出的话 </span></span><br><span class="line">				&#123;</span><br><span class="line">					std::vector&lt;SOCKET&gt;::iterator iter = _clients.<span class="built_in">begin</span>()+n;<span class="comment">//找到退出客户端的地址</span></span><br><span class="line">					<span class="keyword">if</span>(iter != _clients.<span class="built_in">end</span>())<span class="comment">//如果是合理值</span></span><br><span class="line">					&#123;</span><br><span class="line">						_clients.<span class="built_in">erase</span>(iter);<span class="comment">//移除</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//printf(&quot;空闲时间处理其他业务\n&quot;);</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//接收数据</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">RecvData</span><span class="params">(SOCKET _temp_socket)</span><span class="comment">//处理数据 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//缓冲区</span></span><br><span class="line">	<span class="type">char</span> buffer[<span class="number">4096</span>] = &#123;&#125;; </span><br><span class="line">	<span class="comment">//接收客户端发送的数据  </span></span><br><span class="line">	<span class="type">int</span> _buf_len = <span class="built_in">recv</span>(_temp_socket,buffer,<span class="built_in">sizeof</span>(DataHeader),<span class="number">0</span>);</span><br><span class="line">	DataHeader *_head = (DataHeader*)buffer;</span><br><span class="line">	<span class="keyword">if</span>(_buf_len&lt;=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;客户端已退出\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">recv</span>(_temp_socket,buffer+<span class="built_in">sizeof</span>(DataHeader),_head-&gt;date_length-<span class="built_in">sizeof</span>(DataHeader),<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//响应数据</span></span><br><span class="line">	<span class="built_in">NetMsg</span>(_head,_temp_socket); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//响应数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NetMsg</span><span class="params">(DataHeader *_head,SOCKET _temp_socket)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">&quot;接收到包头，命令：%d，数据长度：%d\n&quot;</span>,_head-&gt;cmd,_head-&gt;date_length);</span><br><span class="line">	<span class="keyword">switch</span>(_head-&gt;cmd)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> CMD_LOGIN:<span class="comment">//登录 接收登录包体 </span></span><br><span class="line">		&#123;</span><br><span class="line">			Login *_login = (Login*)_head;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			进行判断操作 </span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s已登录\n密码：%s\n&quot;</span>,_login-&gt;UserName,_login-&gt;PassWord); </span><br><span class="line">			LoginResult *_result = <span class="keyword">new</span> LoginResult;	</span><br><span class="line">			_result-&gt;Result = <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">SendData</span>(_result,_temp_socket);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> CMD_LOGOUT:<span class="comment">//登出 接收登出包体 </span></span><br><span class="line">		&#123;</span><br><span class="line">			Logout *_logout = (Logout*)_head;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			进行判断操作 </span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s已登出\n&quot;</span>,_logout-&gt;UserName); </span><br><span class="line">			LogoutResult *_result = <span class="keyword">new</span> <span class="built_in">LogoutResult</span>();</span><br><span class="line">			_result-&gt;Result = <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">SendData</span>(_result,_temp_socket);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:<span class="comment">//错误 </span></span><br><span class="line">		&#123;</span><br><span class="line">			_head-&gt;cmd = CMD_ERROR; </span><br><span class="line">			_head-&gt;date_length = <span class="number">0</span>; </span><br><span class="line">			<span class="built_in">SendData</span>(_head,_temp_socket); </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;另外，由于已经被封装，所以在调用方法时，可能会出现步骤错误的情况。例如还没进行新建套接字就进行bind绑定端口IP或是关闭套接字操作、传入数据有误等等，此时就会出现问题。<br>&emsp;&emsp;我解决此类问题的方法是多加判定。例如判定套接字是否已经被建立，或是传入数据是否有误等等，随后根据情况进行处理。详细源码请看下文。</p>
<h1 id="三、封装后的详细源码及其注释"><a href="#三、封装后的详细源码及其注释" class="headerlink" title="三、封装后的详细源码及其注释"></a>三、封装后的详细源码及其注释</h1><h2 id="1-客户端"><a href="#1-客户端" class="headerlink" title="1.客户端"></a>1.客户端</h2><h3 id="TcpClient-hpp"><a href="#TcpClient-hpp" class="headerlink" title="TcpClient.hpp"></a>TcpClient.hpp</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TcpClient_hpp_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TcpClient_hpp_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;winSock2.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>) </span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SOCKET int</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> INVALID_SOCKET (SOCKET)(~0)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SOCKET_ERROR (-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">//枚举类型记录命令 </span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">cmd</span> </span><br><span class="line">&#123;</span><br><span class="line">	CMD_LOGIN,<span class="comment">//登录 </span></span><br><span class="line">	CMD_LOGINRESULT,<span class="comment">//登录结果 </span></span><br><span class="line">	CMD_LOGOUT,<span class="comment">//登出 </span></span><br><span class="line">	CMD_LOGOUTRESULT,<span class="comment">//登出结果 </span></span><br><span class="line">	CMD_NEW_USER_JOIN,<span class="comment">//新用户登入 </span></span><br><span class="line">	CMD_ERROR<span class="comment">//错误 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义数据包头 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DataHeader</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">short</span> cmd;<span class="comment">//命令</span></span><br><span class="line">	<span class="type">short</span> date_length;<span class="comment">//数据的长短	</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包1 登录 传输账号与密码</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Login</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Login</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGIN;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Login); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">	<span class="type">char</span> PassWord[<span class="number">32</span>];<span class="comment">//密码 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包2 登录结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoginResult</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LoginResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGINRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LoginResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包3 登出 传输用户名 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Logout</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Logout</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Logout); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包4 登出结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LogoutResult</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LogoutResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUTRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LogoutResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包5 新用户登入 传输通告 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NewUserJoin</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">NewUserJoin</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_NEW_USER_JOIN;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(NewUserJoin); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TcpClient</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造 </span></span><br><span class="line">	<span class="built_in">TcpClient</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		_sock = INVALID_SOCKET; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//析构 </span></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">TcpClient</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//关闭socket </span></span><br><span class="line">		<span class="built_in">CloseSocket</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//初始化socket 返回1为正常 </span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">InitSocket</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">		<span class="comment">//启动windows socket 2,x环境 </span></span><br><span class="line">		WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>); </span><br><span class="line">		WSADATA dat;</span><br><span class="line">		<span class="keyword">if</span>(<span class="number">0</span> != <span class="built_in">WSAStartup</span>(ver,&amp;dat))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//-1为环境错误 </span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">		<span class="comment">//创建socket </span></span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET != _sock)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;&lt;Socket=%d&gt;关闭连接\n&quot;</span>,_sock); </span><br><span class="line">			<span class="built_in">CloseSocket</span>();<span class="comment">//如果之前有连接 就关闭连接 </span></span><br><span class="line">		&#125;</span><br><span class="line">		_sock = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,IPPROTO_TCP); </span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET == _sock)</span><br><span class="line">		&#123;   </span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//0为socket创建错误 </span></span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//连接服务器  返回1为成功 </span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Connect</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ip,<span class="type">unsigned</span> <span class="type">short</span> port)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//如果为无效套接字 则初始化 </span></span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET == _sock)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">InitSocket</span>(); </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//连接服务器</span></span><br><span class="line">	   	sockaddr_in _sin = &#123;&#125;;</span><br><span class="line">	   	_sin.sin_family = AF_INET;<span class="comment">//IPV4</span></span><br><span class="line">	   	_sin.sin_port = <span class="built_in">htons</span>(port);<span class="comment">//端口号 </span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">		_sin.sin_addr.S_un.S_addr =  <span class="built_in">inet_addr</span>(ip);<span class="comment">//IP </span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		_sin.sin_addr.s_addr =  <span class="built_in">inet_addr</span>(ip);<span class="comment">//IP </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">connect</span>(_sock,(sockaddr*)&amp;_sin,<span class="built_in">sizeof</span>(sockaddr_in)))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//连接失败 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//连接成功 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//关闭socket</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">CloseSocket</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET != _sock) </span><br><span class="line">		&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">			<span class="comment">//关闭socket</span></span><br><span class="line">			<span class="built_in">closesocket</span>(_sock); </span><br><span class="line">			<span class="comment">//清除windows socket 环境 </span></span><br><span class="line">			<span class="built_in">WSACleanup</span>(); </span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">			<span class="comment">//关闭socket/LINUX</span></span><br><span class="line">			<span class="built_in">close</span>(_sock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">			_sock = INVALID_SOCKET;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//查询是否有待处理消息 </span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">OnRun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">IsRun</span>())<span class="comment">//如果有连接则监听事件 </span></span><br><span class="line">		&#123;</span><br><span class="line">			fd_set _fdRead;<span class="comment">//建立集合 </span></span><br><span class="line">			<span class="built_in">FD_ZERO</span>(&amp;_fdRead);<span class="comment">//清空集合  </span></span><br><span class="line">			<span class="built_in">FD_SET</span>(_sock,&amp;_fdRead);<span class="comment">//放入集合 </span></span><br><span class="line">			timeval <span class="type">_t</span> = &#123;<span class="number">1</span>,<span class="number">0</span>&#125;;<span class="comment">//select最大响应时间 </span></span><br><span class="line">			<span class="comment">//新建seclect </span></span><br><span class="line">			<span class="type">int</span> _ret = <span class="built_in">select</span>(_sock<span class="number">+1</span>,&amp;_fdRead,<span class="literal">NULL</span>,<span class="literal">NULL</span>,&amp;<span class="type">_t</span>);</span><br><span class="line">			<span class="keyword">if</span>(_ret&lt;<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;seclect任务结束\n&quot;</span>);</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(_sock,&amp;_fdRead))<span class="comment">//获取是否有可读socket </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">FD_CLR</span>(_sock,&amp;_fdRead);<span class="comment">//清理计数器 </span></span><br><span class="line">				<span class="keyword">if</span>(<span class="number">-1</span> == <span class="built_in">RecvData</span>(_sock))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">CloseSocket</span>();</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;	</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//判断是否工作中 </span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">IsRun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _sock != INVALID_SOCKET; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//发送数据 </span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">SendData</span><span class="params">(DataHeader *_head)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">IsRun</span>() &amp;&amp; _head)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">send</span>(_sock,(<span class="type">const</span> <span class="type">char</span>*)_head,_head-&gt;date_length,<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//接收数据</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">RecvData</span><span class="params">(SOCKET _temp_socket)</span><span class="comment">//处理数据 </span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//缓冲区 </span></span><br><span class="line">		<span class="type">char</span> buffer[<span class="number">4096</span>] = &#123;&#125;; </span><br><span class="line">		<span class="comment">//接收客户端发送的数据 </span></span><br><span class="line">		<span class="type">int</span> _buf_len = <span class="built_in">recv</span>(_temp_socket,buffer,<span class="built_in">sizeof</span>(DataHeader),<span class="number">0</span>);</span><br><span class="line">		DataHeader *_head = (DataHeader*)buffer; </span><br><span class="line">		<span class="keyword">if</span>(_buf_len&lt;=<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;与服务器断开连接,任务结束\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="built_in">recv</span>(_temp_socket,buffer+<span class="built_in">sizeof</span>(DataHeader),_head-&gt;date_length-<span class="built_in">sizeof</span>(DataHeader),<span class="number">0</span>);</span><br><span class="line">		<span class="comment">//响应数据 </span></span><br><span class="line">		<span class="built_in">NetMsg</span>(_head);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//响应数据</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">NetMsg</span><span class="params">(DataHeader *_head)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;接收到包头，命令：%d，数据长度：%d\n&quot;</span>,_head-&gt;cmd,_head-&gt;date_length);</span><br><span class="line">		<span class="keyword">switch</span>(_head-&gt;cmd)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> CMD_LOGINRESULT:<span class="comment">//登录结果 接收登录包体 </span></span><br><span class="line">			&#123;</span><br><span class="line">				LoginResult *_result = (LoginResult*)_head; </span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;登录结果:%d\n&quot;</span>,_result-&gt;Result);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> CMD_LOGOUTRESULT:<span class="comment">//登出结果 接收登出包体 </span></span><br><span class="line">			&#123;</span><br><span class="line">				LogoutResult *_result = (LogoutResult*)_head; </span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;登录结果:%d\n&quot;</span>,_result-&gt;Result);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> CMD_NEW_USER_JOIN:<span class="comment">//新用户登录通知 </span></span><br><span class="line">			&#123;</span><br><span class="line">				NewUserJoin *_result = (NewUserJoin*)_head; </span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;用户:%s已登录\n&quot;</span>,_result-&gt;UserName);</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	SOCKET _sock;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="client-test-cpp"><a href="#client-test-cpp" class="headerlink" title="client_test.cpp"></a>client_test.cpp</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;TcpClient.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _cmdThread(TcpClient* tcp)<span class="comment">//命令线程 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(tcp-&gt;<span class="built_in">IsRun</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//输入请求 </span></span><br><span class="line">		<span class="type">char</span> _msg[<span class="number">256</span>] = &#123;&#125;;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,_msg);</span><br><span class="line">		<span class="comment">//处理请求 </span></span><br><span class="line">		<span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(_msg,<span class="string">&quot;exit&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			tcp-&gt;<span class="built_in">CloseSocket</span>();</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;程序退出\n&quot;</span>); </span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(_msg,<span class="string">&quot;login&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//发送 </span></span><br><span class="line">			Login _login;</span><br><span class="line">			<span class="built_in">strcpy</span>(_login.UserName,<span class="string">&quot;hbxxy&quot;</span>);</span><br><span class="line">			<span class="built_in">strcpy</span>(_login.PassWord,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">			tcp-&gt;<span class="built_in">SendData</span>(&amp;_login);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(_msg,<span class="string">&quot;logout&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//发送 </span></span><br><span class="line">			Logout _logout;</span><br><span class="line">			<span class="built_in">strcpy</span>(_logout.UserName,<span class="string">&quot;hbxxy&quot;</span>);</span><br><span class="line">			tcp-&gt;<span class="built_in">SendData</span>(&amp;_logout);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;不存在的命令\n&quot;</span>);</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Welcome\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//建立tcp对象 </span></span><br><span class="line">	TcpClient *tcp1 = <span class="keyword">new</span> <span class="built_in">TcpClient</span>();</span><br><span class="line">	<span class="comment">//建立一个socket </span></span><br><span class="line">	tcp1-&gt;<span class="built_in">InitSocket</span>();</span><br><span class="line">   	<span class="comment">//连接服务器</span></span><br><span class="line">   	tcp1-&gt;<span class="built_in">Connect</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8888</span>);</span><br><span class="line">	<span class="comment">//创建UI线程</span></span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(_cmdThread,tcp1)</span></span>;</span><br><span class="line">	t<span class="number">1.</span><span class="built_in">detach</span>();<span class="comment">//线程分离 </span></span><br><span class="line">	<span class="comment">//循环 </span></span><br><span class="line">	<span class="keyword">while</span>(tcp1-&gt;<span class="built_in">IsRun</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		tcp1-&gt;<span class="built_in">OnRun</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//关闭 </span></span><br><span class="line">	tcp1-&gt;<span class="built_in">CloseSocket</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h2 id="2-服务端"><a href="#2-服务端" class="headerlink" title="2.服务端"></a>2.服务端</h2><h3 id="TcpServer-hpp"><a href="#TcpServer-hpp" class="headerlink" title="TcpServer.hpp"></a>TcpServer.hpp</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TcpServer_hpp_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TcpServer_hpp_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;winSock2.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//链接此动态链接库 windows特有 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span><span class="comment">//selcet</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span><span class="comment">//uni std</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SOCKET int</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> INVALID_SOCKET (SOCKET)(~0)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SOCKET_ERROR (-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">//枚举类型记录命令 </span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">cmd</span> </span><br><span class="line">&#123;</span><br><span class="line">	CMD_LOGIN,<span class="comment">//登录 </span></span><br><span class="line">	CMD_LOGINRESULT,<span class="comment">//登录结果 </span></span><br><span class="line">	CMD_LOGOUT,<span class="comment">//登出 </span></span><br><span class="line">	CMD_LOGOUTRESULT,<span class="comment">//登出结果 </span></span><br><span class="line">	CMD_NEW_USER_JOIN,<span class="comment">//新用户登入 </span></span><br><span class="line">	CMD_ERROR<span class="comment">//错误 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义数据包头 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DataHeader</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">short</span> cmd;<span class="comment">//命令</span></span><br><span class="line">	<span class="type">short</span> date_length;<span class="comment">//数据的长短	</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包1 登录 传输账号与密码</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Login</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Login</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGIN;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Login); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">	<span class="type">char</span> PassWord[<span class="number">32</span>];<span class="comment">//密码 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包2 登录结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoginResult</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LoginResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGINRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LoginResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包3 登出 传输用户名 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Logout</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Logout</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Logout); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包4 登出结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LogoutResult</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LogoutResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUTRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LogoutResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包5 新用户登入 传输通告 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NewUserJoin</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">NewUserJoin</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_NEW_USER_JOIN;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(NewUserJoin); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TcpServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造 </span></span><br><span class="line">	<span class="built_in">TcpServer</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		_sock = INVALID_SOCKET; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//析构 </span></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">TcpServer</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//关闭socket </span></span><br><span class="line">		<span class="built_in">CloseSocket</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//初始化socket 返回1为正常 </span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">InitSocket</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">		<span class="comment">//启动windows socket 2,x环境 </span></span><br><span class="line">		WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>); </span><br><span class="line">		WSADATA dat;</span><br><span class="line">		<span class="keyword">if</span>(<span class="number">0</span> != <span class="built_in">WSAStartup</span>(ver,&amp;dat))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//-1为环境错误 </span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">		<span class="comment">//创建socket </span></span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET != _sock)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;&lt;Socket=%d&gt;关闭连接\n&quot;</span>,_sock); </span><br><span class="line">			<span class="built_in">CloseSocket</span>();<span class="comment">//如果之前有连接 就关闭连接 </span></span><br><span class="line">		&#125;</span><br><span class="line">		_sock = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,IPPROTO_TCP); </span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET == _sock)</span><br><span class="line">		&#123;   </span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//0为socket创建错误 </span></span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//绑定IP/端口</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Bind</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* ip,<span class="type">unsigned</span> <span class="type">short</span> port)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//如果为无效套接字 则初始化 </span></span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET == _sock)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">InitSocket</span>(); </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//绑定网络端口和IP地址 </span></span><br><span class="line">		sockaddr_in _myaddr = &#123;&#125;; </span><br><span class="line">		_myaddr.sin_family = AF_INET;<span class="comment">//IPV4</span></span><br><span class="line">		_myaddr.sin_port = <span class="built_in">htons</span>(port);<span class="comment">//端口</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">		<span class="keyword">if</span>(ip)<span class="comment">//ip为空则监听所有网卡 </span></span><br><span class="line">		&#123;</span><br><span class="line">			_myaddr.sin_addr.S_un.S_addr = <span class="built_in">inet_addr</span>(ip);<span class="comment">//IP</span></span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			_myaddr.sin_addr.S_un.S_addr = INADDR_ANY;<span class="comment">//IP</span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		<span class="keyword">if</span>(ip)<span class="comment">//ip为空则监听所有网卡</span></span><br><span class="line">		&#123;</span><br><span class="line">			_myaddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(ip);<span class="comment">//IP </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			_myaddr.sin_addr.s_addr = INADDR_ANY;<span class="comment">//IP </span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">bind</span>(_sock,(sockaddr*)&amp;_myaddr,<span class="built_in">sizeof</span>(sockaddr_in)))<span class="comment">//socket (强制转换)sockaddr结构体 结构体大小 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;绑定失败\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;绑定成功\n绑定端口为%d\n&quot;</span>,port);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//监听端口</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Listen</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//如果为无效套接字 则提示 </span></span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET == _sock)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;请先初始化套接字并绑定IP端口\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//监听网络端口</span></span><br><span class="line">		<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">listen</span>(_sock,n))<span class="comment">//最大连接队列 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;监听失败\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;监听成功\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//接受连接</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Accept</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//等待接收客户端连接</span></span><br><span class="line">		sockaddr_in _clientAddr = &#123;&#125;;<span class="comment">//新建sockadd结构体接收客户端数据 </span></span><br><span class="line">		<span class="type">int</span> _addr_len = <span class="built_in">sizeof</span>(sockaddr_in);<span class="comment">//获取sockadd结构体长度 </span></span><br><span class="line">		SOCKET _temp_socket = INVALID_SOCKET;<span class="comment">//声明客户端套接字 </span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32	</span></span><br><span class="line">		_temp_socket = <span class="built_in">accept</span>(_sock,(sockaddr*)&amp;_clientAddr,&amp;_addr_len);<span class="comment">//自身套接字 客户端结构体 结构体大小 	</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		_temp_socket = <span class="built_in">accept</span>(_sock,(sockaddr*)&amp;_clientAddr,(<span class="type">socklen_t</span>*)&amp;_addr_len);<span class="comment">//自身套接字 客户端结构体 结构体大小 </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET == _temp_socket)<span class="comment">//接收失败 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;&lt;Socket=%d&gt;错误,接受到无效客户端SOCKET\n&quot;</span>,_temp_socket);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123; </span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;新客户端加入\nIP地址为：%s \n&quot;</span>, <span class="built_in">inet_ntoa</span>(_clientAddr.sin_addr));  </span><br><span class="line">			<span class="comment">//群发所有客户端 通知新用户登录 </span></span><br><span class="line">			NewUserJoin _user_join; </span><br><span class="line">			<span class="built_in">strcpy</span>(_user_join.UserName,<span class="built_in">inet_ntoa</span>(_clientAddr.sin_addr));</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>;n&lt;_clients.<span class="built_in">size</span>();++n)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">send</span>(_clients[n],(<span class="type">const</span> <span class="type">char</span>*)&amp;_user_join,<span class="built_in">sizeof</span>(NewUserJoin),<span class="number">0</span>);	</span><br><span class="line">			&#125; </span><br><span class="line">			<span class="comment">//将新的客户端加入动态数组</span></span><br><span class="line">			_clients.<span class="built_in">push_back</span>(_temp_socket); </span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//关闭socket </span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">CloseSocket</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET != _sock) </span><br><span class="line">		&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">			<span class="comment">//关闭客户端socket</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;_clients.<span class="built_in">size</span>(); ++n)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">closesocket</span>(_clients[n]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//关闭socket</span></span><br><span class="line">			<span class="built_in">closesocket</span>(_sock); </span><br><span class="line">			<span class="comment">//清除windows socket 环境 </span></span><br><span class="line">			<span class="built_in">WSACleanup</span>(); </span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">			<span class="comment">//关闭客户端socket</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;_clients.<span class="built_in">size</span>(); ++n)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">close</span>(_clients[n]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//关闭socket/LINUX</span></span><br><span class="line">			<span class="built_in">close</span>(_sock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">			_sock = INVALID_SOCKET;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//查询是否有待处理消息 </span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">OnRun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">IsRun</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			fd_set _fdRead;<span class="comment">//建立集合 </span></span><br><span class="line">			fd_set _fdWrite;</span><br><span class="line">			fd_set _fdExcept;</span><br><span class="line">			<span class="built_in">FD_ZERO</span>(&amp;_fdRead);<span class="comment">//清空集合 </span></span><br><span class="line">			<span class="built_in">FD_ZERO</span>(&amp;_fdWrite); </span><br><span class="line">			<span class="built_in">FD_ZERO</span>(&amp;_fdExcept); </span><br><span class="line">			<span class="built_in">FD_SET</span>(_sock,&amp;_fdRead);<span class="comment">//放入集合 </span></span><br><span class="line">			<span class="built_in">FD_SET</span>(_sock,&amp;_fdWrite); </span><br><span class="line">			<span class="built_in">FD_SET</span>(_sock,&amp;_fdExcept);</span><br><span class="line">			timeval <span class="type">_t</span> = &#123;<span class="number">2</span>,<span class="number">0</span>&#125;;<span class="comment">//select最大响应时间 </span></span><br><span class="line">			SOCKET _maxSock = _sock;<span class="comment">//最大socket </span></span><br><span class="line">			<span class="comment">//把连接的客户端 放入read集合 </span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> n=_clients.<span class="built_in">size</span>()<span class="number">-1</span>; n&gt;=<span class="number">0</span>; --n)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">FD_SET</span>(_clients[n],&amp;_fdRead);</span><br><span class="line">				<span class="keyword">if</span>(_maxSock &lt; _clients[n])</span><br><span class="line">				&#123;</span><br><span class="line">					_maxSock = _clients[n];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//select函数筛选select </span></span><br><span class="line">			<span class="type">int</span> _ret = <span class="built_in">select</span>(_maxSock<span class="number">+1</span>,&amp;_fdRead,&amp;_fdWrite,&amp;_fdExcept,&amp;<span class="type">_t</span>); </span><br><span class="line">			<span class="keyword">if</span>(_ret&lt;<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;select任务结束\n&quot;</span>);</span><br><span class="line">				<span class="built_in">CloseSocket</span>();</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(_sock,&amp;_fdRead))<span class="comment">//获取是否有新socket连接 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">FD_CLR</span>(_sock,&amp;_fdRead);<span class="comment">//清理</span></span><br><span class="line">				<span class="built_in">Accept</span>();<span class="comment">//连接 </span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//遍历所有socket 查看是否有待处理事件 </span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;_clients.<span class="built_in">size</span>(); ++n)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(_clients[n],&amp;_fdRead))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(<span class="number">-1</span> == <span class="built_in">RecvData</span>(_clients[n]))<span class="comment">//处理请求 客户端退出的话 </span></span><br><span class="line">					&#123;</span><br><span class="line">						std::vector&lt;SOCKET&gt;::iterator iter = _clients.<span class="built_in">begin</span>()+n;<span class="comment">//找到退出客户端的地址</span></span><br><span class="line">						<span class="keyword">if</span>(iter != _clients.<span class="built_in">end</span>())<span class="comment">//如果是合理值</span></span><br><span class="line">						&#123;</span><br><span class="line">							_clients.<span class="built_in">erase</span>(iter);<span class="comment">//移除</span></span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//printf(&quot;空闲时间处理其他业务\n&quot;);</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//判断是否工作中 </span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">IsRun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _sock != INVALID_SOCKET; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//发送数据 </span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">SendData</span><span class="params">(DataHeader *_head,SOCKET _temp_socket)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">IsRun</span>() &amp;&amp; _head)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">send</span>(_temp_socket,(<span class="type">const</span> <span class="type">char</span>*)_head,_head-&gt;date_length,<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//接收数据</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">RecvData</span><span class="params">(SOCKET _temp_socket)</span><span class="comment">//处理数据 </span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//缓冲区</span></span><br><span class="line">		<span class="type">char</span> buffer[<span class="number">4096</span>] = &#123;&#125;; </span><br><span class="line">		<span class="comment">//接收客户端发送的数据  </span></span><br><span class="line">		<span class="type">int</span> _buf_len = <span class="built_in">recv</span>(_temp_socket,buffer,<span class="built_in">sizeof</span>(DataHeader),<span class="number">0</span>);</span><br><span class="line">		DataHeader *_head = (DataHeader*)buffer;</span><br><span class="line">		<span class="keyword">if</span>(_buf_len&lt;=<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;客户端已退出\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="built_in">recv</span>(_temp_socket,buffer+<span class="built_in">sizeof</span>(DataHeader),_head-&gt;date_length-<span class="built_in">sizeof</span>(DataHeader),<span class="number">0</span>);</span><br><span class="line">		<span class="comment">//响应数据</span></span><br><span class="line">		<span class="built_in">NetMsg</span>(_head,_temp_socket); </span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//响应数据</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">NetMsg</span><span class="params">(DataHeader *_head,SOCKET _temp_socket)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	 	<span class="built_in">printf</span>(<span class="string">&quot;接收到包头，命令：%d，数据长度：%d\n&quot;</span>,_head-&gt;cmd,_head-&gt;date_length);</span><br><span class="line">		<span class="keyword">switch</span>(_head-&gt;cmd)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> CMD_LOGIN:<span class="comment">//登录 接收登录包体 </span></span><br><span class="line">			&#123;</span><br><span class="line">				Login *_login = (Login*)_head;</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				进行判断操作 </span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%s已登录\n密码：%s\n&quot;</span>,_login-&gt;UserName,_login-&gt;PassWord); </span><br><span class="line">				LoginResult *_result = <span class="keyword">new</span> LoginResult;	</span><br><span class="line">				_result-&gt;Result = <span class="number">1</span>;</span><br><span class="line">				<span class="built_in">SendData</span>(_result,_temp_socket);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> CMD_LOGOUT:<span class="comment">//登出 接收登出包体 </span></span><br><span class="line">			&#123;</span><br><span class="line">				Logout *_logout = (Logout*)_head;</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				进行判断操作 </span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%s已登出\n&quot;</span>,_logout-&gt;UserName); </span><br><span class="line">				LogoutResult *_result = <span class="keyword">new</span> <span class="built_in">LogoutResult</span>();</span><br><span class="line">				_result-&gt;Result = <span class="number">1</span>;</span><br><span class="line">				<span class="built_in">SendData</span>(_result,_temp_socket);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:<span class="comment">//错误 </span></span><br><span class="line">			&#123;</span><br><span class="line">				_head-&gt;cmd = CMD_ERROR; </span><br><span class="line">				_head-&gt;date_length = <span class="number">0</span>; </span><br><span class="line">				<span class="built_in">SendData</span>(_head,_temp_socket); </span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	 </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	SOCKET _sock; </span><br><span class="line">	std::vector&lt;SOCKET&gt; _clients;<span class="comment">//储存客户端socket</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="server-test-cpp"><a href="#server-test-cpp" class="headerlink" title="server_test.cpp"></a>server_test.cpp</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;TcpServer.hpp&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Welcome\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//建立tcp对象 </span></span><br><span class="line">	TcpServer *tcp1 = <span class="keyword">new</span> <span class="built_in">TcpServer</span>();</span><br><span class="line">	<span class="comment">//建立一个socket</span></span><br><span class="line">	tcp1-&gt;<span class="built_in">InitSocket</span>();</span><br><span class="line">	<span class="comment">//绑定端口和IP</span></span><br><span class="line">	tcp1-&gt;<span class="built_in">Bind</span>(<span class="literal">NULL</span>,<span class="number">8888</span>);</span><br><span class="line">	<span class="comment">//监听</span></span><br><span class="line">	tcp1-&gt;<span class="built_in">Listen</span>(<span class="number">5</span>);</span><br><span class="line">	<span class="comment">//循环 </span></span><br><span class="line">	<span class="keyword">while</span>(tcp1-&gt;<span class="built_in">IsRun</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		tcp1-&gt;<span class="built_in">OnRun</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//关闭</span></span><br><span class="line">	tcp1-&gt;<span class="built_in">CloseSocket</span>();</span><br><span class="line">	 </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;任务结束，程序已退出&quot;</span>); </span><br><span class="line">	<span class="built_in">getchar</span>(); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++网络编程学习：缓冲区溢出与粘包分包</title>
    <url>/2021/01/28/20210128_C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E4%B8%8E%E7%B2%98%E5%8C%85%E5%88%86%E5%8C%85/</url>
    <content><![CDATA[<ul>
<li>使用的语言为C&#x2F;C++</li>
<li>源码支持的平台为：Windows &#x2F; Linux</li>
</ul>
<h1 id="一、关于缓冲区溢出"><a href="#一、关于缓冲区溢出" class="headerlink" title="一、关于缓冲区溢出"></a>一、关于缓冲区溢出</h1><h2 id="1-缓冲区溢出的原因"><a href="#1-缓冲区溢出的原因" class="headerlink" title="1.缓冲区溢出的原因"></a>1.缓冲区溢出的原因</h2><p>&emsp;&emsp;之前我们所编写的服务端与客户端的数据量都是很小的，且操作也不频繁，需要键入指令发送报文。</p>
<p>&emsp;&emsp;我们可以尝试在之前客户端代码的循环里，不断发送一种数据包，且把数据包的大小加大到1000字节，会发现很快服务端和客户端就会出现问题——要么是数据接收出现问题，要么是服务端或者客户端程序直接卡掉。这里出现问题的原因就是socket内核缓冲区溢出。</p>
<span id="more"></span>

<p>&emsp;&emsp;首先，send和recv函数并不是直接通过网卡操作。在使用send函数时，send函数首先把数据写入到<strong>发送缓冲区</strong>，随后通过网卡发出；在使用recv函数时，网卡首先把接收到的消息写入<strong>接收缓冲区</strong>，recv函数再从中copy数据。<strong>注意</strong>，上文中的两个缓冲区是存在于内核中的，并不是程序中自定义的缓冲区。</p>
<p>&emsp;&emsp;我们在之前的源码中，recv的逻辑是先接收包头，随后根据包头接收包体。而当网卡接收数据太多时，我们接收一个包头的时间，网卡可能就新接收了两个完整的数据包，这就导致内核接收缓冲区里的数据量是在不断增加的，最终导致接收缓冲区溢出，造成无法正常发送以及程序阻塞的问题。</p>
<p>&emsp;&emsp;举个例子，缓冲区就像一个浴缸，而我们是一个拿盆子舀水的人。我们之前先接收一个包头就相当于舀出一个包头那么多的水，随后再舀出包体那么多的水。舀了两次仅仅舀出一个报文那么多的水。如果浴缸放水的速度比较大的话，我们很容易就会处理不过来。最终造成浴缸溢出(缓冲区溢出)。</p>
<h2 id="2-缓冲区溢出的处理方法"><a href="#2-缓冲区溢出的处理方法" class="headerlink" title="2.缓冲区溢出的处理方法"></a>2.缓冲区溢出的处理方法</h2><p>&emsp;&emsp;接着看上文的例子，我们怎么能阻止浴缸(缓冲区)溢出呢？首先我们不大可能改变浴缸的大小，因为太过麻烦以及治标不治本，只要浴缸放水的时间够长，总会溢出。接着，舀水的速度我们也不好改变，因为一时半会是改不了的。那我们就只能改变舀水的次数和数量了。</p>
<p>&emsp;&emsp;如何改变舀水的数量和次数？我们可以一次舀出足够多的水，随后再从舀出的水中分出想要数量的水，这样浴缸溢出的可能性就大大减少了。</p>
<p>&emsp;&emsp;从代码层面来看上面的思路，只要我们程序内新建一个足够大的缓冲区，一次从内核缓冲区上recv足够的数据，就可以避免内核缓冲区溢出了。</p>
<ul>
<li>大概思路如下：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> _Recv_buf[<span class="number">4096</span>];</span><br><span class="line"><span class="type">int</span> DataRecv</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//接收客户端发送的数据 </span></span><br><span class="line">	<span class="type">int</span> recv_len = <span class="built_in">recv</span>(socket, _Recv_buf, <span class="number">4096</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(recv_len &lt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">while</span>(_Recv_buf内不为空)</span><br><span class="line">	&#123;</span><br><span class="line">		处理_Recv_buf内的数据</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
&emsp;&emsp;但是这样会出现新的问题，即粘包与分包问题，请看下文。</li>
</ul>
<h1 id="二、粘包与分包"><a href="#二、粘包与分包" class="headerlink" title="二、粘包与分包"></a>二、粘包与分包</h1><h2 id="1-粘包与分包的原因"><a href="#1-粘包与分包的原因" class="headerlink" title="1.粘包与分包的原因"></a>1.粘包与分包的原因</h2><p>&emsp;&emsp;上文中处理缓冲区溢出的思路是没有问题的，但是上文中的源码写法会存在问题。</p>
<p>&emsp;&emsp;我们一次接收那么多数据，其中数据的界限是没有限定的，比如上文中是想要一次接收4096个字节。假如缓冲区内有5个1000字节大小的数据包，我们这次接收4096字节，等于说接收的数据中有4.096个数据包，其中就包含了新的问题。</p>
<p>&emsp;&emsp;<strong>首先是粘包问题</strong>。即一次接收中含有多个数据包，这就导致数据包界限不清，粘在了一起。像上文中的4.096个包，接收端是不清楚的，接收端只知道有4096字节的数据，但是它不知道一个包是多大。所以我们可以通过包头来获取一个数据包的大小，由此来处理相应大小的数据以解决粘包问题。</p>
<p>&emsp;&emsp;<strong>接着是分包问题</strong>。即一次接收中含有不完整的包。例如上文中的4096个字节，其中包含了4个完整的包，和一个包的前96个字节。对此，我们只能处理前4个完整的数据包。那么问题来了，对于上文中的缓冲区，由于recv函数每次都会覆盖这个缓冲区，这就导致缓冲区内无法存放未处理的消息。对于这个问题，我们可以新建一个缓冲区，来存放未处理的消息，实现双缓冲，即可处理分包问题。</p>
<ul>
<li>TCP是面向数据流的协议，所以会出现粘包分包问题；UDP是面向消息的协议，每一个数据段都是一条消息，所以不会出现粘包分包问题。</li>
</ul>
<h2 id="2-粘包与分包的处理方法"><a href="#2-粘包与分包的处理方法" class="headerlink" title="2.粘包与分包的处理方法"></a>2.粘包与分包的处理方法</h2><h3 id="2-1客户端升级思路"><a href="#2-1客户端升级思路" class="headerlink" title="2.1客户端升级思路"></a>2.1客户端升级思路</h3><p>&emsp;&emsp;首先是新建两个缓冲区，一个用来存放recv到的数据，一个用来存放所有待处理数据。首先第一个缓冲区recv到数据，随后把第一个缓冲区内的数据copy到第二个缓冲区内，即可实现数据的存放。随后处理数据之类的还是先获取包头，随后根据包头处理包体数据。</p>
<ul>
<li>大致思路如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接收数据</span></span><br><span class="line"><span class="type">char</span> 接收缓冲区[<span class="number">4096</span>]</span><br><span class="line"><span class="type">char</span> 消息缓冲区[<span class="number">40960</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">RecvData</span><span class="params">(SOCKET temp_socket)</span><span class="comment">//处理数据 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="comment">//接收客户端发送的数据 </span></span><br><span class="line">	<span class="type">int</span> recv_len = <span class="built_in">recv</span>(temp_socket, 接收缓冲区, <span class="number">4096</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(recv_len &lt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;与服务器断开连接,任务结束\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="number">1.</span>将接收缓冲区的数据拷贝到消息缓冲区 </span><br><span class="line">	<span class="keyword">while</span>(<span class="number">2.</span>判断消息缓冲区的数据长度是否大于等于包头长度) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="number">3.</span>选出包头数据 <span class="comment">//解决粘包问题</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="number">4.</span>判断消息缓冲区内数据长度是否大于等于报文长度) <span class="comment">//解决少包问题 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="number">5.</span>响应数据 </span><br><span class="line">			<span class="number">6.</span>将处理过的消息移出消息缓冲区</span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2服务端升级思路"><a href="#2-2服务端升级思路" class="headerlink" title="2.2服务端升级思路"></a>2.2服务端升级思路</h3><p>&emsp;&emsp;与客户端整头思路相似，但是需要注意，服务端有多个连接，如果多个连接共用一个缓冲区会存在错误，所以每一个客户端连接都需要有自己的缓冲区。对此，我们可以新建一个客户端连接类，来存放每一个客户端的socket以及它的缓冲区。</p>
<ul>
<li>大致思路如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> 客户端连接</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="number">1.</span>获取<span class="built_in">socket</span>() </span><br><span class="line">	<span class="number">2.</span>获取缓冲区()</span><br><span class="line">	<span class="number">3.</span>获取缓冲区长度()</span><br><span class="line">	<span class="number">4.</span>设置缓冲区长度()</span><br><span class="line"><span class="keyword">private</span>:	</span><br><span class="line">	<span class="number">1.</span>socket</span><br><span class="line">	<span class="number">2.</span>缓冲区</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">std::vector&lt;客户端连接*&gt; _clients;<span class="comment">//储存客户端socket</span></span><br><span class="line"><span class="type">char</span> 接收缓冲区[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line"><span class="number">0.</span>此时前面OnRun函数里的判断过程也需要改变</span><br><span class="line"><span class="comment">//遍历所有socket 查看是否有待处理事件 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;_clients.<span class="built_in">size</span>(); ++n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(_clients[n]-&gt;获取<span class="built_in">socket</span>(),&amp;fdRead))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="number">-1</span> == <span class="built_in">RecvData</span>(_clients[n]))<span class="comment">//处理请求 客户端退出的话 </span></span><br><span class="line">		&#123;</span><br><span class="line">			std::vector&lt;客户端连接*&gt;::iterator iter = _clients.<span class="built_in">begin</span>()+n;<span class="comment">//找到退出客户端的地址</span></span><br><span class="line">			<span class="keyword">if</span>(iter != _clients.<span class="built_in">end</span>())<span class="comment">//如果是合理值</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">delete</span> _clients[n];</span><br><span class="line">				_clients.<span class="built_in">erase</span>(iter);<span class="comment">//移除</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">RecvData</span><span class="params">(客户端连接* client)</span><span class="comment">//处理数据 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="comment">//接收客户端发送的数据 </span></span><br><span class="line">	<span class="type">int</span> recv_len = <span class="built_in">recv</span>(client-&gt;获取<span class="built_in">socket</span>(), 接收缓冲区, <span class="number">4096</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(recv_len &lt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;与服务器断开连接,任务结束\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="number">1.</span>将接收缓冲区的数据拷贝到传入对象的消息缓冲区 client-&gt;获取缓冲区();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">2.</span>判断消息缓冲区的数据长度是否大于等于包头长度) client-&gt;获取缓冲区长度();</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="number">3.</span>选出包头数据 <span class="comment">//解决粘包问题</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="number">4.</span>判断消息缓冲区内数据长度是否大于等于报文长度) <span class="comment">//解决少包问题 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="number">5.</span>响应数据 </span><br><span class="line">			<span class="number">6.</span>将处理过的消息移出消息缓冲区 client-&gt;设置缓冲区长度();</span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、升级后的源码及其详细注释"><a href="#三、升级后的源码及其详细注释" class="headerlink" title="三、升级后的源码及其详细注释"></a>三、升级后的源码及其详细注释</h1><h2 id="1-客户端源码-TcpClient-hpp"><a href="#1-客户端源码-TcpClient-hpp" class="headerlink" title="1.客户端源码 TcpClient.hpp"></a>1.客户端源码 TcpClient.hpp</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TcpClient_hpp_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TcpClient_hpp_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;winSock2.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>) </span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SOCKET int</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> INVALID_SOCKET (SOCKET)(~0)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SOCKET_ERROR (-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">//枚举类型记录命令 </span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">cmd</span> </span><br><span class="line">&#123;</span><br><span class="line">	CMD_LOGIN,<span class="comment">//登录 </span></span><br><span class="line">	CMD_LOGINRESULT,<span class="comment">//登录结果 </span></span><br><span class="line">	CMD_LOGOUT,<span class="comment">//登出 </span></span><br><span class="line">	CMD_LOGOUTRESULT,<span class="comment">//登出结果 </span></span><br><span class="line">	CMD_NEW_USER_JOIN,<span class="comment">//新用户登入 </span></span><br><span class="line">	CMD_ERROR<span class="comment">//错误 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义数据包头 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DataHeader</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">short</span> cmd;<span class="comment">//命令</span></span><br><span class="line">	<span class="type">short</span> date_length;<span class="comment">//数据的长短	</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包1 登录 传输账号与密码</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Login</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Login</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGIN;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Login); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">	<span class="type">char</span> PassWord[<span class="number">32</span>];<span class="comment">//密码 </span></span><br><span class="line">	<span class="type">char</span> data[<span class="number">932</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包2 登录结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoginResult</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LoginResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGINRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LoginResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">	<span class="type">char</span> Data[<span class="number">992</span>];<span class="comment">//无意义数据 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包3 登出 传输用户名 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Logout</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Logout</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Logout); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">	<span class="type">char</span> data[<span class="number">964</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包4 登出结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LogoutResult</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LogoutResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUTRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LogoutResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">	<span class="type">char</span> data[<span class="number">992</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包5 新用户登入 传输通告 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NewUserJoin</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">NewUserJoin</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_NEW_USER_JOIN;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(NewUserJoin); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RECV_BUFFER_SIZE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TcpClient</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造 </span></span><br><span class="line">	<span class="built_in">TcpClient</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		_sock = INVALID_SOCKET;</span><br><span class="line">		<span class="comment">//缓冲区相关 </span></span><br><span class="line">		_Recv_buf = <span class="keyword">new</span> <span class="type">char</span>[RECV_BUFFER_SIZE];</span><br><span class="line">		_Msg_buf = <span class="keyword">new</span> <span class="type">char</span>[RECV_BUFFER_SIZE*<span class="number">10</span>];</span><br><span class="line">		_Len_buf = <span class="number">0</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构 </span></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">TcpClient</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span>[] _Recv_buf;</span><br><span class="line">		<span class="keyword">delete</span>[] _Msg_buf;</span><br><span class="line">		<span class="comment">//关闭socket </span></span><br><span class="line">		<span class="built_in">CloseSocket</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//初始化socket 返回1为正常 </span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">InitSocket</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">		<span class="comment">//启动windows socket 2,x环境 </span></span><br><span class="line">		WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>); </span><br><span class="line">		WSADATA dat;</span><br><span class="line">		<span class="keyword">if</span>(<span class="number">0</span> != <span class="built_in">WSAStartup</span>(ver,&amp;dat))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//-1为环境错误 </span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">		<span class="comment">//创建socket </span></span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET != _sock)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;&lt;Socket=%d&gt;关闭连接\n&quot;</span>,_sock); </span><br><span class="line">			<span class="built_in">CloseSocket</span>();<span class="comment">//如果之前有连接 就关闭连接 </span></span><br><span class="line">		&#125;</span><br><span class="line">		_sock = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,IPPROTO_TCP); </span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET == _sock)</span><br><span class="line">		&#123;   </span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//0为socket创建错误 </span></span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//连接服务器  返回1为成功 </span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Connect</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ip,<span class="type">unsigned</span> <span class="type">short</span> port)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//如果为无效套接字 则初始化 </span></span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET == _sock)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">InitSocket</span>(); </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//连接服务器</span></span><br><span class="line">	   	sockaddr_in _sin = &#123;&#125;;</span><br><span class="line">	   	_sin.sin_family = AF_INET;<span class="comment">//IPV4</span></span><br><span class="line">	   	_sin.sin_port = <span class="built_in">htons</span>(port);<span class="comment">//端口号 </span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">		_sin.sin_addr.S_un.S_addr =  <span class="built_in">inet_addr</span>(ip);<span class="comment">//IP </span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		_sin.sin_addr.s_addr =  <span class="built_in">inet_addr</span>(ip);<span class="comment">//IP </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">connect</span>(_sock,(sockaddr*)&amp;_sin,<span class="built_in">sizeof</span>(sockaddr_in)))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//连接失败 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//连接成功 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//关闭socket</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">CloseSocket</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET != _sock) </span><br><span class="line">		&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">			<span class="comment">//关闭socket</span></span><br><span class="line">			<span class="built_in">closesocket</span>(_sock); </span><br><span class="line">			<span class="comment">//清除windows socket 环境 </span></span><br><span class="line">			<span class="built_in">WSACleanup</span>(); </span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">			<span class="comment">//关闭socket/LINUX</span></span><br><span class="line">			<span class="built_in">close</span>(_sock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">			_sock = INVALID_SOCKET;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//查询是否有待处理消息 </span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">OnRun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">IsRun</span>())<span class="comment">//如果有连接则监听事件 </span></span><br><span class="line">		&#123;</span><br><span class="line">			fd_set _fdRead;<span class="comment">//建立集合 </span></span><br><span class="line">			<span class="built_in">FD_ZERO</span>(&amp;_fdRead);<span class="comment">//清空集合  </span></span><br><span class="line">			<span class="built_in">FD_SET</span>(_sock,&amp;_fdRead);<span class="comment">//放入集合 </span></span><br><span class="line">			timeval <span class="type">_t</span> = &#123;<span class="number">1</span>,<span class="number">0</span>&#125;;<span class="comment">//select最大响应时间 </span></span><br><span class="line">			<span class="comment">//新建seclect </span></span><br><span class="line">			<span class="type">int</span> _ret = <span class="built_in">select</span>(_sock<span class="number">+1</span>,&amp;_fdRead,<span class="literal">NULL</span>,<span class="literal">NULL</span>,&amp;<span class="type">_t</span>);</span><br><span class="line">			<span class="keyword">if</span>(_ret&lt;<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;seclect任务结束\n&quot;</span>);</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(_sock,&amp;_fdRead))<span class="comment">//获取是否有可读socket </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">FD_CLR</span>(_sock,&amp;_fdRead);<span class="comment">//清理计数器 </span></span><br><span class="line">				<span class="keyword">if</span>(<span class="number">-1</span> == <span class="built_in">RecvData</span>(_sock))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">CloseSocket</span>();</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;	</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//判断是否工作中 </span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">IsRun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _sock != INVALID_SOCKET; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//发送数据 </span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">SendData</span><span class="params">(DataHeader *_head)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">IsRun</span>() &amp;&amp; _head)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">send</span>(_sock,(<span class="type">const</span> <span class="type">char</span>*)_head,_head-&gt;date_length,<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//接收数据</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">RecvData</span><span class="params">(SOCKET temp_socket)</span><span class="comment">//处理数据 </span></span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		<span class="comment">//接收客户端发送的数据 </span></span><br><span class="line">		<span class="type">int</span> recv_len = <span class="built_in">recv</span>(temp_socket, _Recv_buf, RECV_BUFFER_SIZE, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(recv_len &lt;= <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;与服务器断开连接,任务结束\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="comment">//将接收缓冲区的数据拷贝到消息缓冲区 </span></span><br><span class="line">		<span class="built_in">memcpy</span>(_Msg_buf+_Len_buf, _Recv_buf, recv_len); </span><br><span class="line">		<span class="comment">//消息缓冲区的数据末尾后移 </span></span><br><span class="line">		_Len_buf += recv_len; </span><br><span class="line">		<span class="comment">//判断消息缓冲区的数据长度是否大于等于包头长度 </span></span><br><span class="line">		<span class="keyword">while</span>(_Len_buf &gt;= <span class="built_in">sizeof</span>(DataHeader))<span class="comment">//处理粘包问题 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//选出包头数据 </span></span><br><span class="line">			DataHeader* header = (DataHeader*)_Msg_buf; </span><br><span class="line">			<span class="comment">//判断消息缓冲区内数据长度是否大于等于报文长度 避免少包问题 </span></span><br><span class="line">			<span class="keyword">if</span>(_Len_buf &gt;= header-&gt;date_length)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//计算出消息缓冲区内剩余未处理数据的长度</span></span><br><span class="line">				<span class="type">int</span> size = _Len_buf - header-&gt;date_length; </span><br><span class="line">				<span class="comment">//响应数据 </span></span><br><span class="line">				<span class="built_in">NetMsg</span>(header);</span><br><span class="line">				<span class="comment">//将消息缓冲区剩余未处理的数据前移</span></span><br><span class="line">				<span class="built_in">memcpy</span>(_Msg_buf, _Msg_buf + header-&gt;date_length, size);</span><br><span class="line">				<span class="comment">//消息缓冲区的数据末尾前移</span></span><br><span class="line">				_Len_buf = size; </span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//消息缓冲区数据不足 </span></span><br><span class="line">				<span class="keyword">break</span>; </span><br><span class="line">			&#125; </span><br><span class="line">		&#125; </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//响应数据</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">NetMsg</span><span class="params">(DataHeader *_head)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;接收到包头，命令：%d，数据长度：%d\n&quot;</span>,_head-&gt;cmd,_head-&gt;date_length);</span><br><span class="line">		<span class="keyword">switch</span>(_head-&gt;cmd)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> CMD_LOGINRESULT:<span class="comment">//登录结果 接收登录包体 </span></span><br><span class="line">			&#123;</span><br><span class="line">				LoginResult *_result = (LoginResult*)_head; </span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;登录结果:%d\n&quot;</span>,_result-&gt;Result);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> CMD_LOGOUTRESULT:<span class="comment">//登出结果 接收登出包体 </span></span><br><span class="line">			&#123;</span><br><span class="line">				LogoutResult *_result = (LogoutResult*)_head; </span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;登录结果:%d\n&quot;</span>,_result-&gt;Result);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> CMD_NEW_USER_JOIN:<span class="comment">//新用户登录通知 </span></span><br><span class="line">			&#123;</span><br><span class="line">				NewUserJoin *_result = (NewUserJoin*)_head; </span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;用户:%s已登录\n&quot;</span>,_result-&gt;UserName);</span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> CMD_ERROR:<span class="comment">//错误 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;错误数据\n&quot;</span>); </span><br><span class="line">				<span class="built_in">getchar</span>();</span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;未知数据\n&quot;</span>); </span><br><span class="line">				<span class="built_in">getchar</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	SOCKET _sock;</span><br><span class="line">	<span class="comment">//缓冲区相关 </span></span><br><span class="line">	<span class="type">char</span> *_Recv_buf;<span class="comment">//接收缓冲区 </span></span><br><span class="line">	<span class="type">char</span> *_Msg_buf;<span class="comment">//消息缓冲区 </span></span><br><span class="line">	<span class="type">int</span> _Len_buf;<span class="comment">//缓冲区数据尾部变量 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="2-服务端源码-TcpServer-hpp"><a href="#2-服务端源码-TcpServer-hpp" class="headerlink" title="2.服务端源码 TcpServer.hpp"></a>2.服务端源码 TcpServer.hpp</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TcpServer_hpp_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TcpServer_hpp_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;winSock2.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//链接此动态链接库 windows特有 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span><span class="comment">//selcet</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span><span class="comment">//uni std</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SOCKET int</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> INVALID_SOCKET (SOCKET)(~0)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SOCKET_ERROR (-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">//枚举类型记录命令 </span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">cmd</span> </span><br><span class="line">&#123;</span><br><span class="line">	CMD_LOGIN,<span class="comment">//登录 </span></span><br><span class="line">	CMD_LOGINRESULT,<span class="comment">//登录结果 </span></span><br><span class="line">	CMD_LOGOUT,<span class="comment">//登出 </span></span><br><span class="line">	CMD_LOGOUTRESULT,<span class="comment">//登出结果 </span></span><br><span class="line">	CMD_NEW_USER_JOIN,<span class="comment">//新用户登入 </span></span><br><span class="line">	CMD_ERROR<span class="comment">//错误 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义数据包头 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DataHeader</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">short</span> cmd;<span class="comment">//命令</span></span><br><span class="line">	<span class="type">short</span> date_length;<span class="comment">//数据的长短	</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包1 登录 传输账号与密码</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Login</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Login</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGIN;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Login); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">	<span class="type">char</span> PassWord[<span class="number">32</span>];<span class="comment">//密码 </span></span><br><span class="line">	<span class="type">char</span> data[<span class="number">932</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包2 登录结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoginResult</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LoginResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGINRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LoginResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">	<span class="type">char</span> Data[<span class="number">992</span>];<span class="comment">//无意义数据 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包3 登出 传输用户名 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Logout</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Logout</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Logout); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">	<span class="type">char</span> data[<span class="number">964</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包4 登出结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LogoutResult</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LogoutResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUTRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LogoutResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">	<span class="type">char</span> data[<span class="number">992</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包5 新用户登入 传输通告 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NewUserJoin</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">NewUserJoin</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_NEW_USER_JOIN;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(NewUserJoin); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RECV_BUFFER_SIZE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClientSocket</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造 </span></span><br><span class="line">	<span class="built_in">ClientSocket</span>(SOCKET sockfd = INVALID_SOCKET)</span><br><span class="line">	&#123;</span><br><span class="line">		_sockfd = sockfd;</span><br><span class="line">		<span class="comment">//缓冲区相关 </span></span><br><span class="line">		_Msg_buf = <span class="keyword">new</span> <span class="type">char</span>[RECV_BUFFER_SIZE*<span class="number">10</span>];</span><br><span class="line">		_Len_buf = <span class="number">0</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构 </span></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">ClientSocket</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span>[] _Msg_buf;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//获取socket </span></span><br><span class="line">	<span class="function">SOCKET <span class="title">GetSockfd</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _sockfd;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//获取缓冲区 </span></span><br><span class="line">	<span class="function"><span class="type">char</span>* <span class="title">MsgBuf</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _Msg_buf;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//获取缓冲区尾部变量 </span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetLen</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _Len_buf;	</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//设置缓冲区尾巴变量</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetLen</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		_Len_buf = len;</span><br><span class="line">	&#125; </span><br><span class="line">		</span><br><span class="line"><span class="keyword">private</span>:	</span><br><span class="line">	SOCKET _sockfd;</span><br><span class="line">	<span class="comment">//缓冲区相关 </span></span><br><span class="line">	<span class="type">char</span> *_Msg_buf;<span class="comment">//消息缓冲区 </span></span><br><span class="line">	<span class="type">int</span> _Len_buf;<span class="comment">//缓冲区数据尾部变量</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TcpServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造 </span></span><br><span class="line">	<span class="built_in">TcpServer</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		_sock = INVALID_SOCKET; </span><br><span class="line">		<span class="comment">//缓冲区相关 </span></span><br><span class="line">		_Recv_buf = <span class="keyword">new</span> <span class="type">char</span>[RECV_BUFFER_SIZE];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//析构 </span></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">TcpServer</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span>[] _Recv_buf;</span><br><span class="line">		<span class="comment">//关闭socket </span></span><br><span class="line">		<span class="built_in">CloseSocket</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//初始化socket 返回1为正常 </span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">InitSocket</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">		<span class="comment">//启动windows socket 2,x环境 </span></span><br><span class="line">		WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>); </span><br><span class="line">		WSADATA dat;</span><br><span class="line">		<span class="keyword">if</span>(<span class="number">0</span> != <span class="built_in">WSAStartup</span>(ver,&amp;dat))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//-1为环境错误 </span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">		<span class="comment">//创建socket </span></span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET != _sock)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;&lt;Socket=%d&gt;关闭连接\n&quot;</span>,_sock); </span><br><span class="line">			<span class="built_in">CloseSocket</span>();<span class="comment">//如果之前有连接 就关闭连接 </span></span><br><span class="line">		&#125;</span><br><span class="line">		_sock = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,IPPROTO_TCP); </span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET == _sock)</span><br><span class="line">		&#123;   </span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//0为socket创建错误 </span></span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//绑定IP/端口</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Bind</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* ip,<span class="type">unsigned</span> <span class="type">short</span> port)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//如果为无效套接字 则初始化 </span></span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET == _sock)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">InitSocket</span>(); </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//绑定网络端口和IP地址 </span></span><br><span class="line">		sockaddr_in _myaddr = &#123;&#125;; </span><br><span class="line">		_myaddr.sin_family = AF_INET;<span class="comment">//IPV4</span></span><br><span class="line">		_myaddr.sin_port = <span class="built_in">htons</span>(port);<span class="comment">//端口</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">		<span class="keyword">if</span>(ip)<span class="comment">//ip为空则监听所有网卡 </span></span><br><span class="line">		&#123;</span><br><span class="line">			_myaddr.sin_addr.S_un.S_addr = <span class="built_in">inet_addr</span>(ip);<span class="comment">//IP</span></span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			_myaddr.sin_addr.S_un.S_addr = INADDR_ANY;<span class="comment">//IP</span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		<span class="keyword">if</span>(ip)<span class="comment">//ip为空则监听所有网卡</span></span><br><span class="line">		&#123;</span><br><span class="line">			_myaddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(ip);<span class="comment">//IP </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			_myaddr.sin_addr.s_addr = INADDR_ANY;<span class="comment">//IP </span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">bind</span>(_sock,(sockaddr*)&amp;_myaddr,<span class="built_in">sizeof</span>(sockaddr_in)))<span class="comment">//socket (强制转换)sockaddr结构体 结构体大小 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;绑定失败\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;绑定成功\n绑定端口为%d\n&quot;</span>,port);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//监听端口</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Listen</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//如果为无效套接字 则提示 </span></span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET == _sock)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;请先初始化套接字并绑定IP端口\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//监听网络端口</span></span><br><span class="line">		<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">listen</span>(_sock,n))<span class="comment">//最大连接队列 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;监听失败\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;监听成功\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//接受连接</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Accept</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//等待接收客户端连接</span></span><br><span class="line">		sockaddr_in clientAddr = &#123;&#125;;<span class="comment">//新建sockadd结构体接收客户端数据 </span></span><br><span class="line">		<span class="type">int</span> addr_len = <span class="built_in">sizeof</span>(sockaddr_in);<span class="comment">//获取sockadd结构体长度 </span></span><br><span class="line">		SOCKET temp_socket = INVALID_SOCKET;<span class="comment">//声明客户端套接字 </span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32	</span></span><br><span class="line">		temp_socket = <span class="built_in">accept</span>(_sock,(sockaddr*)&amp;clientAddr,&amp;addr_len);<span class="comment">//自身套接字 客户端结构体 结构体大小 	</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		temp_socket = <span class="built_in">accept</span>(_sock,(sockaddr*)&amp;clientAddr,(<span class="type">socklen_t</span>*)&amp;addr_len);<span class="comment">//自身套接字 客户端结构体 结构体大小 </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET == temp_socket)<span class="comment">//接收失败 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;&lt;Socket=%d&gt;错误,接受到无效客户端SOCKET\n&quot;</span>,temp_socket);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123; </span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;新客户端加入\nIP地址为：%s \n&quot;</span>, <span class="built_in">inet_ntoa</span>(clientAddr.sin_addr));  </span><br><span class="line">			<span class="comment">//群发所有客户端 通知新用户登录 </span></span><br><span class="line">			NewUserJoin *user_join = <span class="keyword">new</span> <span class="built_in">NewUserJoin</span>(); </span><br><span class="line">			<span class="built_in">strcpy</span>(user_join-&gt;UserName,<span class="built_in">inet_ntoa</span>(clientAddr.sin_addr));</span><br><span class="line">			<span class="built_in">SendDataToAll</span>(user_join);</span><br><span class="line">			<span class="comment">//将新的客户端加入动态数组</span></span><br><span class="line">			_clients.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">ClientSocket</span>(temp_socket));</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//关闭socket </span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">CloseSocket</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET != _sock) </span><br><span class="line">		&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">			<span class="comment">//关闭客户端socket</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;_clients.<span class="built_in">size</span>(); ++n)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">closesocket</span>(_clients[n]-&gt;<span class="built_in">GetSockfd</span>());</span><br><span class="line">				<span class="keyword">delete</span> _clients[n];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//关闭socket</span></span><br><span class="line">			<span class="built_in">closesocket</span>(_sock); </span><br><span class="line">			<span class="comment">//清除windows socket 环境 </span></span><br><span class="line">			<span class="built_in">WSACleanup</span>(); </span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">			<span class="comment">//关闭客户端socket</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;_clients.<span class="built_in">size</span>(); ++n)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">close</span>(_clients[n]-&gt;<span class="built_in">GetSockfd</span>());</span><br><span class="line">				<span class="keyword">delete</span> _clients[n];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//关闭socket/LINUX</span></span><br><span class="line">			<span class="built_in">close</span>(_sock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">			_sock = INVALID_SOCKET;</span><br><span class="line">			_clients.<span class="built_in">clear</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//查询是否有待处理消息 </span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">OnRun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">IsRun</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			fd_set fdRead;<span class="comment">//建立集合 </span></span><br><span class="line">			fd_set fdWrite;</span><br><span class="line">			fd_set fdExcept;</span><br><span class="line">			<span class="built_in">FD_ZERO</span>(&amp;fdRead);<span class="comment">//清空集合 </span></span><br><span class="line">			<span class="built_in">FD_ZERO</span>(&amp;fdWrite); </span><br><span class="line">			<span class="built_in">FD_ZERO</span>(&amp;fdExcept); </span><br><span class="line">			<span class="built_in">FD_SET</span>(_sock,&amp;fdRead);<span class="comment">//放入集合 </span></span><br><span class="line">			<span class="built_in">FD_SET</span>(_sock,&amp;fdWrite); </span><br><span class="line">			<span class="built_in">FD_SET</span>(_sock,&amp;fdExcept);</span><br><span class="line">			timeval <span class="type">s_t</span> = &#123;<span class="number">2</span>,<span class="number">0</span>&#125;;<span class="comment">//select最大响应时间 </span></span><br><span class="line">			SOCKET maxSock = _sock;<span class="comment">//最大socket </span></span><br><span class="line">			<span class="comment">//把连接的客户端 放入read集合 </span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> n=_clients.<span class="built_in">size</span>()<span class="number">-1</span>; n&gt;=<span class="number">0</span>; --n)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">FD_SET</span>(_clients[n]-&gt;<span class="built_in">GetSockfd</span>(),&amp;fdRead);</span><br><span class="line">				<span class="keyword">if</span>(maxSock &lt; _clients[n]-&gt;<span class="built_in">GetSockfd</span>())</span><br><span class="line">				&#123;</span><br><span class="line">					maxSock = _clients[n]-&gt;<span class="built_in">GetSockfd</span>();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//select函数筛选select </span></span><br><span class="line">			<span class="type">int</span> ret = <span class="built_in">select</span>(maxSock<span class="number">+1</span>,&amp;fdRead,&amp;fdWrite,&amp;fdExcept,&amp;<span class="type">s_t</span>); </span><br><span class="line">			<span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;select任务结束\n&quot;</span>);</span><br><span class="line">				<span class="built_in">CloseSocket</span>();</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(_sock,&amp;fdRead))<span class="comment">//获取是否有新socket连接 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">FD_CLR</span>(_sock,&amp;fdRead);<span class="comment">//清理</span></span><br><span class="line">				<span class="built_in">Accept</span>();<span class="comment">//连接 </span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//遍历所有socket 查看是否有待处理事件 </span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;_clients.<span class="built_in">size</span>(); ++n)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(_clients[n]-&gt;<span class="built_in">GetSockfd</span>(),&amp;fdRead))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(<span class="number">-1</span> == <span class="built_in">RecvData</span>(_clients[n]))<span class="comment">//处理请求 客户端退出的话 </span></span><br><span class="line">					&#123;</span><br><span class="line">						std::vector&lt;ClientSocket*&gt;::iterator iter = _clients.<span class="built_in">begin</span>()+n;<span class="comment">//找到退出客户端的地址</span></span><br><span class="line">						<span class="keyword">if</span>(iter != _clients.<span class="built_in">end</span>())<span class="comment">//如果是合理值</span></span><br><span class="line">						&#123;</span><br><span class="line">							<span class="keyword">delete</span> _clients[n];</span><br><span class="line">							_clients.<span class="built_in">erase</span>(iter);<span class="comment">//移除</span></span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//printf(&quot;空闲时间处理其他业务\n&quot;);</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//判断是否工作中 </span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">IsRun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _sock != INVALID_SOCKET; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//发送数据 </span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">SendData</span><span class="params">(DataHeader *head,SOCKET temp_socket)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">IsRun</span>() &amp;&amp; head)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">send</span>(temp_socket,(<span class="type">const</span> <span class="type">char</span>*)head,head-&gt;date_length,<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//向所有人发送数据</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SendDataToAll</span><span class="params">(DataHeader *head)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>;n&lt;_clients.<span class="built_in">size</span>();++n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">SendData</span>(head, _clients[n]-&gt;<span class="built_in">GetSockfd</span>());	</span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//接收数据</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">RecvData</span><span class="params">(ClientSocket *t_client)</span><span class="comment">//处理数据 </span></span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		<span class="comment">//接收客户端发送的数据  </span></span><br><span class="line">		<span class="type">int</span> buf_len = <span class="built_in">recv</span>(t_client-&gt;<span class="built_in">GetSockfd</span>(), _Recv_buf, RECV_BUFFER_SIZE, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(buf_len&lt;=<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;客户端已退出\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125; </span><br><span class="line">		</span><br><span class="line">		<span class="comment">//将接收缓冲区的数据拷贝到消息缓冲区 </span></span><br><span class="line">		<span class="built_in">memcpy</span>(t_client-&gt;<span class="built_in">MsgBuf</span>() + t_client-&gt;<span class="built_in">GetLen</span>(), _Recv_buf, buf_len); </span><br><span class="line">		<span class="comment">//消息缓冲区的数据末尾后移 </span></span><br><span class="line">		t_client-&gt;<span class="built_in">SetLen</span>(t_client-&gt;<span class="built_in">GetLen</span>() + buf_len);</span><br><span class="line">		<span class="comment">//判断消息缓冲区的数据长度是否大于等于包头长度 </span></span><br><span class="line">		<span class="keyword">while</span>(t_client-&gt;<span class="built_in">GetLen</span>() &gt;= <span class="built_in">sizeof</span>(DataHeader))<span class="comment">//处理粘包问题 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//选出包头数据 </span></span><br><span class="line">			DataHeader* header = (DataHeader*)t_client-&gt;<span class="built_in">MsgBuf</span>(); </span><br><span class="line">			<span class="comment">//判断消息缓冲区内数据长度是否大于等于报文长度 避免少包问题 </span></span><br><span class="line">			<span class="keyword">if</span>(t_client-&gt;<span class="built_in">GetLen</span>() &gt;= header-&gt;date_length)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//计算出消息缓冲区内剩余未处理数据的长度</span></span><br><span class="line">				<span class="type">int</span> size = t_client-&gt;<span class="built_in">GetLen</span>() - header-&gt;date_length; </span><br><span class="line">				<span class="comment">//响应数据 </span></span><br><span class="line">				<span class="built_in">NetMsg</span>(header,t_client-&gt;<span class="built_in">GetSockfd</span>());</span><br><span class="line">				<span class="comment">//将消息缓冲区剩余未处理的数据前移</span></span><br><span class="line">				<span class="built_in">memcpy</span>(t_client-&gt;<span class="built_in">MsgBuf</span>(), t_client-&gt;<span class="built_in">MsgBuf</span>() + header-&gt;date_length, size);</span><br><span class="line">				<span class="comment">//消息缓冲区的数据末尾前移</span></span><br><span class="line">				t_client-&gt;<span class="built_in">SetLen</span>(size); </span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//消息缓冲区数据不足 </span></span><br><span class="line">				<span class="keyword">break</span>; </span><br><span class="line">			&#125; </span><br><span class="line">		&#125;  </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//响应数据</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">NetMsg</span><span class="params">(DataHeader *head,SOCKET temp_socket)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	 	<span class="built_in">printf</span>(<span class="string">&quot;接收到包头，命令：%d，数据长度：%d\n&quot;</span>,head-&gt;cmd,head-&gt;date_length);</span><br><span class="line">		<span class="keyword">switch</span>(head-&gt;cmd)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> CMD_LOGIN:<span class="comment">//登录 接收登录包体 </span></span><br><span class="line">			&#123;</span><br><span class="line">				Login *login = (Login*)head;</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				进行判断操作 </span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				<span class="comment">//printf(&quot;%s已登录\n密码：%s\n&quot;,login-&gt;UserName,login-&gt;PassWord); </span></span><br><span class="line">				LoginResult *result = <span class="keyword">new</span> LoginResult;	</span><br><span class="line">				result-&gt;Result = <span class="number">1</span>;</span><br><span class="line">				<span class="built_in">SendData</span>(result,temp_socket);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> CMD_LOGOUT:<span class="comment">//登出 接收登出包体 </span></span><br><span class="line">			&#123;</span><br><span class="line">				Logout *logout = (Logout*)head;</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				进行判断操作 </span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				<span class="comment">//printf(&quot;%s已登出\n&quot;,logout-&gt;UserName); </span></span><br><span class="line">				LogoutResult *result = <span class="keyword">new</span> <span class="built_in">LogoutResult</span>();</span><br><span class="line">				result-&gt;Result = <span class="number">1</span>;</span><br><span class="line">				<span class="built_in">SendData</span>(result,temp_socket);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:<span class="comment">//错误 </span></span><br><span class="line">			&#123;</span><br><span class="line">				head-&gt;cmd = CMD_ERROR; </span><br><span class="line">				head-&gt;date_length = <span class="number">0</span>; </span><br><span class="line">				<span class="built_in">SendData</span>(head,temp_socket); </span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	 </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	SOCKET _sock; </span><br><span class="line">	std::vector&lt;ClientSocket*&gt; _clients;<span class="comment">//储存客户端</span></span><br><span class="line">	<span class="comment">//缓冲区相关 </span></span><br><span class="line">	<span class="type">char</span> *_Recv_buf;<span class="comment">//接收缓冲区 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>KeepAlive小项目 基于Qt/C++实现后台自动提醒休息</title>
    <url>/2021/01/29/20210129_KeepAlive%E5%B0%8F%E9%A1%B9%E7%9B%AE%E5%9F%BA%E4%BA%8EQt-C++%E5%AE%9E%E7%8E%B0%E5%90%8E%E5%8F%B0%E8%87%AA%E5%8A%A8%E6%8F%90%E9%86%92%E4%BC%91%E6%81%AF/</url>
    <content><![CDATA[<p>&emsp;&emsp;前两天在blink上发的思路，花了一天时间给实现了 。不得不说，好久没写Qt程序，手生了不少，要不应该可以更有效率的。</p>
<h1 id="一、功能"><a href="#一、功能" class="headerlink" title="一、功能"></a>一、功能</h1><p>主要实现以下功能：</p>
<ul>
<li>显示当前系统时间</li>
<li>给定一个定期提醒时间间隔，显示离提醒还有多久</li>
<li>显示程序运行以来经过的时间</li>
<li>可最小化到托盘，实现后台运行</li>
<li>当达到提醒时间间隔后，弹窗提醒</li>
</ul>
<span id="more"></span>

<p>辅助功能：</p>
<ul>
<li>可手动输入，调整时间间隔</li>
<li>可自动创建桌面快捷方式</li>
<li>关于</li>
</ul>
<h1 id="二、详细介绍"><a href="#二、详细介绍" class="headerlink" title="二、详细介绍"></a>二、详细介绍</h1><p><strong>程序主界面</strong>（下图），可见有三个菜单按钮<br><img src="/images/2021-01-29/1.jpg" alt="程序主界面"></p>
<ul>
<li><strong>在点击程序右上角退出键后</strong>，程序会进入托盘最小化，在后台运行。（如下图）<br><img src="/images/2021-01-29/2.jpg" alt="2"><br>同时会弹出通知。<br><img src="/images/2021-01-29/3.jpg" alt="在这里插入图片描述"></li>
<li>此时左键单击托盘图标，弹出提示提醒时间。<br><img src="/images/2021-01-29/4.jpg" alt="在这里插入图片描述"></li>
<li>左键双击，即可显示主窗口。</li>
<li>鼠标右键单击，显示菜单，可令程序退出。</li>
</ul>
<p><strong>第一个菜单</strong>点开后分别为：创建快捷方式、设置相关参数、退出。</p>
<ul>
<li><p><strong>创建快捷方式</strong> 点击后弹窗，点击确定后随即在桌面建立快捷方式。（如下图）<br><img src="/images/2021-01-29/5.jpg" alt="1">  <img src="/images/2021-01-29/6.jpg" alt="在这里插入图片描述"></p>
</li>
<li><p><strong>设置相关参数</strong> 点击后弹窗，可以修改时间间隔参数，范围为1~86400秒。（如下图）<br><img src="/images/2021-01-29/7.jpg" alt="设置相关参数"><br>输入不正确值后会进行提醒。（如下图）<br><img src="/images/2021-01-29/8.jpg" alt="2"><br>当输入正确值后，计时会重置。</p>
</li>
<li><p><strong>退出</strong>，点击退出后，程序彻底退出，不会进入托盘最小化。</p>
</li>
</ul>
<p>第三个菜单内容为显示切换，点击后即可进行切换操作</p>
<ul>
<li>当前系统时间<br><img src="/images/2021-01-29/9.jpg" alt="1"></li>
<li>提醒时间倒计时<br><img src="/images/2021-01-29/10.jpg" alt="在这里插入图片描述"></li>
<li>系统(软件)开启时间<br><img src="/images/2021-01-29/11.jpg" alt="在这里插入图片描述"></li>
</ul>
<p>当倒计时为0时，显示窗口进行提醒。<br><img src="/images/2021-01-29/12.jpg" alt="在这里插入图片描述"></p>
<h1 id="三、源码下载"><a href="#三、源码下载" class="headerlink" title="三、源码下载"></a>三、源码下载</h1><p><a href="https://download.csdn.net/download/qq_45698148/14956361">点我下载</a></p>
<h1 id="四、可执行文件下载"><a href="#四、可执行文件下载" class="headerlink" title="四、可执行文件下载"></a>四、可执行文件下载</h1><p><a href="https://wws.lanzoui.com/iN4jGl1q6ji">点我下载</a> 密码：6eo1</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习记录：多线程相关</title>
    <url>/2021/01/31/20210131_C++%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>&emsp;&emsp;之前学过一点C语言多线程方面的内容(<code>pthread.h</code>)，但是仅仅是会用，对多线程的实现原理什么的基本上算是不了解。接下来，我的网络编程学习要进一步对代码进行优化，其中肯定少不了对多线程的运用，所以在进行下一步之前，先系统的学习一下多线程。<br>&emsp;&emsp;本篇学习记录使用的语言为C++，调用的线程库为C++11里的<code>std::thread</code>库。</p>
<span id="more"></span>

<h1 id="零、基本概念"><a href="#零、基本概念" class="headerlink" title="零、基本概念"></a>零、基本概念</h1><p>&emsp;&emsp;一个进程可以有多个线程，而一个线程只能属于一个进程。</p>
<p>&emsp;&emsp;单核CPU的多线程执行为每条线程代码执行一段时间后进行切换，实际还是为同时进行一条线程，因为切换的速度很快，给人一种同时进行的错觉；而多核CPU的多线程执行为同时进行多条线程，当线程数量大于核数量时，也会进行线程的切换，保证线程的进行。</p>
<p>&emsp;&emsp;多线程的执行是抢占式的，即多条线程下，没有运行顺序的规律，</p>
<h1 id="一、基本线程创建-thread"><a href="#一、基本线程创建-thread" class="headerlink" title="一、基本线程创建 thread"></a>一、基本线程创建 <code>thread</code></h1><p>如下所示，新建一个thread对象，构造函数传参第一个为线程执行函数，随后为执行函数的传参。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">thread *t1 = <span class="keyword">new</span> <span class="built_in">thread</span>(work,<span class="number">1111</span>);  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>;n&lt;a;n++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如下所示，新建一个thread数组，构造函数传参第一个为线程执行函数，随后为执行函数的传参。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">thread *t[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>;n&lt;<span class="number">4</span>;n++)</span><br><span class="line">&#123;</span><br><span class="line">	t[n] = <span class="keyword">new</span> <span class="built_in">thread</span>(work,n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>;n&lt;a;n++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="二、等待-分离-join-detach"><a href="#二、等待-分离-join-detach" class="headerlink" title="二、等待&#x2F;分离 join/detach"></a>二、等待&#x2F;分离 <code>join/detach</code></h1><p>&emsp;&emsp;join是在main函数中等待线程执行完才继续执行main函数，detach则是把该线程分离出来，不管这个线程执行得怎样，往下继续执行main函数。</p>
<ul>
<li>join操作会等待线程执行完毕，然后回收该线程资源；detach操作则不会等待线程完成，线程资源的回收由init进程完成。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">thread *t[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>;n&lt;<span class="number">4</span>;n++)</span><br><span class="line">&#123;</span><br><span class="line">	t[n] = <span class="keyword">new</span> <span class="built_in">thread</span>(work,n);</span><br><span class="line">	t[n]-&gt;<span class="built_in">detach</span>();<span class="comment">//线程分离</span></span><br><span class="line">	t[n]-&gt;<span class="built_in">join</span>();<span class="comment">//线程不分离</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、锁-lock-unlock"><a href="#三、锁-lock-unlock" class="headerlink" title="三、锁 lock/unlock"></a>三、锁 <code>lock/unlock</code></h1><p>&emsp;&emsp;由于线程的执行是抢占式的，且变量资源等是共享的，对于多条线程同时执行的情况下，可能对同一段内容同时执行，其中涉及到的变量操作等就会产生错误。类似同时对一个变量进行运算操作，由于赋值前的值不同，结果也就不同，导致数据出现问题。此时就可以使用锁的操作防止此类错误发生。</p>
<ul>
<li>上锁的区域同时只能被一条线程执行，由此来解决同时执行造成错误的问题。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span><span class="comment">//锁的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">mutex m;<span class="comment">//锁的变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>;n&lt;<span class="number">4</span>;n++)</span><br><span class="line">	&#123;</span><br><span class="line">		m.<span class="built_in">lock</span>();<span class="comment">//临界区域 开始 锁掉相关区域 避免同时调用printf操作导致打印混乱</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br><span class="line">		m.<span class="built_in">unlock</span>();<span class="comment">//临界区域 结束 解锁</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
</ul>
<p>&emsp;&emsp;但是不停的上锁和解锁很容易忘记解锁，就会出现该段代码无法被执行，导致程序出现问题，且不会报错。为了避免这种情况，我们可以使用自解锁。自解锁会自动对所处区间的代码进行上锁和解锁操作，从而防止忘解锁的情况发生。</p>
<ul>
<li>自解锁的大致原理其实就是构造器进行上锁，析构器进行解锁…<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span><span class="comment">//锁的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">mutex m;<span class="comment">//锁的变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>;n&lt;<span class="number">4</span>;n++)</span><br><span class="line">	&#123;</span><br><span class="line">		lock_guard&lt;mutex&gt;<span class="built_in">lock1</span>(m); <span class="comment">//自解锁</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="四、原子操作-atomic"><a href="#四、原子操作-atomic" class="headerlink" title="四、原子操作 atomic"></a>四、原子操作 <code>atomic</code></h1><p>&emsp;&emsp;频繁的上锁解锁操作会非常耗时，如果上锁区域执行的代码很少的话会非常不划算。如果我们在多线程中需要对变量操作的话，频繁的给变量操作区域上下锁性价比很低，此时我们可以使用<strong>原子变量</strong>。</p>
<ul>
<li>原子变量同时只能被一条线程操作，相比读写锁，速度快了不止一个量级。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;atomic&gt;</span><span class="comment">//原子操作</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">atomic_int <span class="title">count</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">//原子变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>;n&lt;<span class="number">2</span>;n++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;other thread:%d\n&quot;</span>,a);</span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	thread *t[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>;n&lt;<span class="number">4</span>;n++)</span><br><span class="line">	&#123;</span><br><span class="line">		t[n] = <span class="keyword">new</span> <span class="built_in">thread</span>(work,n);</span><br><span class="line">		t[n]-&gt;<span class="built_in">join</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>;n&lt;<span class="number">2</span>;n++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;main thread\n&quot;</span>);</span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;count;</span><br><span class="line">		<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++标准库学习</tag>
      </tags>
  </entry>
  <entry>
    <title>C++网络编程学习：对socket select网络模型的优化</title>
    <url>/2021/02/20/20210220_C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%AF%B9socket%20select%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<ul>
<li>使用的语言为C&#x2F;C++</li>
<li>源码支持的平台为：Windows &#x2F; Linux</li>
<li>东西不多，简单记录一下，今后可能会补充</li>
</ul>
<h1 id="零、思路与流程"><a href="#零、思路与流程" class="headerlink" title="零、思路与流程"></a>零、思路与流程</h1><p>select网络模型的大概流程如下：<br>1.获取一个至三个<code>fd_set</code>集合，获取一个<code>timeval</code><br>2.<code>select</code>函数对<code>fd_set</code>集合进行选择筛选<br>3.<code>FD_ISSET</code>函数依据<code>fd_set</code>集合遍历查找待处理事件</p>
<span id="more"></span>

<p><a href="&emsp;https://blog.csdn.net/qq_45698148/article/details/113061122">select相关详细内容点我</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">WINSOCK_API_LINKAGE <span class="type">int</span> WSAAPI <span class="title">select</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="type">int</span> nfds,<span class="comment">//是指待监听集合里的范围 即待监听数量最大值+1</span></span></span></span><br><span class="line"><span class="params"><span class="function">		fd_set *readfds,<span class="comment">//待监听的可读文件集合 </span></span></span></span><br><span class="line"><span class="params"><span class="function">		fd_set *writefds,<span class="comment">//待监听的可写文件集合  </span></span></span></span><br><span class="line"><span class="params"><span class="function">		fd_set *exceptfds,<span class="comment">//待监听的异常文件集合  </span></span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="type">const</span> PTIMEVAL timeout)</span></span>;<span class="comment">//超时设置 传入NULL为阻塞模式 传入timeval结构体为非阻塞模式</span></span><br><span class="line"></span><br><span class="line">	返回值为满足条件的待监听socket数量和，如果出错返回<span class="number">-1</span>，如果超时返回<span class="number">0</span>。</span><br></pre></td></tr></table></figure>
<h1 id="一、对fd-set的优化"><a href="#一、对fd-set的优化" class="headerlink" title="一、对fd_set的优化"></a>一、对<code>fd_set</code>的优化</h1><p>&emsp;&emsp;首先，我们可以对<code>fd_set</code>的相关操作进行优化。<br>&emsp;&emsp;之前，我们每进行一次<code>select</code>操作，都要使用循环把所有的已连接socket放到<code>fd_set</code>集合中，随后进行选择操作。但是当连接数很大、select操作频繁时，不断的新建<code>fd_set</code>并用循环放入socket，很明显会大大增大系统的消耗。<br>&emsp;&emsp;由于<code>fd_set</code>集合中一定存放的是当前所有的socket，由此，我们可以建立两个<code>fd_set</code>集合与一个<code>bool</code>变量。<code>bool</code>变量用来表示socket的组成是否发生了变化，当有客户端加入或断开时，该变量为true，否则为false。<br>&emsp;&emsp;我们使用一个<code>fd_set</code>集合储存”老的”socket集合，当socket集合没有发生变化时，我们另一个新<code>fd_set</code>集合直接使用<code>memcpy</code>函数复制老集合中的内容，从而避免从头循环放入。当socket集合发生变化时，新集合直接循环从头录入，随后老集合使用<code>memcpy</code>函数把新集合内的内容复制过去，方便下一次使用。<br>&emsp;&emsp;这样，我们即可大大减少关于<code>fd_set</code>集合初始化的消耗。</p>
<h1 id="二、对select函数的优化"><a href="#二、对select函数的优化" class="headerlink" title="二、对select函数的优化"></a>二、对<code>select</code>函数的优化</h1><p>&emsp;&emsp;当前我的代码只对read可读集合进行操作，并没有write可写集合与except异常集合的操作，所以我的select目前第三、第四个参数都传了空。这样可以增加一点select的效率。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">select</span>(_sock<span class="number">+1</span>,&amp;fdRead,<span class="number">0</span>,<span class="number">0</span>,&amp;<span class="type">s_t</span>); </span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;其余因为select函数被封装了，目前就我的水平来言应该没法做进一步的优化，可能以后会有吧。</p>
<h1 id="三、对FD-ISSET的优化"><a href="#三、对FD-ISSET的优化" class="headerlink" title="三、对FD_ISSET的优化"></a>三、对<code>FD_ISSET</code>的优化</h1><p>&emsp;&emsp;这是select架构里吃资源的大头，当socket连接数很大时，显而易见的是这种O(N^2)的查询方法会极大的消耗资源。对此我们可以引入map加快查找操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::map&lt;socket,Client&gt; _clients;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;socket当键，客户端对象当值。根据select处理后的<code>fd_set</code>集合内的socket进行查找。效率提高为O(lgN)。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++网络编程学习：服务端多线程分离业务处理高负载</title>
    <url>/2021/02/07/20210207_C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%86%E7%A6%BB%E4%B8%9A%E5%8A%A1%E5%A4%84%E7%90%86%E9%AB%98%E8%B4%9F%E8%BD%BD/</url>
    <content><![CDATA[<ul>
<li>使用的语言为C&#x2F;C++</li>
<li>源码支持的平台为：Windows &#x2F; Linux</li>
</ul>
<h1 id="一、思路与准备"><a href="#一、思路与准备" class="headerlink" title="一、思路与准备"></a>一、思路与准备</h1><p>之前的服务端思路大概是如下的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>建立socket</span><br><span class="line"><span class="number">2.</span>绑定端口IP</span><br><span class="line"><span class="number">3.</span>监听端口</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="number">4.</span>使用select函数获取存在待监听事件的socket</span><br><span class="line">	<span class="number">5.</span>如果有新的连接则与新的客户端连接</span><br><span class="line">	<span class="number">6.</span>如果有待监听事件，则对其进行处理(接受与发送)</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">7.</span>关闭socket</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;但是，这样的架构在select处理事件较多时，很容易效率低下。对于这类问题，我们可以引入<strong>生产者与消费者模式</strong>，来处理此类并发问题。</p>
<span id="more"></span>

<p>&emsp;&emsp;主线程为<strong>生产者</strong>线程，用来处理新客户端加入事件，把新客户端分配至<strong>消费者</strong>线程中。<strong>消费者</strong>线程便是我们建立的新线程，专门用来处理客户端发送的报文。这样就实现了事件处理的分离，从而使服务端处理效率更高。当过多客户端同时涌入时，可以更快的建立连接(因为有专门的线程用来处理这一事件)；而当客户端发送报文频率很快时，多线程处理报文也会大大提高效率。</p>
<ul>
<li>大致改进思路如下，红色的为此次需要加入的核心，黑色为原本架构<br><img src="/images/2021-02-07/1.jpg" alt="核心思路图"></li>
</ul>
<p>&emsp;&emsp;所以我们首先需要新建一个线程类，用来封装关于<strong>消费者</strong>线程的内容，从而建立多线程架构。随后，在本次的改进中，我决定加入<strong>计时器</strong>用来统计数据以及显示数据，主要需要统计的数据为：当前客户端连接数量、数据包的每秒接收数量。同时，我也对报文类型进行了分离，把报文类型放在单独的头文件里，这样既方便更改也方便引用。</p>
<ul>
<li><a href="https://blog.csdn.net/qq_45698148/article/details/113702354">1.计时器相关请点这里</a> &emsp;&emsp; <a href="https://blog.csdn.net/qq_45698148/article/details/113465259">2.多线程相关请点这里</a></li>
</ul>
<h1 id="二、代码的改进"><a href="#二、代码的改进" class="headerlink" title="二、代码的改进"></a>二、代码的改进</h1><h2 id="1-新建子线程类"><a href="#1-新建子线程类" class="headerlink" title="1.新建子线程类"></a>1.新建子线程类</h2><ul>
<li>首先是新建线程类<code>CellServer</code>，其中包含的基础方法以及相关变量如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CellServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造 </span></span><br><span class="line">	<span class="built_in">CellServer</span>(SOCKET sock = INVALID_SOCKET);</span><br><span class="line">	<span class="comment">//析构</span></span><br><span class="line">	~<span class="built_in">CellServer</span>();</span><br><span class="line">	<span class="comment">//关闭socket </span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">CloseSocket</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//判断是否工作中 </span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">IsRun</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//查询是否有待处理消息 </span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">OnRun</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//接收数据</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">RecvData</span><span class="params">(ClientSocket *t_client)</span></span>;</span><br><span class="line">	<span class="comment">//响应数据</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">NetMsg</span><span class="params">(DataHeader *head,SOCKET temp_socket)</span></span>;</span><br><span class="line">	<span class="comment">//增加客户端 </span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">addClient</span><span class="params">(ClientSocket* client)</span></span>;</span><br><span class="line">	<span class="comment">//启动线程</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>; </span><br><span class="line">	<span class="comment">//获取该线程内客户端数量</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetClientCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span></span><br><span class="line"><span class="function"><span class="keyword">private</span>:</span></span><br><span class="line"><span class="function">	//缓冲区相关 </span></span><br><span class="line"><span class="function">	char *_Recv_buf;</span><span class="comment">//接收缓冲区 </span></span><br><span class="line">	<span class="comment">//socket相关 </span></span><br><span class="line">	SOCKET _sock; </span><br><span class="line">	<span class="comment">//正式客户队列 </span></span><br><span class="line">	std::vector&lt;ClientSocket*&gt; _clients;<span class="comment">//储存客户端</span></span><br><span class="line">	<span class="comment">//客户缓冲区队列</span></span><br><span class="line">	std::vector&lt;ClientSocket*&gt; _clientsBuf; </span><br><span class="line">	std::mutex _mutex;<span class="comment">//锁</span></span><br><span class="line">	<span class="comment">//线程 </span></span><br><span class="line">	std::thread* _pThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	std::atomic_int _recvCount;<span class="comment">//接收包的数量 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>大致处理思路如下：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">线程外：</span><br><span class="line"><span class="built_in">Start</span>() 首先调用该方法启动线程</span><br><span class="line"></span><br><span class="line">新客户端加入：</span><br><span class="line"><span class="built_in">GetClientCount</span>() 首先主线程使用这个方法获取各个线程内客户端数量</span><br><span class="line"><span class="comment">//这个添加客户端的方法内涉及到临界区，需要上锁</span></span><br><span class="line"><span class="built_in">addClient</span>(ClientSocket* client) 主线程找到客户端数量最少的线程，使用该线程添加客户端至缓冲队列</span><br><span class="line"></span><br><span class="line">线程内：</span><br><span class="line"><span class="built_in">OnRun</span>()<span class="comment">//运行线程</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">IsRun</span>())<span class="comment">//判断是否工作中</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="number">1.</span>将缓冲队列中的客户数据加入正式队列</span><br><span class="line">		<span class="number">2.</span>正式客户队列为空的话，<span class="keyword">continue</span>本次循环</span><br><span class="line">		<span class="number">3.</span>select选择出待处理事件，错误的话就关闭所有连接<span class="built_in">CloseSocket</span>()</span><br><span class="line">		<span class="number">4.</span>对待处理事件进行接收<span class="built_in">RecvData</span>()，接收包的数量加一，随后处理<span class="built_in">NetMsg</span>()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-客户端主线程类的更改"><a href="#2-客户端主线程类的更改" class="headerlink" title="2.客户端主线程类的更改"></a>2.客户端主线程类的更改</h2><p>&emsp;&emsp;由于我们处理事件都改为在子线程中，所以首先主线程中是不需要处理报文消息了，所以类中接收消息和处理消息的方法都可以删除了。同时我们加入<code>Start</code>方法用来启动子线程，加入<code>time4msg</code>方法用来显示子线程中的客户端数量、每秒收包数等数据。</p>
<ul>
<li>主线程类<code>TcpServer</code>，更改后如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TcpServer</span> : INetEvent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造 </span></span><br><span class="line">	<span class="built_in">TcpServer</span>();</span><br><span class="line">	<span class="comment">//析构 </span></span><br><span class="line">	~<span class="built_in">TcpServer</span>();</span><br><span class="line">	<span class="comment">//初始化socket 返回1为正常 </span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">InitSocket</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//绑定IP/端口</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Bind</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* ip,<span class="type">unsigned</span> <span class="type">short</span> port)</span></span>;</span><br><span class="line">	<span class="comment">//监听端口</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Listen</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line">	<span class="comment">//接受连接</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Accept</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//添加客户端至服务端  </span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">AddClientToServer</span><span class="params">(ClientSocket* pClient)</span></span>;</span><br><span class="line">	<span class="comment">//线程启动 </span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//关闭socket </span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">CloseSocket</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//判断是否工作中 </span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">IsRun</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//查询是否有待处理消息 </span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">OnRun</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//显示各线程数据信息 </span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">time4msg</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//socket相关 </span></span><br><span class="line">	SOCKET _sock; </span><br><span class="line">	std::vector&lt;ClientSocket*&gt; _clients;<span class="comment">//储存客户端</span></span><br><span class="line">	std::vector&lt;CellServer*&gt; _cellServers;<span class="comment">//子线程们 </span></span><br><span class="line">	<span class="comment">//计时器</span></span><br><span class="line">	mytimer _time; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>大致处理思路如下：<a href="https://blog.csdn.net/qq_45698148/article/details/113702354">计时器相关请点这里</a><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">调用TcpServer封装类建立服务端的流程：</span><br><span class="line"><span class="number">1.</span><span class="built_in">InitSocket</span>() 建立一个socket</span><br><span class="line"><span class="number">2.</span><span class="built_in">Bind</span>(<span class="type">const</span> <span class="type">char</span>* ip,<span class="type">unsigned</span> <span class="type">short</span> port) 绑定端口和IP</span><br><span class="line"><span class="number">3.L</span>isten(<span class="type">int</span> n) 监听</span><br><span class="line"><span class="number">4.</span><span class="built_in">Start</span>() 线程启动</span><br><span class="line"><span class="keyword">while</span>(<span class="number">5.</span><span class="built_in">IsRun</span>()) 主线程循环 </span><br><span class="line">&#123;</span><br><span class="line">	<span class="number">6.</span><span class="built_in">OnRun</span>() 开始select选择处理事件</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">7.</span><span class="built_in">CloseSocket</span>() 关闭socket</span><br><span class="line"></span><br><span class="line">主线程内：</span><br><span class="line"><span class="built_in">OnRun</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">time4msg</span>()显示数据 </span><br><span class="line">	select选择出新客户端加入事件</span><br><span class="line">	如果有新客户端加入，调用<span class="built_in">Accept</span>()接受连接</span><br><span class="line">	<span class="built_in">Accept</span>()连接成功后，调用<span class="built_in">AddClientToServer</span>(ClientSocket* pClient)分配客户端到子线程中</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">AddClientToServer</span>()内：</span><br><span class="line">首先调用子线程的<span class="built_in">GetClientCount</span>()方法获取各条子线程中的客户端数量</span><br><span class="line">随后调用子线程的<span class="built_in">addClient</span>(ClientSocket* client)方法，把新客户端添加至客户端最少的线程中</span><br><span class="line"></span><br><span class="line"><span class="built_in">time4msg</span>()内：</span><br><span class="line">首先<span class="built_in">GetSecond</span>()获取计时器的计时</span><br><span class="line">如果大于一秒，就统计客户端的情况：子线程内_recvCount为收包数，主线程内_clients.<span class="built_in">size</span>()获取客户端数量</span><br><span class="line">显示后<span class="built_in">UpDate</span>()重置计时器，并且重置收包数，从而达到统计每秒收包数的作用</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-引入接口，实现子线程向主线程通信"><a href="#3-引入接口，实现子线程向主线程通信" class="headerlink" title="3.引入接口，实现子线程向主线程通信"></a>3.引入接口，实现子线程向主线程通信</h2><p>&emsp;&emsp;通过前两步的实现，多线程服务端已经初步完成，接下来需要进行一些完善。<br>&emsp;&emsp;我们很容易可以发现，子线程对象是在主线程<code>Start()</code>方法被创建的，随后被加入容器<code>_cellServers</code>储存。这就导致主线程中可以调用子线程类中的方法与成员变量，但是子线程中却无法调用主线程的方法与成员变量。从而导致当子线程中有客户端退出时，主线程无法了解。<br>&emsp;&emsp;对于这种情况，我们可以创建一个接口，让主线程类继承这个接口，子线程即可通过这个接口调用主线程中的特定方法。</p>
<ul>
<li>接口类<code>INetEvent</code>如下：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">INetEvent</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//有客户端退出 </span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnLeave</span><span class="params">(ClientSocket* pClient)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span>:	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>主线程类与子线程类中的相关实现：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>首先是主线程类继承该接口：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TcpServer</span> : INetEvent</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>随后实现接口中的虚方法：</span><br><span class="line"><span class="comment">//客户端退出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnLeave</span><span class="params">(ClientSocket* pClient)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//找到退出的客户端 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;_clients.<span class="built_in">size</span>(); n++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(_clients[n] == pClient)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">auto</span> iter = _clients.<span class="built_in">begin</span>() + n;</span><br><span class="line">			<span class="keyword">if</span>(iter != _clients.<span class="built_in">end</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				_clients.<span class="built_in">erase</span>(iter);<span class="comment">//移除 </span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line">即可实现调用该方法，移除客户端容器中指定客户端</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>随后在子线程类中添加私有成员变量： </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	INetEvent* _pNetEvent; </span><br><span class="line">创建接口对象</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>创建方法，让接口对象指向主线程类</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setEventObj</span><span class="params">(INetEvent* event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_pNetEvent = event; </span><br><span class="line">&#125;</span><br><span class="line">event传进去主线程即可，接口对象即指向主线程</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>主线程创建、启动子线程类时，调用该方法，传入自身<span class="keyword">this</span></span><br><span class="line">子线程对象-&gt;<span class="built_in">setEventObj</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span>随后即可通过子线程调用主线程的<span class="built_in">OnLeave</span>()方法删除客户端</span><br><span class="line">_pNetEvent-&gt;<span class="built_in">OnLeave</span>(要删除的客户端);</span><br></pre></td></tr></table></figure>
<h1 id="三、详细代码实现"><a href="#三、详细代码实现" class="headerlink" title="三、详细代码实现"></a>三、详细代码实现</h1><h2 id="1-计时器头文件-mytimer-hpp"><a href="#1-计时器头文件-mytimer-hpp" class="headerlink" title="1.计时器头文件 mytimer.hpp"></a>1.计时器头文件 <code>mytimer.hpp</code></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MY_TIMER_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_TIMER_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mytimer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::chrono::steady_clock::time_point _begin;<span class="comment">//起始时间</span></span><br><span class="line">    std::chrono::steady_clock::time_point _end;<span class="comment">//终止时间</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">mytimer</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		_begin = std::chrono::steady_clock::<span class="built_in">time_point</span>();</span><br><span class="line">		_end = std::chrono::steady_clock::<span class="built_in">time_point</span>();</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">mytimer</span>()&#123;&#125;;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用update时，使起始时间等于当前时间</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">UpDate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _begin = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用getsecond方法时，经过的时间为当前时间减去之前统计过的起始时间。</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">GetSecond</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _end = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">        <span class="comment">//使用duration类型变量进行时间的储存   duration_cast是类型转换方法</span></span><br><span class="line">        std::chrono::duration&lt;<span class="type">double</span>&gt; temp = std::chrono::duration_cast&lt;std::chrono::duration&lt;<span class="type">double</span>&gt;&gt;(_end - _begin);</span><br><span class="line">       	<span class="keyword">return</span> temp.<span class="built_in">count</span>();<span class="comment">//count() 获取当前时间的计数数量</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="2-命令头文件-CMD-h"><a href="#2-命令头文件-CMD-h" class="headerlink" title="2.命令头文件 CMD.h"></a>2.命令头文件 <code>CMD.h</code></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//枚举类型记录命令 </span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">cmd</span> </span><br><span class="line">&#123;</span><br><span class="line">	CMD_LOGIN,<span class="comment">//登录 </span></span><br><span class="line">	CMD_LOGINRESULT,<span class="comment">//登录结果 </span></span><br><span class="line">	CMD_LOGOUT,<span class="comment">//登出 </span></span><br><span class="line">	CMD_LOGOUTRESULT,<span class="comment">//登出结果 </span></span><br><span class="line">	CMD_NEW_USER_JOIN,<span class="comment">//新用户登入 </span></span><br><span class="line">	CMD_ERROR<span class="comment">//错误 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义数据包头 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DataHeader</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">short</span> cmd;<span class="comment">//命令</span></span><br><span class="line">	<span class="type">short</span> date_length;<span class="comment">//数据的长短	</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包1 登录 传输账号与密码</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Login</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Login</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGIN;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Login); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">	<span class="type">char</span> PassWord[<span class="number">32</span>];<span class="comment">//密码 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包2 登录结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoginResult</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LoginResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGINRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LoginResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包3 登出 传输用户名 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Logout</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Logout</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Logout); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包4 登出结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LogoutResult</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LogoutResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUTRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LogoutResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包5 新用户登入 传输通告 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NewUserJoin</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">NewUserJoin</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_NEW_USER_JOIN;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(NewUserJoin); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-服务端头文件-TcpServer-hpp"><a href="#3-服务端头文件-TcpServer-hpp" class="headerlink" title="3.服务端头文件 TcpServer.hpp"></a>3.服务端头文件 <code>TcpServer.hpp</code></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TcpServer_hpp_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TcpServer_hpp_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> FD_SETSIZE 10240 </span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;winSock2.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//链接此动态链接库 windows特有 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span><span class="comment">//selcet</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span><span class="comment">//uni std</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SOCKET int</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> INVALID_SOCKET (SOCKET)(~0)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SOCKET_ERROR (-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;CMD.h&quot;</span><span class="comment">//命令 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;mytimer.hpp&quot;</span><span class="comment">//计时器 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//缓冲区大小 </span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> RECV_BUFFER_SIZE</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> RECV_BUFFER_SIZE 4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程数量 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _THREAD_COUNT 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端类 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClientSocket</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造 </span></span><br><span class="line">	<span class="built_in">ClientSocket</span>(SOCKET sockfd = INVALID_SOCKET)</span><br><span class="line">	&#123;</span><br><span class="line">		_sockfd = sockfd;</span><br><span class="line">		<span class="comment">//缓冲区相关 </span></span><br><span class="line">		_Msg_buf = <span class="keyword">new</span> <span class="type">char</span>[RECV_BUFFER_SIZE*<span class="number">10</span>];</span><br><span class="line">		_Len_buf = <span class="number">0</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构 </span></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">ClientSocket</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span>[] _Msg_buf;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//获取socket </span></span><br><span class="line">	<span class="function">SOCKET <span class="title">GetSockfd</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _sockfd;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//获取缓冲区 </span></span><br><span class="line">	<span class="function"><span class="type">char</span>* <span class="title">MsgBuf</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _Msg_buf;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//获取缓冲区尾部变量 </span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetLen</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _Len_buf;	</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//设置缓冲区尾巴变量</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetLen</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		_Len_buf = len;</span><br><span class="line">	&#125; </span><br><span class="line">		</span><br><span class="line"><span class="keyword">private</span>:	</span><br><span class="line">	SOCKET _sockfd;</span><br><span class="line">	<span class="comment">//缓冲区相关 </span></span><br><span class="line">	<span class="type">char</span> *_Msg_buf;<span class="comment">//消息缓冲区 </span></span><br><span class="line">	<span class="type">int</span> _Len_buf;<span class="comment">//缓冲区数据尾部变量</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">//事件接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">INetEvent</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//有客户端退出 </span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnLeave</span><span class="params">(ClientSocket* pClient)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span>:	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CellServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造 </span></span><br><span class="line">	<span class="built_in">CellServer</span>(SOCKET sock = INVALID_SOCKET)</span><br><span class="line">	&#123;</span><br><span class="line">		_sock = sock; </span><br><span class="line">		_pThread = <span class="literal">nullptr</span>;</span><br><span class="line">		_pNetEvent = <span class="literal">nullptr</span>;</span><br><span class="line">		_recvCount = <span class="number">0</span>; </span><br><span class="line">		<span class="comment">//缓冲区相关 </span></span><br><span class="line">		_Recv_buf = <span class="keyword">new</span> <span class="type">char</span>[RECV_BUFFER_SIZE];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构</span></span><br><span class="line">	~<span class="built_in">CellServer</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span>[] _Recv_buf;</span><br><span class="line">		<span class="comment">//关闭socket </span></span><br><span class="line">		<span class="built_in">CloseSocket</span>();</span><br><span class="line">		_sock = INVALID_SOCKET;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//处理事件 </span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setEventObj</span><span class="params">(INetEvent* event)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		_pNetEvent = event; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//关闭socket </span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">CloseSocket</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET != _sock) </span><br><span class="line">		&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">			<span class="comment">//关闭客户端socket</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;_clients.<span class="built_in">size</span>(); ++n)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">closesocket</span>(_clients[n]-&gt;<span class="built_in">GetSockfd</span>());</span><br><span class="line">				<span class="keyword">delete</span> _clients[n];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//关闭socket</span></span><br><span class="line">			<span class="built_in">closesocket</span>(_sock); </span><br><span class="line">			<span class="comment">//清除windows socket 环境 </span></span><br><span class="line">			<span class="built_in">WSACleanup</span>(); </span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">			<span class="comment">//关闭客户端socket</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;_clients.<span class="built_in">size</span>(); ++n)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">close</span>(_clients[n]-&gt;<span class="built_in">GetSockfd</span>());</span><br><span class="line">				<span class="keyword">delete</span> _clients[n];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//关闭socket/LINUX</span></span><br><span class="line">			<span class="built_in">close</span>(_sock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">			_sock = INVALID_SOCKET;</span><br><span class="line">			_clients.<span class="built_in">clear</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//判断是否工作中 </span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">IsRun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _sock != INVALID_SOCKET; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//查询是否有待处理消息 </span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">OnRun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">IsRun</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//将缓冲队列中的客户数据加入正式队列 </span></span><br><span class="line">			<span class="keyword">if</span>(_clientsBuf.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;<span class="comment">//上锁 </span></span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">auto</span> client :_clientsBuf)</span><br><span class="line">				&#123;</span><br><span class="line">					_clients.<span class="built_in">push_back</span>(client);</span><br><span class="line">				&#125;</span><br><span class="line">				_clientsBuf.<span class="built_in">clear</span>();</span><br><span class="line">			&#125; </span><br><span class="line">			<span class="comment">//如果没有需要处理的客户端就跳过 </span></span><br><span class="line">			<span class="keyword">if</span>(_clients.<span class="built_in">empty</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				std::<span class="function">chrono::milliseconds <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;<span class="comment">//休眠一毫秒 </span></span><br><span class="line">				std::this_thread::<span class="built_in">sleep_for</span>(t);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			fd_set fdRead;<span class="comment">//建立集合 </span></span><br><span class="line">			<span class="built_in">FD_ZERO</span>(&amp;fdRead);<span class="comment">//清空集合 </span></span><br><span class="line">			SOCKET maxSock = _clients[<span class="number">0</span>]-&gt;<span class="built_in">GetSockfd</span>();<span class="comment">//最大socket </span></span><br><span class="line">			<span class="comment">//把连接的客户端 放入read集合 </span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> n=_clients.<span class="built_in">size</span>()<span class="number">-1</span>; n&gt;=<span class="number">0</span>; --n)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">FD_SET</span>(_clients[n]-&gt;<span class="built_in">GetSockfd</span>(),&amp;fdRead);</span><br><span class="line">				<span class="keyword">if</span>(maxSock &lt; _clients[n]-&gt;<span class="built_in">GetSockfd</span>())</span><br><span class="line">				&#123;</span><br><span class="line">					maxSock = _clients[n]-&gt;<span class="built_in">GetSockfd</span>();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//select函数筛选select </span></span><br><span class="line">			<span class="type">int</span> ret = <span class="built_in">select</span>(maxSock<span class="number">+1</span>,&amp;fdRead,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>); </span><br><span class="line">			<span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;select任务结束\n&quot;</span>);</span><br><span class="line">				<span class="built_in">CloseSocket</span>();</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//遍历所有socket 查看是否有待处理事件 </span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;_clients.<span class="built_in">size</span>(); ++n)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(_clients[n]-&gt;<span class="built_in">GetSockfd</span>(),&amp;fdRead))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(<span class="number">-1</span> == <span class="built_in">RecvData</span>(_clients[n]))<span class="comment">//处理请求 客户端退出的话 </span></span><br><span class="line">					&#123;</span><br><span class="line">						std::vector&lt;ClientSocket*&gt;::iterator iter = _clients.<span class="built_in">begin</span>()+n;<span class="comment">//找到退出客户端的地址</span></span><br><span class="line">						<span class="keyword">if</span>(iter != _clients.<span class="built_in">end</span>())<span class="comment">//如果是合理值</span></span><br><span class="line">						&#123;</span><br><span class="line">							<span class="keyword">if</span>(_pNetEvent)<span class="comment">//主线程中删除客户端 </span></span><br><span class="line">							&#123;</span><br><span class="line">								_pNetEvent-&gt;<span class="built_in">OnLeave</span>(_clients[n]);</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">delete</span> _clients[n];</span><br><span class="line">							_clients.<span class="built_in">erase</span>(iter);<span class="comment">//移除</span></span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//printf(&quot;空闲时间处理其他业务\n&quot;);</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//接收数据</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">RecvData</span><span class="params">(ClientSocket *t_client)</span><span class="comment">//处理数据 </span></span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		_recvCount++;<span class="comment">//收包数量加一 </span></span><br><span class="line">		<span class="comment">//接收客户端发送的数据  </span></span><br><span class="line">		<span class="type">int</span> buf_len = <span class="built_in">recv</span>(t_client-&gt;<span class="built_in">GetSockfd</span>(), _Recv_buf, RECV_BUFFER_SIZE, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(buf_len&lt;=<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;客户端已退出\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125; </span><br><span class="line">		</span><br><span class="line">		<span class="comment">//将接收缓冲区的数据拷贝到消息缓冲区 </span></span><br><span class="line">		<span class="built_in">memcpy</span>(t_client-&gt;<span class="built_in">MsgBuf</span>() + t_client-&gt;<span class="built_in">GetLen</span>(), _Recv_buf, buf_len); </span><br><span class="line">		<span class="comment">//消息缓冲区的数据末尾后移 </span></span><br><span class="line">		t_client-&gt;<span class="built_in">SetLen</span>(t_client-&gt;<span class="built_in">GetLen</span>() + buf_len);</span><br><span class="line">		<span class="comment">//判断消息缓冲区的数据长度是否大于等于包头长度 </span></span><br><span class="line">		<span class="keyword">while</span>(t_client-&gt;<span class="built_in">GetLen</span>() &gt;= <span class="built_in">sizeof</span>(DataHeader))<span class="comment">//处理粘包问题 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//选出包头数据 </span></span><br><span class="line">			DataHeader* header = (DataHeader*)t_client-&gt;<span class="built_in">MsgBuf</span>(); </span><br><span class="line">			<span class="comment">//判断消息缓冲区内数据长度是否大于等于报文长度 避免少包问题 </span></span><br><span class="line">			<span class="keyword">if</span>(t_client-&gt;<span class="built_in">GetLen</span>() &gt;= header-&gt;date_length)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//计算出消息缓冲区内剩余未处理数据的长度</span></span><br><span class="line">				<span class="type">int</span> size = t_client-&gt;<span class="built_in">GetLen</span>() - header-&gt;date_length; </span><br><span class="line">				<span class="comment">//响应数据 </span></span><br><span class="line">				<span class="built_in">NetMsg</span>(header,t_client-&gt;<span class="built_in">GetSockfd</span>());</span><br><span class="line">				<span class="comment">//将消息缓冲区剩余未处理的数据前移</span></span><br><span class="line">				<span class="built_in">memcpy</span>(t_client-&gt;<span class="built_in">MsgBuf</span>(), t_client-&gt;<span class="built_in">MsgBuf</span>() + header-&gt;date_length, size);</span><br><span class="line">				<span class="comment">//消息缓冲区的数据末尾前移</span></span><br><span class="line">				t_client-&gt;<span class="built_in">SetLen</span>(size); </span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//消息缓冲区数据不足 </span></span><br><span class="line">				<span class="keyword">break</span>; </span><br><span class="line">			&#125; </span><br><span class="line">		&#125;  </span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//响应数据</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">NetMsg</span><span class="params">(DataHeader *head,SOCKET temp_socket)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		</span><br><span class="line">	 	<span class="comment">//printf(&quot;接收到包头，命令：%d，数据长度：%d\n&quot;,head-&gt;cmd,head-&gt;date_length);</span></span><br><span class="line">		<span class="keyword">switch</span>(head-&gt;cmd)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> CMD_LOGIN:<span class="comment">//登录 接收登录包体 </span></span><br><span class="line">			&#123;</span><br><span class="line">				Login *login = (Login*)head;</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				进行判断操作 </span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				<span class="comment">//printf(&quot;%s已登录\n密码：%s\n&quot;,login-&gt;UserName,login-&gt;PassWord); </span></span><br><span class="line">				LoginResult *result = <span class="keyword">new</span> LoginResult;	</span><br><span class="line">				result-&gt;Result = <span class="number">1</span>;</span><br><span class="line">				<span class="comment">//SendData(result,temp_socket);</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> CMD_LOGOUT:<span class="comment">//登出 接收登出包体 </span></span><br><span class="line">			&#123;</span><br><span class="line">				Logout *logout = (Logout*)head;</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				进行判断操作 </span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				<span class="comment">//printf(&quot;%s已登出\n&quot;,logout-&gt;UserName); </span></span><br><span class="line">				LogoutResult *result = <span class="keyword">new</span> <span class="built_in">LogoutResult</span>();</span><br><span class="line">				result-&gt;Result = <span class="number">1</span>;</span><br><span class="line">				<span class="comment">//SendData(result,temp_socket);</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:<span class="comment">//错误 </span></span><br><span class="line">			&#123;</span><br><span class="line">				head-&gt;cmd = CMD_ERROR; </span><br><span class="line">				head-&gt;date_length = <span class="number">0</span>; </span><br><span class="line">				<span class="comment">//SendData(head,temp_socket); </span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//增加客户端 </span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">addClient</span><span class="params">(ClientSocket* client)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">		<span class="comment">//_mutex.lock();</span></span><br><span class="line">		_clientsBuf.<span class="built_in">push_back</span>(client);	</span><br><span class="line">		<span class="comment">//_mutex.unlock();</span></span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//启动线程</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		_pThread = <span class="keyword">new</span> std::<span class="built_in">thread</span>(std::<span class="built_in">mem_fun</span>(&amp;CellServer::OnRun),<span class="keyword">this</span>);</span><br><span class="line">		 </span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//获取该线程内客户端数量</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetClientCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _clients.<span class="built_in">size</span>() + _clientsBuf.<span class="built_in">size</span>();	</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//缓冲区相关 </span></span><br><span class="line">	<span class="type">char</span> *_Recv_buf;<span class="comment">//接收缓冲区 </span></span><br><span class="line">	<span class="comment">//socket相关 </span></span><br><span class="line">	SOCKET _sock; </span><br><span class="line">	<span class="comment">//正式客户队列 </span></span><br><span class="line">	std::vector&lt;ClientSocket*&gt; _clients;<span class="comment">//储存客户端</span></span><br><span class="line">	<span class="comment">//客户缓冲区</span></span><br><span class="line">	std::vector&lt;ClientSocket*&gt; _clientsBuf; </span><br><span class="line">	std::mutex _mutex;<span class="comment">//锁</span></span><br><span class="line">	<span class="comment">//线程 </span></span><br><span class="line">	std::thread* _pThread;</span><br><span class="line">	<span class="comment">//退出事件接口 </span></span><br><span class="line">	INetEvent* _pNetEvent; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	std::atomic_int _recvCount;<span class="comment">//接收包的数量 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务端类 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TcpServer</span> : INetEvent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造 </span></span><br><span class="line">	<span class="built_in">TcpServer</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		_sock = INVALID_SOCKET; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//析构 </span></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">TcpServer</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//关闭socket </span></span><br><span class="line">		<span class="built_in">CloseSocket</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//初始化socket 返回1为正常 </span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">InitSocket</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">		<span class="comment">//启动windows socket 2,x环境 </span></span><br><span class="line">		WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>); </span><br><span class="line">		WSADATA dat;</span><br><span class="line">		<span class="keyword">if</span>(<span class="number">0</span> != <span class="built_in">WSAStartup</span>(ver,&amp;dat))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//-1为环境错误 </span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">		<span class="comment">//创建socket </span></span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET != _sock)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;&lt;Socket=%d&gt;关闭连接\n&quot;</span>,_sock); </span><br><span class="line">			<span class="built_in">CloseSocket</span>();<span class="comment">//如果之前有连接 就关闭连接 </span></span><br><span class="line">		&#125;</span><br><span class="line">		_sock = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,IPPROTO_TCP); </span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET == _sock)</span><br><span class="line">		&#123;   </span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//0为socket创建错误 </span></span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//绑定IP/端口</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Bind</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* ip,<span class="type">unsigned</span> <span class="type">short</span> port)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//如果为无效套接字 则初始化 </span></span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET == _sock)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">InitSocket</span>(); </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//绑定网络端口和IP地址 </span></span><br><span class="line">		sockaddr_in _myaddr = &#123;&#125;; </span><br><span class="line">		_myaddr.sin_family = AF_INET;<span class="comment">//IPV4</span></span><br><span class="line">		_myaddr.sin_port = <span class="built_in">htons</span>(port);<span class="comment">//端口</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">		<span class="keyword">if</span>(ip)<span class="comment">//ip为空则监听所有网卡 </span></span><br><span class="line">		&#123;</span><br><span class="line">			_myaddr.sin_addr.S_un.S_addr = <span class="built_in">inet_addr</span>(ip);<span class="comment">//IP</span></span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			_myaddr.sin_addr.S_un.S_addr = INADDR_ANY;<span class="comment">//IP</span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		<span class="keyword">if</span>(ip)<span class="comment">//ip为空则监听所有网卡</span></span><br><span class="line">		&#123;</span><br><span class="line">			_myaddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(ip);<span class="comment">//IP </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			_myaddr.sin_addr.s_addr = INADDR_ANY;<span class="comment">//IP </span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">bind</span>(_sock,(sockaddr*)&amp;_myaddr,<span class="built_in">sizeof</span>(sockaddr_in)))<span class="comment">//socket (强制转换)sockaddr结构体 结构体大小 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;绑定失败\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;绑定成功\n绑定端口为%d\n&quot;</span>,port);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//监听端口</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Listen</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//如果为无效套接字 则提示 </span></span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET == _sock)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;请先初始化套接字并绑定IP端口\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//监听网络端口</span></span><br><span class="line">		<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">listen</span>(_sock,n))<span class="comment">//最大连接队列 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;监听失败\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;监听成功\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//接受连接</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Accept</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//等待接收客户端连接</span></span><br><span class="line">		sockaddr_in clientAddr = &#123;&#125;;<span class="comment">//新建sockadd结构体接收客户端数据 </span></span><br><span class="line">		<span class="type">int</span> addr_len = <span class="built_in">sizeof</span>(sockaddr_in);<span class="comment">//获取sockadd结构体长度 </span></span><br><span class="line">		SOCKET temp_socket = INVALID_SOCKET;<span class="comment">//声明客户端套接字 </span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32	</span></span><br><span class="line">		temp_socket = <span class="built_in">accept</span>(_sock,(sockaddr*)&amp;clientAddr,&amp;addr_len);<span class="comment">//自身套接字 客户端结构体 结构体大小 	</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		temp_socket = <span class="built_in">accept</span>(_sock,(sockaddr*)&amp;clientAddr,(<span class="type">socklen_t</span>*)&amp;addr_len);<span class="comment">//自身套接字 客户端结构体 结构体大小 </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET == temp_socket)<span class="comment">//接收失败 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;&lt;Socket=%d&gt;错误,接受到无效客户端SOCKET\n&quot;</span>,temp_socket);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123; </span><br><span class="line">			<span class="comment">//printf(&quot;新客户端加入 count: %d\nIP地址为：%s \n&quot;, _clients.size(), inet_ntoa(clientAddr.sin_addr));  </span></span><br><span class="line">			<span class="comment">//群发所有客户端 通知新用户登录 </span></span><br><span class="line">			<span class="comment">//NewUserJoin *user_join = new NewUserJoin(); </span></span><br><span class="line">			<span class="comment">//strcpy(user_join-&gt;UserName,inet_ntoa(clientAddr.sin_addr));</span></span><br><span class="line">			<span class="comment">//SendDataToAll(user_join);</span></span><br><span class="line">			<span class="comment">//将新的客户端加入动态数组</span></span><br><span class="line">			<span class="built_in">AddClientToServer</span>(<span class="keyword">new</span> <span class="built_in">ClientSocket</span>(temp_socket));</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//添加客户端至服务端  </span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">AddClientToServer</span><span class="params">(ClientSocket* pClient)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		_clients.<span class="built_in">push_back</span>(pClient);</span><br><span class="line">		<span class="comment">//找出客户端最少的线程 然后加入 </span></span><br><span class="line">		<span class="keyword">auto</span> pMinServer = _cellServers[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> pCellServer : _cellServers)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(pMinServer-&gt;<span class="built_in">GetClientCount</span>() &gt; pCellServer-&gt;<span class="built_in">GetClientCount</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				pMinServer = pCellServer;</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">		pMinServer-&gt;<span class="built_in">addClient</span>(pClient);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//线程启动 </span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;_THREAD_COUNT; n++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//线程加入容器 </span></span><br><span class="line">			<span class="keyword">auto</span> ser = <span class="keyword">new</span> <span class="built_in">CellServer</span>(_sock); </span><br><span class="line">			_cellServers.<span class="built_in">push_back</span>(ser);</span><br><span class="line">			ser-&gt;<span class="built_in">setEventObj</span>(<span class="keyword">this</span>);</span><br><span class="line">			ser-&gt;<span class="built_in">Start</span>(); </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//关闭socket </span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">CloseSocket</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET != _sock) </span><br><span class="line">		&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">			<span class="comment">//关闭客户端socket</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;_clients.<span class="built_in">size</span>(); ++n)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">closesocket</span>(_clients[n]-&gt;<span class="built_in">GetSockfd</span>());</span><br><span class="line">				<span class="keyword">delete</span> _clients[n];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//关闭socket</span></span><br><span class="line">			<span class="built_in">closesocket</span>(_sock); </span><br><span class="line">			<span class="comment">//清除windows socket 环境 </span></span><br><span class="line">			<span class="built_in">WSACleanup</span>(); </span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">			<span class="comment">//关闭客户端socket</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;_clients.<span class="built_in">size</span>(); ++n)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">close</span>(_clients[n]-&gt;<span class="built_in">GetSockfd</span>());</span><br><span class="line">				<span class="keyword">delete</span> _clients[n];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//关闭socket/LINUX</span></span><br><span class="line">			<span class="built_in">close</span>(_sock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">			_sock = INVALID_SOCKET;</span><br><span class="line">			_clients.<span class="built_in">clear</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//判断是否工作中 </span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">IsRun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _sock != INVALID_SOCKET; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//查询是否有待处理消息 </span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">OnRun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">IsRun</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">time4msg</span>();<span class="comment">//查看各线程数据信息 </span></span><br><span class="line">			fd_set fdRead;<span class="comment">//建立集合 </span></span><br><span class="line">			<span class="comment">//fd_set fdWrite;</span></span><br><span class="line">			<span class="comment">//fd_set fdExcept;</span></span><br><span class="line">			<span class="built_in">FD_ZERO</span>(&amp;fdRead);<span class="comment">//清空集合 </span></span><br><span class="line">			<span class="comment">//FD_ZERO(&amp;fdWrite); </span></span><br><span class="line">			<span class="comment">//FD_ZERO(&amp;fdExcept); </span></span><br><span class="line">			<span class="built_in">FD_SET</span>(_sock,&amp;fdRead);<span class="comment">//放入集合 </span></span><br><span class="line">			<span class="comment">//FD_SET(_sock,&amp;fdWrite); </span></span><br><span class="line">			<span class="comment">//FD_SET(_sock,&amp;fdExcept);</span></span><br><span class="line">			timeval <span class="type">s_t</span> = &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;<span class="comment">//select最大响应时间 </span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">//select函数筛选select </span></span><br><span class="line">			<span class="type">int</span> ret = <span class="built_in">select</span>(_sock<span class="number">+1</span>,&amp;fdRead,<span class="number">0</span>,<span class="number">0</span>,&amp;<span class="type">s_t</span>); </span><br><span class="line">			<span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;select任务结束\n&quot;</span>);</span><br><span class="line">				<span class="built_in">CloseSocket</span>();</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(_sock,&amp;fdRead))<span class="comment">//获取是否有新socket连接 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">FD_CLR</span>(_sock,&amp;fdRead);<span class="comment">//清理</span></span><br><span class="line">				<span class="built_in">Accept</span>();<span class="comment">//连接 </span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//显示各线程数据信息 </span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">time4msg</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">auto</span> t1 = _time.<span class="built_in">GetSecond</span>();</span><br><span class="line">		<span class="keyword">if</span>(<span class="number">1.0</span> &lt;= t1)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> recvCount = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> ser: _cellServers)</span><br><span class="line">			&#123;</span><br><span class="line">				recvCount += ser-&gt;_recvCount;</span><br><span class="line">				ser-&gt;_recvCount = <span class="number">0</span>; </span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//时间间隔  本机socket连接序号  客户端数量  每秒收包数 </span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;time&lt;%lf&gt;,socket&lt;%d&gt;,clients&lt;%d&gt;,recvCount&lt;%d&gt;\n&quot;</span>, t1, _sock, _clients.<span class="built_in">size</span>(),(<span class="type">int</span>)(recvCount/t1));</span><br><span class="line">			_time.<span class="built_in">UpDate</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//发送数据 </span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">SendData</span><span class="params">(DataHeader *head,SOCKET temp_socket)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">IsRun</span>() &amp;&amp; head)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">send</span>(temp_socket,(<span class="type">const</span> <span class="type">char</span>*)head,head-&gt;date_length,<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//向所有人发送数据</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SendDataToAll</span><span class="params">(DataHeader *head)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>;n&lt;_clients.<span class="built_in">size</span>();++n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">SendData</span>(head, _clients[n]-&gt;<span class="built_in">GetSockfd</span>());	</span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//客户端退出</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">OnLeave</span><span class="params">(ClientSocket* pClient)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//找到退出的客户端 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;_clients.<span class="built_in">size</span>(); n++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(_clients[n] == pClient)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">auto</span> iter = _clients.<span class="built_in">begin</span>() + n;</span><br><span class="line">				<span class="keyword">if</span>(iter != _clients.<span class="built_in">end</span>())</span><br><span class="line">				&#123;</span><br><span class="line">					_clients.<span class="built_in">erase</span>(iter);<span class="comment">//移除 </span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	 </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//socket相关 </span></span><br><span class="line">	SOCKET _sock; </span><br><span class="line">	std::vector&lt;ClientSocket*&gt; _clients;<span class="comment">//储存客户端</span></span><br><span class="line">	std::vector&lt;CellServer*&gt; _cellServers;<span class="comment">//线程处理 </span></span><br><span class="line">	<span class="comment">//计时器</span></span><br><span class="line">	mytimer _time; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="4-服务端样例代码-server-cpp"><a href="#4-服务端样例代码-server-cpp" class="headerlink" title="4.服务端样例代码  server.cpp"></a>4.服务端样例代码  <code>server.cpp</code></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;TcpServer.hpp&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Welcome\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//建立tcp对象 </span></span><br><span class="line">	TcpServer *tcp1 = <span class="keyword">new</span> <span class="built_in">TcpServer</span>();</span><br><span class="line">	<span class="comment">//建立一个socket</span></span><br><span class="line">	tcp1-&gt;<span class="built_in">InitSocket</span>();</span><br><span class="line">	<span class="comment">//绑定端口和IP</span></span><br><span class="line">	tcp1-&gt;<span class="built_in">Bind</span>(<span class="literal">NULL</span>,<span class="number">8888</span>);</span><br><span class="line">	<span class="comment">//监听</span></span><br><span class="line">	tcp1-&gt;<span class="built_in">Listen</span>(<span class="number">5</span>);</span><br><span class="line">	<span class="comment">//线程启动</span></span><br><span class="line">	tcp1-&gt;<span class="built_in">Start</span>(); </span><br><span class="line">	<span class="comment">//循环 </span></span><br><span class="line">	<span class="keyword">while</span>(tcp1-&gt;<span class="built_in">IsRun</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		tcp1-&gt;<span class="built_in">OnRun</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//关闭</span></span><br><span class="line">	tcp1-&gt;<span class="built_in">CloseSocket</span>();</span><br><span class="line">	 </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;任务结束，程序已退出&quot;</span>); </span><br><span class="line">	<span class="built_in">getchar</span>(); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++网络编程学习：消息接收与发送分离</title>
    <url>/2021/02/21/20210221_C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%B6%88%E6%81%AF%E6%8E%A5%E6%94%B6%E4%B8%8E%E5%8F%91%E9%80%81%E5%88%86%E7%A6%BB/</url>
    <content><![CDATA[<ul>
<li>使用的语言为C&#x2F;C++</li>
<li>源码支持的平台为：Windows &#x2F; Linux</li>
</ul>
<h1 id="一、思路与准备"><a href="#一、思路与准备" class="headerlink" title="一、思路与准备"></a>一、思路与准备</h1><p>&emsp;&emsp;在之前的 <a href="https://blog.csdn.net/qq_45698148/article/details/113704768">C++网络编程学习：服务端多线程分离业务处理高负载</a> 笔记中，我将业务处理相关内容从主线程中分离，大大提高了服务端的效率。随着服务端的进一步完善，我会把各个模块进行分离，从而使代码的结构更加便于修改与完善，同时也可以提高代码的运行效率。<br>&emsp;&emsp;本篇笔记中，我会记录自己如何把消息发送的相关内容从业务处理线程中分离出来。</p>
<span id="more"></span>

<p>首先下面是我的思路图。</p>
<ul>
<li>大致思路如下：<strong>处理事件线程 &gt;&gt; 发送线程缓冲区 &gt;&gt; 发送线程</strong><br><img src="/images/2021-02-21/1.jpg" alt="在这里插入图片描述"></li>
</ul>
<p>&emsp;&emsp;我会在新建业务子线程时创建一条发送子线程。其中由主线程创建子线程对象，子线程对象中包含两条子线程，一条为业务子线程，一条为发送子线程。这样两条线程可以在一个对象中进行相关操作，便于实现。同时，主线程只需声明一个对象即可，封装性良好且低耦合。<br>&emsp;&emsp;在业务线程需要发送消息时，首先创建一个消息发送对象，其中包含发送的目标和内容。随后把该对象加入缓冲区。在发送线程中，首先把缓冲区内的对象提取到正式发送队列中，随后把正式发送队列中的待发送事件挨个进行处理即可。</p>
<h1 id="二、代码实现"><a href="#二、代码实现" class="headerlink" title="二、代码实现"></a>二、代码实现</h1><h2 id="1-发送线程类文件相关"><a href="#1-发送线程类文件相关" class="headerlink" title="1.发送线程类文件相关"></a>1.发送线程类文件相关</h2><p>&emsp;&emsp;首先，我们得新建两个类，一个是发送任务基类，一个是发送线程类。<br>&emsp;&emsp;发送任务基类中，含有一个虚方法<code>DoTask</code>用来执行发送任务。该方法在服务端源码中被重载。<br>&emsp;&emsp;发送线程类中，含有一条发送线程，同时有一个<code>Start</code>方法用来启动该线程。含有两条链表，一条为缓冲区链表，一条为正式消息链表，同时有一个<code>addTask</code>方法用来把消息任务加入缓冲区。线程执行<code>OnRun</code>方法把缓冲区中的任务加入正式队列并执行该任务的<code>DoTask</code>方法。</p>
<ul>
<li>发送线程类文件 <code>celltask.hpp</code> 大致代码如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _CELL_Task_hpp_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CELL_Task_hpp_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//任务基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CellTask</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//执行任务 </span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DoTask</span><span class="params">()</span> </span>= <span class="number">0</span>; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送线程类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CellTaskServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CellTaskServer</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">CellTaskServer</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//添加任务 </span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">addTask</span><span class="params">(CellTask* ptask)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::lock_guard&lt;std::mutex&gt;<span class="built_in">lock</span>(_mutex);</span><br><span class="line">		_tasksBuf.<span class="built_in">push_back</span>(ptask);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">//启动服务</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//线程</span></span><br><span class="line">		<span class="function">std::thread <span class="title">t</span><span class="params">(std::mem_fn(&amp;CellTaskServer::OnRun),<span class="keyword">this</span>)</span></span>; </span><br><span class="line">		t.<span class="built_in">detach</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">//工作函数 </span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">OnRun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//将缓冲区内数据加入 </span></span><br><span class="line">			<span class="keyword">if</span>(!_tasksBuf.<span class="built_in">empty</span>())<span class="comment">//不为空 </span></span><br><span class="line">			&#123;</span><br><span class="line">				std::lock_guard&lt;std::mutex&gt;<span class="built_in">lock</span>(_mutex);</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">auto</span> pTask : _tasksBuf)</span><br><span class="line">				&#123;</span><br><span class="line">					_tasks.<span class="built_in">push_back</span>(pTask);	</span><br><span class="line">				&#125; </span><br><span class="line">				_tasksBuf.<span class="built_in">clear</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//如果无任务</span></span><br><span class="line">			<span class="keyword">if</span>(_tasks.<span class="built_in">empty</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//休息一毫秒 </span></span><br><span class="line">				std::<span class="function">chrono::milliseconds <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">				std::this_thread::<span class="built_in">sleep_for</span>(t);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125; </span><br><span class="line">			<span class="comment">//处理任务</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> pTask:_tasks)</span><br><span class="line">			&#123;</span><br><span class="line">				pTask-&gt;<span class="built_in">DoTask</span>();</span><br><span class="line">				<span class="keyword">delete</span> pTask;	</span><br><span class="line">			&#125; </span><br><span class="line">			<span class="comment">//清空任务 </span></span><br><span class="line">			_tasks.<span class="built_in">clear</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//任务数据 </span></span><br><span class="line">	std::list&lt;CellTask*&gt;_tasks;</span><br><span class="line">	<span class="comment">//任务数据缓冲区 </span></span><br><span class="line">	std::list&lt;CellTask*&gt;_tasksBuf;</span><br><span class="line">	<span class="comment">//锁 锁数据缓冲区 </span></span><br><span class="line">	std::mutex _mutex; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>其中的缓冲区加入操作涉及到临界操作，所以加个自解锁。</li>
<li>因为缓冲区以及正式队列涉及到频繁进出，所以用的是链表<code>list</code>。</li>
<li>当没有发送任务时，会进行一毫秒的休息，防止消耗太多的内存。</li>
</ul>
<h2 id="2-主文件相关"><a href="#2-主文件相关" class="headerlink" title="2.主文件相关"></a>2.主文件相关</h2><p>&emsp;&emsp;在导入上述<code>celltask.hpp</code>头文件后，我们需要重载<code>DoTask</code>方法，从而实现把主文件内的相关类型数据进行发送。<br>&emsp;&emsp;我们可以创建一个新类，使他继承<code>CellTask</code>任务基类。其中导入主文件内的相关类型。例如下面的例子中就导入了<code>ClientSocket</code>客户端类与<code>DataHeader</code>报文结构体。同时重写了<code>DoTask</code>方法，使其调用<code>ClientSocket</code>客户端类的<code>SendData</code>方法发送报文。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//网络消息发送任务</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CellSendMsgTask</span> : <span class="keyword">public</span> CellTask</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CellSendMsgTask</span>(ClientSocket* pClient,DataHeader* pHead)</span><br><span class="line">	&#123;</span><br><span class="line">		_pClient = pClient;</span><br><span class="line">		_pHeader = pHead;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//执行任务</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DoTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		_pClient-&gt;<span class="built_in">SendData</span>(_pHeader);</span><br><span class="line">		<span class="keyword">delete</span> _pHeader;</span><br><span class="line">	&#125;  </span><br><span class="line">	</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	ClientSocket* _pClient;</span><br><span class="line">	DataHeader* _pHeader;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;而当我们想要发送报文时，只需要新建上述<code>CellSendMsgTask</code>对象，并调用<code>CellTaskServer</code>任务线程类的<code>addTask</code>方法添加至发送队列即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//向 pClient 客户端发送 pHead 报文</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddSendTask</span><span class="params">(ClientSocket* pClient,DataHeader* pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CellSendMsgTask* ptask = <span class="keyword">new</span> <span class="built_in">CellSendMsgTask</span>(pClient,pHead);</span><br><span class="line">	_taskServer.<span class="built_in">addTask</span>(ptask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习记录：基于chrono库的高精度计时器</title>
    <url>/2021/02/05/20210205_C++%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E5%9F%BA%E4%BA%8Echrono%E5%BA%93%E7%9A%84%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%AE%A1%E6%97%B6%E5%99%A8/</url>
    <content><![CDATA[<p>&emsp;&emsp;C++11中新引入了<code>std::chrono</code>库，由此可以较为容易的实现一个计时器。同时，休眠操作也可以通过这个库来实现，从而使代码有良好的跨平台性，避免使用Windows&#x2F;Linux的系统休眠函数。<br>&emsp;&emsp;在接下来的网络编程学习中，将引入该计时器，实现对每秒收包、连接等数据的计数显示。<br>&emsp;&emsp;本篇学习记录使用的语言为C++，调用的库为C++11里的<code>std::chrono</code>库。</p>
<span id="more"></span>

<h1 id="一、简易的计时器类"><a href="#一、简易的计时器类" class="headerlink" title="一、简易的计时器类"></a>一、简易的计时器类</h1><p><code>mytimer.hpp</code>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MY_TIMER_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_TIMER_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mytimer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::chrono::steady_clock::time_point _begin;<span class="comment">//起始时间</span></span><br><span class="line">    std::chrono::steady_clock::time_point _end;<span class="comment">//终止时间</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">mytimer</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		_begin = std::chrono::steady_clock::<span class="built_in">time_point</span>();</span><br><span class="line">		_end = std::chrono::steady_clock::<span class="built_in">time_point</span>();</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">mytimer</span>()&#123;&#125;;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用update时，使起始时间等于当前时间</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">UpDate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _begin = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用getsecond方法时，经过的时间为当前时间减去之前统计过的起始时间。</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">GetSecond</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _end = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">        <span class="comment">//使用duration类型变量进行时间的储存   duration_cast是类型转换方法</span></span><br><span class="line">        std::chrono::duration&lt;<span class="type">double</span>&gt; temp = std::chrono::duration_cast&lt;std::chrono::duration&lt;<span class="type">double</span>&gt;&gt;(_end - _begin);</span><br><span class="line">       	<span class="keyword">return</span> temp.<span class="built_in">count</span>();<span class="comment">//count() 获取当前时间的计数数量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>测试该计时器的代码示例 <code>main.cpp</code> 代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;mytimer.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	mytimer _time;</span><br><span class="line">	_time.<span class="built_in">UpDate</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>;n&lt;<span class="number">100000000</span>;n++)</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	std::cout&lt;&lt;_time.<span class="built_in">GetSecond</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、基于chrono库的休眠"><a href="#二、基于chrono库的休眠" class="headerlink" title="二、基于chrono库的休眠"></a>二、基于chrono库的休眠</h1><p>使用方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::<span class="function">chrono::milliseconds <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;<span class="comment">//休眠一毫秒 </span></span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(t);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++标准库学习</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习记录：内存池设计与实现 及其详细代码</title>
    <url>/2021/03/01/20210301_C++%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E5%86%85%E5%AD%98%E6%B1%A0%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20%E5%8F%8A%E5%85%B6%E8%AF%A6%E7%BB%86%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>&emsp;&emsp;这是我在VS2019上写的第一个项目，使用VS2019的目的是想在更为规范的IDE上写出更加规范的代码。<br>&emsp;&emsp;使用内存池可以减少程序运行中产生的内存碎片，且可以提高程序内存分配效率从而提升程序效率。在这篇笔记中，我将记录下自己关于这个内存池项目的思路与详细代码。同时，在我的<strong>C++网络编程学习</strong>相关内容的下一步改进中，我将引入这个内存池提高服务端的运行效率。</p>
<span id="more"></span>

<h1 id="一、内存池设计思路"><a href="#一、内存池设计思路" class="headerlink" title="一、内存池设计思路"></a>一、内存池设计思路</h1><p>&emsp;&emsp;首先，为什么要使用内存池？<br>&emsp;&emsp;我是这样理解的：不断的使用<code>new/malloc</code>从堆中申请内存，会在内存中留下一些“缝隙”。例如我们申请三份8个字节大小的内存A、B、C，由于内存地址是连续的，则ABC的地址值每个相差8(正常情况)。此时我们<code>delete/free</code>掉B内存，A与C内存之间此时就有了8个字节的空白。假如我们今后申请的内存都比8个字节大，则A与C之间这块内存就会一直为空白，这就是内存碎片。<br>&emsp;&emsp;过多的内存碎片会影响程序的内存分配效率，为了降低内存碎片的影响，我们可以引入内存池来尝试解决它。</p>
<p>&emsp;&emsp;我们可以在程序启动时(或是其他合适的时机)，预先申请足够的、大小相同的内存，把这些内存放在一个容器内。在需要申请内存时，直接从容器中取出一块内存使用；而释放内存时，把这块内存放回容器中即可。这个容器就被称为<strong>内存池</strong>。而这样操作也可以大大减少内存碎片出现的可能性，提高内存申请&#x2F;释放的效率。</p>
<p>这个项目中内存池的思路图如下：<br><img src="/images/2021-03-01/1.jpg" alt="思路图"><br>我们需要新建三个类：</p>
<ul>
<li>首先是底层的<strong>内存块类</strong>，其中包含了该内存块的信息：<strong>内存块编号、引用情况、所属内存池、下一块的位置</strong>等。</li>
<li>其次是<strong>内存池类</strong>，它对成组的内存块进行管理，可以实现<strong>把内存块从内存池中取出</strong>以及<strong>把内存块放回内存池</strong>。</li>
<li>最后是<strong>内存管理工具类</strong>，其中包含一个或多个内存池，所以它要根据用户申请的内存大小找到合适的内存池，调用内存池类的方法申请&#x2F;释放内存。</li>
</ul>
<p>还需要进行的操作：</p>
<ul>
<li>对<code>new/delete</code>进行重载，使其直接调用内存管理工具类申请&#x2F;释放内存。</li>
</ul>
<p>&emsp;&emsp;上面的工作完成后，我们仍是以<code>new/delete</code>来申请&#x2F;释放内存，但是已经是通过内存池来实现的了，这个内存池项目也就暂时结束。下面我将详细记录实现的过程与思路。</p>
<h1 id="二、内存块类MemoryBlock-设计与实现"><a href="#二、内存块类MemoryBlock-设计与实现" class="headerlink" title="二、内存块类MemoryBlock 设计与实现"></a>二、内存块类<code>MemoryBlock</code> 设计与实现</h1><p>先扔出来思路图：<br><img src="/images/2021-03-01/2.jpg" alt="思路图"><br>&emsp;&emsp;首先，在内存池中每一块内存是由一个内存头以及其可用内存组成的，其中<strong>内存头</strong>里储存了这块内存的相关信息，<strong>可用内存</strong>即为数据域，类似链表中节点的结构。而一块块内存之间正是一种类似链表的结构，即通过内存头中的一个指针进行连接。内存头中包含的信息大概如下：</p>
<ul>
<li>1、内存块编号</li>
<li>2、引用情况</li>
<li>3、所属内存池</li>
<li>4、下一块位置</li>
<li>5、是否在内存池内</li>
</ul>
<p>则我们可以通过上面的思路新建内存块类<code>MemoryBlock</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">由于内存头中要标记所属内存池，所以我们先预声明内存池类，在之后再进行实现。</span><br><span class="line">建立完成后，内存池内一块内存的大小为：<span class="built_in">sizeof</span>(MemoryBlock) + 可用内存的大小</span><br><span class="line"></span><br><span class="line"><span class="comment">//预声明内存池类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemoryAlloc</span>;</span><br><span class="line"><span class="comment">//内存块类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemoryBlock</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//内存块编号</span></span><br><span class="line">	<span class="type">int</span> _nID;</span><br><span class="line">	<span class="comment">//引用情况</span></span><br><span class="line">	<span class="type">int</span> _nRef;</span><br><span class="line">	<span class="comment">//所属内存池</span></span><br><span class="line">	MemoryAlloc* _pAlloc;</span><br><span class="line">	<span class="comment">//下一块位置</span></span><br><span class="line">	MemoryBlock* _pNext;</span><br><span class="line">	<span class="comment">//是否在内存池内</span></span><br><span class="line">	<span class="type">bool</span> _bPool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="三、内存池类MemoryAlloc-设计与实现"><a href="#三、内存池类MemoryAlloc-设计与实现" class="headerlink" title="三、内存池类MemoryAlloc 设计与实现"></a>三、内存池类<code>MemoryAlloc</code> 设计与实现</h1><p>还是先扔出来<strong>内存池申请&#x2F;释放内存</strong>的思路图：<br><img src="/images/2021-03-01/3.jpg" alt="思路图"><br>&emsp;&emsp;由图可知，整个内存池的管理基本为链表结构，内存池对象一直指向头部内存单元。在申请内存时移除头部单元，类似链表头结点的移除；在释放内存时，类似链表的头插法，把回收回来的内存单元放在内存池链表的头部。</p>
<p>内存池类中大概包含这些东西：</p>
<p>1、方法</p>
<ul>
<li>1.成员变量初始化 —— 对内存单元可用内存大小以及内存单元数量进行设定</li>
<li>2.初始化 —— 依据内存单元的大小与数量，对内存池内的内存进行<code>malloc</code>申请，完善每一个内存单元的信息</li>
<li>3.申请内存 —— 从内存池链表中取出一块可用内存</li>
<li>4.释放内存 —— 将一块内存放回内存池链表中</li>
</ul>
<p>2、成员变量</p>
<ul>
<li>1.内存池地址 —— 指向内存池内的总内存</li>
<li>2.头部内存单元 —— 指向头部内存单元</li>
<li>3.内存块大小 —— 内存单元的可用内存大小</li>
<li>4.内存块数量 —— 内存单元的数量</li>
</ul>
<p>则我们可以通过上面的思路新建内存块类<code>MemoryAlloc</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入内存块头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;MemoryBlock.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemoryAlloc</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MemoryAlloc</span>();</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">MemoryAlloc</span>();</span><br><span class="line">	<span class="comment">//设置初始化</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setInit</span><span class="params">(<span class="type">size_t</span> nSize,<span class="type">size_t</span> nBlockSize)</span></span>;<span class="comment">//传入的为内存块可用内存大小和内存块数量</span></span><br><span class="line">	<span class="comment">//初始化</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">initMemory</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//申请内存</span></span><br><span class="line">	<span class="function"><span class="type">void</span>* <span class="title">allocMem</span><span class="params">(<span class="type">size_t</span> nSize)</span></span>;<span class="comment">//传入的为申请可用内存的大小</span></span><br><span class="line">	<span class="comment">//释放内存</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">freeMem</span><span class="params">(<span class="type">void</span>* p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">//内存池地址</span></span><br><span class="line">	<span class="type">char</span>* _pBuf;</span><br><span class="line">	<span class="comment">//头部内存单元</span></span><br><span class="line">	MemoryBlock* _pHeader;</span><br><span class="line">	<span class="comment">//内存块大小</span></span><br><span class="line">	<span class="type">size_t</span> _nSize;</span><br><span class="line">	<span class="comment">//内存块数量</span></span><br><span class="line">	<span class="type">size_t</span> _nBlockSize;</span><br><span class="line">	<span class="comment">//多线程锁</span></span><br><span class="line">	std::mutex _mutex;<span class="comment">//锁上申请内存方法和释放内存方法即可实现多线程操作</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="四、内存管理工具类MemoryMgr-设计与实现"><a href="#四、内存管理工具类MemoryMgr-设计与实现" class="headerlink" title="四、内存管理工具类MemoryMgr 设计与实现"></a>四、内存管理工具类<code>MemoryMgr</code> 设计与实现</h1><p>仍然是先放思路图：<br><img src="/images/2021-03-01/4.jpg" alt="思路图"><br>&emsp;&emsp;首先，内存管理工具类用的是单例对象模式，从而能简易的对内存池进行管理。在这次的实现里，我使用的是<strong>饿汉式</strong>单例对象。其次，为了更简单的判断出申请内存时所需要调用的内存池，我建立了一个数组映射内存池。在工具类构造函数内，首先是对内存池进行初始化，随后便是将其映射到数组上。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">映射：</span><br><span class="line">假如申请一个<span class="number">64</span>字节内存池，申请一个<span class="number">128</span>字节内存池</span><br><span class="line">我们新建一个指针数组test，使下标<span class="number">0</span>~<span class="number">64</span>指向<span class="number">64</span>字节内存池，下标<span class="number">65</span>~<span class="number">128</span>指向<span class="number">128</span>字节内存池</span><br><span class="line">则我们通过 test[要申请的内存大小] 即可确定合适的内存池</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在随后的申请过程中，我们首先判断申请内存大小是否超过内存池最大可用内存，若没超过，则通过映射数组指向的内存池进行内存申请；若超过了，则直接使用<code>malloc</code>申请，记得多申请一个内存头大小的内存。随后完善内存头内的资料。<br>&emsp;&emsp;在随后的释放过程中，我们通过内存头判断这块内存是否使属于内存池的内存，如果是，则通过其所属内存池进行内存回收；若不是，则直接进行<code>free</code>释放。</p>
<p>内存管理工具类中大概包含这些东西：</p>
<p>1、方法</p>
<ul>
<li>饿汉式单例模式 —— 调用返回单例对象</li>
<li>申请内存 —— 调用获取一块内存</li>
<li>释放内存 —— 调用释放一块内存</li>
<li>内存初始化 —— 将内存池映射到数组上</li>
</ul>
<p>2、成员变量</p>
<ul>
<li>映射数组 —— 映射内存池</li>
<li>内存池1</li>
<li>内存池2</li>
<li>内存池…</li>
</ul>
<p>则我们可以通过上面的思路新建内存管理工具类<code>MemoryMgr</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//内存池最大申请</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_MEMORY_SIZE 128</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//导入内存池模板类</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;MemoryAlloc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemoryMgr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//饿汉式单例模式</span></span><br><span class="line">	<span class="function"><span class="type">static</span> MemoryMgr* <span class="title">Instance</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//申请内存</span></span><br><span class="line">	<span class="function"><span class="type">void</span>* <span class="title">allocMem</span><span class="params">(<span class="type">size_t</span> nSize)</span></span>;</span><br><span class="line">	<span class="comment">//释放内存</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">freeMem</span><span class="params">(<span class="type">void</span>* p)</span></span>;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">MemoryMgr</span>();</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">MemoryMgr</span>();</span><br><span class="line">	<span class="comment">//内存映射初始化</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init_szAlloc</span><span class="params">(<span class="type">int</span> begin,<span class="type">int</span> end,MemoryAlloc* pMem)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//映射数组</span></span><br><span class="line">	MemoryAlloc* _szAlloc[MAX_MEMORY_SIZE + <span class="number">1</span>];</span><br><span class="line">	<span class="comment">//64字节内存池</span></span><br><span class="line">	MemoryAlloc _mem64;</span><br><span class="line">	<span class="comment">//128字节内存池</span></span><br><span class="line">	MemoryAlloc _mem128;</span><br><span class="line">	<span class="comment">//内存池...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="五、重载new-delete"><a href="#五、重载new-delete" class="headerlink" title="五、重载new/delete"></a>五、重载<code>new/delete</code></h1><p>重载<code>new/delete</code>就不多说了，直接放代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* p)</span></span>;</span><br><span class="line"><span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span> size);</span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span>* p);</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">mem_alloc</span><span class="params">(<span class="type">size_t</span> size)</span></span>;<span class="comment">//malloc</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mem_free</span><span class="params">(<span class="type">void</span>* p)</span></span>;<span class="comment">//free</span></span><br></pre></td></tr></table></figure>

<h1 id="六、项目代码及其注释"><a href="#六、项目代码及其注释" class="headerlink" title="六、项目代码及其注释"></a>六、项目代码及其注释</h1><h2 id="1-项目图片"><a href="#1-项目图片" class="headerlink" title="1.项目图片"></a>1.项目图片</h2><p><img src="/images/2021-03-01/5.jpg" alt="图片">)</p>
<h2 id="2-重载new-delete"><a href="#2-重载new-delete" class="headerlink" title="2.重载new/delete"></a>2.重载<code>new/delete</code></h2><h3 id="2-1-Alloctor-h"><a href="#2-1-Alloctor-h" class="headerlink" title="2.1 Alloctor.h"></a>2.1 Alloctor.h</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _Alloctor_h_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _Alloctor_h_</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* p)</span></span>;</span><br><span class="line"><span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span> size);</span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span>* p);</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">mem_alloc</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mem_free</span><span class="params">(<span class="type">void</span>* p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-Alloctor-cpp"><a href="#2-2-Alloctor-cpp" class="headerlink" title="2.2 Alloctor.cpp"></a>2.2 Alloctor.cpp</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Alloctor.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;MemoryMgr.h&quot;</span><span class="comment">//内存管理工具</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> MemoryMgr::<span class="built_in">Instance</span>()-&gt;<span class="built_in">allocMem</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MemoryMgr::<span class="built_in">Instance</span>()-&gt;<span class="built_in">freeMem</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> MemoryMgr::<span class="built_in">Instance</span>()-&gt;<span class="built_in">allocMem</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span>* p)</span><br><span class="line">&#123;</span><br><span class="line">	MemoryMgr::<span class="built_in">Instance</span>()-&gt;<span class="built_in">freeMem</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">mem_alloc</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> MemoryMgr::<span class="built_in">Instance</span>()-&gt;<span class="built_in">allocMem</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mem_free</span><span class="params">(<span class="type">void</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MemoryMgr::<span class="built_in">Instance</span>()-&gt;<span class="built_in">freeMem</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-内存池类MemoryAlloc"><a href="#3-内存池类MemoryAlloc" class="headerlink" title="3.内存池类MemoryAlloc"></a>3.内存池类<code>MemoryAlloc</code></h2><h3 id="3-1-MemoryAlloc-h"><a href="#3-1-MemoryAlloc-h" class="headerlink" title="3.1 MemoryAlloc.h"></a>3.1 MemoryAlloc.h</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">内存池类</span></span><br><span class="line"><span class="comment">对内存块进行管理</span></span><br><span class="line"><span class="comment">2021/2/26</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> Memory_Alloc_h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Memory_Alloc_h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//导入内存块头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;MemoryBlock.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemoryAlloc</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MemoryAlloc</span>();</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">MemoryAlloc</span>();</span><br><span class="line">	<span class="comment">//设置初始化</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setInit</span><span class="params">(<span class="type">size_t</span> nSize,<span class="type">size_t</span> nBlockSize)</span></span>;</span><br><span class="line">	<span class="comment">//初始化</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">initMemory</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//申请内存</span></span><br><span class="line">	<span class="function"><span class="type">void</span>* <span class="title">allocMem</span><span class="params">(<span class="type">size_t</span> nSize)</span></span>;</span><br><span class="line">	<span class="comment">//释放内存</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">freeMem</span><span class="params">(<span class="type">void</span>* p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">//内存池地址</span></span><br><span class="line">	<span class="type">char</span>* _pBuf;</span><br><span class="line">	<span class="comment">//头部内存单元</span></span><br><span class="line">	MemoryBlock* _pHeader;</span><br><span class="line">	<span class="comment">//内存块大小</span></span><br><span class="line">	<span class="type">size_t</span> _nSize;</span><br><span class="line">	<span class="comment">//内存块数量</span></span><br><span class="line">	<span class="type">size_t</span> _nBlockSize;</span><br><span class="line">	<span class="comment">//多线程锁</span></span><br><span class="line">	std::mutex _mutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-MemoryAlloc-cpp"><a href="#3-2-MemoryAlloc-cpp" class="headerlink" title="3.2 MemoryAlloc.cpp"></a>3.2 MemoryAlloc.cpp</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;MemoryAlloc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MemoryAlloc::<span class="built_in">MemoryAlloc</span>()</span><br><span class="line">&#123;</span><br><span class="line">	_pBuf = <span class="literal">nullptr</span>;</span><br><span class="line">	_pHeader = <span class="literal">nullptr</span>;</span><br><span class="line">	_nSize = <span class="number">0</span>;</span><br><span class="line">	_nBlockSize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MemoryAlloc::~<span class="built_in">MemoryAlloc</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (_pBuf)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">free</span>(_pBuf);</span><br><span class="line">		<span class="comment">//现在有一个问题就是内存池外申请的内存不会被主动释放</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MemoryAlloc::setInit</span><span class="params">(<span class="type">size_t</span> nSize, <span class="type">size_t</span> nBlockSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*补全nSize</span></span><br><span class="line"><span class="comment">	const size_t n = sizeof(void*)</span></span><br><span class="line"><span class="comment">	_nSize = (nSize/n) * n + (nSize % n ? n : 0);</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	_pBuf = <span class="literal">nullptr</span>;</span><br><span class="line">	_pHeader = <span class="literal">nullptr</span>;</span><br><span class="line">	_nSize = nSize;</span><br><span class="line">	_nBlockSize = nBlockSize;</span><br><span class="line">	<span class="built_in">initMemory</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MemoryAlloc::initMemory</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//断言</span></span><br><span class="line">	<span class="built_in">assert</span>(<span class="literal">nullptr</span> == _pBuf);</span><br><span class="line">	<span class="comment">//若已申请则返回</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">nullptr</span> != _pBuf)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//计算内存池的大小  (块大小+块头) * 块数量</span></span><br><span class="line">	<span class="type">size_t</span> temp_size = _nSize + <span class="built_in">sizeof</span>(MemoryBlock);<span class="comment">//需要偏移的真正大小</span></span><br><span class="line">	<span class="type">size_t</span> bufSize = temp_size * _nBlockSize;</span><br><span class="line">	<span class="comment">//向系统申请池内存</span></span><br><span class="line">	_pBuf = (<span class="type">char</span>*)<span class="built_in">malloc</span>(bufSize);</span><br><span class="line">	<span class="comment">//初始化内存池</span></span><br><span class="line">	_pHeader = (MemoryBlock*)_pBuf;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">nullptr</span> != _pHeader)</span><br><span class="line">	&#123;</span><br><span class="line">		_pHeader-&gt;_bPool = <span class="literal">true</span>;<span class="comment">//在池中</span></span><br><span class="line">		_pHeader-&gt;_nID = <span class="number">0</span>;<span class="comment">//第0块</span></span><br><span class="line">		_pHeader-&gt;_nRef = <span class="number">0</span>;<span class="comment">//引用次数为0</span></span><br><span class="line">		_pHeader-&gt;_pAlloc = <span class="keyword">this</span>;<span class="comment">//属于当前内存池</span></span><br><span class="line">		_pHeader-&gt;_pNext = <span class="literal">nullptr</span>;<span class="comment">//下一块</span></span><br><span class="line">		MemoryBlock* pTemp1 = _pHeader;</span><br><span class="line">		<span class="comment">//遍历内存块进行初始化</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">size_t</span> n = <span class="number">1</span>; n &lt; _nBlockSize; n++)</span><br><span class="line">		&#123;</span><br><span class="line">			MemoryBlock* pTemp2 = (MemoryBlock*)(_pBuf + (n * temp_size));<span class="comment">//指针偏移到下一块</span></span><br><span class="line">			pTemp2-&gt;_bPool = <span class="literal">true</span>;<span class="comment">//在池中</span></span><br><span class="line">			pTemp2-&gt;_nID = n;<span class="comment">//第n块</span></span><br><span class="line">			pTemp2-&gt;_nRef = <span class="number">0</span>;</span><br><span class="line">			pTemp2-&gt;_pAlloc = <span class="keyword">this</span>;</span><br><span class="line">			pTemp2-&gt;_pNext = <span class="literal">nullptr</span>;</span><br><span class="line">			pTemp1-&gt;_pNext = pTemp2;</span><br><span class="line">			pTemp1 = pTemp2;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">MemoryAlloc::allocMem</span><span class="params">(<span class="type">size_t</span> nSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//自解锁</span></span><br><span class="line">	<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">	<span class="comment">//若内存池不存在则初始化</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">nullptr</span> == _pBuf)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">initMemory</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	MemoryBlock* pReturn = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">nullptr</span> == _pHeader)<span class="comment">//如内存池已满 重新申请</span></span><br><span class="line">	&#123;</span><br><span class="line">		pReturn = (MemoryBlock*)<span class="built_in">malloc</span>(nSize+<span class="built_in">sizeof</span>(MemoryBlock));</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">nullptr</span> != pReturn)</span><br><span class="line">		&#123;</span><br><span class="line">			pReturn-&gt;_bPool = <span class="literal">false</span>;<span class="comment">//不在池中</span></span><br><span class="line">			pReturn-&gt;_nID = <span class="number">-1</span>;</span><br><span class="line">			pReturn-&gt;_nRef = <span class="number">1</span>;</span><br><span class="line">			pReturn-&gt;_pAlloc = <span class="keyword">this</span>;</span><br><span class="line">			pReturn-&gt;_pNext = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span><span class="comment">//否则直接使用内存池</span></span><br><span class="line">	&#123;</span><br><span class="line">		pReturn = _pHeader;</span><br><span class="line">		_pHeader = _pHeader-&gt;_pNext;</span><br><span class="line">		<span class="built_in">assert</span>(<span class="number">0</span> == pReturn-&gt;_nRef);</span><br><span class="line">		pReturn-&gt;_nRef = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//debug打印</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">nullptr</span> != pReturn)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">xPrintf</span>(<span class="string">&quot;NEW - allocMem:%p,id=%d,size=%d\n&quot;</span>, pReturn, pReturn-&gt;_nID, nSize);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> ((<span class="type">char</span>*)pReturn + <span class="built_in">sizeof</span>(MemoryBlock));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MemoryAlloc::freeMem</span><span class="params">(<span class="type">void</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//传进来的是消息区 需要加上信息头</span></span><br><span class="line">	MemoryBlock* pBlock = (MemoryBlock*)((<span class="type">char</span>*)p - <span class="built_in">sizeof</span>(MemoryBlock));</span><br><span class="line">	<span class="built_in">assert</span>(<span class="number">1</span> == pBlock-&gt;_nRef);</span><br><span class="line">	<span class="comment">//判断是否被多次引用</span></span><br><span class="line">	<span class="keyword">if</span> (--pBlock-&gt;_nRef != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//判断是否在内存池中</span></span><br><span class="line">	<span class="keyword">if</span> (pBlock-&gt;_bPool)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//自解锁</span></span><br><span class="line">		<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">		<span class="comment">//把内存块放入内存池首位</span></span><br><span class="line">		pBlock-&gt;_pNext = _pHeader;</span><br><span class="line">		_pHeader = pBlock;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">free</span>(pBlock);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-内存块类MemoryBlock"><a href="#4-内存块类MemoryBlock" class="headerlink" title="4.内存块类MemoryBlock"></a>4.内存块类<code>MemoryBlock</code></h2><h3 id="4-1-MemoryBlock-h"><a href="#4-1-MemoryBlock-h" class="headerlink" title="4.1 MemoryBlock.h"></a>4.1 MemoryBlock.h</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">内存块类</span></span><br><span class="line"><span class="comment">内存管理的最小单位</span></span><br><span class="line"><span class="comment">2021/2/26</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> Memory_Block_h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Memory_Block_h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明内存池类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemoryAlloc</span>;</span><br><span class="line"><span class="comment">//最底层导入内存头文件/断言头文件/锁头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="comment">//如果为debug模式则加入调试信息</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> xPrintf(...) printf(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> xPrintf(...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemoryBlock</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//内存块编号</span></span><br><span class="line">	<span class="type">int</span> _nID;</span><br><span class="line">	<span class="comment">//引用情况</span></span><br><span class="line">	<span class="type">int</span> _nRef;</span><br><span class="line">	<span class="comment">//所属内存池</span></span><br><span class="line">	MemoryAlloc* _pAlloc;</span><br><span class="line">	<span class="comment">//下一块位置</span></span><br><span class="line">	MemoryBlock* _pNext;</span><br><span class="line">	<span class="comment">//是否在内存池内</span></span><br><span class="line">	<span class="type">bool</span> _bPool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="4-2-MemoryBlock-cpp"><a href="#4-2-MemoryBlock-cpp" class="headerlink" title="4.2 MemoryBlock.cpp"></a>4.2 MemoryBlock.cpp</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;MemoryBlock.h&quot;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="5-内存管理工具类MemoryMgr"><a href="#5-内存管理工具类MemoryMgr" class="headerlink" title="5.内存管理工具类MemoryMgr"></a>5.内存管理工具类<code>MemoryMgr</code></h2><h3 id="5-1-MemoryMgr-h"><a href="#5-1-MemoryMgr-h" class="headerlink" title="5.1 MemoryMgr.h"></a>5.1 MemoryMgr.h</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">内存管理工具类</span></span><br><span class="line"><span class="comment">对内存池进行管理</span></span><br><span class="line"><span class="comment">2021/2/26</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> Memory_Mgr_h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Memory_Mgr_h</span></span><br><span class="line"><span class="comment">//内存池最大申请</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_MEMORY_SIZE 128</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//导入内存池模板类</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;MemoryAlloc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemoryMgr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//饿汉式单例模式</span></span><br><span class="line">	<span class="function"><span class="type">static</span> MemoryMgr* <span class="title">Instance</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//申请内存</span></span><br><span class="line">	<span class="function"><span class="type">void</span>* <span class="title">allocMem</span><span class="params">(<span class="type">size_t</span> nSize)</span></span>;</span><br><span class="line">	<span class="comment">//释放内存</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">freeMem</span><span class="params">(<span class="type">void</span>* p)</span></span>;</span><br><span class="line">	<span class="comment">//增加内存块引用次数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">addRef</span><span class="params">(<span class="type">void</span>* p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">MemoryMgr</span>();</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">MemoryMgr</span>();</span><br><span class="line">	<span class="comment">//内存映射初始化</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init_szAlloc</span><span class="params">(<span class="type">int</span> begin,<span class="type">int</span> end,MemoryAlloc* pMem)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//映射数组</span></span><br><span class="line">	MemoryAlloc* _szAlloc[MAX_MEMORY_SIZE + <span class="number">1</span>];</span><br><span class="line">	<span class="comment">//64字节内存池</span></span><br><span class="line">	MemoryAlloc _mem64;</span><br><span class="line">	<span class="comment">//128字节内存池</span></span><br><span class="line">	MemoryAlloc _mem128;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="5-2-MemoryMgr-cpp"><a href="#5-2-MemoryMgr-cpp" class="headerlink" title="5.2 MemoryMgr.cpp"></a>5.2 MemoryMgr.cpp</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;MemoryMgr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MemoryMgr::<span class="built_in">MemoryMgr</span>()</span><br><span class="line">&#123;</span><br><span class="line">	_mem<span class="number">64.</span><span class="built_in">setInit</span>(<span class="number">64</span>, <span class="number">10</span>);</span><br><span class="line">	<span class="built_in">init_szAlloc</span>(<span class="number">0</span>, <span class="number">64</span>, &amp;_mem64);</span><br><span class="line">	_mem<span class="number">128.</span><span class="built_in">setInit</span>(<span class="number">128</span>, <span class="number">10</span>);</span><br><span class="line">	<span class="built_in">init_szAlloc</span>(<span class="number">65</span>, <span class="number">128</span>, &amp;_mem128);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MemoryMgr::~<span class="built_in">MemoryMgr</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MemoryMgr::init_szAlloc</span><span class="params">(<span class="type">int</span> begin, <span class="type">int</span> end, MemoryAlloc* pMem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//begin到end大小的内存申请都映射到相关的内存池上</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = begin; i &lt;= end; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		_szAlloc[i] = pMem;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//饿汉式单例模式</span></span><br><span class="line"><span class="function">MemoryMgr* <span class="title">MemoryMgr::Instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> MemoryMgr myMemoryMgr;</span><br><span class="line">	<span class="comment">//单例对象</span></span><br><span class="line">	<span class="keyword">return</span> &amp;myMemoryMgr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//申请内存</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">MemoryMgr::allocMem</span><span class="params">(<span class="type">size_t</span> nSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//若申请的内存大小正常，则直接申请</span></span><br><span class="line">	<span class="keyword">if</span> (nSize &lt;= MAX_MEMORY_SIZE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> _szAlloc[nSize]-&gt;<span class="built_in">allocMem</span>(nSize);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span><span class="comment">//否则用malloc申请一个</span></span><br><span class="line">	&#123;</span><br><span class="line">		MemoryBlock* pReturn = (MemoryBlock*)<span class="built_in">malloc</span>(nSize + <span class="built_in">sizeof</span>(MemoryBlock));</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">nullptr</span> != pReturn)</span><br><span class="line">		&#123;</span><br><span class="line">			pReturn-&gt;_bPool = <span class="literal">false</span>;<span class="comment">//不在池中</span></span><br><span class="line">			pReturn-&gt;_nID = <span class="number">-1</span>;</span><br><span class="line">			pReturn-&gt;_nRef = <span class="number">1</span>;</span><br><span class="line">			pReturn-&gt;_pAlloc = <span class="literal">nullptr</span>;</span><br><span class="line">			pReturn-&gt;_pNext = <span class="literal">nullptr</span>;</span><br><span class="line">			<span class="comment">//debug打印</span></span><br><span class="line">			<span class="built_in">xPrintf</span>(<span class="string">&quot;NEW - allocMem:%p,id=%d,size=%d\n&quot;</span>,pReturn,pReturn-&gt;_nID,nSize);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ((<span class="type">char</span>*)pReturn + <span class="built_in">sizeof</span>(MemoryBlock));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放内存</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MemoryMgr::freeMem</span><span class="params">(<span class="type">void</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//传进来的是消息区 需要加上信息头</span></span><br><span class="line">	MemoryBlock* pBlock = (MemoryBlock*)((<span class="type">char</span>*)p - <span class="built_in">sizeof</span>(MemoryBlock));</span><br><span class="line">	<span class="comment">//debug打印</span></span><br><span class="line">	<span class="built_in">xPrintf</span>(<span class="string">&quot;DELETE - allocMem:%p,id=%d\n&quot;</span>, pBlock, pBlock-&gt;_nID);</span><br><span class="line">	<span class="comment">//内存池内的内存块/内存池外的内存块 不同的处理方式</span></span><br><span class="line">	<span class="keyword">if</span> (pBlock-&gt;_bPool == <span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		pBlock-&gt;_pAlloc-&gt;<span class="built_in">freeMem</span>(p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (--pBlock-&gt;_nRef == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">free</span>(pBlock);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加内存块引用次数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MemoryMgr::addRef</span><span class="params">(<span class="type">void</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MemoryBlock* pBlock = (MemoryBlock*)((<span class="type">char</span>*)p - <span class="built_in">sizeof</span>(MemoryBlock));</span><br><span class="line">	++pBlock-&gt;_nRef;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="6-main文件"><a href="#6-main文件" class="headerlink" title="6.main文件"></a>6.<code>main</code>文件</h2><h3 id="6-1-main-cpp"><a href="#6-1-main-cpp" class="headerlink" title="6.1 main.cpp"></a>6.1 main.cpp</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Alloctor.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span>* data2 = <span class="keyword">new</span> <span class="type">char</span>;</span><br><span class="line">	<span class="keyword">delete</span> data2;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span>* data1 = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">129</span>];</span><br><span class="line">	<span class="keyword">delete</span>[] data1;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span>* data3 = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">65</span>];</span><br><span class="line">	<span class="keyword">delete</span>[] data3;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;--------------------------\n&quot;</span>);</span><br><span class="line">	<span class="type">char</span>* data[<span class="number">15</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		data[i] = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">64</span>];</span><br><span class="line">		<span class="keyword">delete</span>[] data[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="七、小结"><a href="#七、小结" class="headerlink" title="七、小结"></a>七、小结</h1><ul>
<li>在申请与释放内存时，返回给用户和用户传进来的都是可用内存的地址，并不是内存头的地址。我们需要对地址进行偏移，从而返回&#x2F;接收正确的地址。具体为可用内存地址向前偏移一个内存头大小即为内存头地址；内存头地址向后偏移一个内存头大小即为可用内存地址。</li>
<li>内存池初始化时，申请总地址大小为：(可用地址大小+内存头大小) * 内存单元数量</li>
<li>内存池外申请的内存，不会在内存池析构函数内被释放，需要手动释放。（不过一般触发析构函数的时候，也不用手动释放了）</li>
<li>在这次的项目中，我对地址、内存等有了更深刻的理解，同时也能熟练使用VS的调试功能。希望未来能有更大的发展。</li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 蓝桥杯 Java实现 10月C组省赛</title>
    <url>/2021/03/01/20210301-02_2020%E8%93%9D%E6%A1%A5%E6%9D%AFJava%E5%AE%9E%E7%8E%B010%E6%9C%88C%E7%BB%84%E7%9C%81%E8%B5%9B/</url>
    <content><![CDATA[<ul>
<li>几个月没写题了，先找找手感，从简单的C组开始吧。</li>
</ul>
<p><strong>2020 蓝桥杯 Java实现 10月C组省赛 题目 &amp; 题解</strong></p>
<span id="more"></span>

<h1 id="试题-A-约数个数"><a href="#试题-A-约数个数" class="headerlink" title="试题 A: 约数个数"></a>试题 A: 约数个数</h1><p>本题总分：5 分</p>
<p><strong>问题：</strong><br>对于一个整数，能整除这个整数的数称为这个数的约数。<br>例如：1, 2, 3, 6 都是 6 的约数。<br>请问 78120 有多少个约数。</p>
<p><strong>思路：</strong> 暴力</p>
<p><strong>答案：</strong> 96</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.printf(<span class="string">&quot;%d&quot;</span>,func(<span class="number">78120</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> a)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1</span>;now&lt;=a;now++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="number">0</span> == a%now)</span><br><span class="line">			&#123;</span><br><span class="line">				temp++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> temp; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="试题-B-寻找-2020"><a href="#试题-B-寻找-2020" class="headerlink" title="试题 B: 寻找 2020"></a>试题 B: 寻找 2020</h1><p>本题总分：5 分</p>
<p><code>附件在本篇末尾</code></p>
<p><strong>问题：</strong></p>
<p>小蓝有一个数字矩阵，里面只包含数字 0 和 2。小蓝很喜欢 2020，他想找到这个数字矩阵中有多少个 2020 。<br>小蓝只关注三种构成 2020 的方式：</p>
<p>同一行里面连续四个字符从左到右构成 2020。<br>同一列里面连续四个字符从上到下构成 2020。<br>在一条从左上到右下的斜线上连续四个字符，从左上到右下构成 2020。<br>例如，对于下面的矩阵：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">220000</span></span><br><span class="line"><span class="number">000000</span></span><br><span class="line"><span class="number">002202</span></span><br><span class="line"><span class="number">000000</span></span><br><span class="line"><span class="number">000022</span></span><br><span class="line"><span class="number">002020</span></span><br></pre></td></tr></table></figure>
<p>一共有 5 个 2020。其中 1 个是在同一行里的，1 个是在同一列里的，3 个是斜线上的。<br>小蓝的矩阵比上面的矩阵要大，由于太大了，他只好将这个矩阵放在了一个文件里面，在试题目录下有一个文件 2020.txt，里面给出了小蓝的矩阵。<br>请帮助小蓝确定在他的矩阵中有多少个 2020。</p>
<p><strong>思路：</strong> 暴力</p>
<p><strong>答案：</strong> 16120</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:/demo/1.txt&quot;</span>)));</span><br><span class="line">		<span class="type">char</span>[][] map = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">300</span>][];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">300</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			map[i] = in.readLine().toCharArray();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">0</span>;y&lt;<span class="number">300</span>;y++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;x&lt;<span class="number">300</span>;x++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//横排</span></span><br><span class="line">				<span class="keyword">if</span>(x&lt;=<span class="number">296</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(map[y][x]==<span class="string">&#x27;2&#x27;</span>&amp;&amp;map[y][x+<span class="number">1</span>]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;map[y][x+<span class="number">2</span>]==<span class="string">&#x27;2&#x27;</span>&amp;&amp;map[y][x+<span class="number">3</span>]==<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						ans++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//竖排</span></span><br><span class="line">				<span class="keyword">if</span>(y&lt;=<span class="number">296</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(map[y][x]==<span class="string">&#x27;2&#x27;</span>&amp;&amp;map[y+<span class="number">1</span>][x]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;map[y+<span class="number">2</span>][x]==<span class="string">&#x27;2&#x27;</span>&amp;&amp;map[y+<span class="number">3</span>][x]==<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						ans++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//斜排</span></span><br><span class="line">				<span class="keyword">if</span>(y&lt;=<span class="number">296</span>&amp;&amp;x&lt;=<span class="number">296</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(map[y][x]==<span class="string">&#x27;2&#x27;</span>&amp;&amp;map[y+<span class="number">1</span>][x+<span class="number">1</span>]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;map[y+<span class="number">2</span>][x+<span class="number">2</span>]==<span class="string">&#x27;2&#x27;</span>&amp;&amp;map[y+<span class="number">3</span>][x+<span class="number">3</span>]==<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						ans++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	    System.out.print(ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="试题-C-跑步锻炼"><a href="#试题-C-跑步锻炼" class="headerlink" title="试题 C: 跑步锻炼"></a>试题 C: 跑步锻炼</h1><p>本题总分：10 分</p>
<p><strong>问题：</strong><br>小蓝每天都锻炼身体。<br>正常情况下，小蓝每天跑 1 千米。如果某天是周一或者月初（1 日），为了激励自己，小蓝要跑 2 千米。如果同时是周一或月初，小蓝也是跑 2 千米。<br>小蓝跑步已经坚持了很长时间，从 2000 年 1 月 1 日周六（含）到 2020 年10 月 1 日周四（含）。请问这段时间小蓝总共跑步多少千米？</p>
<p><strong>思路：</strong> 根据平年闰年进行暴力</p>
<p><strong>答案：</strong> 8879</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">judge</span><span class="params">(<span class="type">int</span> year)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>((year%<span class="number">4</span>==<span class="number">0</span> &amp;&amp; year%<span class="number">100</span>!=<span class="number">0</span>) || year%<span class="number">400</span>==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span>[] p = &#123;<span class="number">0</span>,<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;<span class="comment">//平年1月到12月</span></span><br><span class="line">		<span class="type">int</span>[] r = &#123;<span class="number">0</span>,<span class="number">31</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;<span class="comment">//闰年1月到12月</span></span><br><span class="line">		<span class="comment">//起始日期</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> <span class="number">2000</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">xq</span> <span class="operator">=</span> <span class="number">6</span>;<span class="comment">//星期6</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//公里</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(year==<span class="number">2020</span> &amp;&amp; month==<span class="number">10</span> &amp;&amp; day==<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				ans+=<span class="number">2</span>;<span class="comment">//10月1号也算上</span></span><br><span class="line">				System.out.print(ans);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(day==<span class="number">1</span> || xq==<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				ans+=<span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				ans++;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			xq = ++xq % <span class="number">7</span>;</span><br><span class="line">			day+=<span class="number">1</span>;</span><br><span class="line">			</span><br><span class="line">			<span class="type">int</span> <span class="variable">state</span> <span class="operator">=</span> judge(year);<span class="comment">//1为闰年 0为平年</span></span><br><span class="line">			<span class="keyword">if</span>(state == <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(day&gt;r[month])</span><br><span class="line">				&#123;</span><br><span class="line">					day=<span class="number">1</span>;</span><br><span class="line">					month++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(day&gt;p[month])</span><br><span class="line">				&#123;</span><br><span class="line">					day=<span class="number">1</span>;</span><br><span class="line">					month++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(month&gt;<span class="number">12</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				month=<span class="number">1</span>;</span><br><span class="line">				year++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="试题-D-平面分割"><a href="#试题-D-平面分割" class="headerlink" title="试题 D: 平面分割"></a>试题 D: 平面分割</h1><p>本题总分：10 分</p>
<p><strong>问题：</strong><br>20 个圆和 20 条直线最多能把平面分成多少个部分？</p>
<p><strong>思路：</strong> 数学题…不会啊，放一个知乎大佬的回答</p>
<p><strong>答案：</strong> 1391<br><a href="https://www.zhihu.com/question/426034179">大佬在这 点我去看大佬</a></p>
<h1 id="试题-E-七段码"><a href="#试题-E-七段码" class="headerlink" title="试题 E: 七段码"></a>试题 E: 七段码</h1><p>本题总分：15 分</p>
<p><strong>问题：</strong><br>小蓝要用七段码数码管来表示一种特殊的文字。<br><img src="/images/2021-03-01/02-1.jpg" alt="图"><br>上图给出了七段码数码管的一个图示，数码管中一共有 7 段可以发光的二极管，分别标记为 a, b, c, d, e, f, g。<br>小蓝要选择一部分二极管（至少要有一个）发光来表达字符。在设计字符的表达时，要求所有发光的二极管是连成一片的。</p>
<p>例如：b 发光，其他二极管不发光可以用来表达一种字符。<br>例如：c 发光，其他二极管不发光可以用来表达一种字符。这种方案与上<br>一行的方案可以用来表示不同的字符，尽管看上去比较相似。</p>
<p>例如：a, b, c, d, e 发光，f, g 不发光可以用来表达一种字符。<br>例如：b, f 发光，其他二极管不发光则不能用来表达一种字符，因为发光的二极管没有连成一片。<br>请问，小蓝可以用七段码数码管表达多少种不同的字符？</p>
<p><strong>思路：</strong> dfs出所有情况，然后用并查集判断是否属于同一子集</p>
<p><strong>答案：</strong> 80</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span>[] jl = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span>[][] map = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span>[] father = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//储存关系 a~g对应1~7</span></span><br><span class="line">		map[<span class="number">1</span>][<span class="number">2</span>] = map[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">1</span>;<span class="comment">//a b</span></span><br><span class="line">		map[<span class="number">1</span>][<span class="number">6</span>] = map[<span class="number">6</span>][<span class="number">1</span>] = <span class="number">1</span>;<span class="comment">//a f</span></span><br><span class="line">		map[<span class="number">2</span>][<span class="number">7</span>] = map[<span class="number">7</span>][<span class="number">2</span>] = <span class="number">1</span>;<span class="comment">//b g</span></span><br><span class="line">		map[<span class="number">2</span>][<span class="number">3</span>] = map[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">1</span>;<span class="comment">//b c</span></span><br><span class="line">		map[<span class="number">3</span>][<span class="number">4</span>] = map[<span class="number">4</span>][<span class="number">3</span>] = <span class="number">1</span>;<span class="comment">//c d </span></span><br><span class="line">		map[<span class="number">3</span>][<span class="number">7</span>] = map[<span class="number">7</span>][<span class="number">3</span>] = <span class="number">1</span>;<span class="comment">//c g</span></span><br><span class="line">		map[<span class="number">4</span>][<span class="number">5</span>] = map[<span class="number">5</span>][<span class="number">4</span>] = <span class="number">1</span>;<span class="comment">//d e</span></span><br><span class="line">		map[<span class="number">5</span>][<span class="number">6</span>] = map[<span class="number">6</span>][<span class="number">5</span>] = <span class="number">1</span>;<span class="comment">//e f</span></span><br><span class="line">		map[<span class="number">5</span>][<span class="number">7</span>] = map[<span class="number">7</span>][<span class="number">5</span>] = <span class="number">1</span>;<span class="comment">//e g </span></span><br><span class="line">		map[<span class="number">6</span>][<span class="number">7</span>] = map[<span class="number">7</span>][<span class="number">6</span>] = <span class="number">1</span>;<span class="comment">//f g</span></span><br><span class="line">		<span class="comment">//dfs遍历所有情况</span></span><br><span class="line">		dfs(<span class="number">0</span>);</span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		System.out.print(ans);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//当7个灯都有状态时 进行判定</span></span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">7</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//把亮着的灯统计下来</span></span><br><span class="line">			ArrayList&lt;Integer&gt; a = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">7</span>;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(jl[i]==<span class="number">1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					a.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(i));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//判断</span></span><br><span class="line">			<span class="keyword">if</span>(a.size()!=<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(judge(a)==<span class="number">1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					ans++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			a.clear();</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//否则dfs灯情况</span></span><br><span class="line">		jl[n+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">		dfs(n+<span class="number">1</span>);</span><br><span class="line">		jl[n+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">		dfs(n+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">judge</span><span class="params">(ArrayList&lt;Integer&gt; a)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//System.out.println(++js);</span></span><br><span class="line">		<span class="comment">//并查集父集重置</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			father[i] = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//并集</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.size();i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> ii=<span class="number">0</span>;ii&lt;a.size();ii++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//如果两边相连的话 进行并集操作</span></span><br><span class="line">				<span class="keyword">if</span>(map[a.get(i).intValue()][a.get(ii).intValue()]==<span class="number">1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="type">int</span> <span class="variable">fx</span> <span class="operator">=</span> find(a.get(i).intValue());</span><br><span class="line">					<span class="type">int</span> <span class="variable">fy</span> <span class="operator">=</span> find(a.get(ii).intValue());	</span><br><span class="line">					<span class="keyword">if</span>(fx!=fy)</span><br><span class="line">					&#123;</span><br><span class="line">						father[fx] = fy;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;	</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//查看是否都属于一个集合</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> find(a.get(<span class="number">0</span>).intValue());</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;a.size();i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(find(a.get(i).intValue())!=temp)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//查集</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> father[x]==x ? x : (father[x] = find(father[x]));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>以下题目部分能通过<a href="https://www.acwing.com/problem/">AcWing</a>和<a href="https://www.lanqiao.cn/problems/">蓝桥杯竞赛</a>的数据测试（有的题没有被录入，无法测试）</li>
</ul>
<h1 id="试题-F-成绩统计"><a href="#试题-F-成绩统计" class="headerlink" title="试题 F: 成绩统计"></a>试题 F: 成绩统计</h1><p>时间限制: 1.0s 内存限制: 512.0MB<br>本题总分：15 分</p>
<p><strong>问题：</strong><br>小蓝给学生们组织了一场考试，卷面总分为 100 分，每个学生的得分都是一个 0 到 100 的整数。<br>如果得分至少是 60 分，则称为及格。如果得分至少为 85 分，则称为优秀。<br>请计算及格率和优秀率，用百分数表示，百分号前的部分四舍五入保留整数。</p>
<p><strong>输入：</strong><br>输入的第一行包含一个整数 n，表示考试人数。<br>接下来 n 行，每行包含一个 0 至 100 的整数，表示一个学生的得分。</p>
<p><strong>输出：</strong><br>输出两行，每行一个百分数，分别表示及格率和优秀率。百分号前的部分四舍五入保留整数。</p>
<p><strong>样例输入：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">80</span></span><br><span class="line"><span class="number">92</span></span><br><span class="line"><span class="number">56</span></span><br><span class="line"><span class="number">74</span></span><br><span class="line"><span class="number">88</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>
<p><strong>样例输出：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">71</span>%</span><br><span class="line"><span class="number">43</span>%</span><br></pre></td></tr></table></figure>
<p><strong>评测用例规模与约定：</strong><br>对于 50% 的评测用例，1 ≤ n ≤ 100。<br>对于所有评测用例，1 ≤ n ≤ 10000。</p>
<p><strong>思路：</strong> 送分题，记得四舍五入保留整数</p>
<p><strong>AC代码：</strong> <a href="https://www.acwing.com/problem/content/2874/">OJ链接</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">double</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextDouble();</span><br><span class="line">		<span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;n;now++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">			<span class="keyword">if</span>(temp&gt;=<span class="number">60</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				a++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(temp&gt;=<span class="number">85</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				b++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println((<span class="type">int</span>)(a/n*<span class="number">100</span>+<span class="number">0.5</span>)+<span class="string">&quot;%&quot;</span>);</span><br><span class="line">		System.out.println((<span class="type">int</span>)(b/n*<span class="number">100</span>+<span class="number">0.5</span>)+<span class="string">&quot;%&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="试题-G-单词分析"><a href="#试题-G-单词分析" class="headerlink" title="试题 G: 单词分析"></a>试题 G: 单词分析</h1><p>时间限制: 1.0s 内存限制: 512.0MB<br>本题总分：20 分</p>
<p><strong>问题：</strong><br>小蓝正在学习一门神奇的语言，这门语言中的单词都是由小写英文字母组成，有些单词很长，远远超过正常英文单词的长度。小蓝学了很长时间也记不住一些单词，他准备不再完全记忆这些单词，而是根据单词中哪个字母出现得最多来分辨单词。<br>现在，请你帮助小蓝，给了一个单词后，帮助他找到出现最多的字母和这个字母出现的次数。</p>
<p><strong>输入：</strong><br>输入一行包含一个单词，单词只由小写英文字母组成。</p>
<p><strong>问题：</strong><br>输出两行，第一行包含一个英文字母，表示单词中出现得最多的字母是哪个。如果有多个字母出现的次数相等，输出字典序最小的那个。<br>第二行包含一个整数，表示出现得最多的那个字母在单词中出现的次数。</p>
<p><strong>样例输入：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lanqiao</span><br></pre></td></tr></table></figure>
<p><strong>样例输出：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><strong>样例输入：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">longlonglongistoolong</span><br></pre></td></tr></table></figure>
<p><strong>样例输出：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">o</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>
<p><strong>评测用例规模与约定：</strong><br>对于所有的评测用例，输入的单词长度不超过 1000。</p>
<p><strong>思路：</strong> 暴力统计即可</p>
<p><strong>代码：</strong> <a href="https://www.lanqiao.cn/problems/504/learning/">OJ链接</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">		<span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">30</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;s.length();now++)</span><br><span class="line">		&#123;</span><br><span class="line">			ans[(<span class="type">int</span>)(s.charAt(now)-<span class="string">&#x27;a&#x27;</span>)+<span class="number">1</span>]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1</span>;now&lt;=<span class="number">26</span>;now++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(ans[end]&lt;ans[now])</span><br><span class="line">			&#123;</span><br><span class="line">				end = now;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println((<span class="type">char</span>)(<span class="string">&#x27;a&#x27;</span>+end-<span class="number">1</span>));</span><br><span class="line">		System.out.println(ans[end]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="试题-H-数字三角形"><a href="#试题-H-数字三角形" class="headerlink" title="试题 H: 数字三角形"></a>试题 H: 数字三角形</h1><p>时间限制: 1.0s 内存限制: 512.0MB<br>本题总分：20 分<br><img src="/images/2021-03-01/02-2.jpg" alt="图"><br><strong>问题：</strong><br>上图给出了一个数字三角形。从三角形的顶部到底部有很多条不同的路径。<br>对于每条路径，把路径上面的数加起来可以得到一个和，你的任务就是找到最大的和。<br>路径上的每一步只能从一个数走到下一层和它最近的左边的那个数或者右边的那个数。此外，向左下走的次数与向右下走的次数相差不能超过 1。</p>
<p><strong>输入：</strong><br>输入的第一行包含一个整数 N (1 &lt; N ≤ 100)，表示三角形的行数。下面的N 行给出数字三角形。数字三角形上的数都是 0 至 100 之间的整数。</p>
<p><strong>输出：</strong><br>输出一个整数，表示答案。</p>
<p><strong>样例输入：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">3</span> <span class="number">8</span></span><br><span class="line"><span class="number">8</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">2</span> <span class="number">7</span> <span class="number">4</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">2</span> <span class="number">6</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p><strong>样例输出：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">27</span></span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong> C组这题是简化过的，数据量少了，也多了条件，所以直接dfs暴力就好。当左右差减一大于剩下行数时，说明走到末尾时必定相差超过1，可以进行剪枝。</p>
<p><strong>AC代码：</strong><br><a href="https://www.lanqiao.cn/problems/505/learning/">OJ链接1</a> <code>链接里是本题版本，用DFS写</code><br><a href="https://www.acwing.com/problem/content/900/">OJ链接2</a> <code>链接里是未简化的版本，用DP写</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span>[][] map = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">510</span>][<span class="number">510</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		num = sc.nextInt();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=num;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> ii=<span class="number">1</span>;ii&lt;=i;ii++)</span><br><span class="line">			&#123;</span><br><span class="line">				map[i][ii]=sc.nextInt();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		dfs(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>+map[<span class="number">1</span>][<span class="number">1</span>],<span class="number">0</span>);</span><br><span class="line">		System.out.print(ans);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> y,<span class="type">int</span> x,<span class="type">int</span> he,<span class="type">int</span> cha)</span><span class="comment">//y x 和  左右差</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(x&lt;=<span class="number">0</span>||x&gt;y)<span class="comment">//剪枝 越界</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(Math.abs(cha)-<span class="number">1</span>&gt;(num-y))<span class="comment">//剪枝 左右差大于剩下行数 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(y==num)<span class="comment">//到达最底层</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(he&gt;ans&amp;&amp;Math.abs(cha)&lt;=<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				ans = he;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		dfs(y+<span class="number">1</span>,x,he+map[y+<span class="number">1</span>][x],cha-<span class="number">1</span>);<span class="comment">//左下</span></span><br><span class="line">		dfs(y+<span class="number">1</span>,x+<span class="number">1</span>,he+map[y+<span class="number">1</span>][x+<span class="number">1</span>],cha+<span class="number">1</span>);<span class="comment">//右下</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="试题-I-作物杂交"><a href="#试题-I-作物杂交" class="headerlink" title="试题 I: 作物杂交"></a>试题 I: 作物杂交</h1><p>时间限制: 1.0s 内存限制: 512.0MB<br>本题总分：25 分</p>
<p><strong>问题：</strong><br>作物杂交是作物栽培中重要的一步。已知有 N 种作物 (编号 1 至 N )，第i 种作物从播种到成熟的时间为 Ti。作物之间两两可以进行杂交，杂交时间取两种中时间较长的一方。如作物 A 种植时间为 5 天，作物 B 种植时间为 7 天，则 AB 杂交花费的时间为 7 天。作物杂交会产生固定的作物，新产生的作物仍然属于 N 种作物中的一种。<br>初始时，拥有其中 M 种作物的种子 (数量无限，可以支持多次杂交)。同时可以进行多个杂交过程。求问对于给定的目标种子，最少需要多少天能够得到。<br>如存在 4 种作物 ABCD，各自的成熟时间为 5 天、7 天、3 天、8 天。初始拥有 AB 两种作物的种子，目标种子为 D，已知杂交情况为 A × B → C，<br>A × C → D。则最短的杂交过程为：</p>
<p>第 1 天到第 7 天 (作物 B 的时间)，A × B → C。<br>第 8 天到第 12 天 (作物 A 的时间)，A × C → D。<br>花费 12 天得到作物 D 的种子。</p>
<p><strong>输入：</strong><br>输入的第 1 行包含 4 个整数 N, M, K, T，N 表示作物种类总数 (编号 1 至N)，M 表示初始拥有的作物种子类型数量，K 表示可以杂交的方案数，T 表示目标种子的编号。<br>第 2 行包含 N 个整数，其中第 i 个整数表示第 i 种作物的种植时间Ti(1 ≤ Ti ≤ 100)。<br>第 3 行包含 M 个整数，分别表示已拥有的种子类型 Kj(1 ≤ Kj ≤ M)，Kj两两不同。<br>第 4 至 K + 3 行，每行包含 3 个整数 A, B,C，表示第 A 类作物和第 B 类作物杂交可以获得第 C 类作物的种子。</p>
<p><strong>输出：</strong><br>输出一个整数，表示得到目标种子的最短杂交时间。</p>
<p><strong>样例输入：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">2</span> <span class="number">4</span> <span class="number">6</span></span><br><span class="line"><span class="number">5</span> <span class="number">3</span> <span class="number">4</span> <span class="number">6</span> <span class="number">4</span> <span class="number">9</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p><strong>样例输出：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure>
<p><strong>样例说明：</strong><br>第 1 天至第 5 天，将编号 1 与编号 2 的作物杂交，得到编号 3 的作物种子。<br>第 6 天至第 10 天，将编号 1 与编号 3 的作物杂交，得到编号 4 的作物种子。<br>第 6 天至第 9 天，将编号 2 与编号 3 的作物杂交，得到编号 5 的作物种子。<br>第 11 天至第 16 天，将编号 4 与编号 5 的作物杂交，得到编号 6 的作物种子。<br>总共花费 16 天。</p>
<p><strong>评测用例规模与约定：</strong><br>对于所有评测用例，1 ≤ N ≤ 2000, 2 ≤ M ≤ N, 1 ≤ K ≤ 100000, 1 ≤ T ≤ N,保证目标种子一定可以通过杂交得到。</p>
<p><strong>思路：</strong> 暴力…感觉应该是过不了全部样例，但是网上也没有判题数据…</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> i,<span class="type">int</span> j)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; arr.length; k++) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (i==arr[k]||j==arr[k]) </span><br><span class="line">			&#123;</span><br><span class="line">				count++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> count&gt;=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">K</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">T</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span> time[]=<span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        <span class="type">int</span> Ztime= <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> M;</span><br><span class="line">        <span class="type">int</span> start[]=<span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        <span class="type">int</span> ZJtime[][]=<span class="keyword">new</span> <span class="title class_">int</span>[K][<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;N; i++) </span><br><span class="line">        &#123;</span><br><span class="line">			time[i]=scanner.nextInt();</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; M; i++) </span><br><span class="line">        &#123;</span><br><span class="line">			start[i]=scanner.nextInt();</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; K; i++) </span><br><span class="line">        &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) </span><br><span class="line">			&#123;</span><br><span class="line">				ZJtime[i][j]=scanner.nextInt();</span><br><span class="line">			&#125;  </span><br><span class="line">		&#125; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;K; i++) </span><br><span class="line">        &#123;</span><br><span class="line">			<span class="keyword">if</span>(f(start, ZJtime[i][<span class="number">0</span>],ZJtime[i][<span class="number">1</span>]))</span><br><span class="line">			&#123;</span><br><span class="line">				start[s]=ZJtime[i][<span class="number">2</span>];</span><br><span class="line">				s++;</span><br><span class="line">				<span class="keyword">if</span> (time[ZJtime[i][<span class="number">0</span>]-<span class="number">1</span>]&gt;time[ZJtime[i][<span class="number">1</span>]-<span class="number">1</span>]) </span><br><span class="line">				&#123;</span><br><span class="line">					Ztime+=time[ZJtime[i][<span class="number">0</span>]-<span class="number">1</span>];</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					Ztime+=time[ZJtime[i][<span class="number">1</span>]-<span class="number">1</span>];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; start.length; j++) </span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (ZJtime[i][<span class="number">2</span>]==T) </span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        System.out.println(Ztime);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="试题-J-子串分值"><a href="#试题-J-子串分值" class="headerlink" title="试题 J: 子串分值"></a>试题 J: 子串分值</h1><p>时间限制: 1.0s 内存限制: 512.0MB<br>本题总分：25 分</p>
<p><strong>问题：</strong><br>对于一个字符串 S，我们定义 S 的分值 f(S ) 为 S 中恰好出现一次的字符个数。例如 f(”aba”) &#x3D; 1，f(”abc”) &#x3D; 3, f(”aaa”) &#x3D; 0。<br>现在给定一个字符串 S [0…n - 1]（长度为 n），请你计算对于所有 S 的非空子串 S [i… j] (0 ≤ i ≤ j &lt; n)，f(S [i… j]) 的和是多少。</p>
<p><strong>输入：</strong><br>输入一行包含一个由小写字母组成的字符串 S。</p>
<p><strong>输出：</strong><br>输出一个整数表示答案。</p>
<p><strong>样例输入：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ababc</span><br></pre></td></tr></table></figure>
<p><strong>样例输出：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">21</span></span><br></pre></td></tr></table></figure>
<p><strong>样例说明：</strong></p>
<p>子串 	f值<br>a		1<br>ab		2<br>aba 	1<br>abab 	0<br>ababc 	1<br>b 		1<br>ba 		2<br>bab 	1<br>babc 	2<br>a 		1<br>ab 		2<br>abc 	3<br>b 		1<br>bc 		2<br>c 		1</p>
<p><strong>评测用例规模与约定：</strong><br>对于 20% 的评测用例，1 ≤ n ≤ 10；<br>对于 40% 的评测用例，1 ≤ n ≤ 100；<br>对于 50% 的评测用例，1 ≤ n ≤ 1000；<br>对于 60% 的评测用例，1 ≤ n ≤ 10000；<br>对于所有评测用例，1 ≤ n ≤ 100000。</p>
<p><strong>思路：</strong> 这题还是有点难度的。根据题意，我们可以发现每一个字母所提供的f值(权值)，为与上一个相同字母之间的差值乘以与后一个相同字母之间的差值。例如样例中的ababc:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ababc</span><br><span class="line">字母a : 无前一个相同字母，前差值为<span class="number">1</span></span><br><span class="line">		与下一个字母a之间的差值为<span class="number">2</span>，后差值为<span class="number">2</span></span><br><span class="line">		总权值为：<span class="number">1</span>*<span class="number">2</span> = <span class="number">2</span></span><br><span class="line">字母b : 无前一个相同字母，前差值为<span class="number">2</span></span><br><span class="line">		与下一个字母b之间的差值为<span class="number">2</span>，后差值为<span class="number">2</span></span><br><span class="line">		总权值为：<span class="number">2</span>*<span class="number">2</span> = <span class="number">4</span></span><br><span class="line">字母a : 与前一个字母a之间的差值为<span class="number">2</span>，前差值为<span class="number">2</span></span><br><span class="line">		无下一个相同字母，后差值为<span class="number">3</span></span><br><span class="line">		总权值为：<span class="number">2</span>*<span class="number">3</span> = <span class="number">6</span></span><br><span class="line">字母b : 与前一个字母b之间的差值为<span class="number">2</span>，前差值为<span class="number">2</span></span><br><span class="line">		无下一个相同字母，后差值为<span class="number">2</span></span><br><span class="line">		总权值为：<span class="number">2</span>*<span class="number">2</span> = <span class="number">4</span></span><br><span class="line">字母c : 无前一个相同字母，前差值为<span class="number">5</span></span><br><span class="line">		无下一个相同字母，后差值为<span class="number">1</span></span><br><span class="line">		总权值为：<span class="number">5</span>*<span class="number">1</span> = <span class="number">5</span></span><br><span class="line">则答案(权值和)为：<span class="number">2</span>+<span class="number">4</span>+<span class="number">6</span>+<span class="number">4</span>+<span class="number">5</span> = <span class="number">21</span></span><br></pre></td></tr></table></figure>
<p>根据这个思路即可较为容易的解出本题，记得最后要用long类型转换，要不会爆int…</p>
<p><strong>代码：</strong> <a href="https://www.acwing.com/problem/content/2871/">OJ链接</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//前数组</span></span><br><span class="line">		<span class="type">int</span>[] piror = <span class="keyword">new</span> <span class="title class_">int</span>[s.length()+<span class="number">10</span>];</span><br><span class="line">		<span class="comment">//后数组</span></span><br><span class="line">		<span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[s.length()+<span class="number">10</span>];</span><br><span class="line">		<span class="comment">//答案值</span></span><br><span class="line">		<span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//中间值数组 用来储存每个字母的前后值位置</span></span><br><span class="line">		<span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//初始化</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length()+<span class="number">10</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			piror[i] = <span class="number">1</span>;</span><br><span class="line">			next[i] = s.length()+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//找每个位置字符的上一位</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s.length();i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> s.charAt(i-<span class="number">1</span>)-<span class="string">&#x27;a&#x27;</span>;<span class="comment">//计算出数组位置</span></span><br><span class="line">			piror[i] = i-temp[t];<span class="comment">//计算出与上一位相同字母位置的差值</span></span><br><span class="line">			temp[t] = i;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//初始化中间值数组</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			temp[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//找每个位置字符的下一位</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s.length();i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> s.charAt(i-<span class="number">1</span>)-<span class="string">&#x27;a&#x27;</span>;<span class="comment">//计算出数组位置</span></span><br><span class="line">			<span class="keyword">if</span>(temp[t]==<span class="number">0</span>)<span class="comment">//说明是第一次碰到</span></span><br><span class="line">			&#123;</span><br><span class="line">				temp[t] = i;<span class="comment">//标记</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span><span class="comment">//不是第一次碰到 说明上一个的下一位找到了</span></span><br><span class="line">			&#123;</span><br><span class="line">				next[temp[t]] = i;</span><br><span class="line">				temp[t] = i;<span class="comment">//标记</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//计算答案 前差值*后差值等于当前字符的权值 累加即可</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s.length();i++)</span><br><span class="line">		&#123;</span><br><span class="line">			ans += (<span class="type">long</span>)piror[i] * (<span class="type">long</span>)(next[i]-i);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="试题-B-寻找-2020-附件"><a href="#试题-B-寻找-2020-附件" class="headerlink" title="试题 B: 寻找 2020 附件"></a>试题 B: 寻找 2020 附件</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">002000000220202000222000202200222220202202020002220002020022202200220220202002002220020200000000220022200202222022220222000022220220020020222020022220022220220000022022002020220002200220020020022200020222020200200000020220020022002202000202222020220020020022020000202022220222200022220000000020020020</span></span><br><span class="line"><span class="number">000020002002200002022222200222002020000200020220000022020002020200000222000000202202220222000222202200202202200200222222220202022020022002220200022020200222002220202202022202222002000220202200202202022000000222220222200200022220202200200020202222202222220022202220020002000000200022222202020020222220</span></span><br><span class="line"><span class="number">220002002202200022020020202000220002000020220202222020000020022222002000002222220022022020002022200020022020202020022200022200202202220200000202020220022200222020020222020020022200222220222000020202000020022220222022202222002002002000002020202200220200222202002002202002020202222220020002020220200000</span></span><br><span class="line"><span class="number">022200022002022002220002002222022020220002222200002002222002222222022200002022002002200220020002220002020002222222022020220020200000022022022220220222002222220000022200002002020000000022220202020020222202222200200220200220222220020202020002022002222022022022222002200220202202002022000022200020220000</span></span><br><span class="line"><span class="number">202222202222222000000022222022202022220000222002002000022202022002220220220022002002200000222200222002222002220000220022002202220222220222002002220200222200020222000202200022022020002222020022202002000200000222200020222020002020022222222222220202002200200200220020002020200000020022000202002000022000</span></span><br><span class="line"><span class="number">020200222020020222002020000022220022020220002220220220200222222000222222002202002200002000220022220020002200020020220002000020002002200200200000200200220202002020022202002002222222222200222020020000020220002222020202202222220202220200202002202220020220200000022020222002222020200200022202202202200002</span></span><br><span class="line"><span class="number">020222000220220200222000000202020022200022002020222220220200202000200200202222020020200220002200000020000002022000020020002220202002222220222000220220222222000002000000000002220022000220022202202202020222202202200002220200022222002000020020220200002200202220022220020002220020002222220220220200022000</span></span><br><span class="line"><span class="number">022002200222022222020022202000002222200002022002020220000220200000002002022000000022000022202022200002000000020200000020002202200020200002200000202002222002220020220200020222002000022002022020000020200000202020200020222200020022222222000222202020200200222000202020020000200022020202202222002020200002</span></span><br><span class="line"><span class="number">202020200000020002020022202222022220002222022222022200200002002220020220220222202000220022002220020022000202022022222200220020022202020202202222002202222000202200020020222222200202200220002222200220002202202220222022222200002220022002222000220002020220000220220022000020200220200022000202020220200222</span></span><br><span class="line"><span class="number">220002222000220022000222020020202220220002000002200222220002000020000000000202202002222022202220220200020202202200220202202022022222020220202202020002222200002020220202022200002222222200020022022202220000020002022020222020022022222022202220222002020000002022000020220020220222200200002202002220222002</span></span><br><span class="line"><span class="number">200222022022022200200220202202200200220222220022022000022000022022020200222020220000220220020020000020222022222002020220020220222000202200222222200020022002220222222002222200020002000202022202220222202020000020022202022002200020220002022022002002000022020202002020022000000220202200022022200020022220</span></span><br><span class="line"><span class="number">002002202022020200022222220022000022202220002202200000220000020220000020022200200020020222000000200022000202002022200222200222000000000202222200222022020202200020020202220022200200022200222022202202002202020222022002022002222222020202022220202020202002222222022220220002220022022002220022202002222002</span></span><br><span class="line"><span class="number">220022002222002220222000220000002200220020022000220022222220202200020022000222022202220220022202222020002020200202202002222022222020220200020000020022020022200000000000022202022022200220222022220222020000020222000200022202202220202002002222000220202220200220000220202022000202222020222000200000000000</span></span><br><span class="line"><span class="number">002220020002202202002220022220222002220002200022200002222002200020200202000000222222220022222200202220002222220000000220220022200002200022202022020200200002202000022202200002220220020220020022220022200000000220200200020022020222200202002200220222222202220202220002022020022020020200002022200222222020</span></span><br><span class="line"><span class="number">002200202020202220200020220220002002022022020022200202000220202220220222200002000020222022000002220020002002022022200002200000222222200022002222000200000220220220022022020022000200220022220002002200002022020200220000020000002002002020222202000202022220000220200200200020002002200220202000220002222002</span></span><br><span class="line"><span class="number">200200202222000020022220222022022002222220200002022222000020002222220200020220222220022220222220220000202022020222022220202000002222000200220202002202200022020220002220020022002202022022000000222020220002222222002020222000022222220200020000000200020200020220220222220020000222000220222222222200222202</span></span><br><span class="line"><span class="number">000200202020220002002020022020022020000202220202022222220020202220220202022220200002000222200000200200220002222202022200022020222022202002000022002200222222000222000202002022222020220202200020022220222022000002020022002000220220022202220202002200202000200222002000202200202222220222222002202200002220</span></span><br><span class="line"><span class="number">020220002002020000002002220020022022020220022022202202220202222222200020020020222222022020000000220222000220020202022202002020200002002202200200222022022020022000020002000222022000200000020000020002022020020200202200222222022222022000002002220220002202022020222000202002222000022022000000200020022022</span></span><br><span class="line"><span class="number">002002002002022220000022220020022222220002200222002200020202000202222002020020222020002200020002002202022220002022020000020022222200002202000020222220020000022000020220002220000202000220020202002220022000022002202000000220020202002202200202220220022002002202222222020220222222020020000222000000002022</span></span><br><span class="line"><span class="number">000202222220222222002202200200200220002022022000002200020202002020200002002202000220000222002020022020002000022020222000000202220220002022220022222220222002200220222220002020202202022002222202222202222002222200020000220020222002000022002222202220020222202202200202000000002200200222020022220220220202</span></span><br><span class="line"><span class="number">022200200022222020002022002000222000020002002222020002002222222020200022020002022220000200000002000020202002020220200020020002200020222000202200202222220020200020202222220200220200222202222002202200200202002222002002200022200022002200222002002000022022022002220002002002202022002222220020220022000022</span></span><br><span class="line"><span class="number">020020200200000000222202222220222020202202220200220022222202002200022022220002002200000202002002020000000220200222222020022220002000200022220202000002022220200002000000222220200020200002202002200200022220002220002220022202002202020220220200002222002020202020220220202000200020222200200222222000222020</span></span><br><span class="line"><span class="number">022200200200000002220002202002022202202220000222202222220220022002022220022002000022002202202000202002220200002002002000000220202200220202220002200002020000222220222020020202000222200202202020200000022002000022220000200020000202222200222200222022020200220200222200222202022202020222020020020200020222</span></span><br><span class="line"><span class="number">000022022222220222222220222000202200022022002000200022022220002020222222202222020200220200222202220002200002000200202022022022020222020200202020000000020000000220000002002200202200202022020200020000220000200000222002002000022220022220022200202202020002022200202220020222020222002222220020202000202222</span></span><br><span class="line"><span class="number">000022202020202002000222002222222200002220222202222022020200000200202002002202022220000202202020200222022220000202022020020022002220222022020000000020022222022020020200220022220020202202022002220202202202222222200002222020000022022220022200022200002202020022200200020202222000002022200000002222002022</span></span><br><span class="line"><span class="number">000200020020220002020022020020202022022200200020000200222202222000000002000200020222000020002020000202202202000000220202002222200202200222202002220222202002020222000202022022022020000022202200220220222000220020220000020000200200222220000222020002222020220020202020022002202002002022022020200220002000</span></span><br><span class="line"><span class="number">000000020200020200020020002202022020220022202002020022002020020020000202020022022200202202200000202220022222000002020020220202002022002222200200000222022022202000020000220000200200000220220200202200222220220202000200020200020200200202020020002000022000200220222020222022002000022202202222222200220020</span></span><br><span class="line"><span class="number">222200222020220220000202200000002020200202002202020200022002222022022000202022200202200020020202020020222200222200000220002200200000202220020202200222000222202000200020202022222000200022020200202220000220000222202202022020022200022002202020022200200000220002220200002222220200000220202222220020222000</span></span><br><span class="line"><span class="number">202222202000020222222220000022000222022020200000020222020220222222220202002222002200020022002200020002020000220000220200002202202200220220202002020222222000220020202200222002020002020222220222202002020202202200200002202202200022220222002222222000020222022000002022222000022200002000000220200200002000</span></span><br><span class="line"><span class="number">002020200202220222202020222220200222000002202022002200202202200220000222000202022002002200200000200202000200000220200020222222202202002222220000020222202222220002002222002222202222020000220222000200200220020020002022222002000002020220022000022220000022220222222000020000020220022002222202220022202022</span></span><br><span class="line"><span class="number">022000200200000002022222200022220222022220000222202002020222200220020020000220002202022022002222200002002020202220022222000200222002200000002222202202000022000000000222022000020200020200000200000020020002200222220202022222000020022202200202000000220000200200022220200222002000202220002000002020020002</span></span><br><span class="line"><span class="number">002022200002022002202002020220002020202222202220022022020202202200002200220022220202022202000220002002200020222222220020200222020200222020020022220200002022202022200200020002020200222200000020222202020000202022220222222222220200020202000202222220000202222220000200000202222222000222220220200220022202</span></span><br><span class="line"><span class="number">000202200220020002222000002200220222022200000202202220202220022220002002022202022222220002002002002000202002020200202202002022202222020202020000020020220000202202202222200000002022200222220000020000022200202022002202022002020200002020022202022222202020000220022220202002200022202000202000200220202222</span></span><br><span class="line"><span class="number">200022020220002222020000222002022022000020220000220200222022000202000002222200020222202022222000000202020002202202002000200222220002020222220020002200000220222222000222002022222002020200022002000222202220202020202020022200020222002200002222002202222000200020222222002222202000020200022022220020222220</span></span><br><span class="line"><span class="number">202020020000222000022220200022200002220200000220000200002002202022202222022020220000220202000020222022222222000020220020200002222002200202002200000020200202020222020020020002222200022002220200200022002022220022222222002220220000222022020222202000200000000220002002000200022022200002202002002220000022</span></span><br><span class="line"><span class="number">002022220022220220200020220020202022022220000020202002222000222222022002222200220020002222020020020220002200220202222222000202222220022002222220222022002222020222200000022002000220200220222000002022002020222202000020020200022000002200200222202202000020220220202220002222020000020200220200020200020022</span></span><br><span class="line"><span class="number">022002202022220000202020220002020002200220222002002220222000022022200000020020022002020000220202202002000002020020222000022000220000200002020202020022022200020022022202022000020020022000200222222020000220202222200022000200202002020022002000202002202220022020022022220020220220200002202022222022002002</span></span><br><span class="line"><span class="number">200200200020000002200222002202200020200202002220000022200200002020220222200000022200022002000000000002222222202220220220202022000002002222222020220202002222020200020020002220000022020022202002002202220020200222202222002200020222222202220200020202020002002202020002220220002000200200020020022000202202</span></span><br><span class="line"><span class="number">020000022220222222220000200222202220220020222202220000200020200020220202200222200220020200200020202020222202220202020000200220220220000002000200222002002002000022202022202222222002020020220000000220002220022202220002000002002000202220000220000222020200020220020000200020222020002222220200200200022202</span></span><br><span class="line"><span class="number">000202222222222002202202200200200002022020000202000200200002222002200020202020220020222200000000020000222222222202000002020002000020020000000000022000220220000200202202000200020002000202020022020200220202222202000020002002020002220222000202000022200000222222022020200222220002020202220202000020022000</span></span><br><span class="line"><span class="number">020022002020000002220000000002220200000000000002020022200220020002220220022002020200220020000222020020020222200000222002022202020020222020020202202202220200222020022200222000220202202202000222200200220000222200200200022022000022022000202000222222022022220002020202202022202002000220200202022020022000</span></span><br><span class="line"><span class="number">000002002002220220222002200000002000002002000222202220022222020202202200220002022002002202222002202200200220022022200020020022020020000220220002220002220022022222220200200022222020000020000000022002002020002220000220202000222200200000202002220020202002220200222002000220000000022220002222200002200002</span></span><br><span class="line"><span class="number">222222002000202020002022022200022002200220202020002220000002000202020200002002020000002002020002220020222002020200000020000022000022022222002202020020202022222220022000022200222022002000220000220202202002000202200222200220222202002220222220200022222002220200202002020002022020020222000220202222022202</span></span><br><span class="line"><span class="number">000220220020200000220202200222022222202000220202022220220000020202222222022202200202220002022002002202220200002000202022020002202222202220222022022222202222002220002020022022022022000022000202220022220220222202022222002202220022222020222002202200022002220022022020022002202000002220222222022002220000</span></span><br><span class="line"><span class="number">200022200020202220222022202022002022202200000000000202000022202200020002022200000222020000222002002002002200220202002000000202222002000200220222202220020020002220222000002202200022220022020202002220222002200222022220002022000222222000000000000000202220000222000200022202000202200222022000220202202002</span></span><br><span class="line"><span class="number">222002000022200202022222220202020000020000022022022200020220202200002220000222000200002202222220220002222022020222020200020020000020222020202022200020002200222002022200002220202022220022022020200020202020000020022200020000002222200022220022000222022020020020222222220222002202020020202222020002022220</span></span><br><span class="line"><span class="number">202202022002000220022020200220220220020002202222202220222002202200222200020022022200020222202202202200200222000202000002222220202020000202002220200200222020002200022000200020202200220002202222020002000020002000002202202220202220002022222222020220000000022200202002022000202002202200022022002202020020</span></span><br><span class="line"><span class="number">020022020000022202022200000200200022000220020022002022002200220002200200000222200202002000022202200022020022020200222220222200002000200200222000200200222022020022222222200002202200222022000000002000022000002220202020202002222020202000020020002022000200002002000200202222020222202200000222222220022220</span></span><br><span class="line"><span class="number">002202000200002022222022222002022222220020202222222020022220220002222022022022200202000000202002000020202200202200000022022200200220002220020020002200022022220000200002202002002200200222002000220020200200022002202020000202020002002222002220200200200200222022000002002022220002202002002002220000022222</span></span><br><span class="line"><span class="number">220002202020220002002200002020022220000220200222002022202220202202200222202220200222202202202022222020022200200220000022220000000220020022222222002022202022200202222020200022202220222200020022202222222020202200022002222000220002202022020000200222022220022200202002200020202222202000000000222200022002</span></span><br><span class="line"><span class="number">002002020000020022000222202202200220000220220000022200020220200200022000000022022000222022022200020202220002002200200220202200002022220200020222020200202022022002220202000220000202222200020002202022022200222222222020200022222002222200022002222222000202020222022200220002000020000022020000202202002200</span></span><br><span class="line"><span class="number">222202002222220222220220020000020022200220022220222202222202200220222220022222222020222000002202022200200222000000222220002002002222020200022220020020002002202200022222220000222200200202000202200202222202202202222200022200200020020220022202220000202020000020000000000220200020220000000002202000020022</span></span><br><span class="line"><span class="number">022020020020020020202020220202022022200002022022002200002202220202002022002002202200000200202200220222220020200220222000022202222022022020202200222000020020220220202222000220002200000000202202002002022200222200022220002022020002000202000000002002022002020220022020000022200200000000000000202202020000</span></span><br><span class="line"><span class="number">000022022000202020000020022222222002202202202000002000222020022002022020020222220202002000022200202222002000200222002220020202000022000002002202000002002002000222022200000202220020202222000220020000222200200222022000200200222222022220002020000202220222220202220002222022020002022220000022200202220002</span></span><br><span class="line"><span class="number">220022002000220222000002200222202220200200020022222000220020200002022222202002220022000022200220202000220000020020020000220002220202220002002002220020002020000200022020002022220202020220022202022200000220222220002200222022000020020020020200200022200220222222220022002200000220000220000022022020222002</span></span><br><span class="line"><span class="number">002002022000000200022220222020202022202022220000200022022220022222000200022000220020202200202222222020002000220222202002000020222220022020002020020222200020002002020022022200002200020020202202220202022020202020202022222202000202022002022002002022200202022000020202000022022022002222200220200222220200</span></span><br><span class="line"><span class="number">202020020022222020220000000000220222220220202220222000220020220022002222200000200020020202202020002022000000002202200222022020002000202000222022202000020002020220222200200202022202222020022002202022022200020002220222002000220220202220022222002200200000222202202222020000222202220222220202222022222200</span></span><br><span class="line"><span class="number">020200020022200020002202002000002220000202220200002202022200000200202220202200220022022020002200022000002202200000022222022222002022022220202022200220220200020022202202020000002022020000202200200000222020020220002000222200220200220000220220200020202000220020222022220020202000222020022000020220020000</span></span><br><span class="line"><span class="number">002220022222020022200022200020022202000020000200202202220200020002000220000000000220020020002202002222022020200022022000020002220022020020222020002220000222200000020022022020022220220200202022202020200022022020220202000020020220020022220202200000220220002000020000200222020220000222020022220022220200</span></span><br><span class="line"><span class="number">022022200000002020002022222000020220020020200022000020022002220200222202002022020002020202002002202020222002202202002020200020202022200220020200222002222222022200022022200222222220020000002220222000002002022200022020002000202222200200002202202000020200202000020002220002222200022020022202200200020220</span></span><br><span class="line"><span class="number">000002022022200222002220020202222220002002222222022000220220200020220220222202220200202222220000000000202022000020000220220202202200022222200000220200222000200222020220202022200020022000000002200220000220222202000002022222022002020222202202220022220022200022222220022202022202000202022202002020020220</span></span><br><span class="line"><span class="number">022202202022220220222220220000202200202002020000022202222020000002002000200002002000022200200220020022002020200202200200020022020202220202202220200002020200002220002000022200000000220220220022202000002000022202220202202202020002220000002202202220022202020022002200202000022022222002000202222202200222</span></span><br><span class="line"><span class="number">022222202022022222000022020222020020022020022202000020002202220200020200220202022222020202222220022220200202022022200022022002222222002220200222222202200222020202002002222022202222000222222202020200022000222000222200202200000020202020200222220000002002002200002020220220220002022202000020000020220020</span></span><br><span class="line"><span class="number">200220222000200002002002202022220220220222200000022200202222000022002202200000000002200022220000202000000002222200222000020200020000020202022220022002000000002022000002002200022000222220220220202220022022222200002222022222000020200022000000020002020202000222002022220020222002202220200020000022200220</span></span><br><span class="line"><span class="number">202002222000222002000200000002222020202222222220020000202000000220202200202020220020020200022002222220222200222020222222202020220220220202022000020020022220000002220200200002000020220002002000222200220222002222200222000220002020022000220200200200222020220220022222020222220200022002022200022020220002</span></span><br><span class="line"><span class="number">002200222222020222200020202222222200220222202022200222000020020022000000200020200000222002022000200000020022002202222002022020202002020000000022222222222202002222020202002020222000202222222020022220002000200220020202022022202202200020020000222220002202002002000222002200002020022222022202002002222022</span></span><br><span class="line"><span class="number">200222020202220002000020000020202200000022022200000220020202202200202200022200000202200200022202222220220020202020000000202222022222020020000022202022020020222020220020022202000022220020002002202200000220222202022200200220222200220220000020202220202200222000022002020002022200202222022002222220220022</span></span><br><span class="line"><span class="number">220022222000020220022222022220222000002022000222020202200200002022022200202000002000020200002002000000202002202222022200202022002202200222022202002222202022202020202020200222000220022220022000020020200200202200020222000200220020020020020220222022020222000002002220202220020222200020000202222002020022</span></span><br><span class="line"><span class="number">202220022020000022220022222002000022220202220000200022022020002200002222222000022020020222002202200220220022000002002000220200002020000020220020220200020200202200000200220002020020202202020222022022002220020022202202000222222202022022020022202222002020002022022200022200222022022020222020222002202222</span></span><br><span class="line"><span class="number">020020200220202002000000222002000002000202020022222000022002020002222020020020200222000022000220022000022220020002022002220002000002002002202202020222020202202022000202222220022220220222000002000002222200220222222200020020002222000000002002022202020020200220002022202200202220220220020202202002022200</span></span><br><span class="line"><span class="number">202222220202022222002200022002200200222202000202222000020000200000202002022220220220000200022002020220000200022020020222020202220220222220000200002022222002202020222202002020000000200002022222202220022222220200222000202000202222222002202022002202202220020002202220002202222002022220020000002220200022</span></span><br><span class="line"><span class="number">200200220202220022220022022222002220220002020000000002222020222200002022222220220220222222000200002022220200022220220200000002200202220222002002200002220222000020002002220022022202222200000220200000000202220002022202222000222200222020000222000002000222022202022220202022220002020220002222000220002002</span></span><br><span class="line"><span class="number">000222022222020022220022220222002000222000022200020020002020222222020202002200020002202200022022200022200200200200222202200220002200020002220022220222220020220200222222000222220220020000220022222202202022020020022200000022200022022002020220000000000020200200202220022002200020000222200000022002222000</span></span><br><span class="line"><span class="number">220200002000220220000002022202202200022200202000022202000002000002002000022002222000220200022222220202002202000202200002022200202000202000200220000000020200222000002200000020022202022000020020202020222202200022020022002002202220200202200220202202020222220222000000002002000022222200222002202020222220</span></span><br><span class="line"><span class="number">020002000222022200202020022200220200020022202022222202022222022002022220222000202222200220202000220220222222000220022002202022020202000222222222200002020002202020002002002020022220200220020202020220222202222202222222020220020002200000020002222200222200002000220000002200000222020022022220220000002222</span></span><br><span class="line"><span class="number">022002220022222200020222220202202020020220022220200020000200002220220222220000000022000002202022202022002022222022220220000002020200022000220020022200220000202002202020222220022202222000222202022220000220220020222220222222202202020220202220200002200000222020022220200000200022020000020200002220002000</span></span><br><span class="line"><span class="number">202000202202222222022022000000220202202222000020000022022222020222020022020002000200220202200202202202200000200000000200000202202002022220222200002202220222222200200222022020222220222220020222000202020200020022020000222020202002002000202020202200220022202220222000000022000022220222220020002222200222</span></span><br><span class="line"><span class="number">020202000222202222020220000022200000020200202220220200020002002000220222220222020222222202220020222222020002000020020220002220222200002220002020220220200220200020002200220202200220200200000002202020022022222220200222220000220022222222222000222002220020202020002002000020020020200222020220000002002022</span></span><br><span class="line"><span class="number">022222200000202200000222220202020220020220222202022202000002202022220200000220200222200000220222220000220202002220202000020222202200020000200222200200020220002022202020002202222220200000022022222222222002202002202020200202202200220000222020000002200222222002220000220220000202220222220202002200002020</span></span><br><span class="line"><span class="number">022200002022222222202000020202220200200000222200000222002202222222200000220000000022220020222022020020202002022000000002202200220222202200222222200200020000220002222222222202002002022000200200222220222020022000022222002002202222022202000020220020020002022000222202000000002200222020002022200000020222</span></span><br><span class="line"><span class="number">200202202022000022002002200020000022202002022002000202202200002022022000200220000222220222002200020202220220000220202022002200020200222002202220222200202022202002222000022222200220220202002220200002000200000000202002200000222000220000022020220002022202000000022000202222200022020022202000002002002202</span></span><br><span class="line"><span class="number">000200000002222002202022200202202002222002220200222220020222000222020020002222000200002220000002000202000002000222200200020002220202220222200020222220220202200200200020202000202200022020200220222222002202000002000200220222020000200002000200020000222202220202222202002022022202000000022222200220200022</span></span><br><span class="line"><span class="number">000202000222000022202000020222000000002022220202002222222002220220222020020222222222002202002000000202020202220200200022022000200222022220002000000202200020000022002022220020200200222200020022022000000000002002022202022020002202020202202000000220002220200222202022200200002002002200220000200202222220</span></span><br><span class="line"><span class="number">002202220002002220202222002002000020022020022220200220022000022002222220002020222000002022000200020022200022022222000222222220220200002000022222222022200000000220220202200002202002202022202220200020002222220020222022000002020220222002200222220202002202002222000200220200002222020202200022000202202002</span></span><br><span class="line"><span class="number">222220202022202020200020220200222022220022020022202002202002220200020200002222000222002200202202220020022000020000002220220200202202222020002220220200002202222020000020222000222022020000002220200002020000200000222022200000202222002002220020002022002220022000202000220000222002202000000002222202202200</span></span><br><span class="line"><span class="number">000002000000222222000222200222200000022022020202002202220000002020000022000202000200020022002022020200222002022222200202200002022200020202000222202222002002222222202200220220202200020000022222002000200202020002002000222222202002002200202020000022220200000220222000000200000002202222220222022220202020</span></span><br><span class="line"><span class="number">022222002000020220222000002220000200222022202222200220020000202220202222020222000000022220022020000002002020220002222022200000202222002022222200200202200002202002002020200222002202000002000022022200022022220002200200022002220222000022000022202200222022220200220020002200202002220000200202220022222222</span></span><br><span class="line"><span class="number">200222022020222000200002220000020220220222000222200022220202002002002020020200020200220222200002200200222020000000222202202000200220220200202220202222000000022022220022222200000222002022222200202002000200220000222000202000022222002220000202222002000002002020200220002002022020220222000202020020000022</span></span><br><span class="line"><span class="number">000022002020200202022000022000000202002220220202002022222002202000022220020202022022000220202222202000200000002002200022202022002020000222022022002002202000200000000220220002002220202202222000020000200200002220002002020020020202202002202202020222000022000020002220220220000022020220220020220022202020</span></span><br><span class="line"><span class="number">202220020020200222200020020002020222000200202000020200020000000202220020200222220022022020222022002002222020000220220002000222202022020200002202020002020002220022022002222200220002202000220022220020002220022020220220200200222222022220220000222220002000020002020220000202222020002200022202220200000000</span></span><br><span class="line"><span class="number">202002000022200022200220020020220000200020002022220002220002002222022222220222222022020222200202022200000220220002020200002022200002002020002022200222222200000200220200200020020200022020000022220020020222222202002000220222000202002020202220020220022222000220022220220020020220022202000022020200220220</span></span><br><span class="line"><span class="number">220200222200020222220000200022002000200220020002002002220000022202020202022020220202002022200220202202002222220020022200222202002222002200202200222000022200022000000022022020222002220002202202022202020022022202222202022222200002200202022002000200002200202022220200200020200020220202000000222020220222</span></span><br><span class="line"><span class="number">002222222002020002202020220220000002022200200202020200202002022020002022220222002020022222002222202000202002202020200220002220000000222002200020220020202000020002200200022022020002200000000200220222222020222202002022002200022000200002220022022200020220200022002020202220000202002202022020000000000200</span></span><br><span class="line"><span class="number">220222022000002202220000002200020022020000022022220000222022020002222022000202020220202200220200002022020002000022202202022202002000200220002220020222020220222202002020200022000200220002002020022222220220020002200222000200022000020022200222022222220022022222202020220222200200020202020220200020000022</span></span><br><span class="line"><span class="number">220000020202022200000202222222220200202202000020200002202220220000002220020200020020002020200000022202022002020000202022022002002020202200200002222022002020000000002020220002022002220002020002222002020222000202020220000002022202000000022222002200220220002200200000002200222222000000002020002002022202</span></span><br><span class="line"><span class="number">220020202020222222022000000022200020000220220200200200000220020222000202000020000220220220220222220202222000002022020022020000020020222220000000000002202022022002200220220200222202000200020002022222202200200002020202220002222020022022200000220220002022222020020000202022200020000000222222200200020002</span></span><br><span class="line"><span class="number">022020222000022202002020220000220222000000200220000202022022222202222022022200220022222202022000002222000220200222020200002020022202220020200000022202022202222200200222002020222000020020202022220202222202220200002220200022202222202000002202000022220020000020020022020202200000000020022200222200000202</span></span><br><span class="line"><span class="number">022202022000020020202000200002022202200020200200020000200222222000000202020220000022222002000222002220222220000002002220202022020020220020000222220222020000222200002022022222202020220002022002020220002220020020202002202022200220020020002220022200020220002000002020020020020200200002222000020202220002</span></span><br><span class="line"><span class="number">222000000022202002200220222002202022202000202202220000222020202002022022000020002020022220200202202220000000022020222020000000200200002022022200000200222002220202220222002020200020022202002020002222002222020022022000200022000002000222020002202020202200020002000000000000020220220022220000220200002002</span></span><br><span class="line"><span class="number">222200000020222000000020000022202200220022020022220200000020020020022000020022222202022002202200000200022000002022220202020202000022200200002000000000200022002202002022220222000002220000020002022022000200222200020000020000022200222220200000002222200022202202220002002220202000202200220020222000222000</span></span><br><span class="line"><span class="number">020200022202022222222220220020202200200022200020202222202002202020202000022222002222202222000002200202022222000022022020220000000022222200002220000020022202202000022222202020000000220202220020200020002220202202020220222000002020202022202200220020000200000200222200000200022020200002200222022022002000</span></span><br><span class="line"><span class="number">022020202222002202200002202000200220200220220220000222022222200020220022200200220022022200202222202022002222202202202020202020002000002200200222000220022220220202000220222002200000022000000022022200202000002202000220020020000200022002020020200220020222002002202022002000220200000020020000222200200020</span></span><br><span class="line"><span class="number">202200002002022222020200222222020220222200022020022222022222202020222002000200020000220000222022222222220020220220220200202002202002000200220200020022002220222022202020200020020200202002220020000202220020002020222020200220022020202222202220202222020020200002200022002202020000222200022222000222200202</span></span><br><span class="line"><span class="number">022020202002002202002202022222200200022020002020022002222202202022202002222220020222000000000022222222020022000002002002202222002222002222222022220000222002020222022002222020000202202020020222220022020000220220022200002002222222002222002222202222220022202000222222022002200022020020022202000222002000</span></span><br><span class="line"><span class="number">220222000222000200022000202002220022222222200020022202222002000022200000222202202020002222222202200020220222020022202000002222202002222000200002222002022220202022220202000200200020202222220022022220022000020020002022002202202222220000200202002222200220020022000002222020200000200220202200020002200222</span></span><br><span class="line"><span class="number">022222220202222020220222002200000222002220200220000022002202020020200200220202222020202000222020022222020220222020220002220200200022002000022020200020020222222222022200022220000002202220200020202020002022022000002202222002202200222020222202220022200200000002202022222200220200200200220222000202020220</span></span><br><span class="line"><span class="number">202202200002002020000200202202202202022020222020202022000202000022000002202022002220000002202020220200220222022200002002002220200200020200002202020202000022002020000000222022220220022002222000222200222002220020000222222020220220222202220202000022000002202002220022000202022020202000000020022202202020</span></span><br><span class="line"><span class="number">220200222020222000222022200020200200020200022020202002002200200200020222000002220200200220200200002202222020020002002020020022220020222002202220222202002022000202020202020222200002220222002022022222222202022000222000020222000022222202220002220202220020220202002022002022220000200200200202220220002002</span></span><br><span class="line"><span class="number">202000000002222202020022000002220002220000022220200202200022022022020002002220002220200202002002220222020220000000220202222002002020202220000022020220222000000020002222000020002222222022022202222020002002022022002002202202000002022020200222022222020020200022220200222002002022022020202220020000022200</span></span><br><span class="line"><span class="number">200220020002200022020222222020022000220202000200202202020220000000002200220000200202020020202202200020222002202000202200002222022020002220002002002202002202202202202202022000222220200002022020220220000222222222222022222020222022020202002202202020202202002200020200222222000022200022222022220022002202</span></span><br><span class="line"><span class="number">220202022220000200022022222002002002020002000000002000220222222202022222202220200002222202202222202022002222022000022020222022222022222200020222220202002020022022202220202202000020000020020200202002222000020022220220020020002220220200220020022220002202002002020202222200220022002200020200220002200002</span></span><br><span class="line"><span class="number">020000222200200222220020222000220200200000022220000002000020000000222002222022220022202200020022022022222220000222200000222002220200022200220222202002020200220020000220002000222220202200020000020202022000200020200202202000020020020002002002220202200222020222202220222222222002020200220202000202020200</span></span><br><span class="line"><span class="number">202202200200222000222220222222202220000000200022202000020202222202020220200222220222222200002200000220000020200200222200202002022220000220022220222200002222020220222202220220002000000202202200202002222022022002020200202202000222200020200200000222020022002000220002002200002000200202022020222222022020</span></span><br><span class="line"><span class="number">220200022022022002022222022202202200002020022202022220002200020220020222020222222002222002202002000002022200022200022020020002020020002202220202022202000220022002222002020022002022200222202200220002200202222002220200222000222222022002020202022022000220202002000000200000202000220022222222220002200002</span></span><br><span class="line"><span class="number">200022000220222020222200000220220022222000220000022022202220222200020002202220020000022000220200020222220222202022000202220222200202000002220200202220022000200002202200200020000202000222020220222002200202202200200220222022220002202000200220000222022220202200220022200020002200002202000222200022200022</span></span><br><span class="line"><span class="number">220202000020000200202022020220000220200022022020022000222200200200200002000022002000000000222002020002000000220002002022200020022202020022022220002202000020020000202000200002222202002200200002020020002200200020220222000002002000202200202020202002020002220020200000220200200202200220022002222200002022</span></span><br><span class="line"><span class="number">000200020000020020200022002000022000000222202200020200200022022220222200022222220202022200200022000222200000022000222202200020202200222002002002220222002222222222000002002020222020222202202220202000202002020220002000002200222202000000022002200000200000000200020020202020220020202222200000020020222022</span></span><br><span class="line"><span class="number">022220220000022020220022000220002022020000002000220020202002202002200020020000020222220020020220000202200202022222222202022222020200020002220002222222022220000000200002022202222202022222020222220220220002200000022220200020022022020000220202002002002022222022000202020020022020020222220002020000220222</span></span><br><span class="line"><span class="number">220200200200020020002020002200022002020202022022020000200200020220202220200222222200222220000002022200000022002222000220020200020202000022002220220220022020220000002222022220022202000022220020200000220000020202020022200202202222022200000022220200002222200222222020222202020000222000002022200220222220</span></span><br><span class="line"><span class="number">202002022220202222000002222202020200000222000220002220000002022220220022200222000220200020202022002002022002202002200002220022002220222020002002200000200020000202220000000002222002000002000220202000000022222022202022020022000022022022200000022000022002222020000022020220020200220222000202020002200022</span></span><br><span class="line"><span class="number">200000222222220200000220222020022000200220200200000002220220020222022022200200202200220022000022002020022222002202022222220220222002200202220000200002202200222200202000200020220002222022002020000220022002000000022222000002020222020002202000000220200022200000000202000020000200000002202220022222222200</span></span><br><span class="line"><span class="number">202020020000220000022200002000022020020222222020002200200002222000022002020220200202000022220000200222000022022220000022020222000202202020020220022000200000200002202000220020202220022022020022200202002000202000202220022202220022202022002022202002202020220202220222220220000002220222020002220022202000</span></span><br><span class="line"><span class="number">200222002202200200000000202202200022222022202222222222002022202200222200222200200220200200000000022002200022220200002200002202202002022022000222200220000200000022222202000020220000022020200202222202022020020020222002220022200020020222200200202202222220202020020200222220002002000222222020022022020000</span></span><br><span class="line"><span class="number">200220000022002202222220202220002200002202222222020220000020002022202000202000220002220222022022022202002022200020200000222022202000222022222202200200000002202200222022022222220022200020022222000200220202000220022020222200000000022020022020200000220020220020222220002202022020022202220000202200022000</span></span><br><span class="line"><span class="number">220000202020022002020022200000222020002022222002000220202022202220002000020202020020220020022002002202022000002022222200220020020000022020002002222022200020200220002222220022222020200222202000202000002200200200202022000222200000020020220200020222020022022002222222002002200200202000000002000200002200</span></span><br><span class="line"><span class="number">002002200020002220202200020200002020220022202220020002222200020222200000202002000200202200020220220222020222202020220020222022220200202020220002222202202020220200202200020202202222022022000200000022000020022020202000202220022020020202022000222200020002202020202220002222202022200202222022000200202000</span></span><br><span class="line"><span class="number">000202020000000020002002000022020020202000022202020020022200202220200200002202020202200002020022200022200020200000002202000002220002000020000002200022222000020202000202002000002022222002202202200222022220022020020002220220222202200000022222222000202220200002202000020022000200220222020020002202002220</span></span><br><span class="line"><span class="number">222022202002020200000020022020200222020220220222202022202220002002000220222022200020222000002202220200022022022200222000002200020202022222200222002000020002022202002002000200220022000220000202020200202202000022200002202020200202222220202202020002020020220200220220020200202202202022200002000000200022</span></span><br><span class="line"><span class="number">220020200222222202220222002202020000000020002202222202022202220002222220202222022220002002022020022020222002202022020222202020200000002020202002002202220202022022200200222222222022202200220220000000020222222202200220000000020022222020222000000200220000200020200020202022002022222222202020200002002222</span></span><br><span class="line"><span class="number">200000222000000020000020200222220202020222222222022002222220200222002200000222000220222020000222200000222022220022020220020020000220220222202220020202222222002002022002000220200002002000220022002222200002002200000002202200022202202202022202000202200220000000220202220022220022202022222202202020202020</span></span><br><span class="line"><span class="number">022202200200000200220220020200202220020202202002220220220220200220020020200200202222002220220020022000022222200020002022002222002020020200222020202202020222022002020022020220222202220222220222000000202000000002220220000002020222022222220000200002000000000200020020020220002022022022202002020222020202</span></span><br><span class="line"><span class="number">000200002222202000202220000202220002000022020222202020222220202022222200020202002202000220020000020220222202220202020220222222200020022022002222202202022202022020000020222002202022202000000022022020202020002202022022022000000202202020022220222202020220202220020002222020202020002220202022020202022200</span></span><br><span class="line"><span class="number">000002222220202002200002222220002222002220222002000222000022202222000222022002002200200000222222202020020020022020202220220220222020022222200200000000020200022022000000200202200022222000202022000222200020222020002000222222222220200000200202020202220020000202002022000022020222022020220220020002202222</span></span><br><span class="line"><span class="number">220200000002202200000202022002000200002220002002222002200022202222020200220020220200220220200222202222022220020020020202222200022020002000222020020220002202000022020220000002202202202002002202222020222022220000002020002220022000202200002002200020020002020220020022202220200020222200000022222000020202</span></span><br><span class="line"><span class="number">020022200220202022200020202020002200020222220020202222222002200000220222222020200222222000220022202002020020222200220002020220002002220020220220200022020222200220222220202222200202002020002202220202200022200002222002002022200020222020200022000202222202220220222222000020000022000202202022002220020022</span></span><br><span class="line"><span class="number">222002002200000022020022200200000002220222200000220000202020002220000002202022022002000222020222220022020020200222222200202222020000200002222200202002202022000022022222020200220002202022000002200020202202022022000022200002000200020020202000202202002000020000222002000002000022020202020022020002022020</span></span><br><span class="line"><span class="number">000002022222200020202022020220202020002222202200002202000000200222222222002200202022220002000002000220000200020222220020200200020202200020200020200022202020200002000200222020020202022022020202222002020022222200002022000202222222000002002020200000020222022000022020222200200000200202200002000020200222</span></span><br><span class="line"><span class="number">222000220220002200200222200202000222022002022222020000020222000020220200022200220002020002020000200200202202220000202022220022022002200222002000222002200222220002200220022222000022202202220020020002222220220002200020002202220220020222200200200202202020000222220222200222202202200220220020220200002002</span></span><br><span class="line"><span class="number">002020202200000200220200222200222002020202022220200020020022222022222022200222020002200022020200222222022002002220200020202000200000020002202002202020202200202020000020002222202222220222202200002200202202002020002220222020022020222002222220220220000200220022202222222202200222202000022000200220020220</span></span><br><span class="line"><span class="number">002220020222200020002202000202200222202020222202022000220020022200022202222222022200222220000220222022020220222000020020022020200002222220220222020200020220220220220202022220200022220202022002020020200002202002000222220200222002020200200020220202222002022200200002020200002002222000000220022002222022</span></span><br><span class="line"><span class="number">200220000220200220220222002022002222020202222022202220022222220200020200200002202202000002220002220202202022220200202022222202022220202202002020020202002202020020222000202200000220222220002200200200200202220202202202200220000202202020202020220222202202202002002002220200200202022202020002002220022020</span></span><br><span class="line"><span class="number">222220220222202200222020000220002020220022022220000222000000202002022000002000200000220020020002000220220020002020222202020222000220222020202020002202200222220220020202020220022020222020002002022220220220000020220200002220002202202200020020000202000202222220002200002020002202020222200220222022020222</span></span><br><span class="line"><span class="number">222022200222002222002220222220002002000220000222222000200202000002022022200220220000002220220202222022022202002002222002020020200002020002202222202202020002022200222000000020222202222002222020220022000000220000220200000222002200000222202022020022202220202002202200222200002222222002022000220200000202</span></span><br><span class="line"><span class="number">022220222202200202000022022002200022200202020022002222020002202220020200020202020022200002202202220222022200022022222222200000002202002002022002222020222022022000002000002200022022022022202200002022002020222200022220002020200220220202020220020202200020020222002020022002220220220002220000222002002000</span></span><br><span class="line"><span class="number">020022002022222200002200200000020020222020002222220002202220022022200222022020020200022200222020022222002200002020222200020002222200220000220000002202000220022022202200220020200002020222202002202022022022002200020200020222022002200020220000020000202000202020002020202200002022000020200002002200020000</span></span><br><span class="line"><span class="number">200202220002022022222202022020022000200202222220000222222200002202202202020220022200220000200002222020000002000002202222220202002200200202202020202020022200000000200202002000000020000220002200220020222020022222222002220222002220020002220000020200200000200000222222002202022202002222000002222220022202</span></span><br><span class="line"><span class="number">202200200002202002202222222220220000200000220202000200220002222020200020220000202202022200200000200000200022020022000022020220002202000222202222000222022022022222220002020000200200002022020020200020020022220220000202202000200022000000000202222022222202022022002202222220000002200000222222220022220222</span></span><br><span class="line"><span class="number">002202202202222022222020022022022022220202020022000220222002020222000002000220002000200020200000222202200000220200220020020002000200002022002222200222202002000002200000220000020002000020202220020202222220202200200202022000020200222200020200002000222022222022200200002222000020000002202000022002022002</span></span><br><span class="line"><span class="number">200020222202000222202202002000002200002000220202220020020000002220022020222000200022000200220022000022000200220200022022200222202002022200202022020222020002222220222000000022022202022020000202000020202222020020202002200022020222020220222022202222000202202200002000222000202020022222200002220020000220</span></span><br><span class="line"><span class="number">222000202022222222220220020000220222222222220202220220220002020020020000002220020000002002000000000202020200200022000220200022220020002200002222200002200222022000000022222220220000200000002222222220200002220202000202222202202220000202220202000220002202002222022200202220002220000020002020220222202000</span></span><br><span class="line"><span class="number">022202020000022022202002002222000002002000220222020220002022020002022200002000202022000222020002000020222022202220200022022000002222202000222200020222222022222002000220222022020202020000222220200000200000022222020020000002022222002202000202220020000020222200202022222220202000020200200202200222222002</span></span><br><span class="line"><span class="number">000202220020200022022222220200202000222020200002022202220220220200222222222020000220220202000000222202222022200022220200222002202220002222022200022000200222020202222200200222200222000002002022220200022220002200022000020022022002002000022022002020220202000000200200022202200222002022000220220002020202</span></span><br><span class="line"><span class="number">222202220000022222022220002020002002000220002020222000202222022220020020220020002202200200022222222002222222022000022202000200200000002200202200202200022002202222220220220020200220220020200002220020220022002202022000002022020202022220022222202002220000222000020002202000020020000020002202020222202020</span></span><br><span class="line"><span class="number">022202020202200202222002200202000022220020220020020000022222220002200002022202202202200000020202200222022200020002022000000222220220200200022000020222000220202020022220220200020200220220202202222220220202220222022002202222022200020022000202200202002000020020022220000000220022202002000200020202202020</span></span><br><span class="line"><span class="number">002022002002022200000222020200220022222002200200202000002000020020000000000022222022200200200220002220022202200220202002022022202002222020200020022002202222220220200020022220222020220200000202200202200000220202020222000222022022022220222202220022022222200202022022202202202002020020222002222002022000</span></span><br><span class="line"><span class="number">022022020222022020000222002002022020200202220202202202222002222000000020022022022200202222220000002020220222202202220022200220002202020200000220200200000220222200200022200200202220200202222020002002022022202022220222002202002200022002022020202222022020022000002020222200002202222022222200200022002002</span></span><br><span class="line"><span class="number">222220202202220222222202202002002200222222000202022220220002020020220022022000200200222200200020202222022200000222220000002202002200002202222022220220200202000000022200020020000220020222200202222000200000000220202000020220200200002200202002200002220220020202002200022220022220222220202020022020002220</span></span><br><span class="line"><span class="number">200022020022220000000222200200222202202020220200222222020200002202020020022202002020022202220202222222002202220200202002022002200000200202020002020020202000020200200200222000220222202220222222220002220000020020202022000202222002220200200022202022222020220220202220002000020002022020222200222002002000</span></span><br><span class="line"><span class="number">202222202202200022202020002020020200020022000000220222222202020002022220002000020000002220022202200002222020220000002202202022000200020020220220002220200222022000022200000002202002020222002002222200022020200222020022002020000022000000200022220202022000020022000022002002020220222022222220002000202002</span></span><br><span class="line"><span class="number">220202222022222020020222220000220020200220220020020022200220022002202022022002202200202200022202202020000222002020020022002000022222202200022202020022220222000022202020200220000000222000200220000000002020022002202022020202002022202220022000200220222222002022200202022222220220222200222002000020220200</span></span><br><span class="line"><span class="number">020002000222022000220200222022020000202022002002200000222200020220202222022220202222202000220002202022020222220220022200200000002022000202020022222022000222000200000000022022000000002222220002000002222202020220000022200002222220222202202002000000022200020022222200202002220022220000220020222020002002</span></span><br><span class="line"><span class="number">220002202222000200002222202002000202020022022002020220220020222220020020020220200020020220022000002020000220002000202000000000022002022222200000022002020020222220220222022020200022222200200220200202220220222022222002020200000000022222200202000202200202022000220000002220002220002202022000202222220000</span></span><br><span class="line"><span class="number">222220022020202222220020002202222002222202202000002000222202020022202202022002200222000020220020200000202002220020200202220000020000022222000002222002222222020022020222002002222202000220220002220020202000022200000020020220200200202200000022202002020000020202022002202222200220020020020000220202022020</span></span><br><span class="line"><span class="number">000022220002220222002202022020000200200002202202202002020202200020222000200022222202200002220202220002200202022002222202220000202020022000022022200220020202022200222222222022220200202222022202220022222002002222220202220220000202222022200000002202200200200220002200000020022220000022020220020022222022</span></span><br><span class="line"><span class="number">220202222000200202002200220002200000222022202022000002000220202022020000202222002200002000200000222020222220222020220002200022222022000002222000200220202202022020022020222220022002200222202220022200020200222000222002000000020202000002020020202020220000202000200022020022200222002002202000202000220200</span></span><br><span class="line"><span class="number">222200222022222220202200002020000022222200202002002222200022002222020202022222220000220222022220002000002202202220000220220202022002200002200220000222220220002202220200002220020000020220020020000202002022022202220200202222222220002202020022022200020220020022220020002002220200022020022020202200022022</span></span><br><span class="line"><span class="number">020000202020000202200020202202220000000220000202002202220200002020220220220200000000020220222222220000220220020200022202222020220220002000002022202220202020220200000202000002200022000222200020000220022220000222202022002222020222022022222222200200002020002222200020022022222202200202220002022022020220</span></span><br><span class="line"><span class="number">200222220002222202000200202022200202202000022020002022002202220202220002200020002020222002220200002222200202022022222220000002222000222002022222220000020202220222002000022200000200222222222000222022020000202000200022002202000222200000202002202200022000002002000000020020220002020002020002222020000002</span></span><br><span class="line"><span class="number">202200020202020222020220002000200002002000020220020002020002222020002022200220022022020202200020002220020220202200202202002002220002000202222002000022020220202202022000222000000002020022022202022222202220002202022200200020220220222000202022202220220000020222002200020200200220000202002020002220222000</span></span><br><span class="line"><span class="number">022220002222020022020220200222202200220222022022022000002222020002002000002220200022000022200222002220022222020000220222000022000000020222000000222022222200200202202222000202022222022020000022020202002222022020022200020222022000222200220222000222002022222002022000022222020020222002220002002222000002</span></span><br><span class="line"><span class="number">222020022200000020002020002202202000022200200222222002020020200000200200200000020002200202022020002202020002220022202220202222220002220020222222020220022222000022002002220220200202202020002000020200022220002202220200220202022000200200000222022000220020220000002002200202222022002002000002002002220022</span></span><br><span class="line"><span class="number">202002202200002020220002220020202002202020002002000022202020222220200002202222000022200000002020000202020020220002020200220222200020020202200000222002202020000220202000020220022220222200202222000200022220020002002002222000020002222222002202200002222022002000000220222020022002000202220020200002202222</span></span><br><span class="line"><span class="number">220220002022000200022000022202002000202002020222220002200020220000022220022020022222220222020200200222020020022020022000000002000002202000202202002200202222222200022000020220200200222022020022022022022202222202022202222000000000222000202222020200002202222222002020220000202202020000000202022002202022</span></span><br><span class="line"><span class="number">002200020002200000202022202220000002222002000200202200202220000002022020000222020220020200000220222022020220200000000222220220000202220020002000220220000020022222220200222002000020022022020200220022222000000022202000000002002202002202202222200200200020022002000002222222002222000022202020020222020002</span></span><br><span class="line"><span class="number">020020020020200020222202020022020220022200222000220202020022020022220000202200220200000220222202202000020022022202222022020200220200222222220222022202002200200200202222020002020002022022020000200020000202202222202000220020202222000222220002002000022200222022000002200220022202022002222202002002200020</span></span><br><span class="line"><span class="number">202020002020222202000020220222022022222202200222002002202222000000202002022202202020220202020220022002022022002000222222220002002222222022020002000022022222222202220022202222002200202222222200020220000002020202220200022200002020222022202002020020020222022000002202000200022020020220002200022000202220</span></span><br><span class="line"><span class="number">022000000202000022222000202202220222020202020022220200000202202200022022022022000000022220220020222202220020022020222022222222220022022220020002022222202020020200202020020022000220200022202202200222000200020220200200002000202222200000220022002020202220200220220222002222200200220200220022022022000202</span></span><br><span class="line"><span class="number">200222020022002000002202202020022202000202022220000200020222020000222200000000000000022200002200220020022022022220020022000222022020222222222202000200202202222000002020222000222202022222002200022202200022022222022022200000220020222000202002022202020002220220000220000000002000022000200002220002022222</span></span><br><span class="line"><span class="number">020220202002000200222222200022002002020022200220022000200020222002022002002022000202002002202200202220200200022200220002222002022220022020022220202222200002222220222020220022200200220000020222222202220200202002020220222202202022002202002022222022222002202200000202022220222200220002200002020200222020</span></span><br><span class="line"><span class="number">200202002200000200022222220200222200020202002202022020022020222222222220000220220202200222020222200022002022022200222200022000002002020000220020002002022022020222200202020020020202220202222020202202222222200200022202222020022022202200020022220200000222002222200002002022200200022220020000002222022222</span></span><br><span class="line"><span class="number">220200022020000220022220220000002022222222000020202220020022020020222020000002020002022200202202200220020202222200000002200020200000022022222200200200220002222022222022200022020200220222000000020202022200220002002000002222220202220200020002000220200222220202200022202020020020022000020022022220220202</span></span><br><span class="line"><span class="number">000202022222020002002200020020020002220200202022020202202200222222220022200000002020200200002220020002022020200022222020202000220020202022220020222022222000022220002000020202220202202220222022020200000202022200022222002022020020002002202020002000220002000020202022022200202002220000000200222022000202</span></span><br><span class="line"><span class="number">220220202200000002022022002002020000000200220002220022220220200002222200202000000220200202002022020220222022220020222222200200220200202200002220202200020022220022200022200200022222022022022222022000200022202222220202020200022202200000202202200020200000202222220200202202220002022200222220200002220020</span></span><br><span class="line"><span class="number">202020222222220000022222200002200200002200202000200200200020220002000220202202022200200002020022000200020002002000020220220000000222020222022222022222020022022020222020222020020022202022220220020202222202022222002020202000000020202002220000002200002202200220002002020020222202002020020020222022002202</span></span><br><span class="line"><span class="number">022002202202022220002002222202000200202220202000220000000222020200222220022002202002020002200202000202200000000022200000222022022222002222020222000220022222200222200020200002202022200220000022000200200002200200002222202020000002220220022000002002002200222000000220202022020220022200220000000022022222</span></span><br><span class="line"><span class="number">022002022202220220000200222222200220002202220020222020202200002000022020020002020020000202020020002002220200002000202020020222002002022022000000022200002202200200200220220220202022022002002202202002220200000202022000000022022000002220222200002222220020220220002222202002022000020200200220200000200002</span></span><br><span class="line"><span class="number">000222202020020022222002222022200000200220020222020222222022220022220220002200200222022222000002022002220020020000020200222222202200002222202200022020222022222002202020022000000022000202020020000022222222020020220220000022220222220002022000022020222002002000220202020202020220200022000200220200200222</span></span><br><span class="line"><span class="number">202200222200220000020022000202222200002220022222022022002022002220200002222002002002222220022202220020222020202220020022000220000220020002002222222020022000002000022020202200220020220220200220020222220202000020020200200202222202200022222002020020202202200220002200000222002222200002002000200200020202</span></span><br><span class="line"><span class="number">000020200200222220200022202222202200202202020000002202020002202222220002222000200200020000222020202000220202220000222220020002022000000020020020022222200222020202202222022020202000020000022220020222200022222002002200202200020020002222002020200022220200202020222002022022222202222000220002220220200220</span></span><br><span class="line"><span class="number">002000022222220020022222202222022202202002002200202222002022000020222222200002002022022222020020022002200022022220222222222002000020202002002220222002022000022002022020222022202200022220200002222222020000022022000000220020002022220000020020002202202002002022222220222000022000202020220000022002002020</span></span><br><span class="line"><span class="number">200202202000022222020222200022220022220022022020200000200202202022222002020022000202200200022200022022220002000200022020020020000002202200020220200222020202022202000020222000022020022222020000202022022220222200020202022002200022200202200202020222022020200022200222022000200222020000000000002200002220</span></span><br><span class="line"><span class="number">222220000020020022020222002022002222002200020202020200022200020220222200000220002000022200200222002002000000000000022002222022020220002002222220220220200202200222000022020002020220222020000220022200000020022022020000000200222200202000000202022002022020000200200220022002020200022002202202200000000020</span></span><br><span class="line"><span class="number">222002222000220202002022220200200220222000000220202220222002022022022220202202020220202220000022222202200020002000000222020222202022222202022020002022222022000220002222022222000202020002202222220200020200020020200002020020200020200222202200022020202020222022002222022222022000020200002202200002002222</span></span><br><span class="line"><span class="number">222222000222022200222222200222222022200220202020022222202022202020002022000202200222200002222002222202000200222020200220202200002202220220022222202220002222002020220202220022002020002200200220202022202002200202020020002022222200220002220222022200000200200020002200202222200202002022222200020200202202</span></span><br><span class="line"><span class="number">022002222202002220202020002200200220220202200220002022200202022000220200222020022222000020200202002222000200202020000202222220000220222000202220022000222002222022022202000200200020222222002222002022002220002022220002002000200020200002200020200020020200000202022022220022000022022000200000020220000202</span></span><br><span class="line"><span class="number">220022222222200220200200222200002222200000222200220222002000022222022200200222002222000020200022000222000002000022002222222022022022200222222000020222220022000000020000020202222200222220202222000020200220222202202222222222020202202202022002020200220020220202002202220222022000220022002220022222202222</span></span><br><span class="line"><span class="number">200000000002002200220222222202220022002020200020000000000200222220220202220002200220002222022220000202222202000022000202002020000002000200222222202202220220200002002222022222222000002020222022000202200000202220220202000022002202000020020022002200020202222002222200200202222220000020222000200000022020</span></span><br><span class="line"><span class="number">022000022202020222020022022020202202020000220220222202022020000020220020022202022022022222022000000200002000020202202022202000022022202220220022200202200200202000020000220220022202200220202220200022020022002000220022020202000000222202202002022000022200000000200000022022020000002000002002200220222020</span></span><br><span class="line"><span class="number">202220000002200002020200220020222020022020200202020202000200222000222020002022022022022220200220202200022222022220000000022002000222220002002000002200220022022202020200020220220000020000222002220020202222200220200020002220220202202020020022200200202002000000022000000200000020222200202002220202202000</span></span><br><span class="line"><span class="number">200000020020200220020022020200000000202202222022200220200222020200002202202022020200222022200200020002202200222202002020220022022222222220220000222002200200220022202220022020200020020222000002000220202020022000022200200202222020202222002220222220200022220022002000022220020222020020222222020200020022</span></span><br><span class="line"><span class="number">200000000020220022000020222202222202220000022222000002222202222200020200220220022020002002222222220020000220202202220020020220202022220222020220022002202200000202202002002220002020200022200022000022220202220000200200020022020200002002000202020022220222022220022202202020202202200222000202002002022002</span></span><br><span class="line"><span class="number">222002002222200002002222202020220000220020202020220020020202000202022000002202222020220002000202022222220202222000022200200200222022202002000002200022202002002222020222200220222000022202020020200022222020220202222000222220200020022022202020220020000222222002220200020222022022022220000200022220000220</span></span><br><span class="line"><span class="number">022200000002002200222202002222002222222022020020000020020202022202022020202200002220202222200220020000220220202202000002000202220222222000222022202200200000220202022022202200200000020022202200200202202222222202220202200202220020000020022200002222220222202220220222020022000222002200022002200220202200</span></span><br><span class="line"><span class="number">202220002022220002200202022000022000020220202020220222022200200022202022000002022022222020222220220022022200002000000222222220222002200022222002220220022222020200202002000020022022002200220222222002002020002200220000002222002022020022002220222000220020222002200000020222020002002002020220200220022022</span></span><br><span class="line"><span class="number">202002022000222202200200222022222020002000220202222000222202002020020202220222222020020020022202000022222022220202200020000000022202200222202200202220002002022202022222220002002022220220000020020200222022022022222002000002000220202200002202222000020020200002220222222202002020020020022220200022202222</span></span><br><span class="line"><span class="number">000000220202202022220220222020022022220222020002000220202000220000002020202222020002200200222022022202022000222002002200000000022002022000202020222022200020200200202220000020002220202020000022022222022022222220000022202200202022020200200222002222000022000000200022002020000002220220220022022222000020</span></span><br><span class="line"><span class="number">200200220022202222202020200000220222000000222020220022002022222220000000202022002002202202200202222200000002220202220020220222020002200020022222000222200022202022022002002220020222000020220000000002020022202220002222220022002200222220202222200002222202202220022200002020020202202200220022002000220220</span></span><br><span class="line"><span class="number">200002020022020202220222200222000202020022202022002222022222002020020202022022002220000200200000220202222200000000200000200002220022220200220222020022222200022202220202200220002002022200020000000020000022222022200002022020002220020200020202202020020020002002000002000020020002000022002000200200222020</span></span><br><span class="line"><span class="number">202222202002000222002220220220202202002220020220202022200220002222202020200220222222202220002200200202202000200200020020000222000002222000222200202202020220022222220202200202200202220200202000222000000200002000200220222020222222002222220022022222022222020222002000202022020222022202222020202020200002</span></span><br><span class="line"><span class="number">220200222000020020220200202202222222202020002202022222222000222200000202220022002020020000000002002002002220020002222220200220002000022002220000002020200002222000220220220020220200020200222000002200220200022000020000222202000020220000200202222020220200002220220000200200220000020200222220222022200200</span></span><br><span class="line"><span class="number">002022000222200200000220202002000202022222000222020022002222202222002022220202200000202222220220002002220002200200220000202002002220222220020202222222200202200020200220000200000200220020022202200220202020220220220002200020200002000020222020000222222220022000220022200222220220202220002002202202022022</span></span><br><span class="line"><span class="number">000202200020222022200220222222002222200002020202000200022202002220022200000220220220020222000222022200022222220002000222222022020220002200200020200020220220200200200020000202022000202020222000200020022200202022002220000002222222000220202200020202200000022222200200222200000002000022220202002020000202</span></span><br><span class="line"><span class="number">220000220202020022000000220000022222200200000022200220220220000020202202202020022200000200222020200022020000022020002022002022200220222220200022022000002220220002000200200220222022200222200222002222022220222002202002200202022022020020002022000000020000202222220000022022202220200000020000202220022202</span></span><br><span class="line"><span class="number">200002022002000200022220002200002202000222220202020202220222200000202002222020202200222222002200020002022202022222020202022022000200020220222002020202220000002220222020222220222022000022002020022200222200200220000222022002002222002020002020022220220022202000222020222022202202200222222202202002222020</span></span><br><span class="line"><span class="number">020020222200002022200220200000022020002002020220222222002202220220022200000220000202222220222022222000000002220022222202202200202222020222222022000002220020020220020020202002020022020220020002022002200222202200222200020022202002200002220020000202202220220200200202222222020200022020222000002020202200</span></span><br><span class="line"><span class="number">000222020222202002000000222002022000000022000202020200022002020002020000200022220200220020002200222020200022002220200002022020020220000220002022202222020220022022020220222220002000222200220022202020000002202002222000200200002000020020202020020220202202222200202220222200002200220222220202002222220022</span></span><br><span class="line"><span class="number">200202220222220020202022200200200000022220000220022000022220022200000022200222000002000020022020020020200000022200200222002202000220200000000220020202220200000200220000220202202020220222202220202222222022022202220000202022000222220002220220200220222020200002220022000000202000222202020222000020002020</span></span><br><span class="line"><span class="number">200020020200020002220002222220222020202000022020002202200020002002000220022222002022200022200222222022000022002222200222022222222000000202200000222022000020002202022020000220020200220202020020022222002202222200222202000022220022220000200000000222022220022202220020220202222022000002000022000200222020</span></span><br><span class="line"><span class="number">220020022002202022220202222022022202000000000200000020222020202222202020200020022022022022200022000020202202000220222002200202222022202222022222200202022200022202002200000202002020222000222020220002002200200202022022000220202222222200220002202000020000200022220000200220220200020220000220000200222220</span></span><br><span class="line"><span class="number">020022020200222002200220220220002220200020202202222220200220220022002022202000020200220220220020222202020000200002220000222222220220220222220222022002222020000002200022020222202220200222220020222020202222200022222202002000200022200002002202002002202200000000202020020220022000202220020202200022000202</span></span><br><span class="line"><span class="number">002020002000022022200202002202002020022222200000200002202220000202002202220202000002000000220002000220222022222202220000002020220200000200222022002002220020220202022200222022220200202000020222220220000022022222000000220020020222020002220220020202020220002220002202002000202222202020200220002200020220</span></span><br><span class="line"><span class="number">200020220220002200000200022220202022220220000200020002000022022022022222020202002200202200002022022002022020202000000220222020200202222220002220022020022000222022000020020200222000002222022000022000000020002222020022022002200220222000222020222000000020020200220202222220020020000200200022000000222220</span></span><br><span class="line"><span class="number">002222022020222222220000202020220200002000002202200202200200000220202020222020022000020020020000022002200202002022020022220002220200222202000002000000022222220000020002020000222200022022022220002020022000200200220022022002222200002200022000022000222200220022002000200000200022022000202200002220200022</span></span><br><span class="line"><span class="number">202002220020020222000020220002022022202222200002220200020222020220000000000000202022002202202200220222020202222220220022202022022220022220202200020220200022020222220000220020200222000200200202200000022200000022002022002222022200220000220222002220220200222022220222022002202202222202202200202022020220</span></span><br><span class="line"><span class="number">002022022000000000002200020220222220200222000020202002000000202000202202022002000220200202222220020200022000020202202220002002002002222020200022200200202200022222202020220002220022020200000200202202022202202202000020220202200222002222220222222020022220220222000202022000000200022200200200000022222022</span></span><br><span class="line"><span class="number">222222222000220022200220002002002020200002002002222000202220000022022220220200202222002202000220000220222000220222000000200200202220022220022002200020000020220002022222000002222020022020200222200202222222022020022222220022220002020002222022222220202222220222002002220202222002222202022000022000220200</span></span><br><span class="line"><span class="number">202220200022022220022020020222220202222202020202220200002220220000000022200002020202202200022202020220222202220020202002000022020202222002020202222220222020220002000020000222000020000020002202222022000220200200200002022200220022000220220022202020020000002200220220002020202002000022002000022202002220</span></span><br><span class="line"><span class="number">220200000002202002200222000002200222002002000200020000002222000220022000022200222020200222200200220022220202200202220022202020200202200000222000022200220022200020220202000200222022222002200000222022220222222222202002022000020002000200202220202002002200202002020020000020200202002020222000002222020200</span></span><br><span class="line"><span class="number">202020002222000000002220220020002000222220222020020200020220020000020002000200022020222222020022220200220200200002202222002022000200022002200020020020002202200202002002202200200000220020022220022220020020202200020200222200200220220222220200020000022020200220200200022202002200000002220220022000200000</span></span><br><span class="line"><span class="number">022000002220222022202020002000200002020222220220002020022002220200222020020022022022220020202022020220022222200202002220020002220220000222022002020020202220000000220022220002000222002002222200222220200222220220002202220220200022222202220022202022020002200002200022222222202000002200020020202002220220</span></span><br><span class="line"><span class="number">202000220002202220002200020002002022002020200020022020022000000020202020000202020202022000000020000200222000220020022000220002022000022000220022000022000200022200222222002200220220022200220000000202002220220022200020002000200220002000020222020202202002022000020000020200202220222220220020220002222222</span></span><br><span class="line"><span class="number">222220002020020002200200020000200020222220200022202220002002000202022022000022200202000202200222200202020022202000020200022202222222222222000220222002002022000220000200022000222002220002222000022002220202202022222200000000220000002202000222000000222222200200220002222002220002020020202202222002022220</span></span><br><span class="line"><span class="number">002002222000200220200220220000220002222222200202202220220020200002202022002200200000002000202000222020020220020220202222020002200000020222002202020202000202220200200222022020020020220002202022200202000200200002222022220200020022222000220222022020020002222002222200000002220022000022202222200200200220</span></span><br><span class="line"><span class="number">020020220022202200220000222022002222020020202200222220222222022022020200002022202020000222200202202202220222022002200202022200222000022002202202000022220220000200020020022000000202222020000022220222000000202220200200000220000200000200222202020020200020000202022222000022202200202022002002220020200222</span></span><br><span class="line"><span class="number">000220220022002020020022222200020200222000000022020200022220000000202220222222202220202220200200200000220222200022200200000000002200002022202202020200222022020220020220020222202000202020000000220202000200202020000202222022200002222202202200222000002020002220020200020002022022220022002200000022200022</span></span><br><span class="line"><span class="number">202022020000020200202002220220000200020022222020220022022200200220002000202022002202022202200022022202002202000000200000022002002222000220200222022020222222022000220220020020200220020002002000202000000002220220220200000020020222222200200022200220202020002022020202222022002002202200020020020220022220</span></span><br><span class="line"><span class="number">222022200020022202222220222220222020020220202202002200000020000020022222022000200222002020020200022202022000022220020022222202220220020022022022022020000222220000220220000000222002200022002220202022202000022020220200020222002220222022002020000222020020222220220000002222002022220200000220222220022220</span></span><br><span class="line"><span class="number">200222000222202022200220202022000220022220022002022222200220202022002002202000200220022022002000000020200200000020220222200022222222020022202000000200000022002002202202200222020020022222002220202022020202222022002022200222200022020220020222022220020200022222202000200222020000220000000200022002200200</span></span><br><span class="line"><span class="number">000222020202002020022000002000002000022000002220222200220200022022220022000002000220200002002002202022222222002202200020220000200200202020002202220000020222020022022200022220222022000020222022000000020202220020222020000222202222222022220202022020200202220220222002220200022202002202000000220202220202</span></span><br><span class="line"><span class="number">000000202200202200002000022002002202202022000022022002220002220022002200022022022220020020022000222022022002020022000000220200220022220020220202202222222200002000000200020202002000202200220000002022002220020000222022002222202022022020222222200202200000020220000222022202220000202022222020000202222022</span></span><br><span class="line"><span class="number">222200000202220202222002022002202220000222000222000220002022002020200200202222000022020202020200200202022202220200002202200000022200020220002202202222222000222002022020002002000222200002000000200220022020000220022022220022002002022202022000202222022022022222200202002200202000222002222020222200000200</span></span><br><span class="line"><span class="number">020220202022200002202002020202222220022022220000222202220222202000002200002200020020202200202200002200002020002020200020220220202220200022220020000000200000000200022202002220020022022202220020000222020200000002000020202200202200002000222002222022202202020020020020200020202202020222222220222222200222</span></span><br><span class="line"><span class="number">222022002202002202020020202220222200222202222200022022022220000220000220002202002020222020002202000220200020200022000000220202022202000022220002020202022022200022000000002222000200002000020020202222202202022022002020000222202002020202200020000222202020020220220022000200020020222222220220000020020220</span></span><br><span class="line"><span class="number">202200220000220202002020022000202002002000000002222000020222220020000220002220002222002020220002202220202000022222020002222222000022020022202220220200222020220020220202020020002202220222202200002000022222222022202220200022220222020222202002002022222200202022000002202002200002022000200002022020200022</span></span><br><span class="line"><span class="number">202020020020020222220002002200200200022200220200222220222202202200000222200020222000020200220202020220022002022022020020020202200222022222222220202220202220220222002020020200220002022020220022020220220222202020220020002202002002222202000220000022222020220200202022020022000002202222200020020002022220</span></span><br><span class="line"><span class="number">222200222202202222200200202202002200000200202022202220202220202202202020220222022220022202200200020200020022022220002002000000002200220200002200020200200222202002222222020202202022002020202220022000020020022202020002202002220220202020220200002200002222200222002202222202000220202002200022200002022202</span></span><br><span class="line"><span class="number">220202020000022202220020202202000222200222200002002020020220002220022002020220002202222200222000202222000000202222200202000000220200022202000002022220200000000222220022200020020202222220200020200200000000202022000022002220220022002220222020222200222200202222002002002200200202022020200000022200220202</span></span><br><span class="line"><span class="number">002200022020222020200000200002022020202002002202222002002002220000200022000000022220200020022222020000022220002222022222200202202222022222020202202000200002020200000202200022222002020022002202002002200222200022202020022022002202222202202022202222200202220200000002002022000000222220200002000000222022</span></span><br><span class="line"><span class="number">000022000002000020222200200022202202200220220222020000022022222020200220022220000222220000200000022220222220200220022000002000220002020020022202202222222020000002220000200020000222200002022020200002200220220222200222002020020022000002222022020202000220000022202200022002222222000002002022220022222222</span></span><br><span class="line"><span class="number">200020022220202220202222202222220220222002200000202020000022220220002002202022222200222202202220000202200022022202000222022222020220222022020002222020022002022020200222020202000002000220020020202002002222002200220000202020002022200222022002220200000000220202200020202200020220220000202222020002020002</span></span><br><span class="line"><span class="number">202220222020202200002222220200002020222202020000200000000000202220202022202000000222202000000222202222202000000022200000200202200220002022202002200220222000022222002200200020002222202002000202000220000222022020002020000000222022022022022202022020202202002022020002000020202020222220220200222202002002</span></span><br><span class="line"><span class="number">000002222222020002200000222220222220002202020022002020022020202222020220002020000002020222200220000202022002220002022202022202200202000002220020200222000020222200022020020022220200222200202200020022202022222000002220200002020000022222202020222002002022022202200000222020200000220222002222200200000022</span></span><br><span class="line"><span class="number">200022020000022020202220022022200002000202020202020220002220200022002222000022002000022202220200000022000002022220202220020000220200000202020220222200022220000202220002222000202222200222202222022002020002000020020200222200202022220200020000000022220200220202222000022002202022002222220202202020200020</span></span><br><span class="line"><span class="number">220220222000002220022000202202220022020000220000000022000200222200020020200002022202222222200222022022202220020002222002022022000222220022020000220000200202220200220202020020000222220202022000022200000020022000002200220222000020220220200222002200202000000022202000000220022000000200020022000020200002</span></span><br><span class="line"><span class="number">222220022022200202200200022222020022020200002022220220202220022222002202200002002022220200200202000222000020222220202200202220202220220020022002020000222202020200222020222002200200022022000200022220020002222220220220022020222200202002022022222020220200022220022200222202222020202020220020002220220020</span></span><br><span class="line"><span class="number">002020022220220220022202200000020222200202000002220022202202022020220022022202022002000220020220020000220200200202222002020000020022022002202202220222222002200022002002220202202022000222220002202222020200200002222220002220022022222222222000000002000200200202020022222022000000020200202022000020202220</span></span><br><span class="line"><span class="number">220222000222220020220002022022002000220202200002000022002220200000002000202220202020222022002020222000200222022202202220220220022202002020222220000200000000222202200002000200220200002000222202220202220200202002200002200220202202220202020200002000202020222202200200200222222022202200022022022022220002</span></span><br><span class="line"><span class="number">020002000000022020220200222222200222000220002000222022222022022202000222200222200020202220200220222202220200020222000000202202202220002022202000000000022002002002202202222020020222202022202202222000022002220202020200220200002222222220222200000000002022222020222022220220222222222220022200200222202202</span></span><br><span class="line"><span class="number">002022202220222022202020220020202200202000002022220222022020222000200022202022220002222200000020020202200000222020202000202022220220022220220022020222222000222222222000202222222222222020220002200220222000200220022020202200220222200020220220200002222200022020002020220200020220202002002000202200020220</span></span><br><span class="line"><span class="number">002200022200202002002022200002202200222200002202202220020022220020022202022200000020020000222020202002020002022022200202202020020220022222222022022000200200022002222222022222022022200002000220000020202002002200222020022022002000022002002202200220020002220220220020220222200200222000222000220020000000</span></span><br><span class="line"><span class="number">202202220000020222220222222220022022020222000222200202022200002202222202022000220202022000202200022022200222222220000222000002222002222000000022022202020222020020002220022002200202020222000222222022202020202222022020222222022020222000220200022020202222220222220022220020000022002020220202020000000220</span></span><br><span class="line"><span class="number">022220002200020022022200222200202002022022202002200002200200002022000200000202220000022000202202022020222020020220200022200202000020002022200200220202222200202002200020000002022200202020000200222220202000000020002002202000222020022022002000202222022202020020222002000002000200020020000002000022000222</span></span><br><span class="line"><span class="number">020220020020020022220022202000220000200200002020000022002000220000020200022002002220022000220020020220022002022222000200000020022000222202220002220202000200020002020022020002002222222222202022220002002220222020002222200020222200022022022022002200202022022222202000022022202200200002000220220222000200</span></span><br><span class="line"><span class="number">022222002002220000220020202022000200022002200020000222020022200000022222222222222202000222200022202220002022202002200020022200202002022000022022220002202020000000202020222220222220020020002220200202002222000222200022202222002000000200222000020020200020202220220222220200020202020002220222002200022020</span></span><br><span class="line"><span class="number">002222000202020000220020020202220202020222220220002220222222000002220000220022200020020220220200000000200022002020220202000020222020000202002020022022200220020202200200200220222002000002000200022002002200002220220020002220200002002002002202200022202022222000000202020222202022000202202200020222002220</span></span><br><span class="line"><span class="number">022202220202002200222002000020222022220222022222002002000202000222020000000020200222222220002202022020022202022002002220020022002020220220220020222220002020002222202202220022200220220022020022002200222002202222200002202022022220002002220020220020202200000200002222022202202200022202202200020020220000</span></span><br><span class="line"><span class="number">000002222002002200020022222222022220022222000202020202022000020202022220220222020022202222022022202202000020200002002222200000000220000222002022202222020000020000022020000000220202000000020220000200222000020020020002202022222202022022220202002202002222220020002202200222000220220222002220020000222202</span></span><br><span class="line"><span class="number">222002022022002202200022022200220202202220022002020222202020222022000022000202202202202200020022222022020000222002022022022000222220000000222002020200222022002222020220000222200202200022020002000202002002200002000202200002002002020000020220002202200222220000222222200220220000000022020002020002202000</span></span><br><span class="line"><span class="number">020202220002000200002220220002000000020202002220022000022200222002020020222202200020000220002202022002220202000002022222222200002220022022022020222220220022200002002002200222200200222220002220200202202220022222220020022200020020002220202000222022002202200202002222020000202220200020202202020020022000</span></span><br><span class="line"><span class="number">202022200222202000002220222002020020002200000000020202220000022000002220022000000022202020200020002200222022220222220020222202002022002200002022000000200000200220222220220002200220000200002000002002200200000220000000020200022222002020002202200022222200000222022022000020202220000220220222022002002220</span></span><br><span class="line"><span class="number">000000222200002202202022202002202000002002002000002220002202220220200220002000222202020222220222222222200202220200222222222002022220220020020220220220220202020200202020020002222020020022002222002000202022020022022002002222202202002200200000220202200200022220002000020020020202002200022220220200200202</span></span><br><span class="line"><span class="number">000022200222002222222202002022022020002200002220000222020020222022202022222222022020022020200220020222220002202222222222222202002020222222220020022202020222220220000000022002002002022222022200020220022020020220200000202022022220002202000022022202200022000220202022220022222022002022222022022022200020</span></span><br><span class="line"><span class="number">002222202000220202000022200220222200002202200020022202202200000020000222020222202000200000202000222000020020222020000222220002202000222000220022022200200022222002200002000202202220220000022200220202222020000002022000220022220002200202022200222220220220222200222000202000222022022000220222020222202220</span></span><br><span class="line"><span class="number">020222020000202020200220002020002222200200000222002200020022220220220220202202220002200200000000220022002222200222200222220020020200022022022020022222202220000200020202020002020000222202220020000220000022202220022200220202002202000000020222022200200002022022220200000220020222020220200002220222022020</span></span><br><span class="line"><span class="number">220020002222002220220202002000202020020202020202020000002022202020022020022022020002202020022220202022220020020022000002200202200000202202020220220000020200222222222200200000200202000200022200220200220022000002222202220220202002020222020022222222002002200020020222022202022200020002022220222020200200</span></span><br><span class="line"><span class="number">002202202020002000020220022002020020002220222000200022022200200202000220000022002202222200002002000020222200002000200000202000020000002220202220220002220222002022022222000222202000202222002020002222202202000202002200220020020222002220022222002002222220000020000022020020000202020002200200202220220002</span></span><br><span class="line"><span class="number">002020222222020020222202002202222200020220200222022200002200202200222200200202220202022200220200020000220202022200020220022220200220222222000220000020220002220002220220002022220222202202002000202220222022200222222222200220220222002022000020020202220020022220222000220020220200020222000222200002222220</span></span><br><span class="line"><span class="number">220020020220000200202202020002020202220020020200202022220220200220220000202002222200200222022220222202200020200222200020220000220000202220020002222222020222020000022220200220220202220022220220022000202200002022020020222020202022022002020200022002002022020202220202020002200220202200022000000020002220</span></span><br><span class="line"><span class="number">020002200000000220222222000200022222022020002220020222022202000002202222002002022220202202022220222000222000002220020220002002202220200222222020020002200022000220202000000222022000000020022200200202220200200200002000202202000000222222222202020022220222200200202002002220000002222200202200022202200020</span></span><br><span class="line"><span class="number">200202020002220220022222222002200222200200002022222020000020022020200002002000220000220002220000000220002020002022202020002022020220200220002002020000200200000200222202002202022020222220002000020222222022022202222022022220002202200220220022020202202002202220220020202000202002000202222020202222000222</span></span><br><span class="line"><span class="number">022220002222222200200200220002022222022220002000202002002020222000222222002002000220002020220022002202022220020000022022202000002002200020000002020020000022220020200020220220020220002022220222002000202220202200202020000020202000000220000202202020020002220020022000000022000202200000002002200020202022</span></span><br><span class="line"><span class="number">022000020002000022200000002020202220022200022200002202002222220202020202200000222222022022002222020200200200222020002022220222220200220202200200022202222022022002020000200200200002222220002202000022220022002002222222222002220000222202022222222000002200022220202220222220202020000220022022222222020022</span></span><br><span class="line"><span class="number">222022002220022200000200200202000220020000002222000020000022220202220022222220222020202022200022020000220200022002000202220222220002200202022000022200022022202222222000020202000000000220222202022222200202002202020200220220202220022000000200002200020200000002020200200200202020022220220220000222222000</span></span><br><span class="line"><span class="number">202202222022220200222022022200002200200022000002200022200222020220022200202202202200020200200220000020200000202220022020002220020200222022002200000020200002220202000000002200200002020002200022220220220022222202220202222200022020022202222220220022002000022020020202022020222222220000000000002022000020</span></span><br><span class="line"><span class="number">202022020200022202000000020220000222022202200220202020020002002002220220222200000222002022022022200022002222020220000020002022022000020002200020202000222022220222220202002222220020002222200220202002002202002220002222202002202220002000000200220202020222222202000020000020220222220002020020220200020200</span></span><br><span class="line"><span class="number">220220002022220000220222022002002222200200002020002202200200002200200222220202000202002200022220022020222020002202000020022000000200220000220000022220200220000020000200022222020022200020202002202222020020002202022222022220202222022022222202022002000020002202020022002002200020002022000002020002020202</span></span><br><span class="line"><span class="number">020202200022200220000220022220220202202202002220200022202200220220220220200200020020200022222022000202000220200002220222202000022020220002000220020222220000220000022022220000202000222202220020020222002222000000022220020220200022002002200200220022222022022200202222020222220200220200202220202202002222</span></span><br><span class="line"><span class="number">202200222020220202002020200020020022000220220002002022200000002020020020220002000022020222020020002220002200020020020200020200022002000020220202200202022022222200022022222022202020220000022220022020222000020220220202200022220022200220022220000220222020022000222022222022022002002020200020202002020022</span></span><br><span class="line"><span class="number">202000000220000200200022222022222000002200200000002220220222000022222222022020002020220202200222020002002202000200200220202002022020002202000000202020000022002220022002202200002022202000022220222202222202022020000200200222202220022020200222202220020220200020202000200200000222202222020000022002020200</span></span><br><span class="line"><span class="number">002022020222222202222020000002000220000000202200022202022202000000022002020022002002000220222002000222002000022020000220222222000202220002202200202000220000220020000022000200222020222222222000020200002222020000000200200200000022202222020000202220000200202222222002202000200022022002222000200022220222</span></span><br><span class="line"><span class="number">022000220020002000002222200202222222202000222020002000022200002200020222200022222022200020002020000202020000222020200222000022200222022022200020000020220000220000200022022200022220002220220222020200000020202022002220222002002220020002220002202202202200002002200222002220222000220000200000220200202200</span></span><br><span class="line"><span class="number">000022200000200220222200220000002002020020220220002222220002220020022020200222222222220202202202000220022002220222200002222220022000022200202222022200200222222020002002002220002202022220002022222022222022022220022000022200202220000000202022002022202002222020002202022202022202200222222220202200022222</span></span><br><span class="line"><span class="number">002222220220002020022220220202020200002002220020220022022002000202202002200202002020200000200022222222022022220000002200022002020200000220222022200020002202020220002200202220220002020000002020000020022020000200022202000002200202022200200200000022200220022002020020202022200000000002222020222002020222</span></span><br><span class="line"><span class="number">022022020220000202200220202020200200002000002000000020200220222002222220222000002200002222022200222222002222200020220020000200222222000020022000220000002220200000202002020220200220000202220222202222000200200000222222220022222002020002020022020000020000200222222020202220022200220220002200222202022002</span></span><br><span class="line"><span class="number">020200000220002000022200002020000222200200220200000200000002002020200202000202222002222200020220000202222202220020222220202222000222022202022202002000000020020022222200202002000022220222220020000020200020220020222022202200202002202002002002222202222222202222202002022020000200002222002000200000002202</span></span><br><span class="line"><span class="number">200020020200000200000220200022202020202220220020222200020202022022022202020202002200220002000200022222220022220000200000220222000002200020202022200002000020200222220002222220202202000200202220222022022200200000200020200000002000220200000020222022220220200222000200002222000222020200200202200202220222</span></span><br><span class="line"><span class="number">002200202002200202202222222002020220020000000202200000222200220000000000022200022000220202020222022022220220220202200020200222222022020020000002222202002222200000202020200220200200002020002022222002020000202222200202200002222200200000222200202022000202022220200002002220222202200002202220200222020002</span></span><br><span class="line"><span class="number">020222002000000202222220020000000000022002022002020202202002002200222200020222222002200000022000222200200222202000200000202022002222020220002222020000000002022220202000202202222200002222200022002000000002222200222222220000220200020020220202022020022222222002002200200002002200000002202220222200222000</span></span><br><span class="line"><span class="number">000000002022022020022202202200000200020220022220000022022002000020002022220200220220222020022200002022222222002200020222020002222220200002202002020022220022022002220222220002022020022022202002002222020020022202200222200000200022002220202000200222200202020022002220202200022002000200002202020002022000</span></span><br><span class="line"><span class="number">022220000002200200202022000202222022202222222202022002222200022200222220020200222020002022222220022202000002220020220002022222022022002022202222222000022002020002202002022000022000202200000220200022200020220222000022202222000222222022202022222022200002202220222000202000200002220200000200202002202202</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构与算法</tag>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 蓝桥杯 Java实现 10月B组省赛</title>
    <url>/2021/03/03/20210303_2020%E8%93%9D%E6%A1%A5%E6%9D%AFJava%E5%AE%9E%E7%8E%B010%E6%9C%88B%E7%BB%84%E7%9C%81%E8%B5%9B/</url>
    <content><![CDATA[<p><strong>2020 蓝桥杯 Java实现 10月B组省赛 题目 &amp; 题解</strong></p>
<span id="more"></span>

<h1 id="试题-A-门牌制作"><a href="#试题-A-门牌制作" class="headerlink" title="试题 A: 门牌制作"></a>试题 A: 门牌制作</h1><p>本题总分： 5 分</p>
<p><strong>问题：</strong><br>小蓝要为一条街的住户制作门牌号。<br>这条街一共有 2020 位住户，门牌号从 1 到 2020 编号。<br>小蓝制作门牌的方法是先制作 0 到 9 这几个数字字符，最后根据需要将字<br>符粘贴到门牌上，例如门牌 1017 需要依次粘贴字符 1、 0、 1、 7，即需要 1 个<br>字符 0， 2 个字符 1， 1 个字符 7。<br>请问要制作所有的 1 到 2020 号门牌，总共需要多少个字符 2？</p>
<p><strong>思路：</strong> 暴力</p>
<p><strong>答案：</strong> 624</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2020</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			ans += judge(i);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.print(ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//判断这个数字里有几个 2</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">judge</span><span class="params">(<span class="type">int</span> a)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(a!=<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a%<span class="number">10</span>;</span><br><span class="line">			<span class="keyword">if</span>(t==<span class="number">2</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				temp++;</span><br><span class="line">			&#125;</span><br><span class="line">			a/=<span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="试题-B-寻找-2020"><a href="#试题-B-寻找-2020" class="headerlink" title="试题 B: 寻找 2020"></a>试题 B: 寻找 2020</h1><p>本题总分：5 分</p>
<p><code>附件在本篇末尾</code></p>
<p><strong>问题：</strong></p>
<p>小蓝有一个数字矩阵，里面只包含数字 0 和 2。小蓝很喜欢 2020，他想找到这个数字矩阵中有多少个 2020 。<br>小蓝只关注三种构成 2020 的方式：</p>
<p>同一行里面连续四个字符从左到右构成 2020。<br>同一列里面连续四个字符从上到下构成 2020。<br>在一条从左上到右下的斜线上连续四个字符，从左上到右下构成 2020。<br>例如，对于下面的矩阵：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">220000</span></span><br><span class="line"><span class="number">000000</span></span><br><span class="line"><span class="number">002202</span></span><br><span class="line"><span class="number">000000</span></span><br><span class="line"><span class="number">000022</span></span><br><span class="line"><span class="number">002020</span></span><br></pre></td></tr></table></figure>
<p>一共有 5 个 2020。其中 1 个是在同一行里的，1 个是在同一列里的，3 个是斜线上的。<br>小蓝的矩阵比上面的矩阵要大，由于太大了，他只好将这个矩阵放在了一个文件里面，在试题目录下有一个文件 2020.txt，里面给出了小蓝的矩阵。<br>请帮助小蓝确定在他的矩阵中有多少个 2020。</p>
<p><strong>思路：</strong> 暴力</p>
<p><strong>答案：</strong> 16120</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:/demo/1.txt&quot;</span>)));</span><br><span class="line">		<span class="type">char</span>[][] map = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">300</span>][];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">300</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			map[i] = in.readLine().toCharArray();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">0</span>;y&lt;<span class="number">300</span>;y++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;x&lt;<span class="number">300</span>;x++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//横排</span></span><br><span class="line">				<span class="keyword">if</span>(x&lt;=<span class="number">296</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(map[y][x]==<span class="string">&#x27;2&#x27;</span>&amp;&amp;map[y][x+<span class="number">1</span>]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;map[y][x+<span class="number">2</span>]==<span class="string">&#x27;2&#x27;</span>&amp;&amp;map[y][x+<span class="number">3</span>]==<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						ans++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//竖排</span></span><br><span class="line">				<span class="keyword">if</span>(y&lt;=<span class="number">296</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(map[y][x]==<span class="string">&#x27;2&#x27;</span>&amp;&amp;map[y+<span class="number">1</span>][x]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;map[y+<span class="number">2</span>][x]==<span class="string">&#x27;2&#x27;</span>&amp;&amp;map[y+<span class="number">3</span>][x]==<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						ans++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//斜排</span></span><br><span class="line">				<span class="keyword">if</span>(y&lt;=<span class="number">296</span>&amp;&amp;x&lt;=<span class="number">296</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(map[y][x]==<span class="string">&#x27;2&#x27;</span>&amp;&amp;map[y+<span class="number">1</span>][x+<span class="number">1</span>]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;map[y+<span class="number">2</span>][x+<span class="number">2</span>]==<span class="string">&#x27;2&#x27;</span>&amp;&amp;map[y+<span class="number">3</span>][x+<span class="number">3</span>]==<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						ans++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	    System.out.print(ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="试题-C-蛇形填数"><a href="#试题-C-蛇形填数" class="headerlink" title="试题 C: 蛇形填数"></a>试题 C: 蛇形填数</h1><p>本题总分： 10 分</p>
<p><strong>问题：</strong><br>如下图所示，小明用从 1 开始的正整数“蛇形”填充无限大的矩阵。<br><img src="/images/2021-03-03/0.jpg" alt="图1"><br>容易看出矩阵第二行第二列中的数是 5。请你计算矩阵中第 20 行第 20 列 的数是多少？</p>
<p><strong>思路：</strong> 由题意可看出，求第x行第x列数的规律为：值 &#x3D; (x-1)*2的累加 + x</p>
<ul>
<li>则这一题中20行20列的值为：1+2+3+…+(19*2-1)+(19*2) + 20 &#x3D; 761</li>
</ul>
<p><strong>答案：</strong> 761</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">38</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			ans += i;</span><br><span class="line">		&#125;</span><br><span class="line">		ans+=<span class="number">20</span>;</span><br><span class="line">		System.out.print(ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="试题-D-七段码"><a href="#试题-D-七段码" class="headerlink" title="试题 D: 七段码"></a>试题 D: 七段码</h1><p>本题总分：10 分</p>
<p><strong>问题：</strong><br>小蓝要用七段码数码管来表示一种特殊的文字。<br><img src="/images/2021-03-03/1.jpg" alt="图"><br>上图给出了七段码数码管的一个图示，数码管中一共有 7 段可以发光的二极管，分别标记为 a, b, c, d, e, f, g。<br>小蓝要选择一部分二极管（至少要有一个）发光来表达字符。在设计字符的表达时，要求所有发光的二极管是连成一片的。</p>
<p>例如：b 发光，其他二极管不发光可以用来表达一种字符。<br>例如：c 发光，其他二极管不发光可以用来表达一种字符。这种方案与上<br>一行的方案可以用来表示不同的字符，尽管看上去比较相似。</p>
<p>例如：a, b, c, d, e 发光，f, g 不发光可以用来表达一种字符。<br>例如：b, f 发光，其他二极管不发光则不能用来表达一种字符，因为发光的二极管没有连成一片。<br>请问，小蓝可以用七段码数码管表达多少种不同的字符？</p>
<p><strong>思路：</strong> dfs出所有情况，然后用并查集判断是否属于同一子集</p>
<p><strong>答案：</strong> 80</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span>[] jl = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span>[][] map = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span>[] father = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//储存关系 a~g对应1~7</span></span><br><span class="line">		map[<span class="number">1</span>][<span class="number">2</span>] = map[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">1</span>;<span class="comment">//a b</span></span><br><span class="line">		map[<span class="number">1</span>][<span class="number">6</span>] = map[<span class="number">6</span>][<span class="number">1</span>] = <span class="number">1</span>;<span class="comment">//a f</span></span><br><span class="line">		map[<span class="number">2</span>][<span class="number">7</span>] = map[<span class="number">7</span>][<span class="number">2</span>] = <span class="number">1</span>;<span class="comment">//b g</span></span><br><span class="line">		map[<span class="number">2</span>][<span class="number">3</span>] = map[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">1</span>;<span class="comment">//b c</span></span><br><span class="line">		map[<span class="number">3</span>][<span class="number">4</span>] = map[<span class="number">4</span>][<span class="number">3</span>] = <span class="number">1</span>;<span class="comment">//c d </span></span><br><span class="line">		map[<span class="number">3</span>][<span class="number">7</span>] = map[<span class="number">7</span>][<span class="number">3</span>] = <span class="number">1</span>;<span class="comment">//c g</span></span><br><span class="line">		map[<span class="number">4</span>][<span class="number">5</span>] = map[<span class="number">5</span>][<span class="number">4</span>] = <span class="number">1</span>;<span class="comment">//d e</span></span><br><span class="line">		map[<span class="number">5</span>][<span class="number">6</span>] = map[<span class="number">6</span>][<span class="number">5</span>] = <span class="number">1</span>;<span class="comment">//e f</span></span><br><span class="line">		map[<span class="number">5</span>][<span class="number">7</span>] = map[<span class="number">7</span>][<span class="number">5</span>] = <span class="number">1</span>;<span class="comment">//e g </span></span><br><span class="line">		map[<span class="number">6</span>][<span class="number">7</span>] = map[<span class="number">7</span>][<span class="number">6</span>] = <span class="number">1</span>;<span class="comment">//f g</span></span><br><span class="line">		<span class="comment">//dfs遍历所有情况</span></span><br><span class="line">		dfs(<span class="number">0</span>);</span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		System.out.print(ans);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//当7个灯都有状态时 进行判定</span></span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">7</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//把亮着的灯统计下来</span></span><br><span class="line">			ArrayList&lt;Integer&gt; a = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">7</span>;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(jl[i]==<span class="number">1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					a.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(i));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//判断</span></span><br><span class="line">			<span class="keyword">if</span>(a.size()!=<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(judge(a)==<span class="number">1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					ans++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			a.clear();</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//否则dfs灯情况</span></span><br><span class="line">		jl[n+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">		dfs(n+<span class="number">1</span>);</span><br><span class="line">		jl[n+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">		dfs(n+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">judge</span><span class="params">(ArrayList&lt;Integer&gt; a)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//System.out.println(++js);</span></span><br><span class="line">		<span class="comment">//并查集父集重置</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			father[i] = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//并集</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.size();i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> ii=<span class="number">0</span>;ii&lt;a.size();ii++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//如果两边相连的话 进行并集操作</span></span><br><span class="line">				<span class="keyword">if</span>(map[a.get(i).intValue()][a.get(ii).intValue()]==<span class="number">1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="type">int</span> <span class="variable">fx</span> <span class="operator">=</span> find(a.get(i).intValue());</span><br><span class="line">					<span class="type">int</span> <span class="variable">fy</span> <span class="operator">=</span> find(a.get(ii).intValue());	</span><br><span class="line">					<span class="keyword">if</span>(fx!=fy)</span><br><span class="line">					&#123;</span><br><span class="line">						father[fx] = fy;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;	</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//查看是否都属于一个集合</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> find(a.get(<span class="number">0</span>).intValue());</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;a.size();i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(find(a.get(i).intValue())!=temp)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//查集</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> father[x]==x ? x : (father[x] = find(father[x]));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="试题-E-排序"><a href="#试题-E-排序" class="headerlink" title="试题 E: 排序"></a>试题 E: 排序</h1><p>本题总分： 15 分<br><img src="/images/2021-03-03/2.jpg" alt="图2"><br><strong>思路：</strong> 不能有相同字符的话就从a开始倒着加，因为<strong>14+13+12+11+10+9+8+7+6+5+4+3+2+1+0 &#x3D; 105</strong>，所以一共有15个字母。然后让总排序次数减五次，因为字典序要求最小，则让第六位向前挪5次即可。</p>
<ul>
<li>答案即为：9 14 13 12 11 10 8 7 6 5 4 3 2 1 0</li>
</ul>
<p><strong>答案：</strong> jonmlkihgfedcba</p>
<ul>
<li>以下题目均能通过<a href="https://www.acwing.com/problem/">AcWing</a>和<a href="https://www.lanqiao.cn/problems/">蓝桥杯题库</a>的数据测试</li>
</ul>
<h1 id="试题-F-成绩分析"><a href="#试题-F-成绩分析" class="headerlink" title="试题 F: 成绩分析"></a>试题 F: 成绩分析</h1><p>试题 F: 成绩分析 本题总分： 15 分<br>时间限制: 1.0s 内存限制: 512.0MB</p>
<p><strong>问题：</strong><br> 小蓝给学生们组织了一场考试，卷面总分为 100 分，每个学生的得分都是 一个 0 到 100 的整数。<br>请计算这次考试的最高分、最低分和平均分。</p>
<p><strong>输入：</strong><br> 输入的第一行包含一个整数 n，表示考试人数。 接下来 n 行，每行包含一个 0 至 100 的整数，表示一个学生的得分。</p>
<p><strong>输出：</strong><br> 输出三行。 第一行包含一个整数，表示最高分。 第二行包含一个整数，表示最低分。<br>第三行包含一个实数，四舍五入保留正好两位小数，表示平均分。</p>
<p><strong>样例输入：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">80</span></span><br><span class="line"><span class="number">92</span></span><br><span class="line"><span class="number">56</span></span><br><span class="line"><span class="number">74</span></span><br><span class="line"><span class="number">88</span></span><br><span class="line"><span class="number">99</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>
<p><strong>样例输出：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">99</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">71.29</span></span><br></pre></td></tr></table></figure>
<p><strong>评测用例规模与约定：</strong><br>对于 50% 的评测用例， 1 ≤ n ≤ 100。<br>对于所有评测用例， 1 ≤ n ≤ 10000。</p>
<p><strong>思路：</strong> 送分题，挨个统计即可</p>
<p><strong>AC代码：</strong> <a href="https://www.lanqiao.cn/problems/497/learning/">OJ链接</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">		<span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">101</span>;</span><br><span class="line">		<span class="type">double</span> <span class="variable">he</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">			<span class="keyword">if</span>(t&gt;max)</span><br><span class="line">			&#123;</span><br><span class="line">				max = t;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(t&lt;min)</span><br><span class="line">			&#123;</span><br><span class="line">				min = t;</span><br><span class="line">			&#125;</span><br><span class="line">			he += t;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="type">double</span> <span class="variable">ans</span> <span class="operator">=</span> (<span class="type">double</span>)(<span class="type">int</span>)((he/n+<span class="number">0.005</span>)*<span class="number">100</span>)/<span class="number">100</span>;</span><br><span class="line">		</span><br><span class="line">		System.out.println(max);</span><br><span class="line">		System.out.println(min);</span><br><span class="line">		System.out.println(ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="试题-G-单词分析"><a href="#试题-G-单词分析" class="headerlink" title="试题 G: 单词分析"></a>试题 G: 单词分析</h1><p>时间限制: 1.0s 内存限制: 512.0MB<br>本题总分：20 分</p>
<p><strong>问题：</strong><br>小蓝正在学习一门神奇的语言，这门语言中的单词都是由小写英文字母组成，有些单词很长，远远超过正常英文单词的长度。小蓝学了很长时间也记不住一些单词，他准备不再完全记忆这些单词，而是根据单词中哪个字母出现得最多来分辨单词。<br>现在，请你帮助小蓝，给了一个单词后，帮助他找到出现最多的字母和这个字母出现的次数。</p>
<p><strong>输入：</strong><br>输入一行包含一个单词，单词只由小写英文字母组成。</p>
<p><strong>问题：</strong><br>输出两行，第一行包含一个英文字母，表示单词中出现得最多的字母是哪个。如果有多个字母出现的次数相等，输出字典序最小的那个。<br>第二行包含一个整数，表示出现得最多的那个字母在单词中出现的次数。</p>
<p><strong>样例输入：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lanqiao</span><br></pre></td></tr></table></figure>
<p><strong>样例输出：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><strong>样例输入：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">longlonglongistoolong</span><br></pre></td></tr></table></figure>
<p><strong>样例输出：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">o</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>
<p><strong>评测用例规模与约定：</strong><br>对于所有的评测用例，输入的单词长度不超过 1000。</p>
<p><strong>思路：</strong> 暴力统计即可</p>
<p><strong>代码：</strong> <a href="https://www.lanqiao.cn/problems/504/learning/">OJ链接</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">		<span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">30</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;s.length();now++)</span><br><span class="line">		&#123;</span><br><span class="line">			ans[(<span class="type">int</span>)(s.charAt(now)-<span class="string">&#x27;a&#x27;</span>)+<span class="number">1</span>]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1</span>;now&lt;=<span class="number">26</span>;now++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(ans[end]&lt;ans[now])</span><br><span class="line">			&#123;</span><br><span class="line">				end = now;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println((<span class="type">char</span>)(<span class="string">&#x27;a&#x27;</span>+end-<span class="number">1</span>));</span><br><span class="line">		System.out.println(ans[end]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="试题-H-数字三角形"><a href="#试题-H-数字三角形" class="headerlink" title="试题 H: 数字三角形"></a>试题 H: 数字三角形</h1><p>时间限制: 1.0s 内存限制: 512.0MB<br>本题总分：20 分<br><img src="/images/2021-03-03/3.jpg" alt="图"><br><strong>问题：</strong><br>上图给出了一个数字三角形。从三角形的顶部到底部有很多条不同的路径。<br>对于每条路径，把路径上面的数加起来可以得到一个和，你的任务就是找到最大的和。<br>路径上的每一步只能从一个数走到下一层和它最近的左边的那个数或者右边的那个数。此外，向左下走的次数与向右下走的次数相差不能超过 1。</p>
<p><strong>输入：</strong><br>输入的第一行包含一个整数 N (1 &lt; N ≤ 100)，表示三角形的行数。下面的N 行给出数字三角形。数字三角形上的数都是 0 至 100 之间的整数。</p>
<p><strong>输出：</strong><br>输出一个整数，表示答案。</p>
<p><strong>样例输入：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">3</span> <span class="number">8</span></span><br><span class="line"><span class="number">8</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">2</span> <span class="number">7</span> <span class="number">4</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">2</span> <span class="number">6</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p><strong>样例输出：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">27</span></span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong> B组这题是简化过的，数据量少了，也多了条件，所以直接dfs暴力就好。当左右差减一大于剩下行数时，说明走到末尾时必定相差超过1，可以进行剪枝。</p>
<p><strong>AC代码：</strong><br><a href="https://www.lanqiao.cn/problems/505/learning/">OJ链接1</a> <code>链接里是本题版本，用DFS写</code><br><a href="https://www.acwing.com/problem/content/900/">OJ链接2</a> <code>链接里是未简化的版本，用DP写</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span>[][] map = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">510</span>][<span class="number">510</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		num = sc.nextInt();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=num;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> ii=<span class="number">1</span>;ii&lt;=i;ii++)</span><br><span class="line">			&#123;</span><br><span class="line">				map[i][ii]=sc.nextInt();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		dfs(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>+map[<span class="number">1</span>][<span class="number">1</span>],<span class="number">0</span>);</span><br><span class="line">		System.out.print(ans);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> y,<span class="type">int</span> x,<span class="type">int</span> he,<span class="type">int</span> cha)</span><span class="comment">//y x 和  左右差</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(x&lt;=<span class="number">0</span>||x&gt;y)<span class="comment">//剪枝 越界</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(Math.abs(cha)-<span class="number">1</span>&gt;(num-y))<span class="comment">//剪枝 左右差大于剩下行数 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(y==num)<span class="comment">//到达最底层</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(he&gt;ans&amp;&amp;Math.abs(cha)&lt;=<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				ans = he;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		dfs(y+<span class="number">1</span>,x,he+map[y+<span class="number">1</span>][x],cha-<span class="number">1</span>);<span class="comment">//左下</span></span><br><span class="line">		dfs(y+<span class="number">1</span>,x+<span class="number">1</span>,he+map[y+<span class="number">1</span>][x+<span class="number">1</span>],cha+<span class="number">1</span>);<span class="comment">//右下</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="试题-I-子串分值和"><a href="#试题-I-子串分值和" class="headerlink" title="试题 I: 子串分值和"></a>试题 I: 子串分值和</h1><p>时间限制: 1.0s 内存限制: 512.0MB<br>本题总分：25 分</p>
<p><strong>问题：</strong><br>对于一个字符串 S，我们定义 S 的分值 f(S) 为 S 中出现的不同的字符个数。</p>
<p>例如 f(“aba”)&#x3D;2，f(“abc”)&#x3D;3,f(“aaa”)&#x3D;1。</p>
<p>现在给定一个字符串 S[0..n−1]（长度为 n），请你计算对于所有 S 的非空子串 S<a href="0%E2%89%A4i%E2%89%A4j%3Cn">i..j</a>，f(S[i..j]) 的和是多少。</p>
<p><strong>输入：</strong><br>输入一行包含一个由小写字母组成的字符串 S。</p>
<p><strong>输出：</strong><br>输出一个整数表示答案。</p>
<p><strong>样例输入：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ababc</span><br></pre></td></tr></table></figure>
<p><strong>样例输出：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">28</span></span><br></pre></td></tr></table></figure>
<p><strong>样例说明：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">子串 f值</span><br><span class="line">a     <span class="number">1</span></span><br><span class="line">ab    <span class="number">2</span></span><br><span class="line">aba   <span class="number">2</span></span><br><span class="line">abab  <span class="number">2</span></span><br><span class="line">ababc <span class="number">3</span></span><br><span class="line"> b    <span class="number">1</span></span><br><span class="line"> ba   <span class="number">2</span></span><br><span class="line"> bab  <span class="number">2</span></span><br><span class="line"> babc <span class="number">3</span></span><br><span class="line">  a   <span class="number">1</span></span><br><span class="line">  ab  <span class="number">2</span></span><br><span class="line">  abc <span class="number">3</span></span><br><span class="line">   b  <span class="number">1</span></span><br><span class="line">   bc <span class="number">2</span></span><br><span class="line">    c <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>评测用例规模与约定：</strong><br>对于 20% 的评测用例，1≤n≤10；<br>对于 40% 的评测用例，1≤n≤100；<br>对于 50% 的评测用例，1≤n≤1000；<br>对于 60% 的评测用例，1≤n≤10000；<br>对于所有评测用例，1≤n≤100000。</p>
<p><strong>思路：</strong> 总体思路和C组的那道题有点类似，不过这个更绕一点，没那个直接。</p>
<ul>
<li>思路就是每一个字符的权值为：(上一次出现的与当前出现的位置间隔+1) * (末尾与当前位置差值+1)</li>
<li>如果是第一次出现，前间隔值就为当前位置-1</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">例如： ababc 末尾长度为<span class="number">5</span></span><br><span class="line"></span><br><span class="line">a的当前位置为<span class="number">1</span>，前间隔值为<span class="number">0</span>，权值为 (<span class="number">0</span>+<span class="number">1</span>) * (<span class="number">5</span>-<span class="number">1</span>+<span class="number">1</span>) = <span class="number">5</span></span><br><span class="line">b的当前位置为<span class="number">2</span>，前间隔值为<span class="number">1</span>，权值为 (<span class="number">1</span>+<span class="number">1</span>) * (<span class="number">5</span>-<span class="number">2</span>+<span class="number">1</span>) = <span class="number">8</span></span><br><span class="line">a的当前位置为<span class="number">3</span>，前间隔值为<span class="number">1</span>，权值为 (<span class="number">1</span>+<span class="number">1</span>) * (<span class="number">5</span>-<span class="number">3</span>+<span class="number">1</span>) = <span class="number">6</span></span><br><span class="line">b的当前位置为<span class="number">4</span>，前间隔值为<span class="number">1</span>，权值为 (<span class="number">1</span>+<span class="number">1</span>) * (<span class="number">5</span>-<span class="number">4</span>+<span class="number">1</span>) = <span class="number">4</span></span><br><span class="line">c的当前位置为<span class="number">5</span>，前间隔值为<span class="number">4</span>，权值为 (<span class="number">4</span>+<span class="number">1</span>) * (<span class="number">5</span>-<span class="number">5</span>+<span class="number">1</span>) = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">累加：<span class="number">5</span>+<span class="number">8</span>+<span class="number">6</span>+<span class="number">4</span>+<span class="number">5</span> = <span class="number">28</span></span><br></pre></td></tr></table></figure>

<p><strong>代码：</strong> <a href="https://www.acwing.com/problem/content/2875/">OJ链接</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//前数组</span></span><br><span class="line">		<span class="type">int</span>[] piror = <span class="keyword">new</span> <span class="title class_">int</span>[s.length()+<span class="number">10</span>];</span><br><span class="line">		<span class="comment">//答案值</span></span><br><span class="line">		<span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//中间值数组 用来储存每个字母的前后值位置</span></span><br><span class="line">		<span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//初始化</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length()+<span class="number">10</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			piror[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//找每个位置字符的上一位</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s.length();i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> s.charAt(i-<span class="number">1</span>)-<span class="string">&#x27;a&#x27;</span>;<span class="comment">//计算出数组位置</span></span><br><span class="line">			piror[i] = i-temp[t];<span class="comment">//计算出与上一位相同字母位置的差值</span></span><br><span class="line">			temp[t] = i;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//计算答案 前差值*后值等于当前字符的权值 累加即可</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s.length();i++)</span><br><span class="line">		&#123;</span><br><span class="line">			ans += (<span class="type">long</span>)(piror[i]) * (<span class="type">long</span>)(s.length()-i+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="试题-J-装饰珠"><a href="#试题-J-装饰珠" class="headerlink" title="试题 J: 装饰珠"></a>试题 J: 装饰珠</h1><p>本题总分： 25 分<br>时间限制: 1.0s 内存限制: 512.0MB</p>
<p><img src="/images/2021-03-03/4.jpg" alt="图3"><br><img src="/images/2021-03-03/5.jpg" alt="在这里插入图片描述"><br><strong>样例输入：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">2</span> <span class="number">4</span> <span class="number">8</span> <span class="number">15</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">5</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p><strong>样例输出：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure>
<p><strong>样例说明：</strong></p>
<p>按照如下方式镶嵌珠子得到最大价值 18，括号内表示镶嵌的装饰珠的种类编号：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>: (<span class="number">1</span>)</span><br><span class="line"><span class="number">2</span>: (<span class="number">1</span>) (<span class="number">2</span>)</span><br><span class="line"><span class="number">3</span>: (<span class="number">1</span>)</span><br><span class="line"><span class="number">4</span>: (<span class="number">2</span>) (<span class="number">2</span>)</span><br><span class="line"><span class="number">5</span>: (<span class="number">1</span>)</span><br><span class="line"><span class="number">6</span>: (<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/images/2021-03-03/6.jpg" alt="在这里插入图片描述"><br><strong>思路：</strong></p>
<p><strong>AC代码：</strong> <a href="https://www.lanqiao.cn/problems/507/learning/">OJ链接</a></p>
<h1 id="试题-B-寻找-2020-附件"><a href="#试题-B-寻找-2020-附件" class="headerlink" title="试题 B: 寻找 2020 附件"></a>试题 B: 寻找 2020 附件</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">002000000220202000222000202200222220202202020002220002020022202200220220202002002220020200000000220022200202222022220222000022220220020020222020022220022220220000022022002020220002200220020020022200020222020200200000020220020022002202000202222020220020020022020000202022220222200022220000000020020020</span></span><br><span class="line"><span class="number">000020002002200002022222200222002020000200020220000022020002020200000222000000202202220222000222202200202202200200222222220202022020022002220200022020200222002220202202022202222002000220202200202202022000000222220222200200022220202200200020202222202222220022202220020002000000200022222202020020222220</span></span><br><span class="line"><span class="number">220002002202200022020020202000220002000020220202222020000020022222002000002222220022022020002022200020022020202020022200022200202202220200000202020220022200222020020222020020022200222220222000020202000020022220222022202222002002002000002020202200220200222202002002202002020202222220020002020220200000</span></span><br><span class="line"><span class="number">022200022002022002220002002222022020220002222200002002222002222222022200002022002002200220020002220002020002222222022020220020200000022022022220220222002222220000022200002002020000000022220202020020222202222200200220200220222220020202020002022002222022022022222002200220202202002022000022200020220000</span></span><br><span class="line"><span class="number">202222202222222000000022222022202022220000222002002000022202022002220220220022002002200000222200222002222002220000220022002202220222220222002002220200222200020222000202200022022020002222020022202002000200000222200020222020002020022222222222220202002200200200220020002020200000020022000202002000022000</span></span><br><span class="line"><span class="number">020200222020020222002020000022220022020220002220220220200222222000222222002202002200002000220022220020002200020020220002000020002002200200200000200200220202002020022202002002222222222200222020020000020220002222020202202222220202220200202002202220020220200000022020222002222020200200022202202202200002</span></span><br><span class="line"><span class="number">020222000220220200222000000202020022200022002020222220220200202000200200202222020020200220002200000020000002022000020020002220202002222220222000220220222222000002000000000002220022000220022202202202020222202202200002220200022222002000020020220200002200202220022220020002220020002222220220220200022000</span></span><br><span class="line"><span class="number">022002200222022222020022202000002222200002022002020220000220200000002002022000000022000022202022200002000000020200000020002202200020200002200000202002222002220020220200020222002000022002022020000020200000202020200020222200020022222222000222202020200200222000202020020000200022020202202222002020200002</span></span><br><span class="line"><span class="number">202020200000020002020022202222022220002222022222022200200002002220020220220222202000220022002220020022000202022022222200220020022202020202202222002202222000202200020020222222200202200220002222200220002202202220222022222200002220022002222000220002020220000220220022000020200220200022000202020220200222</span></span><br><span class="line"><span class="number">220002222000220022000222020020202220220002000002200222220002000020000000000202202002222022202220220200020202202200220202202022022222020220202202020002222200002020220202022200002222222200020022022202220000020002022020222020022022222022202220222002020000002022000020220020220222200200002202002220222002</span></span><br><span class="line"><span class="number">200222022022022200200220202202200200220222220022022000022000022022020200222020220000220220020020000020222022222002020220020220222000202200222222200020022002220222222002222200020002000202022202220222202020000020022202022002200020220002022022002002000022020202002020022000000220202200022022200020022220</span></span><br><span class="line"><span class="number">002002202022020200022222220022000022202220002202200000220000020220000020022200200020020222000000200022000202002022200222200222000000000202222200222022020202200020020202220022200200022200222022202202002202020222022002022002222222020202022220202020202002222222022220220002220022022002220022202002222002</span></span><br><span class="line"><span class="number">220022002222002220222000220000002200220020022000220022222220202200020022000222022202220220022202222020002020200202202002222022222020220200020000020022020022200000000000022202022022200220222022220222020000020222000200022202202220202002002222000220202220200220000220202022000202222020222000200000000000</span></span><br><span class="line"><span class="number">002220020002202202002220022220222002220002200022200002222002200020200202000000222222220022222200202220002222220000000220220022200002200022202022020200200002202000022202200002220220020220020022220022200000000220200200020022020222200202002200220222222202220202220002022020022020020200002022200222222020</span></span><br><span class="line"><span class="number">002200202020202220200020220220002002022022020022200202000220202220220222200002000020222022000002220020002002022022200002200000222222200022002222000200000220220220022022020022000200220022220002002200002022020200220000020000002002002020222202000202022220000220200200200020002002200220202000220002222002</span></span><br><span class="line"><span class="number">200200202222000020022220222022022002222220200002022222000020002222220200020220222220022220222220220000202022020222022220202000002222000200220202002202200022020220002220020022002202022022000000222020220002222222002020222000022222220200020000000200020200020220220222220020000222000220222222222200222202</span></span><br><span class="line"><span class="number">000200202020220002002020022020022020000202220202022222220020202220220202022220200002000222200000200200220002222202022200022020222022202002000022002200222222000222000202002022222020220202200020022220222022000002020022002000220220022202220202002200202000200222002000202200202222220222222002202200002220</span></span><br><span class="line"><span class="number">020220002002020000002002220020022022020220022022202202220202222222200020020020222222022020000000220222000220020202022202002020200002002202200200222022022020022000020002000222022000200000020000020002022020020200202200222222022222022000002002220220002202022020222000202002222000022022000000200020022022</span></span><br><span class="line"><span class="number">002002002002022220000022220020022222220002200222002200020202000202222002020020222020002200020002002202022220002022020000020022222200002202000020222220020000022000020220002220000202000220020202002220022000022002202000000220020202002202200202220220022002002202222222020220222222020020000222000000002022</span></span><br><span class="line"><span class="number">000202222220222222002202200200200220002022022000002200020202002020200002002202000220000222002020022020002000022020222000000202220220002022220022222220222002200220222220002020202202022002222202222202222002222200020000220020222002000022002222202220020222202202200202000000002200200222020022220220220202</span></span><br><span class="line"><span class="number">022200200022222020002022002000222000020002002222020002002222222020200022020002022220000200000002000020202002020220200020020002200020222000202200202222220020200020202222220200220200222202222002202200200202002222002002200022200022002200222002002000022022022002220002002002202022002222220020220022000022</span></span><br><span class="line"><span class="number">020020200200000000222202222220222020202202220200220022222202002200022022220002002200000202002002020000000220200222222020022220002000200022220202000002022220200002000000222220200020200002202002200200022220002220002220022202002202020220220200002222002020202020220220202000200020222200200222222000222020</span></span><br><span class="line"><span class="number">022200200200000002220002202002022202202220000222202222220220022002022220022002000022002202202000202002220200002002002000000220202200220202220002200002020000222220222020020202000222200202202020200000022002000022220000200020000202222200222200222022020200220200222200222202022202020222020020020200020222</span></span><br><span class="line"><span class="number">000022022222220222222220222000202200022022002000200022022220002020222222202222020200220200222202220002200002000200202022022022020222020200202020000000020000000220000002002200202200202022020200020000220000200000222002002000022220022220022200202202020002022200202220020222020222002222220020202000202222</span></span><br><span class="line"><span class="number">000022202020202002000222002222222200002220222202222022020200000200202002002202022220000202202020200222022220000202022020020022002220222022020000000020022222022020020200220022220020202202022002220202202202222222200002222020000022022220022200022200002202020022200200020202222000002022200000002222002022</span></span><br><span class="line"><span class="number">000200020020220002020022020020202022022200200020000200222202222000000002000200020222000020002020000202202202000000220202002222200202200222202002220222202002020222000202022022022020000022202200220220222000220020220000020000200200222220000222020002222020220020202020022002202002002022022020200220002000</span></span><br><span class="line"><span class="number">000000020200020200020020002202022020220022202002020022002020020020000202020022022200202202200000202220022222000002020020220202002022002222200200000222022022202000020000220000200200000220220200202200222220220202000200020200020200200202020020002000022000200220222020222022002000022202202222222200220020</span></span><br><span class="line"><span class="number">222200222020220220000202200000002020200202002202020200022002222022022000202022200202200020020202020020222200222200000220002200200000202220020202200222000222202000200020202022222000200022020200202220000220000222202202022020022200022002202020022200200000220002220200002222220200000220202222220020222000</span></span><br><span class="line"><span class="number">202222202000020222222220000022000222022020200000020222020220222222220202002222002200020022002200020002020000220000220200002202202200220220202002020222222000220020202200222002020002020222220222202002020202202200200002202202200022220222002222222000020222022000002022222000022200002000000220200200002000</span></span><br><span class="line"><span class="number">002020200202220222202020222220200222000002202022002200202202200220000222000202022002002200200000200202000200000220200020222222202202002222220000020222202222220002002222002222202222020000220222000200200220020020002022222002000002020220022000022220000022220222222000020000020220022002222202220022202022</span></span><br><span class="line"><span class="number">022000200200000002022222200022220222022220000222202002020222200220020020000220002202022022002222200002002020202220022222000200222002200000002222202202000022000000000222022000020200020200000200000020020002200222220202022222000020022202200202000000220000200200022220200222002000202220002000002020020002</span></span><br><span class="line"><span class="number">002022200002022002202002020220002020202222202220022022020202202200002200220022220202022202000220002002200020222222220020200222020200222020020022220200002022202022200200020002020200222200000020222202020000202022220222222222220200020202000202222220000202222220000200000202222222000222220220200220022202</span></span><br><span class="line"><span class="number">000202200220020002222000002200220222022200000202202220202220022220002002022202022222220002002002002000202002020200202202002022202222020202020000020020220000202202202222200000002022200222220000020000022200202022002202022002020200002020022202022222202020000220022220202002200022202000202000200220202222</span></span><br><span class="line"><span class="number">200022020220002222020000222002022022000020220000220200222022000202000002222200020222202022222000000202020002202202002000200222220002020222220020002200000220222222000222002022222002020200022002000222202220202020202020022200020222002200002222002202222000200020222222002222202000020200022022220020222220</span></span><br><span class="line"><span class="number">202020020000222000022220200022200002220200000220000200002002202022202222022020220000220202000020222022222222000020220020200002222002200202002200000020200202020222020020020002222200022002220200200022002022220022222222002220220000222022020222202000200000000220002002000200022022200002202002002220000022</span></span><br><span class="line"><span class="number">002022220022220220200020220020202022022220000020202002222000222222022002222200220020002222020020020220002200220202222222000202222220022002222220222022002222020222200000022002000220200220222000002022002020222202000020020200022000002200200222202202000020220220202220002222020000020200220200020200020022</span></span><br><span class="line"><span class="number">022002202022220000202020220002020002200220222002002220222000022022200000020020022002020000220202202002000002020020222000022000220000200002020202020022022200020022022202022000020020022000200222222020000220202222200022000200202002020022002000202002202220022020022022220020220220200002202022222022002002</span></span><br><span class="line"><span class="number">200200200020000002200222002202200020200202002220000022200200002020220222200000022200022002000000000002222222202220220220202022000002002222222020220202002222020200020020002220000022020022202002002202220020200222202222002200020222222202220200020202020002002202020002220220002000200200020020022000202202</span></span><br><span class="line"><span class="number">020000022220222222220000200222202220220020222202220000200020200020220202200222200220020200200020202020222202220202020000200220220220000002000200222002002002000022202022202222222002020020220000000220002220022202220002000002002000202220000220000222020200020220020000200020222020002222220200200200022202</span></span><br><span class="line"><span class="number">000202222222222002202202200200200002022020000202000200200002222002200020202020220020222200000000020000222222222202000002020002000020020000000000022000220220000200202202000200020002000202020022020200220202222202000020002002020002220222000202000022200000222222022020200222220002020202220202000020022000</span></span><br><span class="line"><span class="number">020022002020000002220000000002220200000000000002020022200220020002220220022002020200220020000222020020020222200000222002022202020020222020020202202202220200222020022200222000220202202202000222200200220000222200200200022022000022022000202000222222022022220002020202202022202002000220200202022020022000</span></span><br><span class="line"><span class="number">000002002002220220222002200000002000002002000222202220022222020202202200220002022002002202222002202200200220022022200020020022020020000220220002220002220022022222220200200022222020000020000000022002002020002220000220202000222200200000202002220020202002220200222002000220000000022220002222200002200002</span></span><br><span class="line"><span class="number">222222002000202020002022022200022002200220202020002220000002000202020200002002020000002002020002220020222002020200000020000022000022022222002202020020202022222220022000022200222022002000220000220202202002000202200222200220222202002220222220200022222002220200202002020002022020020222000220202222022202</span></span><br><span class="line"><span class="number">000220220020200000220202200222022222202000220202022220220000020202222222022202200202220002022002002202220200002000202022020002202222202220222022022222202222002220002020022022022022000022000202220022220220222202022222002202220022222020222002202200022002220022022020022002202000002220222222022002220000</span></span><br><span class="line"><span class="number">200022200020202220222022202022002022202200000000000202000022202200020002022200000222020000222002002002002200220202002000000202222002000200220222202220020020002220222000002202200022220022020202002220222002200222022220002022000222222000000000000000202220000222000200022202000202200222022000220202202002</span></span><br><span class="line"><span class="number">222002000022200202022222220202020000020000022022022200020220202200002220000222000200002202222220220002222022020222020200020020000020222020202022200020002200222002022200002220202022220022022020200020202020000020022200020000002222200022220022000222022020020020222222220222002202020020202222020002022220</span></span><br><span class="line"><span class="number">202202022002000220022020200220220220020002202222202220222002202200222200020022022200020222202202202200200222000202000002222220202020000202002220200200222020002200022000200020202200220002202222020002000020002000002202202220202220002022222222020220000000022200202002022000202002202200022022002202020020</span></span><br><span class="line"><span class="number">020022020000022202022200000200200022000220020022002022002200220002200200000222200202002000022202200022020022020200222220222200002000200200222000200200222022020022222222200002202200222022000000002000022000002220202020202002222020202000020020002022000200002002000200202222020222202200000222222220022220</span></span><br><span class="line"><span class="number">002202000200002022222022222002022222220020202222222020022220220002222022022022200202000000202002000020202200202200000022022200200220002220020020002200022022220000200002202002002200200222002000220020200200022002202020000202020002002222002220200200200200222022000002002022220002202002002002220000022222</span></span><br><span class="line"><span class="number">220002202020220002002200002020022220000220200222002022202220202202200222202220200222202202202022222020022200200220000022220000000220020022222222002022202022200202222020200022202220222200020022202222222020202200022002222000220002202022020000200222022220022200202002200020202222202000000000222200022002</span></span><br><span class="line"><span class="number">002002020000020022000222202202200220000220220000022200020220200200022000000022022000222022022200020202220002002200200220202200002022220200020222020200202022022002220202000220000202222200020002202022022200222222222020200022222002222200022002222222000202020222022200220002000020000022020000202202002200</span></span><br><span class="line"><span class="number">222202002222220222220220020000020022200220022220222202222202200220222220022222222020222000002202022200200222000000222220002002002222020200022220020020002002202200022222220000222200200202000202200202222202202202222200022200200020020220022202220000202020000020000000000220200020220000000002202000020022</span></span><br><span class="line"><span class="number">022020020020020020202020220202022022200002022022002200002202220202002022002002202200000200202200220222220020200220222000022202222022022020202200222000020020220220202222000220002200000000202202002002022200222200022220002022020002000202000000002002022002020220022020000022200200000000000000202202020000</span></span><br><span class="line"><span class="number">000022022000202020000020022222222002202202202000002000222020022002022020020222220202002000022200202222002000200222002220020202000022000002002202000002002002000222022200000202220020202222000220020000222200200222022000200200222222022220002020000202220222220202220002222022020002022220000022200202220002</span></span><br><span class="line"><span class="number">220022002000220222000002200222202220200200020022222000220020200002022222202002220022000022200220202000220000020020020000220002220202220002002002220020002020000200022020002022220202020220022202022200000220222220002200222022000020020020020200200022200220222222220022002200000220000220000022022020222002</span></span><br><span class="line"><span class="number">002002022000000200022220222020202022202022220000200022022220022222000200022000220020202200202222222020002000220222202002000020222220022020002020020222200020002002020022022200002200020020202202220202022020202020202022222202000202022002022002002022200202022000020202000022022022002222200220200222220200</span></span><br><span class="line"><span class="number">202020020022222020220000000000220222220220202220222000220020220022002222200000200020020202202020002022000000002202200222022020002000202000222022202000020002020220222200200202022202222020022002202022022200020002220222002000220220202220022222002200200000222202202222020000222202220222220202222022222200</span></span><br><span class="line"><span class="number">020200020022200020002202002000002220000202220200002202022200000200202220202200220022022020002200022000002202200000022222022222002022022220202022200220220200020022202202020000002022020000202200200000222020020220002000222200220200220000220220200020202000220020222022220020202000222020022000020220020000</span></span><br><span class="line"><span class="number">002220022222020022200022200020022202000020000200202202220200020002000220000000000220020020002202002222022020200022022000020002220022020020222020002220000222200000020022022020022220220200202022202020200022022020220202000020020220020022220202200000220220002000020000200222020220000222020022220022220200</span></span><br><span class="line"><span class="number">022022200000002020002022222000020220020020200022000020022002220200222202002022020002020202002002202020222002202202002020200020202022200220020200222002222222022200022022200222222220020000002220222000002002022200022020002000202222200200002202202000020200202000020002220002222200022020022202200200020220</span></span><br><span class="line"><span class="number">000002022022200222002220020202222220002002222222022000220220200020220220222202220200202222220000000000202022000020000220220202202200022222200000220200222000200222020220202022200020022000000002200220000220222202000002022222022002020222202202220022220022200022222220022202022202000202022202002020020220</span></span><br><span class="line"><span class="number">022202202022220220222220220000202200202002020000022202222020000002002000200002002000022200200220020022002020200202200200020022020202220202202220200002020200002220002000022200000000220220220022202000002000022202220202202202020002220000002202202220022202020022002200202000022022222002000202222202200222</span></span><br><span class="line"><span class="number">022222202022022222000022020222020020022020022202000020002202220200020200220202022222020202222220022220200202022022200022022002222222002220200222222202200222020202002002222022202222000222222202020200022000222000222200202200000020202020200222220000002002002200002020220220220002022202000020000020220020</span></span><br><span class="line"><span class="number">200220222000200002002002202022220220220222200000022200202222000022002202200000000002200022220000202000000002222200222000020200020000020202022220022002000000002022000002002200022000222220220220202220022022222200002222022222000020200022000000020002020202000222002022220020222002202220200020000022200220</span></span><br><span class="line"><span class="number">202002222000222002000200000002222020202222222220020000202000000220202200202020220020020200022002222220222200222020222222202020220220220202022000020020022220000002220200200002000020220002002000222200220222002222200222000220002020022000220200200200222020220220022222020222220200022002022200022020220002</span></span><br><span class="line"><span class="number">002200222222020222200020202222222200220222202022200222000020020022000000200020200000222002022000200000020022002202222002022020202002020000000022222222222202002222020202002020222000202222222020022220002000200220020202022022202202200020020000222220002202002002000222002200002020022222022202002002222022</span></span><br><span class="line"><span class="number">200222020202220002000020000020202200000022022200000220020202202200202200022200000202200200022202222220220020202020000000202222022222020020000022202022020020222020220020022202000022220020002002202200000220222202022200200220222200220220000020202220202200222000022002020002022200202222022002222220220022</span></span><br><span class="line"><span class="number">220022222000020220022222022220222000002022000222020202200200002022022200202000002000020200002002000000202002202222022200202022002202200222022202002222202022202020202020200222000220022220022000020020200200202200020222000200220020020020020220222022020222000002002220202220020222200020000202222002020022</span></span><br><span class="line"><span class="number">202220022020000022220022222002000022220202220000200022022020002200002222222000022020020222002202200220220022000002002000220200002020000020220020220200020200202200000200220002020020202202020222022022002220020022202202000222222202022022020022202222002020002022022200022200222022022020222020222002202222</span></span><br><span class="line"><span class="number">020020200220202002000000222002000002000202020022222000022002020002222020020020200222000022000220022000022220020002022002220002000002002002202202020222020202202022000202222220022220220222000002000002222200220222222200020020002222000000002002022202020020200220002022202200202220220220020202202002022200</span></span><br><span class="line"><span class="number">202222220202022222002200022002200200222202000202222000020000200000202002022220220220000200022002020220000200022020020222020202220220222220000200002022222002202020222202002020000000200002022222202220022222220200222000202000202222222002202022002202202220020002202220002202222002022220020000002220200022</span></span><br><span class="line"><span class="number">200200220202220022220022022222002220220002020000000002222020222200002022222220220220222222000200002022220200022220220200000002200202220222002002200002220222000020002002220022022202222200000220200000000202220002022202222000222200222020000222000002000222022202022220202022220002020220002222000220002002</span></span><br><span class="line"><span class="number">000222022222020022220022220222002000222000022200020020002020222222020202002200020002202200022022200022200200200200222202200220002200020002220022220222220020220200222222000222220220020000220022222202202022020020022200000022200022022002020220000000000020200200202220022002200020000222200000022002222000</span></span><br><span class="line"><span class="number">220200002000220220000002022202202200022200202000022202000002000002002000022002222000220200022222220202002202000202200002022200202000202000200220000000020200222000002200000020022202022000020020202020222202200022020022002002202220200202200220202202020222220222000000002002000022222200222002202020222220</span></span><br><span class="line"><span class="number">020002000222022200202020022200220200020022202022222202022222022002022220222000202222200220202000220220222222000220022002202022020202000222222222200002020002202020002002002020022220200220020202020220222202222202222222020220020002200000020002222200222200002000220000002200000222020022022220220000002222</span></span><br><span class="line"><span class="number">022002220022222200020222220202202020020220022220200020000200002220220222220000000022000002202022202022002022222022220220000002020200022000220020022200220000202002202020222220022202222000222202022220000220220020222220222222202202020220202220200002200000222020022220200000200022020000020200002220002000</span></span><br><span class="line"><span class="number">202000202202222222022022000000220202202222000020000022022222020222020022020002000200220202200202202202200000200000000200000202202002022220222200002202220222222200200222022020222220222220020222000202020200020022020000222020202002002000202020202200220022202220222000000022000022220222220020002222200222</span></span><br><span class="line"><span class="number">020202000222202222020220000022200000020200202220220200020002002000220222220222020222222202220020222222020002000020020220002220222200002220002020220220200220200020002200220202200220200200000002202020022022222220200222220000220022222222222000222002220020202020002002000020020020200222020220000002002022</span></span><br><span class="line"><span class="number">022222200000202200000222220202020220020220222202022202000002202022220200000220200222200000220222220000220202002220202000020222202200020000200222200200020220002022202020002202222220200000022022222222222002202002202020200202202200220000222020000002200222222002220000220220000202220222220202002200002020</span></span><br><span class="line"><span class="number">022200002022222222202000020202220200200000222200000222002202222222200000220000000022220020222022020020202002022000000002202200220222202200222222200200020000220002222222222202002002022000200200222220222020022000022222002002202222022202000020220020020002022000222202000000002200222020002022200000020222</span></span><br><span class="line"><span class="number">200202202022000022002002200020000022202002022002000202202200002022022000200220000222220222002200020202220220000220202022002200020200222002202220222200202022202002222000022222200220220202002220200002000200000000202002200000222000220000022020220002022202000000022000202222200022020022202000002002002202</span></span><br><span class="line"><span class="number">000200000002222002202022200202202002222002220200222220020222000222020020002222000200002220000002000202000002000222200200020002220202220222200020222220220202200200200020202000202200022020200220222222002202000002000200220222020000200002000200020000222202220202222202002022022202000000022222200220200022</span></span><br><span class="line"><span class="number">000202000222000022202000020222000000002022220202002222222002220220222020020222222222002202002000000202020202220200200022022000200222022220002000000202200020000022002022220020200200222200020022022000000000002002022202022020002202020202202000000220002220200222202022200200002002002200220000200202222220</span></span><br><span class="line"><span class="number">002202220002002220202222002002000020022020022220200220022000022002222220002020222000002022000200020022200022022222000222222220220200002000022222222022200000000220220202200002202002202022202220200020002222220020222022000002020220222002200222220202002202002222000200220200002222020202200022000202202002</span></span><br><span class="line"><span class="number">222220202022202020200020220200222022220022020022202002202002220200020200002222000222002200202202220020022000020000002220220200202202222020002220220200002202222020000020222000222022020000002220200002020000200000222022200000202222002002220020002022002220022000202000220000222002202000000002222202202200</span></span><br><span class="line"><span class="number">000002000000222222000222200222200000022022020202002202220000002020000022000202000200020022002022020200222002022222200202200002022200020202000222202222002002222222202200220220202200020000022222002000200202020002002000222222202002002200202020000022220200000220222000000200000002202222220222022220202020</span></span><br><span class="line"><span class="number">022222002000020220222000002220000200222022202222200220020000202220202222020222000000022220022020000002002020220002222022200000202222002022222200200202200002202002002020200222002202000002000022022200022022220002200200022002220222000022000022202200222022220200220020002200202002220000200202220022222222</span></span><br><span class="line"><span class="number">200222022020222000200002220000020220220222000222200022220202002002002020020200020200220222200002200200222020000000222202202000200220220200202220202222000000022022220022222200000222002022222200202002000200220000222000202000022222002220000202222002000002002020200220002002022020220222000202020020000022</span></span><br><span class="line"><span class="number">000022002020200202022000022000000202002220220202002022222002202000022220020202022022000220202222202000200000002002200022202022002020000222022022002002202000200000000220220002002220202202222000020000200200002220002002020020020202202002202202020222000022000020002220220220000022020220220020220022202020</span></span><br><span class="line"><span class="number">202220020020200222200020020002020222000200202000020200020000000202220020200222220022022020222022002002222020000220220002000222202022020200002202020002020002220022022002222200220002202000220022220020002220022020220220200200222222022220220000222220002000020002020220000202222020002200022202220200000000</span></span><br><span class="line"><span class="number">202002000022200022200220020020220000200020002022220002220002002222022222220222222022020222200202022200000220220002020200002022200002002020002022200222222200000200220200200020020200022020000022220020020222222202002000220222000202002020202220020220022222000220022220220020020220022202000022020200220220</span></span><br><span class="line"><span class="number">220200222200020222220000200022002000200220020002002002220000022202020202022020220202002022200220202202002222220020022200222202002222002200202200222000022200022000000022022020222002220002202202022202020022022202222202022222200002200202022002000200002200202022220200200020200020220202000000222020220222</span></span><br><span class="line"><span class="number">002222222002020002202020220220000002022200200202020200202002022020002022220222002020022222002222202000202002202020200220002220000000222002200020220020202000020002200200022022020002200000000200220222222020222202002022002200022000200002220022022200020220200022002020202220000202002202022020000000000200</span></span><br><span class="line"><span class="number">220222022000002202220000002200020022020000022022220000222022020002222022000202020220202200220200002022020002000022202202022202002000200220002220020222020220222202002020200022000200220002002020022222220220020002200222000200022000020022200222022222220022022222202020220222200200020202020220200020000022</span></span><br><span class="line"><span class="number">220000020202022200000202222222220200202202000020200002202220220000002220020200020020002020200000022202022002020000202022022002002020202200200002222022002020000000002020220002022002220002020002222002020222000202020220000002022202000000022222002200220220002200200000002200222222000000002020002002022202</span></span><br><span class="line"><span class="number">220020202020222222022000000022200020000220220200200200000220020222000202000020000220220220220222220202222000002022020022020000020020222220000000000002202022022002200220220200222202000200020002022222202200200002020202220002222020022022200000220220002022222020020000202022200020000000222222200200020002</span></span><br><span class="line"><span class="number">022020222000022202002020220000220222000000200220000202022022222202222022022200220022222202022000002222000220200222020200002020022202220020200000022202022202222200200222002020222000020020202022220202222202220200002220200022202222202000002202000022220020000020020022020202200000000020022200222200000202</span></span><br><span class="line"><span class="number">022202022000020020202000200002022202200020200200020000200222222000000202020220000022222002000222002220222220000002002220202022020020220020000222220222020000222200002022022222202020220002022002020220002220020020202002202022200220020020002220022200020220002000002020020020020200200002222000020202220002</span></span><br><span class="line"><span class="number">222000000022202002200220222002202022202000202202220000222020202002022022000020002020022220200202202220000000022020222020000000200200002022022200000200222002220202220222002020200020022202002020002222002222020022022000200022000002000222020002202020202200020002000000000000020220220022220000220200002002</span></span><br><span class="line"><span class="number">222200000020222000000020000022202200220022020022220200000020020020022000020022222202022002202200000200022000002022220202020202000022200200002000000000200022002202002022220222000002220000020002022022000200222200020000020000022200222220200000002222200022202202220002002220202000202200220020222000222000</span></span><br><span class="line"><span class="number">020200022202022222222220220020202200200022200020202222202002202020202000022222002222202222000002200202022222000022022020220000000022222200002220000020022202202000022222202020000000220202220020200020002220202202020220222000002020202022202200220020000200000200222200000200022020200002200222022022002000</span></span><br><span class="line"><span class="number">022020202222002202200002202000200220200220220220000222022222200020220022200200220022022200202222202022002222202202202020202020002000002200200222000220022220220202000220222002200000022000000022022200202000002202000220020020000200022002020020200220020222002002202022002000220200000020020000222200200020</span></span><br><span class="line"><span class="number">202200002002022222020200222222020220222200022020022222022222202020222002000200020000220000222022222222220020220220220200202002202002000200220200020022002220222022202020200020020200202002220020000202220020002020222020200220022020202222202220202222020020200002200022002202020000222200022222000222200202</span></span><br><span class="line"><span class="number">022020202002002202002202022222200200022020002020022002222202202022202002222220020222000000000022222222020022000002002002202222002222002222222022220000222002020222022002222020000202202020020222220022020000220220022200002002222222002222002222202222220022202000222222022002200022020020022202000222002000</span></span><br><span class="line"><span class="number">220222000222000200022000202002220022222222200020022202222002000022200000222202202020002222222202200020220222020022202000002222202002222000200002222002022220202022220202000200200020202222220022022220022000020020002022002202202222220000200202002222200220020022000002222020200000200220202200020002200222</span></span><br><span class="line"><span class="number">022222220202222020220222002200000222002220200220000022002202020020200200220202222020202000222020022222020220222020220002220200200022002000022020200020020222222222022200022220000002202220200020202020002022022000002202222002202200222020222202220022200200000002202022222200220200200200220222000202020220</span></span><br><span class="line"><span class="number">202202200002002020000200202202202202022020222020202022000202000022000002202022002220000002202020220200220222022200002002002220200200020200002202020202000022002020000000222022220220022002222000222200222002220020000222222020220220222202220202000022000002202002220022000202022020202000000020022202202020</span></span><br><span class="line"><span class="number">220200222020222000222022200020200200020200022020202002002200200200020222000002220200200220200200002202222020020002002020020022220020222002202220222202002022000202020202020222200002220222002022022222222202022000222000020222000022222202220002220202220020220202002022002022220000200200200202220220002002</span></span><br><span class="line"><span class="number">202000000002222202020022000002220002220000022220200202200022022022020002002220002220200202002002220222020220000000220202222002002020202220000022020220222000000020002222000020002222222022022202222020002002022022002002202202000002022020200222022222020020200022220200222002002022022020202220020000022200</span></span><br><span class="line"><span class="number">200220020002200022020222222020022000220202000200202202020220000000002200220000200202020020202202200020222002202000202200002222022020002220002002002202002202202202202202022000222220200002022020220220000222222222222022222020222022020202002202202020202202002200020200222222000022200022222022220022002202</span></span><br><span class="line"><span class="number">220202022220000200022022222002002002020002000000002000220222222202022222202220200002222202202222202022002222022000022020222022222022222200020222220202002020022022202220202202000020000020020200202002222000020022220220020020002220220200220020022220002202002002020202222200220022002200020200220002200002</span></span><br><span class="line"><span class="number">020000222200200222220020222000220200200000022220000002000020000000222002222022220022202200020022022022222220000222200000222002220200022200220222202002020200220020000220002000222220202200020000020202022000200020200202202000020020020002002002220202200222020222202220222222222002020200220202000202020200</span></span><br><span class="line"><span class="number">202202200200222000222220222222202220000000200022202000020202222202020220200222220222222200002200000220000020200200222200202002022220000220022220222200002222020220222202220220002000000202202200202002222022022002020200202202000222200020200200000222020022002000220002002200002000200202022020222222022020</span></span><br><span class="line"><span class="number">220200022022022002022222022202202200002020022202022220002200020220020222020222222002222002202002000002022200022200022020020002020020002202220202022202000220022002222002020022002022200222202200220002200202222002220200222000222222022002020202022022000220202002000000200000202000220022222222220002200002</span></span><br><span class="line"><span class="number">200022000220222020222200000220220022222000220000022022202220222200020002202220020000022000220200020222220222202022000202220222200202000002220200202220022000200002202200200020000202000222020220222002200202202200200220222022220002202000200220000222022220202200220022200020002200002202000222200022200022</span></span><br><span class="line"><span class="number">220202000020000200202022020220000220200022022020022000222200200200200002000022002000000000222002020002000000220002002022200020022202020022022220002202000020020000202000200002222202002200200002020020002200200020220222000002002000202200202020202002020002220020200000220200200202200220022002222200002022</span></span><br><span class="line"><span class="number">000200020000020020200022002000022000000222202200020200200022022220222200022222220202022200200022000222200000022000222202200020202200222002002002220222002222222222000002002020222020222202202220202000202002020220002000002200222202000000022002200000200000000200020020202020220020202222200000020020222022</span></span><br><span class="line"><span class="number">022220220000022020220022000220002022020000002000220020202002202002200020020000020222220020020220000202200202022222222202022222020200020002220002222222022220000000200002022202222202022222020222220220220002200000022220200020022022020000220202002002002022222022000202020020022020020222220002020000220222</span></span><br><span class="line"><span class="number">220200200200020020002020002200022002020202022022020000200200020220202220200222222200222220000002022200000022002222000220020200020202000022002220220220022020220000002222022220022202000022220020200000220000020202020022200202202222022200000022220200002222200222222020222202020000222000002022200220222220</span></span><br><span class="line"><span class="number">202002022220202222000002222202020200000222000220002220000002022220220022200222000220200020202022002002022002202002200002220022002220222020002002200000200020000202220000000002222002000002000220202000000022222022202022020022000022022022200000022000022002222020000022020220020200220222000202020002200022</span></span><br><span class="line"><span class="number">200000222222220200000220222020022000200220200200000002220220020222022022200200202200220022000022002020022222002202022222220220222002200202220000200002202200222200202000200020220002222022002020000220022002000000022222000002020222020002202000000220200022200000000202000020000200000002202220022222222200</span></span><br><span class="line"><span class="number">202020020000220000022200002000022020020222222020002200200002222000022002020220200202000022220000200222000022022220000022020222000202202020020220022000200000200002202000220020202220022022020022200202002000202000202220022202220022202022002022202002202020220202220222220220000002220222020002220022202000</span></span><br><span class="line"><span class="number">200222002202200200000000202202200022222022202222222222002022202200222200222200200220200200000000022002200022220200002200002202202002022022000222200220000200000022222202000020220000022020200202222202022020020020222002220022200020020222200200202202222220202020020200222220002002000222222020022022020000</span></span><br><span class="line"><span class="number">200220000022002202222220202220002200002202222222020220000020002022202000202000220002220222022022022202002022200020200000222022202000222022222202200200000002202200222022022222220022200020022222000200220202000220022020222200000000022020022020200000220020220020222220002202022020022202220000202200022000</span></span><br><span class="line"><span class="number">220000202020022002020022200000222020002022222002000220202022202220002000020202020020220020022002002202022000002022222200220020020000022020002002222022200020200220002222220022222020200222202000202000002200200200202022000222200000020020220200020222020022022002222222002002200200202000000002000200002200</span></span><br><span class="line"><span class="number">002002200020002220202200020200002020220022202220020002222200020222200000202002000200202200020220220222020222202020220020222022220200202020220002222202202020220200202200020202202222022022000200000022000020022020202000202220022020020202022000222200020002202020202220002222202022200202222022000200202000</span></span><br><span class="line"><span class="number">000202020000000020002002000022020020202000022202020020022200202220200200002202020202200002020022200022200020200000002202000002220002000020000002200022222000020202000202002000002022222002202202200222022220022020020002220220222202200000022222222000202220200002202000020022000200220222020020002202002220</span></span><br><span class="line"><span class="number">222022202002020200000020022020200222020220220222202022202220002002000220222022200020222000002202220200022022022200222000002200020202022222200222002000020002022202002002000200220022000220000202020200202202000022200002202020200202222220202202020002020020220200220220020200202202202022200002000000200022</span></span><br><span class="line"><span class="number">220020200222222202220222002202020000000020002202222202022202220002222220202222022220002002022020022020222002202022020222202020200000002020202002002202220202022022200200222222222022202200220220000000020222222202200220000000020022222020222000000200220000200020200020202022002022222222202020200002002222</span></span><br><span class="line"><span class="number">200000222000000020000020200222220202020222222222022002222220200222002200000222000220222020000222200000222022220022020220020020000220220222202220020202222222002002022002000220200002002000220022002222200002002200000002202200022202202202022202000202200220000000220202220022220022202022222202202020202020</span></span><br><span class="line"><span class="number">022202200200000200220220020200202220020202202002220220220220200220020020200200202222002220220020022000022222200020002022002222002020020200222020202202020222022002020022020220222202220222220222000000202000000002220220000002020222022222220000200002000000000200020020020220002022022022202002020222020202</span></span><br><span class="line"><span class="number">000200002222202000202220000202220002000022020222202020222220202022222200020202002202000220020000020220222202220202020220222222200020022022002222202202022202022020000020222002202022202000000022022020202020002202022022022000000202202020022220222202020220202220020002222020202020002220202022020202022200</span></span><br><span class="line"><span class="number">000002222220202002200002222220002222002220222002000222000022202222000222022002002200200000222222202020020020022020202220220220222020022222200200000000020200022022000000200202200022222000202022000222200020222020002000222222222220200000200202020202220020000202002022000022020222022020220220020002202222</span></span><br><span class="line"><span class="number">220200000002202200000202022002000200002220002002222002200022202222020200220020220200220220200222202222022220020020020202222200022020002000222020020220002202000022020220000002202202202002002202222020222022220000002020002220022000202200002002200020020002020220020022202220200020222200000022222000020202</span></span><br><span class="line"><span class="number">020022200220202022200020202020002200020222220020202222222002200000220222222020200222222000220022202002020020222200220002020220002002220020220220200022020222200220222220202222200202002020002202220202200022200002222002002022200020222020200022000202222202220220222222000020000022000202202022002220020022</span></span><br><span class="line"><span class="number">222002002200000022020022200200000002220222200000220000202020002220000002202022022002000222020222220022020020200222222200202222020000200002222200202002202022000022022222020200220002202022000002200020202202022022000022200002000200020020202000202202002000020000222002000002000022020202020022020002022020</span></span><br><span class="line"><span class="number">000002022222200020202022020220202020002222202200002202000000200222222222002200202022220002000002000220000200020222220020200200020202200020200020200022202020200002000200222020020202022022020202222002020022222200002022000202222222000002002020200000020222022000022020222200200000200202200002000020200222</span></span><br><span class="line"><span class="number">222000220220002200200222200202000222022002022222020000020222000020220200022200220002020002020000200200202202220000202022220022022002200222002000222002200222220002200220022222000022202202220020020002222220220002200020002202220220020222200200200202202020000222220222200222202202200220220020220200002002</span></span><br><span class="line"><span class="number">002020202200000200220200222200222002020202022220200020020022222022222022200222020002200022020200222222022002002220200020202000200000020002202002202020202200202020000020002222202222220222202200002200202202002020002220222020022020222002222220220220000200220022202222222202200222202000022000200220020220</span></span><br><span class="line"><span class="number">002220020222200020002202000202200222202020222202022000220020022200022202222222022200222220000220222022020220222000020020022020200002222220220222020200020220220220220202022220200022220202022002020020200002202002000222220200222002020200200020220202222002022200200002020200002002222000000220022002222022</span></span><br><span class="line"><span class="number">200220000220200220220222002022002222020202222022202220022222220200020200200002202202000002220002220202202022220200202022222202022220202202002020020202002202020020222000202200000220222220002200200200200202220202202202200220000202202020202020220222202202202002002002220200200202022202020002002220022020</span></span><br><span class="line"><span class="number">222220220222202200222020000220002020220022022220000222000000202002022000002000200000220020020002000220220020002020222202020222000220222020202020002202200222220220020202020220022020222020002002022220220220000020220200002220002202202200020020000202000202222220002200002020002202020222200220222022020222</span></span><br><span class="line"><span class="number">222022200222002222002220222220002002000220000222222000200202000002022022200220220000002220220202222022022202002002222002020020200002020002202222202202020002022200222000000020222202222002222020220022000000220000220200000222002200000222202022020022202220202002202200222200002222222002022000220200000202</span></span><br><span class="line"><span class="number">022220222202200202000022022002200022200202020022002222020002202220020200020202020022200002202202220222022200022022222222200000002202002002022002222020222022022000002000002200022022022022202200002022002020222200022220002020200220220202020220020202200020020222002020022002220220220002220000222002002000</span></span><br><span class="line"><span class="number">020022002022222200002200200000020020222020002222220002202220022022200222022020020200022200222020022222002200002020222200020002222200220000220000002202000220022022202200220020200002020222202002202022022022002200020200020222022002200020220000020000202000202020002020202200002022000020200002002200020000</span></span><br><span class="line"><span class="number">200202220002022022222202022020022000200202222220000222222200002202202202020220022200220000200002222020000002000002202222220202002200200202202020202020022200000000200202002000000020000220002200220020222020022222222002220222002220020002220000020200200000200000222222002202022202002222000002222220022202</span></span><br><span class="line"><span class="number">202200200002202002202222222220220000200000220202000200220002222020200020220000202202022200200000200000200022020022000022020220002202000222202222000222022022022222220002020000200200002022020020200020020022220220000202202000200022000000000202222022222202022022002202222220000002200000222222220022220222</span></span><br><span class="line"><span class="number">002202202202222022222020022022022022220202020022000220222002020222000002000220002000200020200000222202200000220200220020020002000200002022002222200222202002000002200000220000020002000020202220020202222220202200200202022000020200222200020200002000222022222022200200002222000020000002202000022002022002</span></span><br><span class="line"><span class="number">200020222202000222202202002000002200002000220202220020020000002220022020222000200022000200220022000022000200220200022022200222202002022200202022020222020002222220222000000022022202022020000202000020202222020020202002200022020222020220222022202222000202202200002000222000202020022222200002220020000220</span></span><br><span class="line"><span class="number">222000202022222222220220020000220222222222220202220220220002020020020000002220020000002002000000000202020200200022000220200022220020002200002222200002200222022000000022222220220000200000002222222220200002220202000202222202202220000202220202000220002202002222022200202220002220000020002020220222202000</span></span><br><span class="line"><span class="number">022202020000022022202002002222000002002000220222020220002022020002022200002000202022000222020002000020222022202220200022022000002222202000222200020222222022222002000220222022020202020000222220200000200000022222020020000002022222002202000202220020000020222200202022222220202000020200200202200222222002</span></span><br><span class="line"><span class="number">000202220020200022022222220200202000222020200002022202220220220200222222222020000220220202000000222202222022200022220200222002202220002222022200022000200222020202222200200222200222000002002022220200022220002200022000020022022002002000022022002020220202000000200200022202200222002022000220220002020202</span></span><br><span class="line"><span class="number">222202220000022222022220002020002002000220002020222000202222022220020020220020002202200200022222222002222222022000022202000200200000002200202200202200022002202222220220220020200220220020200002220020220022002202022000002022020202022220022222202002220000222000020002202000020020000020002202020222202020</span></span><br><span class="line"><span class="number">022202020202200202222002200202000022220020220020020000022222220002200002022202202202200000020202200222022200020002022000000222220220200200022000020222000220202020022220220200020200220220202202222220220202220222022002202222022200020022000202200202002000020020022220000000220022202002000200020202202020</span></span><br><span class="line"><span class="number">002022002002022200000222020200220022222002200200202000002000020020000000000022222022200200200220002220022202200220202002022022202002222020200020022002202222220220200020022220222020220200000202200202200000220202020222000222022022022220222202220022022222200202022022202202202002020020222002222002022000</span></span><br><span class="line"><span class="number">022022020222022020000222002002022020200202220202202202222002222000000020022022022200202222220000002020220222202202220022200220002202020200000220200200000220222200200022200200202220200202222020002002022022202022220222002202002200022002022020202222022020022000002020222200002202222022222200200022002002</span></span><br><span class="line"><span class="number">222220202202220222222202202002002200222222000202022220220002020020220022022000200200222200200020202222022200000222220000002202002200002202222022220220200202000000022200020020000220020222200202222000200000000220202000020220200200002200202002200002220220020202002200022220022220222220202020022020002220</span></span><br><span class="line"><span class="number">200022020022220000000222200200222202202020220200222222020200002202020020022202002020022202220202222222002202220200202002022002200000200202020002020020202000020200200200222000220222202220222222220002220000020020202022000202222002220200200022202022222020220220202220002000020002022020222200222002002000</span></span><br><span class="line"><span class="number">202222202202200022202020002020020200020022000000220222222202020002022220002000020000002220022202200002222020220000002202202022000200020020220220002220200222022000022200000002202002020222002002222200022020200222020022002020000022000000200022220202022000020022000022002002020220222022222220002000202002</span></span><br><span class="line"><span class="number">220202222022222020020222220000220020200220220020020022200220022002202022022002202200202200022202202020000222002020020022002000022222202200022202020022220222000022202020200220000000222000200220000000002020022002202022020202002022202220022000200220222222002022200202022222220220222200222002000020220200</span></span><br><span class="line"><span class="number">020002000222022000220200222022020000202022002002200000222200020220202222022220202222202000220002202022020222220220022200200000002022000202020022222022000222000200000000022022000000002222220002000002222202020220000022200002222220222202202002000000022200020022222200202002220022220000220020222020002002</span></span><br><span class="line"><span class="number">220002202222000200002222202002000202020022022002020220220020222220020020020220200020020220022000002020000220002000202000000000022002022222200000022002020020222220220222022020200022222200200220200202220220222022222002020200000000022222200202000202200202022000220000002220002220002202022000202222220000</span></span><br><span class="line"><span class="number">222220022020202222220020002202222002222202202000002000222202020022202202022002200222000020220020200000202002220020200202220000020000022222000002222002222222020022020222002002222202000220220002220020202000022200000020020220200200202200000022202002020000020202022002202222200220020020020000220202022020</span></span><br><span class="line"><span class="number">000022220002220222002202022020000200200002202202202002020202200020222000200022222202200002220202220002200202022002222202220000202020022000022022200220020202022200222222222022220200202222022202220022222002002222220202220220000202222022200000002202200200200220002200000020022220000022020220020022222022</span></span><br><span class="line"><span class="number">220202222000200202002200220002200000222022202022000002000220202022020000202222002200002000200000222020222220222020220002200022222022000002222000200220202202022020022020222220022002200222202220022200020200222000222002000000020202000002020020202020220000202000200022020022200222002002202000202000220200</span></span><br><span class="line"><span class="number">222200222022222220202200002020000022222200202002002222200022002222020202022222220000220222022220002000002202202220000220220202022002200002200220000222220220002202220200002220020000020220020020000202002022022202220200202222222220002202020022022200020220020022220020002002220200022020022020202200022022</span></span><br><span class="line"><span class="number">020000202020000202200020202202220000000220000202002202220200002020220220220200000000020220222222220000220220020200022202222020220220002000002022202220202020220200000202000002200022000222200020000220022220000222202022002222020222022022222222200200002020002222200020022022222202200202220002022022020220</span></span><br><span class="line"><span class="number">200222220002222202000200202022200202202000022020002022002202220202220002200020002020222002220200002222200202022022222220000002222000222002022222220000020202220222002000022200000200222222222000222022020000202000200022002202000222200000202002202200022000002002000000020020220002020002020002222020000002</span></span><br><span class="line"><span class="number">202200020202020222020220002000200002002000020220020002020002222020002022200220022022020202200020002220020220202200202202002002220002000202222002000022020220202202022000222000000002020022022202022222202220002202022200200020220220222000202022202220220000020222002200020200200220000202002020002220222000</span></span><br><span class="line"><span class="number">022220002222020022020220200222202200220222022022022000002222020002002000002220200022000022200222002220022222020000220222000022000000020222000000222022222200200202202222000202022222022020000022020202002222022020022200020222022000222200220222000222002022222002022000022222020020222002220002002222000002</span></span><br><span class="line"><span class="number">222020022200000020002020002202202000022200200222222002020020200000200200200000020002200202022020002202020002220022202220202222220002220020222222020220022222000022002002220220200202202020002000020200022220002202220200220202022000200200000222022000220020220000002002200202222022002002000002002002220022</span></span><br><span class="line"><span class="number">202002202200002020220002220020202002202020002002000022202020222220200002202222000022200000002020000202020020220002020200220222200020020202200000222002202020000220202000020220022220222200202222000200022220020002002002222000020002222222002202200002222022002000000220222020022002000202220020200002202222</span></span><br><span class="line"><span class="number">220220002022000200022000022202002000202002020222220002200020220000022220022020022222220222020200200222020020022020022000000002000002202000202202002200202222222200022000020220200200222022020022022022022202222202022202222000000000222000202222020200002202222222002020220000202202020000000202022002202022</span></span><br><span class="line"><span class="number">002200020002200000202022202220000002222002000200202200202220000002022020000222020220020200000220222022020220200000000222220220000202220020002000220220000020022222220200222002000020022022020200220022222000000022202000000002002202002202202222200200200020022002000002222222002222000022202020020222020002</span></span><br><span class="line"><span class="number">020020020020200020222202020022020220022200222000220202020022020022220000202200220200000220222202202000020022022202222022020200220200222222220222022202002200200200202222020002020002022022020000200020000202202222202000220020202222000222220002002000022200222022000002200220022202022002222202002002200020</span></span><br><span class="line"><span class="number">202020002020222202000020220222022022222202200222002002202222000000202002022202202020220202020220022002022022002000222222220002002222222022020002000022022222222202220022202222002200202222222200020220000002020202220200022200002020222022202002020020020222022000002202000200022020020220002200022000202220</span></span><br><span class="line"><span class="number">022000000202000022222000202202220222020202020022220200000202202200022022022022000000022220220020222202220020022020222022222222220022022220020002022222202020020200202020020022000220200022202202200222000200020220200200002000202222200000220022002020202220200220220222002222200200220200220022022022000202</span></span><br><span class="line"><span class="number">200222020022002000002202202020022202000202022220000200020222020000222200000000000000022200002200220020022022022220020022000222022020222222222202000200202202222000002020222000222202022222002200022202200022022222022022200000220020222000202002022202020002220220000220000000002000022000200002220002022222</span></span><br><span class="line"><span class="number">020220202002000200222222200022002002020022200220022000200020222002022002002022000202002002202200202220200200022200220002222002022220022020022220202222200002222220222020220022200200220000020222222202220200202002020220222202202022002202002022222022222002202200000202022220222200220002200002020200222020</span></span><br><span class="line"><span class="number">200202002200000200022222220200222200020202002202022020022020222222222220000220220202200222020222200022002022022200222200022000002002020000220020002002022022020222200202020020020202220202222020202202222222200200022202222020022022202200020022220200000222002222200002002022200200022220020000002222022222</span></span><br><span class="line"><span class="number">220200022020000220022220220000002022222222000020202220020022020020222020000002020002022200202202200220020202222200000002200020200000022022222200200200220002222022222022200022020200220222000000020202022200220002002000002222220202220200020002000220200222220202200022202020020020022000020022022220220202</span></span><br><span class="line"><span class="number">000202022222020002002200020020020002220200202022020202202200222222220022200000002020200200002220020002022020200022222020202000220020202022220020222022222000022220002000020202220202202220222022020200000202022200022222002022020020002002202020002000220002000020202022022200202002220000000200222022000202</span></span><br><span class="line"><span class="number">220220202200000002022022002002020000000200220002220022220220200002222200202000000220200202002022020220222022220020222222200200220200202200002220202200020022220022200022200200022222022022022222022000200022202222220202020200022202200000202202200020200000202222220200202202220002022200222220200002220020</span></span><br><span class="line"><span class="number">202020222222220000022222200002200200002200202000200200200020220002000220202202022200200002020022000200020002002000020220220000000222020222022222022222020022022020222020222020020022202022220220020202222202022222002020202000000020202002220000002200002202200220002002020020222202002020020020222022002202</span></span><br><span class="line"><span class="number">022002202202022220002002222202000200202220202000220000000222020200222220022002202002020002200202000202200000000022200000222022022222002222020222000220022222200222200020200002202022200220000022000200200002200200002222202020000002220220022000002002002200222000000220202022020220022200220000000022022222</span></span><br><span class="line"><span class="number">022002022202220220000200222222200220002202220020222020202200002000022020020002020020000202020020002002220200002000202020020222002002022022000000022200002202200200200220220220202022022002002202202002220200000202022000000022022000002220222200002222220020220220002222202002022000020200200220200000200002</span></span><br><span class="line"><span class="number">000222202020020022222002222022200000200220020222020222222022220022220220002200200222022222000002022002220020020000020200222222202200002222202200022020222022222002202020022000000022000202020020000022222222020020220220000022220222220002022000022020222002002000220202020202020220200022000200220200200222</span></span><br><span class="line"><span class="number">202200222200220000020022000202222200002220022222022022002022002220200002222002002002222220022202220020222020202220020022000220000220020002002222222020022000002000022020202200220020220220200220020222220202000020020200200202222202200022222002020020202202200220002200000222002222200002002000200200020202</span></span><br><span class="line"><span class="number">000020200200222220200022202222202200202202020000002202020002202222220002222000200200020000222020202000220202220000222220020002022000000020020020022222200222020202202222022020202000020000022220020222200022222002002200202200020020002222002020200022220200202020222002022022222202222000220002220220200220</span></span><br><span class="line"><span class="number">002000022222220020022222202222022202202002002200202222002022000020222222200002002022022222020020022002200022022220222222222002000020202002002220222002022000022002022020222022202200022220200002222222020000022022000000220020002022220000020020002202202002002022222220222000022000202020220000022002002020</span></span><br><span class="line"><span class="number">200202202000022222020222200022220022220022022020200000200202202022222002020022000202200200022200022022220002000200022020020020000002202200020220200222020202022202000020222000022020022222020000202022022220222200020202022002200022200202200202020222022020200022200222022000200222020000000000002200002220</span></span><br><span class="line"><span class="number">222220000020020022020222002022002222002200020202020200022200020220222200000220002000022200200222002002000000000000022002222022020220002002222220220220200202200222000022020002020220222020000220022200000020022022020000000200222200202000000202022002022020000200200220022002020200022002202202200000000020</span></span><br><span class="line"><span class="number">222002222000220202002022220200200220222000000220202220222002022022022220202202020220202220000022222202200020002000000222020222202022222202022020002022222022000220002222022222000202020002202222220200020200020020200002020020200020200222202200022020202020222022002222022222022000020200002202200002002222</span></span><br><span class="line"><span class="number">222222000222022200222222200222222022200220202020022222202022202020002022000202200222200002222002222202000200222020200220202200002202220220022222202220002222002020220202220022002020002200200220202022202002200202020020002022222200220002220222022200000200200020002200202222200202002022222200020200202202</span></span><br><span class="line"><span class="number">022002222202002220202020002200200220220202200220002022200202022000220200222020022222000020200202002222000200202020000202222220000220222000202220022000222002222022022202000200200020222222002222002022002220002022220002002000200020200002200020200020020200000202022022220022000022022000200000020220000202</span></span><br><span class="line"><span class="number">220022222222200220200200222200002222200000222200220222002000022222022200200222002222000020200022000222000002000022002222222022022022200222222000020222220022000000020000020202222200222220202222000020200220222202202222222222020202202202022002020200220020220202002202220222022000220022002220022222202222</span></span><br><span class="line"><span class="number">200000000002002200220222222202220022002020200020000000000200222220220202220002200220002222022220000202222202000022000202002020000002000200222222202202220220200002002222022222222000002020222022000202200000202220220202000022002202000020020022002200020202222002222200200202222220000020222000200000022020</span></span><br><span class="line"><span class="number">022000022202020222020022022020202202020000220220222202022020000020220020022202022022022222022000000200002000020202202022202000022022202220220022200202200200202000020000220220022202200220202220200022020022002000220022020202000000222202202002022000022200000000200000022022020000002000002002200220222020</span></span><br><span class="line"><span class="number">202220000002200002020200220020222020022020200202020202000200222000222020002022022022022220200220202200022222022220000000022002000222220002002000002200220022022202020200020220220000020000222002220020202222200220200020002220220202202020020022200200202002000000022000000200000020222200202002220202202000</span></span><br><span class="line"><span class="number">200000020020200220020022020200000000202202222022200220200222020200002202202022020200222022200200020002202200222202002020220022022222222220220000222002200200220022202220022020200020020222000002000220202020022000022200200202222020202222002220222220200022220022002000022220020222020020222222020200020022</span></span><br><span class="line"><span class="number">200000000020220022000020222202222202220000022222000002222202222200020200220220022020002002222222220020000220202202220020020220202022220222020220022002202200000202202002002220002020200022200022000022220202220000200200020022020200002002000202020022220222022220022202202020202202200222000202002002022002</span></span><br><span class="line"><span class="number">222002002222200002002222202020220000220020202020220020020202000202022000002202222020220002000202022222220202222000022200200200222022202002000002200022202002002222020222200220222000022202020020200022222020220202222000222220200020022022202020220020000222222002220200020222022022022220000200022220000220</span></span><br><span class="line"><span class="number">022200000002002200222202002222002222222022020020000020020202022202022020202200002220202222200220020000220220202202000002000202220222222000222022202200200000220202022022202200200000020022202200200202202222222202220202200202220020000020022200002222220222202220220222020022000222002200022002200220202200</span></span><br><span class="line"><span class="number">202220002022220002200202022000022000020220202020220222022200200022202022000002022022222020222220220022022200002000000222222220222002200022222002220220022222020200202002000020022022002200220222222002002020002200220000002222002022020022002220222000220020222002200000020222020002002002020220200220022022</span></span><br><span class="line"><span class="number">202002022000222202200200222022222020002000220202222000222202002020020202220222222020020020022202000022222022220202200020000000022202200222202200202220002002022202022222220002002022220220000020020200222022022022222002000002000220202200002202222000020020200002220222222202002020020020022220200022202222</span></span><br><span class="line"><span class="number">000000220202202022220220222020022022220222020002000220202000220000002020202222020002200200222022022202022000222002002200000000022002022000202020222022200020200200202220000020002220202020000022022222022022222220000022202200202022020200200222002222000022000000200022002020000002220220220022022222000020</span></span><br><span class="line"><span class="number">200200220022202222202020200000220222000000222020220022002022222220000000202022002002202202200202222200000002220202220020220222020002200020022222000222200022202022022002002220020222000020220000000002020022202220002222220022002200222220202222200002222202202220022200002020020202202200220022002000220220</span></span><br><span class="line"><span class="number">200002020022020202220222200222000202020022202022002222022222002020020202022022002220000200200000220202222200000000200000200002220022220200220222020022222200022202220202200220002002022200020000000020000022222022200002022020002220020200020202202020020020002002000002000020020002000022002000200200222020</span></span><br><span class="line"><span class="number">202222202002000222002220220220202202002220020220202022200220002222202020200220222222202220002200200202202000200200020020000222000002222000222200202202020220022222220202200202200202220200202000222000000200002000200220222020222222002222220022022222022222020222002000202022020222022202222020202020200002</span></span><br><span class="line"><span class="number">220200222000020020220200202202222222202020002202022222222000222200000202220022002020020000000002002002002220020002222220200220002000022002220000002020200002222000220220220020220200020200222000002200220200022000020000222202000020220000200202222020220200002220220000200200220000020200222220222022200200</span></span><br><span class="line"><span class="number">002022000222200200000220202002000202022222000222020022002222202222002022220202200000202222220220002002220002200200220000202002002220222220020202222222200202200020200220000200000200220020022202200220202020220220220002200020200002000020222020000222222220022000220022200222220220202220002002202202022022</span></span><br><span class="line"><span class="number">000202200020222022200220222222002222200002020202000200022202002220022200000220220220020222000222022200022222220002000222222022020220002200200020200020220220200200200020000202022000202020222000200020022200202022002220000002222222000220202200020202200000022222200200222200000002000022220202002020000202</span></span><br><span class="line"><span class="number">220000220202020022000000220000022222200200000022200220220220000020202202202020022200000200222020200022020000022020002022002022200220222220200022022000002220220002000200200220222022200222200222002222022220222002202002200202022022020020002022000000020000202222220000022022202220200000020000202220022202</span></span><br><span class="line"><span class="number">200002022002000200022220002200002202000222220202020202220222200000202002222020202200222222002200020002022202022222020202022022000200020220222002020202220000002220222020222220222022000022002020022200222200200220000222022002002222002020002020022220220022202000222020222022202202200222222202202002222020</span></span><br><span class="line"><span class="number">020020222200002022200220200000022020002002020220222222002202220220022200000220000202222220222022222000000002220022222202202200202222020222222022000002220020020220020020202002020022020220020002022002200222202200222200020022202002200002220020000202202220220200200202222222020200022020222000002020202200</span></span><br><span class="line"><span class="number">000222020222202002000000222002022000000022000202020200022002020002020000200022220200220020002200222020200022002220200002022020020220000220002022202222020220022022020220222220002000222200220022202020000002202002222000200200002000020020202020020220202202222200202220222200002200220222220202002222220022</span></span><br><span class="line"><span class="number">200202220222220020202022200200200000022220000220022000022220022200000022200222000002000020022020020020200000022200200222002202000220200000000220020202220200000200220000220202202020220222202220202222222022022202220000202022000222220002220220200220222020200002220022000000202000222202020222000020002020</span></span><br><span class="line"><span class="number">200020020200020002220002222220222020202000022020002202200020002002000220022222002022200022200222222022000022002222200222022222222000000202200000222022000020002202022020000220020200220202020020022222002202222200222202000022220022220000200000000222022220022202220020220202222022000002000022000200222020</span></span><br><span class="line"><span class="number">220020022002202022220202222022022202000000000200000020222020202222202020200020022022022022200022000020202202000220222002200202222022202222022222200202022200022202002200000202002020222000222020220002002200200202022022000220202222222200220002202000020000200022220000200220220200020220000220000200222220</span></span><br><span class="line"><span class="number">020022020200222002200220220220002220200020202202222220200220220022002022202000020200220220220020222202020000200002220000222222220220220222220222022002222020000002200022020222202220200222220020222020202222200022222202002000200022200002002202002002202200000000202020020220022000202220020202200022000202</span></span><br><span class="line"><span class="number">002020002000022022200202002202002020022222200000200002202220000202002202220202000002000000220002000220222022222202220000002020220200000200222022002002220020220202022200222022220200202000020222220220000022022222000000220020020222020002220220020202020220002220002202002000202222202020200220002200020220</span></span><br><span class="line"><span class="number">200020220220002200000200022220202022220220000200020002000022022022022222020202002200202200002022022002022020202000000220222020200202222220002220022020022000222022000020020200222000002222022000022000000020002222020022022002200220222000222020222000000020020200220202222220020020000200200022000000222220</span></span><br><span class="line"><span class="number">002222022020222222220000202020220200002000002202200202200200000220202020222020022000020020020000022002200202002022020022220002220200222202000002000000022222220000020002020000222200022022022220002020022000200200220022022002222200002200022000022000222200220022002000200000200022022000202200002220200022</span></span><br><span class="line"><span class="number">202002220020020222000020220002022022202222200002220200020222020220000000000000202022002202202200220222020202222220220022202022022220022220202200020220200022020222220000220020200222000200200202200000022200000022002022002222022200220000220222002220220200222022220222022002202202222202202200202022020220</span></span><br><span class="line"><span class="number">002022022000000000002200020220222220200222000020202002000000202000202202022002000220200202222220020200022000020202202220002002002002222020200022200200202200022222202020220002220022020200000200202202022202202202000020220202200222002222220222222020022220220222000202022000000200022200200200000022222022</span></span><br><span class="line"><span class="number">222222222000220022200220002002002020200002002002222000202220000022022220220200202222002202000220000220222000220222000000200200202220022220022002200020000020220002022222000002222020022020200222200202222222022020022222220022220002020002222022222220202222220222002002220202222002222202022000022000220200</span></span><br><span class="line"><span class="number">202220200022022220022020020222220202222202020202220200002220220000000022200002020202202200022202020220222202220020202002000022020202222002020202222220222020220002000020000222000020000020002202222022000220200200200002022200220022000220220022202020020000002200220220002020202002000022002000022202002220</span></span><br><span class="line"><span class="number">220200000002202002200222000002200222002002000200020000002222000220022000022200222020200222200200220022220202200202220022202020200202200000222000022200220022200020220202000200222022222002200000222022220222222222202002022000020002000200202220202002002200202002020020000020200202002020222000002222020200</span></span><br><span class="line"><span class="number">202020002222000000002220220020002000222220222020020200020220020000020002000200022020222222020022220200220200200002202222002022000200022002200020020020002202200202002002202200200000220020022220022220020020202200020200222200200220220222220200020000022020200220200200022202002200000002220220022000200000</span></span><br><span class="line"><span class="number">022000002220222022202020002000200002020222220220002020022002220200222020020022022022220020202022020220022222200202002220020002220220000222022002020020202220000000220022220002000222002002222200222220200222220220002202220220200022222202220022202022020002200002200022222222202000002200020020202002220220</span></span><br><span class="line"><span class="number">202000220002202220002200020002002022002020200020022020022000000020202020000202020202022000000020000200222000220020022000220002022000022000220022000022000200022200222222002200220220022200220000000202002220220022200020002000200220002000020222020202202002022000020000020200202220222220220020220002222222</span></span><br><span class="line"><span class="number">222220002020020002200200020000200020222220200022202220002002000202022022000022200202000202200222200202020022202000020200022202222222222222000220222002002022000220000200022000222002220002222000022002220202202022222200000000220000002202000222000000222222200200220002222002220002020020202202222002022220</span></span><br><span class="line"><span class="number">002002222000200220200220220000220002222222200202202220220020200002202022002200200000002000202000222020020220020220202222020002200000020222002202020202000202220200200222022020020020220002202022200202000200200002222022220200020022222000220222022020020002222002222200000002220022000022202222200200200220</span></span><br><span class="line"><span class="number">020020220022202200220000222022002222020020202200222220222222022022020200002022202020000222200202202202220222022002200202022200222000022002202202000022220220000200020020022000000202222020000022220222000000202220200200000220000200000200222202020020200020000202022222000022202200202022002002220020200222</span></span><br><span class="line"><span class="number">000220220022002020020022222200020200222000000022020200022220000000202220222222202220202220200200200000220222200022200200000000002200002022202202020200222022020220020220020222202000202020000000220202000200202020000202222022200002222202202200222000002020002220020200020002022022220022002200000022200022</span></span><br><span class="line"><span class="number">202022020000020200202002220220000200020022222020220022022200200220002000202022002202022202200022022202002202000000200000022002002222000220200222022020222222022000220220020020200220020002002000202000000002220220220200000020020222222200200022200220202020002022020202222022002002202200020020020220022220</span></span><br><span class="line"><span class="number">222022200020022202222220222220222020020220202202002200000020000020022222022000200222002020020200022202022000022220020022222202220220020022022022022020000222220000220220000000222002200022002220202022202000022020220200020222002220222022002020000222020020222220220000002222002022220200000220222220022220</span></span><br><span class="line"><span class="number">200222000222202022200220202022000220022220022002022222200220202022002002202000200220022022002000000020200200000020220222200022222222020022202000000200000022002002202202200222020020022222002220202022020202222022002022200222200022020220020222022220020200022222202000200222020000220000000200022002200200</span></span><br><span class="line"><span class="number">000222020202002020022000002000002000022000002220222200220200022022220022000002000220200002002002202022222222002202200020220000200200202020002202220000020222020022022200022220222022000020222022000000020202220020222020000222202222222022220202022020200202220220222002220200022202002202000000220202220202</span></span><br><span class="line"><span class="number">000000202200202200002000022002002202202022000022022002220002220022002200022022022220020020022000222022022002020022000000220200220022220020220202202222222200002000000200020202002000202200220000002022002220020000222022002222202022022020222222200202200000020220000222022202220000202022222020000202222022</span></span><br><span class="line"><span class="number">222200000202220202222002022002202220000222000222000220002022002020200200202222000022020202020200200202022202220200002202200000022200020220002202202222222000222002022020002002000222200002000000200220022020000220022022220022002002022202022000202222022022022222200202002200202000222002222020222200000200</span></span><br><span class="line"><span class="number">020220202022200002202002020202222220022022220000222202220222202000002200002200020020202200202200002200002020002020200020220220202220200022220020000000200000000200022202002220020022022202220020000222020200000002000020202200202200002000222002222022202202020020020020200020202202020222222220222222200222</span></span><br><span class="line"><span class="number">222022002202002202020020202220222200222202222200022022022220000220000220002202002020222020002202000220200020200022000000220202022202000022220002020202022022200022000000002222000200002000020020202222202202022022002020000222202002020202200020000222202020020220220022000200020020222222220220000020020220</span></span><br><span class="line"><span class="number">202200220000220202002020022000202002002000000002222000020222220020000220002220002222002020220002202220202000022222020002222222000022020022202220220200222020220020220202020020002202220222202200002000022222222022202220200022220222020222202002002022222200202022000002202002200002022000200002022020200022</span></span><br><span class="line"><span class="number">202020020020020222220002002200200200022200220200222220222202202200000222200020222000020200220202020220022002022022020020020202200222022222222220202220202220220222002020020200220002022020220022020220220222202020220020002202002002222202000220000022222020220200202022020022000002202222200020020002022220</span></span><br><span class="line"><span class="number">222200222202202222200200202202002200000200202022202220202220202202202020220222022220022202200200020200020022022220002002000000002200220200002200020200200222202002222222020202202022002020202220022000020020022202020002202002220220202020220200002200002222200222002202222202000220202002200022200002022202</span></span><br><span class="line"><span class="number">220202020000022202220020202202000222200222200002002020020220002220022002020220002202222200222000202222000000202222200202000000220200022202000002022220200000000222220022200020020202222220200020200200000000202022000022002220220022002220222020222200222200202222002002002200200202022020200000022200220202</span></span><br><span class="line"><span class="number">002200022020222020200000200002022020202002002202222002002002220000200022000000022220200020022222020000022220002222022222200202202222022222020202202000200002020200000202200022222002020022002202002002200222200022202020022022002202222202202022202222200202220200000002002022000000222220200002000000222022</span></span><br><span class="line"><span class="number">000022000002000020222200200022202202200220220222020000022022222020200220022220000222220000200000022220222220200220022000002000220002020020022202202222222020000002220000200020000222200002022020200002200220220222200222002020020022000002222022020202000220000022202200022002222222000002002022220022222222</span></span><br><span class="line"><span class="number">200020022220202220202222202222220220222002200000202020000022220220002002202022222200222202202220000202200022022202000222022222020220222022020002222020022002022020200222020202000002000220020020202002002222002200220000202020002022200222022002220200000000220202200020202200020220220000202222020002020002</span></span><br><span class="line"><span class="number">202220222020202200002222220200002020222202020000200000000000202220202022202000000222202000000222202222202000000022200000200202200220002022202002200220222000022222002200200020002222202002000202000220000222022020002020000000222022022022022202022020202202002022020002000020202020222220220200222202002002</span></span><br><span class="line"><span class="number">000002222222020002200000222220222220002202020022002020022020202222020220002020000002020222200220000202022002220002022202022202200202000002220020200222000020222200022020020022220200222200202200020022202022222000002220200002020000022222202020222002002022022202200000222020200000220222002222200200000022</span></span><br><span class="line"><span class="number">200022020000022020202220022022200002000202020202020220002220200022002222000022002000022202220200000022000002022220202220020000220200000202020220222200022220000202220002222000202222200222202222022002020002000020020200222200202022220200020000000022220200220202222000022002202022002222220202202020200020</span></span><br><span class="line"><span class="number">220220222000002220022000202202220022020000220000000022000200222200020020200002022202222222200222022022202220020002222002022022000222220022020000220000200202220200220202020020000222220202022000022200000020022000002200220222000020220220200222002200202000000022202000000220022000000200020022000020200002</span></span><br><span class="line"><span class="number">222220022022200202200200022222020022020200002022220220202220022222002202200002002022220200200202000222000020222220202200202220202220220020022002020000222202020200222020222002200200022022000200022220020002222220220220022020222200202002022022222020220200022220022200222202222020202020220020002220220020</span></span><br><span class="line"><span class="number">002020022220220220022202200000020222200202000002220022202202022020220022022202022002000220020220020000220200200202222002020000020022022002202202220222222002200022002002220202202022000222220002202222020200200002222220002220022022222222222000000002000200200202020022222022000000020200202022000020202220</span></span><br><span class="line"><span class="number">220222000222220020220002022022002000220202200002000022002220200000002000202220202020222022002020222000200222022202202220220220022202002020222220000200000000222202200002000200220200002000222202220202220200202002200002200220202202220202020200002000202020222202200200200222222022202200022022022022220002</span></span><br><span class="line"><span class="number">020002000000022020220200222222200222000220002000222022222022022202000222200222200020202220200220222202220200020222000000202202202220002022202000000000022002002002202202222020020222202022202202222000022002220202020200220200002222222220222200000000002022222020222022220220222222222220022200200222202202</span></span><br><span class="line"><span class="number">002022202220222022202020220020202200202000002022220222022020222000200022202022220002222200000020020202200000222020202000202022220220022220220022020222222000222222222000202222222222222020220002200220222000200220022020202200220222200020220220200002222200022020002020220200020220202002002000202200020220</span></span><br><span class="line"><span class="number">002200022200202002002022200002202200222200002202202220020022220020022202022200000020020000222020202002020002022022200202202020020220022222222022022000200200022002222222022222022022200002000220000020202002002200222020022022002000022002002202200220020002220220220020220222200200222000222000220020000000</span></span><br><span class="line"><span class="number">202202220000020222220222222220022022020222000222200202022200002202222202022000220202022000202200022022200222222220000222000002222002222000000022022202020222020020002220022002200202020222000222222022202020202222022020222222022020222000220200022020202222220222220022220020000022002020220202020000000220</span></span><br><span class="line"><span class="number">022220002200020022022200222200202002022022202002200002200200002022000200000202220000022000202202022020222020020220200022200202000020002022200200220202222200202002200020000002022200202020000200222220202000000020002002202000222020022022002000202222022202020020222002000002000200020020000002000022000222</span></span><br><span class="line"><span class="number">020220020020020022220022202000220000200200002020000022002000220000020200022002002220022000220020020220022002022222000200000020022000222202220002220202000200020002020022020002002222222222202022220002002220222020002222200020222200022022022022002200202022022222202000022022202200200002000220220222000200</span></span><br><span class="line"><span class="number">022222002002220000220020202022000200022002200020000222020022200000022222222222222202000222200022202220002022202002200020022200202002022000022022220002202020000000202020222220222220020020002220200202002222000222200022202222002000000200222000020020200020202220220222220200020202020002220222002200022020</span></span><br><span class="line"><span class="number">002222000202020000220020020202220202020222220220002220222222000002220000220022200020020220220200000000200022002020220202000020222020000202002020022022200220020202200200200220222002000002000200022002002200002220220020002220200002002002002202200022202022222000000202020222202022000202202200020222002220</span></span><br><span class="line"><span class="number">022202220202002200222002000020222022220222022222002002000202000222020000000020200222222220002202022020022202022002002220020022002020220220220020222220002020002222202202220022200220220022020022002200222002202222200002202022022220002002220020220020202200000200002222022202202200022202202200020020220000</span></span><br><span class="line"><span class="number">000002222002002200020022222222022220022222000202020202022000020202022220220222020022202222022022202202000020200002002222200000000220000222002022202222020000020000022020000000220202000000020220000200222000020020020002202022222202022022220202002202002222220020002202200222000220220222002220020000222202</span></span><br><span class="line"><span class="number">222002022022002202200022022200220202202220022002020222202020222022000022000202202202202200020022222022020000222002022022022000222220000000222002020200222022002222020220000222200202200022020002000202002002200002000202200002002002020000020220002202200222220000222222200220220000000022020002020002202000</span></span><br><span class="line"><span class="number">020202220002000200002220220002000000020202002220022000022200222002020020222202200020000220002202022002220202000002022222222200002220022022022020222220220022200002002002200222200200222220002220200202202220022222220020022200020020002220202000222022002202200202002222020000202220200020202202020020022000</span></span><br><span class="line"><span class="number">202022200222202000002220222002020020002200000000020202220000022000002220022000000022202020200020002200222022220222220020222202002022002200002022000000200000200220222220220002200220000200002000002002200200000220000000020200022222002020002202200022222200000222022022000020202220000220220222022002002220</span></span><br><span class="line"><span class="number">000000222200002202202022202002202000002002002000002220002202220220200220002000222202020222220222222222200202220200222222222002022220220020020220220220220202020200202020020002222020020022002222002000202022020022022002002222202202002200200000220202200200022220002000020020020202002200022220220200200202</span></span><br><span class="line"><span class="number">000022200222002222222202002022022020002200002220000222020020222022202022222222022020022020200220020222220002202222222222222202002020222222220020022202020222220220000000022002002002022222022200020220022020020220200000202022022220002202000022022202200022000220202022220022222022002022222022022022200020</span></span><br><span class="line"><span class="number">002222202000220202000022200220222200002202200020022202202200000020000222020222202000200000202000222000020020222020000222220002202000222000220022022200200022222002200002000202202220220000022200220202222020000002022000220022220002200202022200222220220220222200222000202000222022022000220222020222202220</span></span><br><span class="line"><span class="number">020222020000202020200220002020002222200200000222002200020022220220220220202202220002200200000000220022002222200222200222220020020200022022022020022222202220000200020202020002020000222202220020000220000022202220022200220202002202000000020222022200200002022022220200000220020222020220200002220222022020</span></span><br><span class="line"><span class="number">220020002222002220220202002000202020020202020202020000002022202020022020022022020002202020022220202022220020020022000002200202200000202202020220220000020200222222222200200000200202000200022200220200220022000002222202220220202002020222020022222222002002200020020222022202022200020002022220222020200200</span></span><br><span class="line"><span class="number">002202202020002000020220022002020020002220222000200022022200200202000220000022002202222200002002000020222200002000200000202000020000002220202220220002220222002022022222000222202000202222002020002222202202000202002200220020020222002220022222002002222220000020000022020020000202020002200200202220220002</span></span><br><span class="line"><span class="number">002020222222020020222202002202222200020220200222022200002200202200222200200202220202022200220200020000220202022200020220022220200220222222000220000020220002220002220220002022220222202202002000202220222022200222222222200220220222002022000020020202220020022220222000220020220200020222000222200002222220</span></span><br><span class="line"><span class="number">220020020220000200202202020002020202220020020200202022220220200220220000202002222200200222022220222202200020200222200020220000220000202220020002222222020222020000022220200220220202220022220220022000202200002022020020222020202022022002020200022002002022020202220202020002200220202200022000000020002220</span></span><br><span class="line"><span class="number">020002200000000220222222000200022222022020002220020222022202000002202222002002022220202202022220222000222000002220020220002002202220200222222020020002200022000220202000000222022000000020022200200202220200200200002000202202000000222222222202020022220222200200202002002220000002222200202200022202200020</span></span><br><span class="line"><span class="number">200202020002220220022222222002200222200200002022222020000020022020200002002000220000220002220000000220002020002022202020002022020220200220002002020000200200000200222202002202022020222220002000020222222022022202222022022220002202200220220022020202202002202220220020202000202002000202222020202222000222</span></span><br><span class="line"><span class="number">022220002222222200200200220002022222022220002000202002002020222000222222002002000220002020220022002202022220020000022022202000002002200020000002020020000022220020200020220220020220002022220222002000202220202200202020000020202000000220000202202020020002220020022000000022000202200000002002200020202022</span></span><br><span class="line"><span class="number">022000020002000022200000002020202220022200022200002202002222220202020202200000222222022022002222020200200200222020002022220222220200220202200200022202222022022002020000200200200002222220002202000022220022002002222222222002220000222202022222222000002200022220202220222220202020000220022022222222020022</span></span><br><span class="line"><span class="number">222022002220022200000200200202000220020000002222000020000022220202220022222220222020202022200022020000220200022002000202220222220002200202022000022200022022202222222000020202000000000220222202022222200202002202020200220220202220022000000200002200020200000002020200200200202020022220220220000222222000</span></span><br><span class="line"><span class="number">202202222022220200222022022200002200200022000002200022200222020220022200202202202200020200200220000020200000202220022020002220020200222022002200000020200002220202000000002200200002020002200022220220220022222202220202222200022020022202222220220022002000022020020202022020222222220000000000002022000020</span></span><br><span class="line"><span class="number">202022020200022202000000020220000222022202200220202020020002002002220220222200000222002022022022200022002222020220000020002022022000020002200020202000222022220222220202002222220020002222200220202002002202002220002222202002202220002000000200220202020222222202000020000020220222220002020020220200020200</span></span><br><span class="line"><span class="number">220220002022220000220222022002002222200200002020002202200200002200200222220202000202002200022220022020222020002202000020022000000200220000220000022220200220000020000200022222020022200020202002202222020020002202022222022220202222022022222202022002000020002202020022002002200020002022000002020002020202</span></span><br><span class="line"><span class="number">020202200022200220000220022220220202202202002220200022202200220220220220200200020020200022222022000202000220200002220222202000022020220002000220020222220000220000022022220000202000222202220020020222002222000000022220020220200022002002200200220022222022022200202222020222220200220200202220202202002222</span></span><br><span class="line"><span class="number">202200222020220202002020200020020022000220220002002022200000002020020020220002000022020222020020002220002200020020020200020200022002000020220202200202022022222200022022222022202020220000022220022020222000020220220202200022220022200220022220000220222020022000222022222022022002002020200020202002020022</span></span><br><span class="line"><span class="number">202000000220000200200022222022222000002200200000002220220222000022222222022020002020220202200222020002002202000200200220202002022020002202000000202020000022002220022002202200002022202000022220222202222202022020000200200222202220022020200222202220020220200020202000200200000222202222020000022002020200</span></span><br><span class="line"><span class="number">002022020222222202222020000002000220000000202200022202022202000000022002020022002002000220222002000222002000022020000220222222000202220002202200202000220000220020000022000200222020222222222000020200002222020000000200200200000022202222020000202220000200202222222002202000200022022002222000200022220222</span></span><br><span class="line"><span class="number">022000220020002000002222200202222222202000222020002000022200002200020222200022222022200020002020000202020000222020200222000022200222022022200020000020220000220000200022022200022220002220220222020200000020202022002220222002002220020002220002202202202200002002200222002220222000220000200000220200202200</span></span><br><span class="line"><span class="number">000022200000200220222200220000002002020020220220002222220002220020022020200222222222220202202202000220022002220222200002222220022000022200202222022200200222222020002002002220002202022220002022222022222022022220022000022200202220000000202022002022202002222020002202022202022202200222222220202200022222</span></span><br><span class="line"><span class="number">002222220220002020022220220202020200002002220020220022022002000202202002200202002020200000200022222222022022220000002200022002020200000220222022200020002202020220002200202220220002020000002020000020022020000200022202000002200202022200200200000022200220022002020020202022200000000002222020222002020222</span></span><br><span class="line"><span class="number">022022020220000202200220202020200200002000002000000020200220222002222220222000002200002222022200222222002222200020220020000200222222000020022000220000002220200000202002020220200220000202220222202222000200200000222222220022222002020002020022020000020000200222222020202220022200220220002200222202022002</span></span><br><span class="line"><span class="number">020200000220002000022200002020000222200200220200000200000002002020200202000202222002222200020220000202222202220020222220202222000222022202022202002000000020020022222200202002000022220222220020000020200020220020222022202200202002202002002002222202222222202222202002022020000200002222002000200000002202</span></span><br><span class="line"><span class="number">200020020200000200000220200022202020202220220020222200020202022022022202020202002200220002000200022222220022220000200000220222000002200020202022200002000020200222220002222220202202000200202220222022022200200000200020200000002000220200000020222022220220200222000200002222000222020200200202200202220222</span></span><br><span class="line"><span class="number">002200202002200202202222222002020220020000000202200000222200220000000000022200022000220202020222022022220220220202200020200222222022020020000002222202002222200000202020200220200200002020002022222002020000202222200202200002222200200000222200202022000202022220200002002220222202200002202220200222020002</span></span><br><span class="line"><span class="number">020222002000000202222220020000000000022002022002020202202002002200222200020222222002200000022000222200200222202000200000202022002222020220002222020000000002022220202000202202222200002222200022002000000002222200222222220000220200020020220202022020022222222002002200200002002200000002202220222200222000</span></span><br><span class="line"><span class="number">000000002022022020022202202200000200020220022220000022022002000020002022220200220220222020022200002022222222002200020222020002222220200002202002020022220022022002220222220002022020022022202002002222020020022202200222200000200022002220202000200222200202020022002220202200022002000200002202020002022000</span></span><br><span class="line"><span class="number">022220000002200200202022000202222022202222222202022002222200022200222220020200222020002022222220022202000002220020220002022222022022002022202222222000022002020002202002022000022000202200000220200022200020220222000022202222000222222022202022222022200002202220222000202000200002220200000200202002202202</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构与算法</tag>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title>C++网络编程学习：项目化 (加入内存池静态库 / 报文动态库)</title>
    <url>/2021/04/26/20210426_C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E9%A1%B9%E7%9B%AE%E5%8C%96(%E5%8A%A0%E5%85%A5%E5%86%85%E5%AD%98%E6%B1%A0%E9%9D%99%E6%80%81%E5%BA%93-%E6%8A%A5%E6%96%87%E5%8A%A8%E6%80%81%E5%BA%93)/</url>
    <content><![CDATA[<ul>
<li>使用的语言为C&#x2F;C++</li>
<li>源码支持的平台为：Windows（本文项目全部使用windows平台下vs2019开发，故本文项目不支持linux平台）</li>
</ul>
<h1 id="一、思路与准备"><a href="#一、思路与准备" class="headerlink" title="一、思路与准备"></a>一、思路与准备</h1><p>&emsp;&emsp;之前的客户端虽然可以跑起来，但是声明和实现全写于一个hpp文件中，随着代码日渐增多，增删改变得越发困难。所以我决定尝试将其实现的更加标准。本次我准备的内容如下：</p>
<ul>
<li>服务端源码 —— <a href="https://blog.csdn.net/qq_45698148/article/details/113899184">C++网络编程学习：消息接收与发送分离</a>（即笔记九版本的源码）</li>
<li>内存池源码 —— <a href="https://blog.csdn.net/qq_45698148/article/details/114239346?spm=1001.2014.3001.5501">C++学习记录：内存池设计与实现 及其详细代码 </a></li>
<li>计时器类 —— <a href="https://blog.csdn.net/qq_45698148/article/details/113702354?spm=1001.2014.3001.5501">C++学习记录：基于chrono库的高精度计时器</a></li>
<li>报文CMD文件 —— 即报文类型定义，在之前的网络编程笔记中可以找到</li>
</ul>
<span id="more"></span>

<p>&emsp;&emsp;我<strong>首先</strong>准备将之前服务端源代码的hpp文件进行分离，分离成单独类声明与实现。且服务端本体源码放在一个项目中。<strong>随后</strong>新建静态库项目存储内存池源码，使服务端源码项目链接内存池静态库。<strong>最后</strong>新建一个动态库项目，里面存放计时器类代码和报文CMD文件，因为服务端和客户端程序都要用这个库里的文件，为了今后方便改动，我选择使用动态库。</p>
<h1 id="二、服务端本体-项目"><a href="#二、服务端本体-项目" class="headerlink" title="二、服务端本体 项目"></a>二、服务端本体 项目</h1><h2 id="1-思路"><a href="#1-思路" class="headerlink" title="1. 思路"></a>1. 思路</h2><p>&emsp;&emsp;首先，服务端源码按功能可分为五个部分：</p>
<ol>
<li>服务端基础接口部分。此部分定义了几个服务端的基本操作，可以通过继承重写这几个基本操作实现不同的功能。</li>
<li>服务端主线程部分。此部分调用基础的socket函数，与客户端建立socket连接，仅监控是否有新客户端加入。</li>
<li>客户端类部分。每当有新客户端加入，都会新建一个客户端对象，通过该客户端对象(获取socket&#x2F;使用缓冲区)发送网络报文。</li>
<li>子线程类任务处理(发送)部分。此类每一个对象即为一条新的子线程，用来处理服务端与客户端之间的网络报文发送任务。<br>任务处理接口。通过重写该接口，实现自己的任务处理方式。</li>
<li>子线程类接收部分。此类每一个对象即为一条新的子线程，用来处理监控服务端与客户端之间的网络报文接收。<br>重写任务处理接口方法。实现自己的任务处理方式。</li>
</ol>
<p>&emsp;&emsp;按照五个部分的关系等，可画出如下的关系图：<br><img src="/images/2021-04-26/1.jpg" alt="在这里插入图片描述"><br>&emsp;&emsp;由此，我令 ⑤部分 include ①③④部分，再令 ②部分 include ⑤部分，即可实现项目各文件间的关联。</p>
<h2 id="2-头文件源码"><a href="#2-头文件源码" class="headerlink" title="2. 头文件源码"></a>2. 头文件源码</h2><h3 id="①服务端基础接口部分"><a href="#①服务端基础接口部分" class="headerlink" title="①服务端基础接口部分"></a>①服务端基础接口部分</h3><p><code>INetEvent.h</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 本文件中定义了服务端的基础接口</span></span><br><span class="line"><span class="comment">* 在TcpServer.h中服务端类继承了该接口</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* 目前仅定义了四个基础事件</span></span><br><span class="line"><span class="comment">* 2021/4/22</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _INET_EVENT_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _INET_EVENT_H_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//相关预声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClientSocket</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CellServer</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DataHeader</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务端基础接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">INetEvent</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//客户端退出事件 </span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnNetJoin</span><span class="params">(ClientSocket* pClient)</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//客户端退出事件 </span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnNetLeave</span><span class="params">(ClientSocket* pClient)</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//服务端发送消息事件 </span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnNetMsg</span><span class="params">(CellServer* pCellServer, ClientSocket* pClient, DataHeader* pHead)</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//服务端接收消息事件</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnNetRecv</span><span class="params">(ClientSocket* pClient)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="②服务端主线程部分"><a href="#②服务端主线程部分" class="headerlink" title="②服务端主线程部分"></a>②服务端主线程部分</h3><p><code>TcpServer.h</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 服务端类</span></span><br><span class="line"><span class="comment">* 实现基础的socket连接操作</span></span><br><span class="line"><span class="comment">* 通过start方法生成子线程 监控收包</span></span><br><span class="line"><span class="comment">* 主线程仅进行客户端加入退出监控</span></span><br><span class="line"><span class="comment">* 2021/4/22</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TCP_SERVER_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TCP_SERVER_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;CellServer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//服务端类 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TcpServer</span> : INetEvent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造 </span></span><br><span class="line">	<span class="built_in">TcpServer</span>();</span><br><span class="line">	<span class="comment">//析构 </span></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">TcpServer</span>();</span><br><span class="line">	<span class="comment">//初始化socket 返回1为正常 </span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">InitSocket</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//绑定IP/端口</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Bind</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* ip, <span class="type">unsigned</span> <span class="type">short</span> port)</span></span>;</span><br><span class="line">	<span class="comment">//监听端口</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Listen</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line">	<span class="comment">//接受连接</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Accept</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//关闭socket </span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">CloseSocket</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//添加客户端至服务端  </span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">AddClientToServer</span><span class="params">(ClientSocket* pClient)</span></span>;</span><br><span class="line">	<span class="comment">//线程启动 </span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">(<span class="type">int</span> nCellServer)</span></span>;</span><br><span class="line">	<span class="comment">//判断是否工作中 </span></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">IsRun</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//查询是否有待处理消息 </span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">OnRun</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//显示各线程数据信息 </span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">time4msg</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//客户端加入事件 </span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnNetJoin</span><span class="params">(ClientSocket* pClient)</span></span>;</span><br><span class="line">	<span class="comment">//客户端退出</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnNetLeave</span><span class="params">(ClientSocket* pClient)</span></span>;</span><br><span class="line">	<span class="comment">//客户端发送消息事件</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnNetMsg</span><span class="params">(CellServer* pCellServer, ClientSocket* pClient, DataHeader* pHead)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnNetRecv</span><span class="params">(ClientSocket* pClient)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//socket相关 </span></span><br><span class="line">	SOCKET _sock;</span><br><span class="line">	std::vector&lt;CellServer*&gt; _cellServers;<span class="comment">//线程处理 </span></span><br><span class="line">	<span class="comment">//计时器</span></span><br><span class="line">	mytimer _time;</span><br><span class="line">	<span class="comment">//发送包的数量</span></span><br><span class="line">	std::atomic_int _msgCount;</span><br><span class="line">	<span class="comment">//接收包的数量</span></span><br><span class="line">	std::atomic_int _recvCount;</span><br><span class="line">	<span class="comment">//客户端计数</span></span><br><span class="line">	std::atomic_int _clientCount;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="③客户端类部分"><a href="#③客户端类部分" class="headerlink" title="③客户端类部分"></a>③客户端类部分</h3><p><code>ClientSocket.h</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 客户端类 </span></span><br><span class="line"><span class="comment">* 服务端对象中每加入一个新的客户端，都会新建一个客户端对象</span></span><br><span class="line"><span class="comment">* 通过该客户端对象向客户端进行发送消息等操作</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* 目前来说只实现了定量发送数据，即发送缓冲区满后发送消息，下一步预备完善为定时定量发送信息</span></span><br><span class="line"><span class="comment">* 2021/4/22</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _CLIENT_SOCKET_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CLIENT_SOCKET_H_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//socket相关内容</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> FD_SETSIZE 1024 </span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;winSock2.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;WS2tcpip.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//链接此动态链接库 windows特有 </span></span></span><br><span class="line">	<span class="comment">//连接动态库 此动态库里含有计时器类timer 和 cmd命令</span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;guguDll.lib&quot;</span>)</span></span><br><span class="line">	<span class="comment">//连接静态库 此静态库里含有一个内存池</span></span><br><span class="line">	<span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;guguAlloc.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span><span class="comment">//selcet</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span><span class="comment">//uni std</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SOCKET int</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> INVALID_SOCKET (SOCKET)(~0)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SOCKET_ERROR (-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//缓冲区大小 </span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> RECV_BUFFER_SIZE</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> RECV_BUFFER_SIZE 4096</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SEND_BUFFER_SIZE 40</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端类 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClientSocket</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造 </span></span><br><span class="line">	<span class="built_in">ClientSocket</span>(SOCKET sockfd = INVALID_SOCKET);</span><br><span class="line">	<span class="comment">//析构 </span></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">ClientSocket</span>();</span><br><span class="line">	<span class="comment">//获取socket </span></span><br><span class="line">	<span class="function">SOCKET <span class="title">GetSockfd</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//获取接收缓冲区 </span></span><br><span class="line">	<span class="function"><span class="type">char</span>* <span class="title">MsgBuf</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//获取接收缓冲区尾部变量 </span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetLen</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//设置缓冲区尾部变量</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetLen</span><span class="params">(<span class="type">int</span> len)</span></span>;</span><br><span class="line">	<span class="comment">//发送数据 </span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">SendData</span><span class="params">(DataHeader* head)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	SOCKET _sockfd;</span><br><span class="line">	<span class="comment">//缓冲区相关 </span></span><br><span class="line">	<span class="type">char</span>* _Msg_Recv_buf;<span class="comment">//消息缓冲区 </span></span><br><span class="line">	<span class="type">int</span> _Len_Recv_buf;<span class="comment">//缓冲区数据尾部变量</span></span><br><span class="line"></span><br><span class="line">	<span class="type">char</span>* _Msg_Send_buf;<span class="comment">//消息发送缓冲区 </span></span><br><span class="line">	<span class="type">int</span> _Len_Send_buf;<span class="comment">//发送缓冲区数据尾部变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="④子线程类任务处理-发送-部分"><a href="#④子线程类任务处理-发送-部分" class="headerlink" title="④子线程类任务处理(发送)部分"></a>④子线程类任务处理(发送)部分</h3><p><code>CellTask.h</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 子线程发送部分</span></span><br><span class="line"><span class="comment">* 本头文件中实现了任务执行的分离操作</span></span><br><span class="line"><span class="comment">* 通过list结构存储需要执行的任务</span></span><br><span class="line"><span class="comment">* start()启动线程进行任务处理</span></span><br><span class="line"><span class="comment">* 为防止出现冲突，所有临界操作均进行上锁，且首先使用缓冲区储存新任务</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* 2021/4/22</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _CELL_Task_hpp_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CELL_Task_hpp_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span><span class="comment">//mem_fn</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//任务基类接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CellTask</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//执行任务 </span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DoTask</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送线程类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CellTaskServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CellTaskServer</span>();</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">CellTaskServer</span>();</span><br><span class="line">	<span class="comment">//添加任务 </span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">addTask</span><span class="params">(CellTask* ptask)</span></span>;</span><br><span class="line">	<span class="comment">//启动服务</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">//工作函数 </span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">OnRun</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//任务数据 </span></span><br><span class="line">	std::list&lt;CellTask*&gt;_tasks;</span><br><span class="line">	<span class="comment">//任务数据缓冲区 </span></span><br><span class="line">	std::list&lt;CellTask*&gt;_tasksBuf;</span><br><span class="line">	<span class="comment">//锁 锁数据缓冲区 </span></span><br><span class="line">	std::mutex _mutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="⑤子线程类接收部分"><a href="#⑤子线程类接收部分" class="headerlink" title="⑤子线程类接收部分"></a>⑤子线程类接收部分</h3><p><code>CellServer.h</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 子线程接收部分</span></span><br><span class="line"><span class="comment">* 本文件中实现线程类以及DoTask接口</span></span><br><span class="line"><span class="comment">* 使服务端线程分离 主线程接收连接 其余子线程处理消息</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* 初步实现了发送任务的接口，使其调用客户端对象的SendData方法发送消息</span></span><br><span class="line"><span class="comment">* 目前采用的是select结构 未来可能尝试其他结构</span></span><br><span class="line"><span class="comment">* 2021/4/22</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _CELL_SERVER_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CELL_SERVER_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;INetEvent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;CellTask.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;ClientSocket.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//网络消息发送任务</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CellSendMsgTask</span> : <span class="keyword">public</span> CellTask</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CellSendMsgTask</span>(ClientSocket* pClient, DataHeader* pHead)</span><br><span class="line">	&#123;</span><br><span class="line">		_pClient = pClient;</span><br><span class="line">		_pHeader = pHead;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//执行任务</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DoTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		_pClient-&gt;<span class="built_in">SendData</span>(_pHeader);</span><br><span class="line">		<span class="keyword">delete</span> _pHeader;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	ClientSocket* _pClient;</span><br><span class="line">	DataHeader* _pHeader;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CellServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造 </span></span><br><span class="line">	<span class="built_in">CellServer</span>(SOCKET sock = INVALID_SOCKET);</span><br><span class="line">	<span class="comment">//析构</span></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">CellServer</span>();</span><br><span class="line">	<span class="comment">//处理事件 </span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setEventObj</span><span class="params">(INetEvent* event)</span></span>;</span><br><span class="line">	<span class="comment">//关闭socket </span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">CloseSocket</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//判断是否工作中 </span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">IsRun</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//查询是否有待处理消息 </span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">OnRun</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//接收数据</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">RecvData</span><span class="params">(ClientSocket* t_client)</span></span>;<span class="comment">//处理数据 </span></span><br><span class="line">	<span class="comment">//响应数据</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">NetMsg</span><span class="params">(DataHeader* pHead, ClientSocket* pClient)</span></span>;</span><br><span class="line">	<span class="comment">//增加客户端 </span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">addClient</span><span class="params">(ClientSocket* client)</span></span>;</span><br><span class="line">	<span class="comment">//启动线程</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//获取该线程内客户端数量</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetClientCount</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="comment">//添加任务</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">AddSendTask</span><span class="params">(ClientSocket* pClient, DataHeader* pHead)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//select优化</span></span><br><span class="line">	SOCKET _maxSock;<span class="comment">//最大socket值 </span></span><br><span class="line">	fd_set _fd_read_bak;<span class="comment">//读集合备份</span></span><br><span class="line">	<span class="type">bool</span> _client_change;<span class="comment">//客户端集合bool true表示发生改变 需重新统计 fd_read集合</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//缓冲区相关 </span></span><br><span class="line">	<span class="type">char</span>* _Recv_buf;<span class="comment">//接收缓冲区 </span></span><br><span class="line">	<span class="comment">//socket相关 </span></span><br><span class="line">	SOCKET _sock;</span><br><span class="line">	<span class="comment">//正式客户队列 </span></span><br><span class="line">	std::vector&lt;ClientSocket*&gt; _clients;<span class="comment">//储存客户端</span></span><br><span class="line">	<span class="comment">//客户缓冲区</span></span><br><span class="line">	std::vector&lt;ClientSocket*&gt; _clientsBuf;</span><br><span class="line">	std::mutex _mutex;<span class="comment">//锁</span></span><br><span class="line">	<span class="comment">//线程 </span></span><br><span class="line">	std::thread* _pThread;</span><br><span class="line">	<span class="comment">//退出事件接口 </span></span><br><span class="line">	INetEvent* _pNetEvent;</span><br><span class="line">	<span class="comment">//发送线程队列 </span></span><br><span class="line">	CellTaskServer _taskServer;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h1 id="三、内存池静态库-项目"><a href="#三、内存池静态库-项目" class="headerlink" title="三、内存池静态库 项目"></a>三、内存池静态库 项目</h1><h2 id="1-思路-1"><a href="#1-思路-1" class="headerlink" title="1. 思路"></a>1. 思路</h2><p>&emsp;&emsp;在服务端源码基本完成后，我开始为内存池的连接进行准备。我打算在VS2019上尝试动态库和静态库的生成与链接。内存池我打算首先用静态库来链接，在之后可能我会改为动态库链接。<br>&emsp;&emsp;在网上查阅资料后，我按如下步骤进行静态库生成与链接：</p>
<ol>
<li>更改该项目配置类型为静态库类型<br><img src="/images/2021-04-26/2.jpg" alt="图1"></li>
<li>关闭预编译头(我是关掉了，也可以把内存池放在预编译头中)<br><img src="/images/2021-04-26/3.jpg" alt="图2"></li>
<li>在解决方案属性中，使得应用程序项目(即服务端项目)依赖于内存池静态库项目。这样在编译服务端项目时，会自动编译更新静态库<br><img src="/images/2021-04-26/4.jpg" alt="图3"></li>
<li>在应用程序项目(即服务端项目)属性中，在链接器选项中的附加依赖项中，添加上lib静态库文件<br><img src="/images/2021-04-26/5.jpg" alt="图4"></li>
<li>由于两个项目(服务端和静态库)在同一个解决方案，所以可以不用用代码链接静态库(我个人实验得出结论，不一定对)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//连接静态库 此静态库里含有一个内存池 在该解决方案代码中不加也可以连接上</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;guguAlloc.lib&quot;</span>)</span></span><br></pre></td></tr></table></figure>
<img src="/images/2021-04-26/6.jpg" alt="图5"></li>
</ol>
<h2 id="2-头文件源码-1"><a href="#2-头文件源码-1" class="headerlink" title="2. 头文件源码"></a>2. 头文件源码</h2><h3 id="①重载new-delete部分"><a href="#①重载new-delete部分" class="headerlink" title="①重载new&#x2F;delete部分"></a>①重载new&#x2F;delete部分</h3><p><code>Alloctor.h</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 本文件中重载了new/delete操作</span></span><br><span class="line"><span class="comment">* 使new/delete调用内存池</span></span><br><span class="line"><span class="comment">* 2021/4/22</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _Alloctor_h_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _Alloctor_h_</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* p)</span></span>;</span><br><span class="line"><span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span> size);</span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span>* p);</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">mem_alloc</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mem_free</span><span class="params">(<span class="type">void</span>* p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="②内存池类部分"><a href="#②内存池类部分" class="headerlink" title="②内存池类部分"></a>②内存池类部分</h3><p><code>MemoryAlloc.h</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">内存池类</span></span><br><span class="line"><span class="comment">对内存块进行管理</span></span><br><span class="line"><span class="comment">2021/4/22</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _Memory_Alloc_h_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _Memory_Alloc_h_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//导入内存块头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;MemoryBlock.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemoryAlloc</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MemoryAlloc</span>();</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">MemoryAlloc</span>();</span><br><span class="line">	<span class="comment">//设置初始化</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setInit</span><span class="params">(<span class="type">size_t</span> nSize, <span class="type">size_t</span> nBlockSize)</span></span>;</span><br><span class="line">	<span class="comment">//初始化</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">initMemory</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//申请内存</span></span><br><span class="line">	<span class="function"><span class="type">void</span>* <span class="title">allocMem</span><span class="params">(<span class="type">size_t</span> nSize)</span></span>;</span><br><span class="line">	<span class="comment">//释放内存</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">freeMem</span><span class="params">(<span class="type">void</span>* p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">//内存池地址</span></span><br><span class="line">	<span class="type">char</span>* _pBuf;</span><br><span class="line">	<span class="comment">//头部内存单元</span></span><br><span class="line">	MemoryBlock* _pHeader;</span><br><span class="line">	<span class="comment">//内存块大小</span></span><br><span class="line">	<span class="type">size_t</span> _nSize;</span><br><span class="line">	<span class="comment">//内存块数量</span></span><br><span class="line">	<span class="type">size_t</span> _nBlockSize;</span><br><span class="line">	<span class="comment">//多线程锁</span></span><br><span class="line">	std::mutex _mutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="③内存块类部分"><a href="#③内存块类部分" class="headerlink" title="③内存块类部分"></a>③内存块类部分</h3><p><code>MemoryBlock.h</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">内存块类</span></span><br><span class="line"><span class="comment">内存管理的最小单位</span></span><br><span class="line"><span class="comment">2021/4/22</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _Memory_Block_h_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _Memory_Block_h_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明内存池类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemoryAlloc</span>;</span><br><span class="line"><span class="comment">//最底层导入内存头文件/断言头文件/锁头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="comment">//如果为debug模式则加入调试信息</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> xPrintf(...) printf(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> xPrintf(...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemoryBlock</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//内存块编号</span></span><br><span class="line">	<span class="type">int</span> _nID;</span><br><span class="line">	<span class="comment">//引用情况</span></span><br><span class="line">	<span class="type">int</span> _nRef;</span><br><span class="line">	<span class="comment">//所属内存池</span></span><br><span class="line">	MemoryAlloc* _pAlloc;</span><br><span class="line">	<span class="comment">//下一块位置</span></span><br><span class="line">	MemoryBlock* _pNext;</span><br><span class="line">	<span class="comment">//是否在内存池内</span></span><br><span class="line">	<span class="type">bool</span> _bPool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="④内存管理工具类"><a href="#④内存管理工具类" class="headerlink" title="④内存管理工具类"></a>④内存管理工具类</h3><p><code>MemoryMgr.h</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">内存管理工具类</span></span><br><span class="line"><span class="comment">对内存池进行管理</span></span><br><span class="line"><span class="comment">2021/4/22</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _Memory_Mgr_h_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _Memory_Mgr_h_</span></span><br><span class="line"><span class="comment">//内存池最大申请</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_MEMORY_SIZE 128</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//导入内存池模板类</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;MemoryAlloc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemoryMgr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//饿汉式单例模式</span></span><br><span class="line">	<span class="function"><span class="type">static</span> MemoryMgr* <span class="title">Instance</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//申请内存</span></span><br><span class="line">	<span class="function"><span class="type">void</span>* <span class="title">allocMem</span><span class="params">(<span class="type">size_t</span> nSize)</span></span>;</span><br><span class="line">	<span class="comment">//释放内存</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">freeMem</span><span class="params">(<span class="type">void</span>* p)</span></span>;</span><br><span class="line">	<span class="comment">//增加内存块引用次数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">addRef</span><span class="params">(<span class="type">void</span>* p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">MemoryMgr</span>();</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">MemoryMgr</span>();</span><br><span class="line">	<span class="comment">//内存映射初始化</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init_szAlloc</span><span class="params">(<span class="type">int</span> begin, <span class="type">int</span> end, MemoryAlloc* pMem)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//映射数组</span></span><br><span class="line">	MemoryAlloc* _szAlloc[MAX_MEMORY_SIZE + <span class="number">1</span>];</span><br><span class="line">	<span class="comment">//64字节内存池</span></span><br><span class="line">	MemoryAlloc _mem64;</span><br><span class="line">	<span class="comment">//128字节内存池</span></span><br><span class="line">	MemoryAlloc _mem128;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h1 id="四、计时-报文动态库-项目"><a href="#四、计时-报文动态库-项目" class="headerlink" title="四、计时&#x2F;报文动态库 项目"></a>四、计时&#x2F;报文动态库 项目</h1><h2 id="1-思路-2"><a href="#1-思路-2" class="headerlink" title="1. 思路"></a>1. 思路</h2><p>&emsp;&emsp;内存池静态库链接完成后，我开始准备新建动态库项目，存放<strong>自实现计时器类</strong>和<strong>报文命令类型</strong>。<br>&emsp;&emsp;在网上查阅资料后，我按如下步骤进行静态库生成与链接：</p>
<ol>
<li>新建动态库项目，配置类型为动态库<br><img src="/images/2021-04-26/7.jpg" alt="在这里插入图片描述"></li>
<li>此项目中，我使用了预编译头文件<br><img src="/images/2021-04-26/8.jpg" alt="加粗样式"></li>
<li>添加<strong>自实现计时器类</strong>和<strong>报文命令类型</strong>文件<br>（下图中<code>guguTimer.h/guguTimer.cpp</code>为计时器类声明&#x2F;定义、<code>CMD.h</code>为报文命令类型文件)<br><img src="/images/2021-04-26/9.jpg" alt="在这里插入图片描述"></li>
<li>添加库导出关键字<code>__declspec(dllexport)</code><br><img src="/images/2021-04-26/10.jpg" alt="在这里插入图片描述"></li>
<li>将计时类的成员变量改为全局变量，保证生命周期<br>(cpp文件需要<code>include&quot;pch.h&quot;</code>来保证预编译正常进行)<br><img src="/images/2021-04-26/11.jpg" alt="在这里插入图片描述"></li>
<li>编译动态库，得到<strong>dll</strong>文件和<strong>lib</strong>文件<br><img src="/images/2021-04-26/12.jpg" alt="在这里插入图片描述"></li>
<li>将<strong>dll文件</strong>、<strong>lib文件</strong>、动态库中所有的<strong>头文件</strong>复制到服务端项目的源码文件夹下<br>(如下图所示，复制的文件有:<code>guguDll.dll</code>、<code>guguDll.lib</code>、<code>pch.h</code>、<code>framework.h</code>、<code>guguTimer.h</code>、<code>CMD.h</code>)<br><img src="/images/2021-04-26/13.jpg" alt="在这里插入图片描述"></li>
<li>链接动态库、include预编译文件，此时动态库链接完成<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//连接动态库 此动态库里含有计时器类timer 和 cmd命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;guguDll.lib&quot;</span>)</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="2-头文件源码-2"><a href="#2-头文件源码-2" class="headerlink" title="2. 头文件源码"></a>2. 头文件源码</h2><h3 id="①pch-h"><a href="#①pch-h" class="headerlink" title="①pch.h"></a>①<code>pch.h</code></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pch.h: 这是预编译标头文件。</span></span><br><span class="line"><span class="comment">// 下方列出的文件仅编译一次，提高了将来生成的生成性能。</span></span><br><span class="line"><span class="comment">// 这还将影响 IntelliSense 性能，包括代码完成和许多代码浏览功能。</span></span><br><span class="line"><span class="comment">// 但是，如果此处列出的文件中的任何一个在生成之间有更新，它们全部都将被重新编译。</span></span><br><span class="line"><span class="comment">// 请勿在此处添加要频繁更新的文件，这将使得性能优势无效。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PCH_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCH_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加要在此处预编译的标头</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;framework.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;guguTimer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CMD.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//PCH_H</span></span></span><br></pre></td></tr></table></figure>

<h3 id="②framework"><a href="#②framework" class="headerlink" title="②framework"></a>②<code>framework</code></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once<span class="comment">//懒得改了(</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN             <span class="comment">// 从 Windows 头文件中排除极少使用的内容</span></span></span><br><span class="line"><span class="comment">// Windows 头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="③guguTimer-h"><a href="#③guguTimer-h" class="headerlink" title="③guguTimer.h"></a>③<code>guguTimer.h</code></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 计时器类</span></span><br><span class="line"><span class="comment">* 2021/4/23</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MY_TIMER_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_TIMER_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__declspec</span>(dllexport) mytimer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">mytimer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">mytimer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用update时，使起始时间等于当前时间</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">UpDate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用getsecond方法时，经过的时间为当前时间减去之前统计过的起始时间。</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">GetSecond</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="④CMD-h"><a href="#④CMD-h" class="headerlink" title="④CMD.h"></a>④<code>CMD.h</code></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 报文数据类型</span></span><br><span class="line"><span class="comment">* 2021/4/23</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _CMD_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CMD_H_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//枚举类型记录命令 </span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">cmd</span></span><br><span class="line">&#123;</span><br><span class="line">	CMD_LOGIN,<span class="comment">//登录 </span></span><br><span class="line">	CMD_LOGINRESULT,<span class="comment">//登录结果 </span></span><br><span class="line">	CMD_LOGOUT,<span class="comment">//登出 </span></span><br><span class="line">	CMD_LOGOUTRESULT,<span class="comment">//登出结果 </span></span><br><span class="line">	CMD_NEW_USER_JOIN,<span class="comment">//新用户登入 </span></span><br><span class="line">	CMD_ERROR<span class="comment">//错误 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义数据包头 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DataHeader</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">short</span> cmd;<span class="comment">//命令</span></span><br><span class="line">	<span class="type">short</span> date_length;<span class="comment">//数据的长短	</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包1 登录 传输账号与密码</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Login</span> : <span class="keyword">public</span> DataHeader</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Login</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGIN;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Login);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">	<span class="type">char</span> PassWord[<span class="number">32</span>];<span class="comment">//密码 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包2 登录结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoginResult</span> : <span class="keyword">public</span> DataHeader</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LoginResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGINRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LoginResult);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包3 登出 传输用户名 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Logout</span> : <span class="keyword">public</span> DataHeader</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Logout</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Logout);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包4 登出结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LogoutResult</span> : <span class="keyword">public</span> DataHeader</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LogoutResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUTRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LogoutResult);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包5 新用户登入 传输通告 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NewUserJoin</span> : <span class="keyword">public</span> DataHeader</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">NewUserJoin</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_NEW_USER_JOIN;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(NewUserJoin);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h1 id="五、项目完整源码-github"><a href="#五、项目完整源码-github" class="headerlink" title="五、项目完整源码(github)"></a>五、项目完整源码(github)</h1><p><a href="https://github.com/zgg2001/TcpServer">github链接</a><br>如下图：guguServer为服务端程序、guguAlloc为内存池静态库、guguDll为动态库<br><img src="/images/2021-04-26/14.jpg" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习记录：总结与扩展</title>
    <url>/2021/03/29/20210329_Redis%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E6%80%BB%E7%BB%93%E4%B8%8E%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<p>&emsp;&emsp;本文将个人在Redis数据库学习中记录的知识点进行了总结，方便日后的复习以及对明年春招实习的准备。</p>
<span id="more"></span>

<h1 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Redis是什么：</span><br><span class="line">	Redis是一种NoSql，即<span class="keyword">Not</span><span class="operator">-</span><span class="keyword">Only</span><span class="operator">-</span><span class="keyword">Sql</span>。是一种&quot;高性能键值对数据库&quot;，是对常规数据库的一种补充。</span><br><span class="line"></span><br><span class="line">Redis的存在需求：</span><br><span class="line">	当一些数据需要被频繁操作时，不断的从常规<span class="keyword">sql</span>中读取<span class="operator">/</span>更改数据会大大提高磁盘IO次数，消耗大量时间。</span><br><span class="line">	此时就需要一个中间件对热点数据进行储存与操作，从而提高操作效率。</span><br><span class="line"></span><br><span class="line">Redis的思路：</span><br><span class="line">	通过<span class="string">&#x27;在内存进行储存&#x27;</span>的思路，降低磁盘的IO次数。</span><br><span class="line">	通过<span class="string">&#x27;不储存关系，仅储存数据&#x27;</span>的思路，去除数据间的关系，从而减少内存消耗。</span><br><span class="line"></span><br><span class="line">Redis的优点：</span><br><span class="line">	<span class="number">1.</span>可扩容，可伸缩</span><br><span class="line">	<span class="number">2.</span>大数据下高性能</span><br><span class="line">	<span class="number">3.</span>灵活的数据类型</span><br><span class="line">	<span class="number">4.</span>高可用</span><br><span class="line"></span><br><span class="line">Redis的速度快的原因：</span><br><span class="line">	<span class="number">1.</span>内存操作</span><br><span class="line">	<span class="number">2.</span>IO多路复用机制，减少了阻塞</span><br><span class="line">	<span class="number">3.</span>单线程避免了线程切换的开销和竞争问题</span><br><span class="line">	<span class="number">4.</span>C语言编写，与操作系统交互，命令执行快</span><br><span class="line"></span><br><span class="line">Redis的使用场景：</span><br><span class="line">	<span class="number">1.</span>对热点数据进行储存，提高热点数据的操作效率。</span><br><span class="line">	<span class="number">2.</span>排行榜等实时变化性强的数据存储。</span><br><span class="line">	<span class="number">3.</span>具有时效性的数据存储，方便删除与更新。</span><br><span class="line">	<span class="number">4.</span>...	</span><br><span class="line">	总之，我认为Redis相当于一个缓存区，对于操作频率高的数据可以放在该缓存区里，方便客户端进行操作。</span><br></pre></td></tr></table></figure>

<h1 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h1><h2 id="1-基础数据类型"><a href="#1-基础数据类型" class="headerlink" title="1. 基础数据类型"></a>1. 基础数据类型</h2><h3 id="①-string"><a href="#①-string" class="headerlink" title="① string"></a>① string</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">string类型 最大纯数值范围为long long <span class="number">512</span>M </span><br><span class="line"><span class="string">&#x27;讲究整体性，更新少时用&#x27;</span></span><br><span class="line"></span><br><span class="line">基础操作:</span><br><span class="line">· <span class="keyword">set</span> key <span class="keyword">value</span>							添加修改键值对</span><br><span class="line">· <span class="keyword">get</span> key								根据键 获取值</span><br><span class="line">· del key								根据键 删除键值对</span><br><span class="line">· strlen key							根据键 获取值字符个数</span><br><span class="line">· append key <span class="keyword">value</span>						追加内容到原始信息尾部，不存在则新建</span><br><span class="line"></span><br><span class="line">· mset key1 value1 key2 value2...		添加<span class="operator">/</span>修改多个键值对</span><br><span class="line">· mget key1 key2...						根据键 获取多个值</span><br><span class="line"></span><br><span class="line">设置数值增加指定的值: #实现按次案例 加一个负数即为减</span><br><span class="line">· incr key								</span><br><span class="line">· incrby key increment</span><br><span class="line">· incrbyfloat key increment</span><br><span class="line"></span><br><span class="line">设置数值减少指定的值:</span><br><span class="line">· decr key</span><br><span class="line">· decrby key increment</span><br><span class="line"></span><br><span class="line">设置数值具有指定的生命周期: #实现按时案例</span><br><span class="line">· setex key seconds <span class="keyword">value</span></span><br><span class="line">· psetex key milliseconds <span class="keyword">value</span></span><br></pre></td></tr></table></figure>
<h3 id="②-hash"><a href="#②-hash" class="headerlink" title="② hash"></a>② hash</h3><p><img src="/images/2021-03-29/1.jpg" alt="hash"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">hash类型 </span><br><span class="line"><span class="string">&#x27;一个空间保存多个键值对数据&#x27;</span></span><br><span class="line"></span><br><span class="line">基础操作:</span><br><span class="line">· hset key field <span class="keyword">value</span>							添加<span class="operator">/</span>修改 键<span class="operator">/</span>字段<span class="operator">/</span>值</span><br><span class="line">· hget key field								获取值</span><br><span class="line">· hgetall key									获取全部值</span><br><span class="line">· hdel key field1...							删除</span><br><span class="line"></span><br><span class="line">· hmset key field1 value1 field2 value2...		多个添加<span class="operator">/</span>修改 键<span class="operator">/</span>字段<span class="operator">/</span>值</span><br><span class="line">· hmget key field1 field2...					获取多个值</span><br><span class="line">· hexists key field								获取表中是否存在指定字段</span><br><span class="line">· hlen key										获取字段数量</span><br><span class="line"></span><br><span class="line">· hkeys key										查看所有字段名</span><br><span class="line">· hvals key										查看所有字段值</span><br><span class="line"></span><br><span class="line">· hsetnx key field <span class="keyword">value</span>						添加 键<span class="operator">/</span>字段<span class="operator">/</span>值，有就不改，无则添加</span><br><span class="line"></span><br><span class="line">设置数值增加指定的值: #实现按次案例 加一个负数即为减							</span><br><span class="line">· hincrby key field increment</span><br><span class="line">· hincrbyfloat key field increment</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line"><span class="number">1.</span><span class="keyword">value</span>只能是字符串<span class="operator">/</span>数值，不能嵌套数据结构。</span><br><span class="line"><span class="number">2.</span>每个hash最多 <span class="number">2</span><span class="operator">^</span><span class="number">32</span><span class="number">-1</span> 个键值对</span><br><span class="line"><span class="number">3.</span>不可滥用，不可以全面作为对象列表使用</span><br><span class="line"><span class="number">4.</span><span class="string">&#x27;hgetall&#x27;</span>在field很多时，效率低，存在瓶颈</span><br><span class="line"><span class="number">5.</span>hash更新方便</span><br></pre></td></tr></table></figure>
<h3 id="③-list"><a href="#③-list" class="headerlink" title="③ list"></a>③ list</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">list类型 底层为双向链表 实现消息队列</span><br><span class="line"><span class="string">&#x27;一个空间储存多个数据，且体现顺序&#x27;</span></span><br><span class="line"></span><br><span class="line">· lpush key value1 value2...			从左 添加<span class="operator">/</span>修改数据</span><br><span class="line">· rpush key value1 value2...			从右 添加<span class="operator">/</span>修改数据</span><br><span class="line"></span><br><span class="line">· lrange key <span class="keyword">start</span> stop					取<span class="keyword">start</span>到stop的数据 #下标从<span class="number">0</span>开始 <span class="number">-1</span>为倒数第一个数据</span><br><span class="line">· lindex key index						依据index索引取数据</span><br><span class="line">· llen key								获取长度</span><br><span class="line"></span><br><span class="line">· lpop key								从左 获取并移除数据 #类似java的pop</span><br><span class="line">· rpop key								从右 获取并移除数据</span><br><span class="line"></span><br><span class="line"># <span class="type">time</span>单位为秒 当list内为空时，不会立刻返回，直到时间归零返回空，或者有人入队返回数据</span><br><span class="line">· blpop key... <span class="type">time</span>						从左 在规定的时间内获取并移除数据 </span><br><span class="line">· brpop key... <span class="type">time</span>						从右 在规定的时间内获取并移除数据 </span><br><span class="line"></span><br><span class="line">· lrem key count <span class="keyword">value</span>					移除指定数据 #count为移除数量，<span class="keyword">value</span>为要移除的值</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line"><span class="number">1.</span>每个list最多 <span class="number">2</span><span class="operator">^</span><span class="number">32</span><span class="number">-1</span> 个元素</span><br><span class="line"><span class="number">2.</span>可以实现栈<span class="operator">/</span>队列</span><br><span class="line"><span class="number">3.</span><span class="string">&#x27;-1&#x27;</span>表示的是倒数第一</span><br><span class="line"><span class="number">4.</span>可以分页 #<span class="string">&#x27;lrange&#x27;</span>取指定个数据</span><br></pre></td></tr></table></figure>
<h3 id="④-set"><a href="#④-set" class="headerlink" title="④ set"></a>④ set</h3><p><img src="/images/2021-03-29/2.jpg" alt="set"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>类型 hash结构 hash中field储存值 hash中<span class="keyword">value</span>为空</span><br><span class="line"><span class="string">&#x27;储存大量数据，查询效率高&#x27;</span></span><br><span class="line"></span><br><span class="line">基础操作:</span><br><span class="line">· sadd key member1 member2...					添加<span class="operator">/</span>修改 键<span class="operator">/</span>值</span><br><span class="line">· smembers key									获取全部数据</span><br><span class="line">· srem key member1 member2...					删除数据</span><br><span class="line">· scard key										获取集合数据总量</span><br><span class="line">· sismember key <span class="keyword">member</span>							判断集合中是否包含指定数据</span><br><span class="line"></span><br><span class="line"># 可以实现随机推荐</span><br><span class="line">· srandmember key [count]						随机获取集合中指定数量的数据</span><br><span class="line">· spop key [count]								随机获取集合中指定数量的数据，并将其移出集合</span><br><span class="line"></span><br><span class="line"># 可以实现相关推送、共同好友等</span><br><span class="line">求集合的交、并、差集:</span><br><span class="line">· sinter key1 [key2]</span><br><span class="line">· sunion key1 [key2]</span><br><span class="line">· sdiff key1 [key2]</span><br><span class="line"></span><br><span class="line"># 数据合并</span><br><span class="line">求集合的交、并、差集并储存到指定的集合中:</span><br><span class="line">· sinterstore destination key1 [key2]</span><br><span class="line">· sunionstore destination key1 [key2]</span><br><span class="line">· sdiffstore destination key1 [key2]</span><br><span class="line"></span><br><span class="line"># 数据合并</span><br><span class="line">将指定数据从原始集合中移动到目标集合中:</span><br><span class="line">smove source destination <span class="keyword">member</span></span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line"><span class="number">1.</span>不会重复</span><br><span class="line"><span class="number">2.</span>与hash的储存空间相同，但是无法启用hash中储存值的空间 #全为空</span><br><span class="line"><span class="number">3.</span>去重可以实现记录访问数据</span><br><span class="line"><span class="number">4.</span>由上可以实现黑<span class="operator">/</span>白名单 #ID<span class="operator">/</span>IP<span class="operator">/</span>设备</span><br></pre></td></tr></table></figure>
<h3 id="⑤-sorted-set"><a href="#⑤-sorted-set" class="headerlink" title="⑤ sorted_set"></a>⑤ sorted_set</h3><p><img src="/images/2021-03-29/3.jpg" alt="sorted_set"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sorted_set类型 在<span class="keyword">set</span>的基础上增加了score模块 可以根据score进行排序</span><br><span class="line"><span class="string">&#x27;可排序的set&#x27;</span></span><br><span class="line"></span><br><span class="line">基础操作:</span><br><span class="line">· zadd key score1 member1 score2 member2...					添加<span class="operator">/</span>修改 键<span class="operator">/</span>值<span class="operator">/</span>分</span><br><span class="line">· zrem key member1 member2...								删除数据</span><br><span class="line"></span><br><span class="line">依据排名获取全部数据: #withscores为值带分</span><br><span class="line">· zrange key <span class="keyword">start</span> stop [withscores] 						小到大					</span><br><span class="line">· zrevrange key <span class="keyword">start</span> stop [withscores] 					大到小</span><br><span class="line"></span><br><span class="line">依据分数获取全部数据: #withscores为值带分</span><br><span class="line">· zrangebyscore key min max [withscores] 					小到大					</span><br><span class="line">· zrevrangebyscore key max min [withscores] 				大到小</span><br><span class="line"></span><br><span class="line">按条件删除数据:</span><br><span class="line">· zremrangebyrank key <span class="keyword">start</span> stop							按从大到小的排名</span><br><span class="line">· zremrangebyscore key min max								按分数</span><br><span class="line"></span><br><span class="line">获取集合数据数量:</span><br><span class="line">· zcard key</span><br><span class="line">· zcount key min max</span><br><span class="line"></span><br><span class="line"># 数据合并</span><br><span class="line">求集合的交、并集并储存到指定的集合中:</span><br><span class="line">· zinterstore destination numkeys key1 [key2] #后续参数为score最终结果:求和<span class="operator">/</span>最大<span class="operator">/</span>最小</span><br><span class="line">· zunionstore destination numkeys key1 [key2]</span><br><span class="line"></span><br><span class="line">获取数据对应的索引排名 #下标<span class="number">0</span>开始</span><br><span class="line">· zrank key <span class="keyword">member</span></span><br><span class="line">· zrevrank key <span class="keyword">member</span></span><br><span class="line"></span><br><span class="line">score值获取与修改:</span><br><span class="line">· zscore key <span class="keyword">member</span></span><br><span class="line">· zincrby key increment <span class="keyword">member</span> #increment为加值</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line"><span class="number">1.</span>有<span class="keyword">set</span>的特性，反复添加会覆盖</span><br><span class="line"><span class="number">2.</span>long long为范围，<span class="number">64</span>位，小数则为<span class="keyword">double</span>，可能丢失精度</span><br><span class="line"><span class="number">3.</span>可以实现：时间队列、优先队列、VIP、权重</span><br></pre></td></tr></table></figure>
<h2 id="2-高级数据类型"><a href="#2-高级数据类型" class="headerlink" title="2. 高级数据类型"></a>2. 高级数据类型</h2><h3 id="①-Bitmaps"><a href="#①-Bitmaps" class="headerlink" title="① Bitmaps"></a>① Bitmaps</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Bitmaps类型 </span><br><span class="line"><span class="string">&#x27;状态统计&#x27;</span></span><br><span class="line"></span><br><span class="line">· getbit key <span class="keyword">offset</span>								获取指定key对应偏移量上的bit值</span><br><span class="line">· setbit key <span class="keyword">offset</span> <span class="keyword">value</span>						设置指定key对应偏移量上的bit值 #只能是<span class="number">0</span>或<span class="number">1</span></span><br><span class="line"></span><br><span class="line">· bitop op destkey key1 key2...					进行<span class="string">&#x27;操作&#x27;</span>结果保存到destkey</span><br><span class="line">  op: <span class="keyword">and</span>交 <span class="keyword">or</span>并 <span class="keyword">not</span>非 xor异或</span><br><span class="line"></span><br><span class="line"># 一个字节有八个bit 后面的<span class="keyword">start</span>和<span class="keyword">end</span>是字节</span><br><span class="line">· bitcount key [<span class="keyword">start</span> <span class="keyword">end</span>]						统计指定key中<span class="number">1</span>的数量</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line"><span class="number">1.</span>可以进行单日数据的统计 例如某电影今日是否被点播</span><br><span class="line"><span class="number">2.</span>可以进行并操作来对多日数据进行合并等等</span><br><span class="line"><span class="number">3.</span>可以通过统计<span class="number">1</span>的数量来实现类似<span class="string">&#x27;统计今日电影被点播种数&#x27;</span>的功能</span><br></pre></td></tr></table></figure>
<h3 id="②-HyperLogLog"><a href="#②-HyperLogLog" class="headerlink" title="② HyperLogLog"></a>② HyperLogLog</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">HyperLogLog类型 底层为loglog算法 统计独立的元素个数</span><br><span class="line"><span class="string">&#x27;基数统计&#x27;</span></span><br><span class="line"></span><br><span class="line">· pfadd key element1 element2...				添加数据</span><br><span class="line">· pfcount key1 key2...							统计数据</span><br><span class="line">· pfmerge destkey sourcekey1 sourcekey2...		合并数据</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line"><span class="number">1.</span>HyperLogLog只进行基数统计，不记录具体数据</span><br><span class="line"><span class="number">2.</span>核心是基数统计算法，存在一定误差，大概是百分之<span class="number">0.81</span> #该算法中存储的都是近似值 所以有误差</span><br><span class="line"><span class="number">3.</span>该数据类型消耗内存最大为<span class="number">12</span>K，相比<span class="keyword">set</span>上M的内存消耗很小</span><br><span class="line"><span class="number">4.</span>HyperLogLog数据不断累积最大为<span class="number">12</span>K，合并数据后结果消耗直接为最大的<span class="number">12</span>K</span><br></pre></td></tr></table></figure>
<h3 id="③-GEO"><a href="#③-GEO" class="headerlink" title="③ GEO"></a>③ GEO</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">GEO类型</span><br><span class="line"><span class="string">&#x27;地理信息&#x27;</span></span><br><span class="line"></span><br><span class="line">· geoadd key logitude latitude <span class="keyword">member</span> [logitude latitude <span class="keyword">member</span>]		添加坐标点</span><br><span class="line">· geopos key <span class="keyword">member</span> [<span class="keyword">member</span>]											获取坐标点</span><br><span class="line">· geodist key member1 member2 [unit]									计算距离 默认为m [unit]参数是m<span class="operator">/</span>km</span><br><span class="line"></span><br><span class="line">根据坐标求范围内的数据:</span><br><span class="line">· georadius key longitude latitude radius m<span class="operator">|</span>km<span class="operator">|</span>ft<span class="operator">|</span>mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count]</span><br><span class="line"></span><br><span class="line">根据点求范围内的数据:</span><br><span class="line">· georadiusbymember key <span class="keyword">member</span> radius m<span class="operator">|</span>km<span class="operator">|</span>ft<span class="operator">|</span>mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count]</span><br><span class="line"></span><br><span class="line">获取指定点对应的坐标hash值:</span><br><span class="line">· geohash key <span class="keyword">member</span> [<span class="keyword">member</span> ...]</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line"><span class="number">1.</span>基本都是估算，存在误差，但是不追求高精度也够用</span><br><span class="line"><span class="number">2.</span>可以实现<span class="string">&#x27;附近的人&#x27;</span>之类的功能</span><br></pre></td></tr></table></figure>
<h1 id="三、通用指令"><a href="#三、通用指令" class="headerlink" title="三、通用指令"></a>三、通用指令</h1><h2 id="1-key操作"><a href="#1-key操作" class="headerlink" title="1. key操作"></a>1. key操作</h2><p>基本操作:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">· del key				删除指定的key</span><br><span class="line">· <span class="keyword">exists</span> key			获取key是否存在</span><br><span class="line">· type key 				获取key的类型</span><br></pre></td></tr></table></figure>
<p>时效性控制:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">为指定的key设置有效期: #前两个是秒<span class="operator">/</span>毫秒 后两个是时间戳</span><br><span class="line">· expire key seconds</span><br><span class="line">· pexpire key milliseconds</span><br><span class="line">· expireat key <span class="type">timestamp</span></span><br><span class="line">· pexpireat key milliseconds<span class="operator">-</span><span class="type">timestamp</span></span><br><span class="line"></span><br><span class="line">获取key的有效时间: #剩余秒<span class="operator">/</span>毫秒 xx为时效 <span class="number">-1</span>为永久 <span class="number">-2</span>为失效</span><br><span class="line">· ttl key</span><br><span class="line">· pttl key</span><br><span class="line"></span><br><span class="line">切换key从时效性至永久</span><br><span class="line">· persist key</span><br></pre></td></tr></table></figure>
<p>查询模式:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">keys <span class="keyword">pattern</span>			查询key</span><br><span class="line"><span class="keyword">pattern</span>: <span class="operator">*</span>为所有 ?为匹配一个任意符号 []为匹配一个指定符号 </span><br><span class="line">eg: keys u[st]er:<span class="number">1</span>  匹配一个以u开头，以er:<span class="number">1</span>结尾，中间包含一个字母s<span class="operator">/</span>t的key</span><br></pre></td></tr></table></figure>
<p>其他操作:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">为key改名:</span><br><span class="line">· rename key newkey #会覆盖</span><br><span class="line">· renamenx key newkey #不会覆盖</span><br><span class="line"></span><br><span class="line">对所有key排序:</span><br><span class="line">· sort key #支持<span class="keyword">set</span> list zset 只排序结果 不动原表</span><br><span class="line"></span><br><span class="line">其他:</span><br><span class="line">· help <span class="variable">@generio</span></span><br></pre></td></tr></table></figure>
<h2 id="2-数据库操作"><a href="#2-数据库操作" class="headerlink" title="2. 数据库操作"></a>2. 数据库操作</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">切换数据库: #默认<span class="number">0</span> <span class="number">0</span><span class="number">-15</span> 共<span class="number">16</span>个 可以从配置文件里改总数</span><br><span class="line">· <span class="keyword">select</span> index</span><br><span class="line"></span><br><span class="line">· quit				退出</span><br><span class="line">· ping				测联通</span><br><span class="line">· echo message		控制台日志</span><br><span class="line"></span><br><span class="line">· move key db		数据移动</span><br><span class="line"></span><br><span class="line">· dbsize			获取当前库中key的数量</span><br><span class="line">· flushdb			删当前库</span><br><span class="line">· flushall			删全部</span><br></pre></td></tr></table></figure>
<h1 id="四、Linux下Redis的配置相关"><a href="#四、Linux下Redis的配置相关" class="headerlink" title="四、Linux下Redis的配置相关"></a>四、Linux下Redis的配置相关</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">打开服务端:		· redis<span class="operator">-</span>server [<span class="comment">--port 6379] 			</span></span><br><span class="line">打开客户端:		· redis<span class="operator">-</span>cli [<span class="operator">-</span>h ip] [<span class="operator">-</span>p host]</span><br><span class="line"></span><br><span class="line">按配置文件打开服务端:</span><br><span class="line">· redis<span class="operator">-</span>server redis<span class="number">-6379.</span>conf</span><br><span class="line"></span><br><span class="line">配置文件基础:</span><br><span class="line">· port 端口					设置当前服务启动端口</span><br><span class="line">· daemonize yes<span class="operator">|</span><span class="keyword">no</span>			若yes则以守护进程方式启动，日志不再打印到命令窗口</span><br><span class="line">· logfile &quot;xxx.log&quot;			设置日志文件名，便于查阅</span><br><span class="line">· dir &quot;/.../redis/data&quot;		设置当前服务文件保存位置 [日志<span class="operator">/</span>持久化等]</span><br><span class="line">· bind <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>			设置本机地址</span><br><span class="line">· databases <span class="number">16</span>				设置库数量</span><br><span class="line">· maxclients <span class="number">0</span>				设置最大连接数</span><br><span class="line">· timeout <span class="number">300</span>				设置客户端限制最大时长 #<span class="number">0</span>为关</span><br><span class="line">· loglevel debug<span class="operator">|</span>verbase<span class="operator">|</span>notice<span class="operator">|</span>warning		设置日志级别 #默认是verbase 线上一般用notice简化日志</span><br><span class="line">· include <span class="operator">/</span>path<span class="operator">/</span>server<span class="operator">-</span>host.conf			导入<span class="operator">/</span>加载指定conf 便于维护</span><br><span class="line"></span><br><span class="line">注:</span><br><span class="line"><span class="number">1.</span>使用<span class="string">&#x27;ps -ef | grep redis-&#x27;</span>命令即可筛选出redis相关进程</span><br><span class="line"><span class="number">2.</span>当以守护进程方式启动时，日志不再显示，可以通过上述ps命令找到进程，使用<span class="string">&#x27;kill -s 9 进程ID&#x27;</span>关闭服务端</span><br></pre></td></tr></table></figure>
<h1 id="五、持久化"><a href="#五、持久化" class="headerlink" title="五、持久化"></a>五、持久化</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">持久化主要分为两种: RDB与AOF</span><br><span class="line">其中AOF是相对主流的持久化方案</span><br></pre></td></tr></table></figure>
<h2 id="1-RDB-快照"><a href="#1-RDB-快照" class="headerlink" title="1. RDB - 快照"></a>1. RDB - 快照</h2><p>相关:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">首先，RDB的原理是生成一张当前redis的状态的快照(二进制压缩文件)。</span><br><span class="line">恢复则是根据该快照进行全面的恢复。</span><br><span class="line">快照的占用空间较少(因为进行了压缩)，存取的速度相对较慢(全部保存)，但恢复速度快(整体恢复)。</span><br><span class="line"></span><br><span class="line">rdb保存分为两种: save 和 bgsave</span><br><span class="line">· save是直接保存，当保存数据较多时，由于是单线程，会阻塞进程。</span><br><span class="line">同步<span class="operator">/</span>阻塞<span class="operator">/</span>无额外内存<span class="operator">/</span>不启动新进程</span><br><span class="line">· bgsave是后台保存，执行该命令后，redis新建子进程进行save保存，不会阻塞进程。但是CPU消耗会相对增大。</span><br><span class="line">异步<span class="operator">/</span>不阻塞<span class="operator">/</span>有额外内存<span class="operator">/</span>启动新进程</span><br></pre></td></tr></table></figure>
<p>配置文件相关:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">· dbfilename dump<span class="number">-6379.</span>rdb			设置本地数据库rdb名</span><br><span class="line">· dir &quot;/.../redis/data&quot;				设置当前服务文件保存位置 [日志<span class="operator">/</span>持久化等]</span><br><span class="line">· rdbcompression yes<span class="operator">|</span><span class="keyword">no</span>				储存本地库时是否压缩(LZF压缩) #通常开启 否则节省CPU运行时间 但是数据文件增大</span><br><span class="line">· rdbchecksum yes<span class="operator">|</span><span class="keyword">no</span>				设置是否进行RDB文件格式校验(读<span class="operator">/</span>写时) #通常开启 否则节省约<span class="number">10</span><span class="operator">%</span>时间 但可能损坏数据</span><br><span class="line"></span><br><span class="line">· stop<span class="operator">-</span>writes<span class="operator">-</span><span class="keyword">on</span><span class="operator">-</span>bgsave<span class="operator">-</span>error yes<span class="operator">|</span><span class="keyword">no</span>	若bgsave出现错误，是否停止写入 #默认开启 		</span><br><span class="line">如果为yes，redis会创建一个新的后台进程dump rdb。</span><br><span class="line">假设创建快照需要<span class="number">20</span>s时间，redis主进程在这<span class="number">20</span>s内则会继续接受客户端命令。</span><br><span class="line">若在这<span class="number">20</span>s内创建快照出错，那么redis会拒绝新的写入。</span><br><span class="line"></span><br><span class="line"># 满足在指定时间 <span class="keyword">second</span> 中改变 changes 个 key 即会执行 bgsave</span><br><span class="line">· save <span class="keyword">second</span> changes				自动save #执行的是bgsave 根据业务量进行设置</span><br><span class="line">在执行命令返回结果后，系统会对该命令进行判定，服务器成功执行一个数据库修改命令，则计数器<span class="operator">+</span><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>相关命令:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">· save 					手动执行一次保存操作</span><br><span class="line">· bgsave				手动执行一次后台保存操作</span><br><span class="line"></span><br><span class="line">· debug reload			重启服务端并执行rdb</span><br><span class="line">· shutdown save			关机并执行rdb</span><br></pre></td></tr></table></figure>
<p>bgsave流程:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>bgsave指令</span><br><span class="line"><span class="number">2.</span>发送指令至服务器</span><br><span class="line"><span class="number">3.</span>服务器调用fork函数生成子进程，并返回<span class="string">&#x27;Background saving started&#x27;</span></span><br><span class="line"><span class="number">4.</span>成功创建rdb文件后，返回成功消息至log日志文件</span><br></pre></td></tr></table></figure>
<p>RDB优缺点:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">优点:</span><br><span class="line"><span class="number">1.</span>效率高 使用压缩二进制保存</span><br><span class="line"><span class="number">2.</span>使用快照 进行全量复制</span><br><span class="line"><span class="number">3.</span>恢复快</span><br><span class="line"></span><br><span class="line">缺点:</span><br><span class="line"><span class="number">1.</span>无法实时持久化 两次快照之间必定存在时间</span><br><span class="line"><span class="number">2.</span>牺牲了性能 快照时消耗较大</span><br><span class="line"><span class="number">3.</span>不同redis版本可能对rdb文件不兼容</span><br></pre></td></tr></table></figure>
<h2 id="2-AOF-日志"><a href="#2-AOF-日志" class="headerlink" title="2. AOF - 日志"></a>2. AOF - 日志</h2><p>相关:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">AOF为记录数据产生的工程，即日志。</span><br><span class="line">主要注重<span class="string">&#x27;实时性&#x27;</span>。</span><br><span class="line"></span><br><span class="line">AOF有三种日志策略</span><br><span class="line">· always(每次)				零误差，性能低</span><br><span class="line">· everysec(每秒<span class="operator">/</span>默认)		准确性较高，性能较高，宕机丢失一秒数据 #每秒操作先存在aof缓存区中</span><br><span class="line">· <span class="keyword">no</span>(系统控制)				整体不可控，操作系统控制周期</span><br></pre></td></tr></table></figure>
<p>配置文件相关:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">· appendonly yes<span class="operator">|</span><span class="keyword">no</span>						是否开启aof #默认<span class="keyword">no</span></span><br><span class="line">· appendfsync always<span class="operator">|</span>everysec<span class="operator">|</span><span class="keyword">no</span>		选择策略</span><br><span class="line">· appendfilename appendonly<span class="number">-6379.</span>aof	设置本地数据库aof名</span><br><span class="line">· dir &quot;/.../redis/data&quot;					设置当前服务文件保存位置 [日志<span class="operator">/</span>持久化等]</span><br><span class="line"></span><br><span class="line">· auto<span class="operator">-</span>aof<span class="operator">-</span>rewrite<span class="operator">-</span>min<span class="operator">-</span>size size			最小尺寸</span><br><span class="line">· auto<span class="operator">-</span>aof<span class="operator">-</span>rewrite<span class="operator">-</span>percentage percentage 	百分比</span><br><span class="line">自动参数: #info查看</span><br><span class="line">aof_current_size	当前大小</span><br><span class="line">aof_base_size		</span><br><span class="line">条件: #满足则系统更新</span><br><span class="line"><span class="number">1.</span>aof_current_size <span class="operator">&gt;</span> auto<span class="operator">-</span>aof<span class="operator">-</span>rewrite<span class="operator">-</span>min<span class="operator">-</span>size</span><br><span class="line"><span class="number">2.</span>(aof_current_size <span class="operator">-</span> aof_base_size) <span class="operator">/</span> aof_base_size <span class="operator">&gt;=</span> auto<span class="operator">-</span>aof<span class="operator">-</span>rewrite<span class="operator">-</span>percentage percentage</span><br></pre></td></tr></table></figure>
<p>AOF重写机制:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">日志中大量重复命令存在会大大增加资源消耗，此时可以进行数据重写。</span><br><span class="line"></span><br><span class="line">按照以下规律:</span><br><span class="line"><span class="number">1.</span>已超时数据不再写入文件</span><br><span class="line"><span class="number">2.</span>忽略无效命令 重写时使用进程内的数据生成 这样新的AOF文件只保存最终写入命令</span><br><span class="line"><span class="number">3.</span>对同一数据的多条命令合并为一条命令</span><br><span class="line">注:在aof缓存区后，有aof重写缓存区提供数据</span><br><span class="line"></span><br><span class="line">好处:</span><br><span class="line"><span class="number">1.</span>降低占用空间 利用率up</span><br><span class="line"><span class="number">2.</span>提高效率 降低时间 提高IO性能</span><br><span class="line"><span class="number">3.</span>恢复时间减少 提高恢复效率</span><br></pre></td></tr></table></figure>
<p>相关命令:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">· bgrewriteaof			手动重写 #和 bgsave 机制差不多</span><br></pre></td></tr></table></figure>
<p>AOF流程:<br><img src="/images/2021-03-29/4.jpg" alt="流程"><br>AOF与RDB对比:</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>RDB</th>
<th>AOF</th>
</tr>
</thead>
<tbody><tr>
<td>占用空间</td>
<td>小(压缩)</td>
<td>大(重写)</td>
</tr>
<tr>
<td>存储速度</td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td>恢复速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>安全性</td>
<td>会丢失数据</td>
<td>依据策略不同</td>
</tr>
<tr>
<td>资源消耗</td>
<td>高&#x2F;重量级</td>
<td>低&#x2F;轻量级</td>
</tr>
<tr>
<td>启动优先</td>
<td>优先级低</td>
<td>优先级高</td>
</tr>
<tr>
<td>选择</td>
<td>呈现阶段有效性(如回档)</td>
<td>数据敏感</td>
</tr>
<tr>
<td>注:</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1.灾难恢复一般选择RDB</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2.可以进行双保险备份</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="六、事务"><a href="#六、事务" class="headerlink" title="六、事务"></a>六、事务</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;一个队列中，一次性，顺序性，排他性的执行一系列命令&#x27;</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/2021-03-29/5.jpg" alt="事务"></p>
<h2 id="1-基本指令"><a href="#1-基本指令" class="headerlink" title="1. 基本指令"></a>1. 基本指令</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">· multi				开启事务		执行后，后续指令加入事务</span><br><span class="line">· <span class="keyword">exec</span>				执行事务		执行事务，与multi成对使用</span><br><span class="line">· discard			取消事务</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line"><span class="number">1.</span>出现语法错误后，销毁队列，所有不执行 #书写错误</span><br><span class="line"><span class="number">2.</span>出现命令执行错误后，对正确的命令执行，错误的不执行</span><br><span class="line"><span class="number">3.</span>redis事务执行后不会回滚，需要程序员自己备份</span><br></pre></td></tr></table></figure>
<h2 id="2-锁"><a href="#2-锁" class="headerlink" title="2. 锁"></a>2. 锁</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">监视锁<span class="operator">/</span>乐观锁:</span><br><span class="line">· watch key1 [key2]			添加监视锁</span><br><span class="line">· unwatch					取消监视锁</span><br><span class="line">如果在事务提交之前，监视的key进行了变动，则该事务失效</span><br><span class="line"></span><br><span class="line">公共锁<span class="operator">/</span>悲观锁: #个人觉得类似线程锁</span><br><span class="line">· setnx lock<span class="operator">-</span>key <span class="keyword">value</span>		设置公共锁</span><br><span class="line"># 返回设置成功 说明有控制权 </span><br><span class="line"># 返回设置失败 则说明不具有控制权 进行排队<span class="operator">/</span>等待</span><br><span class="line">· del lock<span class="operator">-</span>key				删除公共锁</span><br><span class="line"></span><br><span class="line">为公共锁添加时间限定: #时间到了自动解锁 防止死锁</span><br><span class="line">· expire lock<span class="operator">-</span>key seconds		</span><br><span class="line">· pexpire lock<span class="operator">-</span>key milliseconds	</span><br><span class="line">注:一般都是微秒或毫秒级，具体需要测试 #推荐: 最大耗时 <span class="operator">*</span> <span class="number">120</span><span class="operator">%</span> <span class="operator">+</span> 平均网络延迟 <span class="operator">*</span> <span class="number">110</span><span class="operator">%</span></span><br></pre></td></tr></table></figure>
<h1 id="七、删除策略"><a href="#七、删除策略" class="headerlink" title="七、删除策略"></a>七、删除策略</h1><h2 id="1-数据删除"><a href="#1-数据删除" class="headerlink" title="1. 数据删除"></a>1. 数据删除</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">·定时删除 #时间换空间</span><br><span class="line">优点:节约内存</span><br><span class="line">缺点:CPU压力大</span><br><span class="line"></span><br><span class="line">·惰性删除 &quot;过期后，不做处理，下次访问时删除，不过期则返回&quot; #空间换时间</span><br><span class="line">优点:节约CPU</span><br><span class="line">缺点:内存压力大</span><br><span class="line"></span><br><span class="line">·定期删除 &quot;随机抽查，重点检查&quot; #每秒消耗固定的CPU资源 可以自由调整</span><br><span class="line"><span class="number">1.</span>读取配置server.hz的值，默认为<span class="number">0</span></span><br><span class="line"><span class="number">2.</span>每秒钟执行server.hz次serverCron()</span><br><span class="line"><span class="number">3.</span>serverCron()会调用databasesCron()获取数据</span><br><span class="line"><span class="number">4.</span>获取数据后，调用activeExpireCycle()随机抽取数据检测</span><br><span class="line"><span class="number">5.</span>若该数据超时，则删除</span><br><span class="line">注意:</span><br><span class="line"><span class="number">1.</span>抽取判定数据的时长为<span class="number">250</span>ms<span class="operator">/</span>server.hz</span><br><span class="line"><span class="number">2.</span>W取值为ACTIVE_EXPIRE_CYCLE_LOOKUPS_PRE_LOOP属性值，若本次删除数据 <span class="operator">&gt;</span> W<span class="operator">*</span><span class="number">25</span><span class="operator">%</span>，则再次执行删除过程</span><br><span class="line"><span class="number">3.</span>若本次删除数据 <span class="operator">&lt;</span> W<span class="operator">*</span><span class="number">25</span><span class="operator">%</span>，则检查下一个库</span><br><span class="line"><span class="number">4.</span>有参数current_db记录本次检测执行到哪个库，下次继续即可</span><br><span class="line"><span class="number">5.</span>通常使用定期删除和惰性删除</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>删除策略</th>
<th>优缺点</th>
<th>特性</th>
<th>总结</th>
</tr>
</thead>
<tbody><tr>
<td>定时删除</td>
<td>节约内存，无占用</td>
<td>不分时段占用CPU资源，频度高</td>
<td>拿时间换空间</td>
</tr>
<tr>
<td>惰性删除</td>
<td>内存占用严重</td>
<td>延时执行，CPU利用率高</td>
<td>拿空间换时间</td>
</tr>
<tr>
<td>定期删除</td>
<td>内存定期随机清理</td>
<td>每秒花费固定的CPU资源维护内存</td>
<td>随机抽查，重点抽查</td>
</tr>
</tbody></table>
<h2 id="2-数据逐出"><a href="#2-数据逐出" class="headerlink" title="2. 数据逐出"></a>2. 数据逐出</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">主要依靠&quot;逐出算法&quot; #可能失效</span><br><span class="line">执行命令前，调用freeMemoryIfNeeded()检测内存是否够多</span><br><span class="line">不够则临时删除一些数据清理空间</span><br><span class="line"></span><br><span class="line">info命令可以看缓存hit和miss的次数，根据业务进行调优</span><br><span class="line"></span><br><span class="line">conf配置:</span><br><span class="line">· maxmemory					最大可使用内存 #默认为<span class="number">0</span>即不限 通常设置<span class="number">50</span><span class="operator">%</span>以上</span><br><span class="line">· maxmemory<span class="operator">-</span>sampless		设置每次选取待删除数据个数 #默认为<span class="number">5</span></span><br><span class="line">· maxmemory<span class="operator">-</span>policy			设置删除策略 #选项见下图</span><br></pre></td></tr></table></figure>
<p><img src="/images/2021-03-29/6.jpg" alt="策略"></p>
<h1 id="八、Redis集群"><a href="#八、Redis集群" class="headerlink" title="八、Redis集群"></a>八、Redis集群</h1><h2 id="1-主从连接"><a href="#1-主从连接" class="headerlink" title="1. 主从连接"></a>1. 主从连接</h2><p>理论基础:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">我们建立服务器的最终目标是:</span><br><span class="line"><span class="number">1.</span>高并发 <span class="number">2.</span>高性能 <span class="number">3.</span>高可用</span><br><span class="line">其中，高可用的理论目标是全年宕机低于<span class="number">315</span>秒。</span><br><span class="line"></span><br><span class="line">对此，我们可以建立主从连接来提高可用性，即一台主服务器对应多台从服务器。</span><br><span class="line">主服务器只进行写操作，从服务器只进行读操作，读写分离提高效率。</span><br><span class="line">而当主服务器出现问题时，可以让一台从服务器接替成为主服务器，从而保证服务器集群正常运行。</span><br><span class="line"></span><br><span class="line">主从连接的特点:</span><br><span class="line"><span class="number">1.</span>读写分离 	提高效率。</span><br><span class="line"><span class="number">2.</span>负载均衡 	基于主从结构，配合读写分离，slave分担master负载。根据需求改变slave的数量，分担负载，提高并发与吞吐。</span><br><span class="line"><span class="number">3.</span>故障恢复	由于主从服务器上的数据是一致的，当需要恢复数据时，直接复制另一台服务器上的数据即可。</span><br><span class="line"><span class="number">4.</span>数据冗余持久化		由于是集群形态，相同数据在多个服务器上，造成数据冗余，易于持久化。</span><br><span class="line"><span class="number">5.</span>高可用基础		主从连接是高可用服务器的基础。	</span><br></pre></td></tr></table></figure>
<p>主从连接的方式:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">方法一: 客户端发送命令</span><br><span class="line">· slaveof <span class="operator">&lt;</span>masterip<span class="operator">&gt;</span> <span class="operator">&lt;</span>masterport<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line">方法二: 启动服务器参数</span><br><span class="line">· redis<span class="operator">-</span>server <span class="operator">-</span>slaveof <span class="operator">&lt;</span>masterip<span class="operator">&gt;</span> <span class="operator">&lt;</span>masterport<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line">方法三: 服务器配置 #主流</span><br><span class="line">· slaveof <span class="operator">&lt;</span>masterip<span class="operator">&gt;</span> <span class="operator">&lt;</span>masterport<span class="operator">&gt;</span>	</span><br></pre></td></tr></table></figure>
<p>主从复制的三个阶段:</p>
<ul>
<li>阶段一：建立连接阶段<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>slave 	<span class="operator">-</span>	发送<span class="string">&#x27;slaveof ip port&#x27;</span>，申请建立连接</span><br><span class="line"><span class="number">2.</span>master	<span class="operator">-</span>	接收到指令，发送信息响应对方</span><br><span class="line"><span class="number">3.</span>slave		<span class="operator">-</span>	保存master的IP和端口</span><br><span class="line"><span class="number">4.</span>slave		<span class="operator">-</span>	与master建立socket连接</span><br><span class="line"><span class="number">5.</span>slave		<span class="operator">-</span>	ping</span><br><span class="line"><span class="number">6.</span>master	<span class="operator">-</span>	pong</span><br><span class="line"><span class="number">7.</span>slave		<span class="operator">-</span>	发送指令</span><br><span class="line"><span class="number">8.</span>master	<span class="operator">-</span>	验证授权</span><br><span class="line"><span class="number">9.</span>slave		<span class="operator">-</span>	发送指令 port端口</span><br><span class="line"><span class="number">10.</span>master	<span class="operator">-</span>	保存端口号</span><br><span class="line"></span><br><span class="line">相关:</span><br><span class="line"># 从属客户端发送命令</span><br><span class="line">· slaveof <span class="operator">&lt;</span>masterip<span class="operator">&gt;</span> <span class="operator">&lt;</span>masterport<span class="operator">&gt;</span>	主从连接</span><br><span class="line">· slaveof <span class="keyword">no</span> <span class="keyword">one</span>					主从断开连接</span><br><span class="line"></span><br><span class="line">· requirepass <span class="operator">&lt;</span>password<span class="operator">&gt;</span>				master配置文件设置密码</span><br><span class="line">· config <span class="keyword">set</span> requirepass <span class="operator">&lt;</span>password<span class="operator">&gt;</span>		master客户端发送命令设置密码</span><br><span class="line">· config <span class="keyword">get</span> requirepass</span><br><span class="line">· auth <span class="operator">&lt;</span>password<span class="operator">&gt;</span>						slave客户端发送命令设置密码</span><br><span class="line">· masterauth <span class="operator">&lt;</span>password<span class="operator">&gt;</span>					slave配置文件设置密码</span><br><span class="line">· redis<span class="operator">-</span>cli <span class="operator">-</span>a <span class="operator">&lt;</span>password<span class="operator">&gt;</span>				启动客户端设置密码</span><br></pre></td></tr></table></figure></li>
<li>阶段二：数据同步阶段<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">服务器运行ID (runid) # info Server 查看相关信息</span><br><span class="line">· 是每一台服务器每次运行的身份识别码，一台服务器多次运行可用生成多个运行id</span><br><span class="line">· id由<span class="number">40</span>位字符组成，是一个随机的十六进制字符</span><br><span class="line">· 用于识别身份，进行操作时需要首先进行id比对</span><br><span class="line"></span><br><span class="line"># 以下为全量复制 复制大部分整体</span><br><span class="line"><span class="number">1.</span>slave		<span class="operator">-</span>	发送指令<span class="string">&#x27;psync2 &lt;runid&gt; &lt;offset&gt;&#x27;</span> # ? <span class="number">-1</span> 此时不知道runid 和 <span class="keyword">offset</span></span><br><span class="line"><span class="number">2.</span>master	<span class="operator">-</span>	接收指令，执行bgsave生成RDB文件，记录当前的复制偏移量</span><br><span class="line"><span class="number">3.</span>master	<span class="operator">-</span>	发送<span class="string">&#x27;+FULLRESYNC runid offset&#x27;</span>，通过socket发送RDB文件给slave，期间接收客户端命令，<span class="keyword">offset</span>发生了变化</span><br><span class="line"><span class="number">4.</span>slave		<span class="operator">-</span>	收到<span class="string">&#x27;+FULLRESYNC&#x27;</span>，保存master的runid和<span class="keyword">offset</span>，清空当前全部数据，通过socket接收RDB文件，恢复RDB数据</span><br><span class="line"># 以下为部分复制 复制发送RDB文件期间master接收到的命令</span><br><span class="line"><span class="number">5.</span>slave		<span class="operator">-</span>	发送指令<span class="string">&#x27;psync2 runid offset&#x27;</span></span><br><span class="line"><span class="number">6.</span>master	<span class="operator">-</span>	接收命令，判定runid是否匹配，判定<span class="keyword">offset</span>是否在复制缓冲区内</span><br><span class="line"><span class="number">7.</span>master	<span class="operator">-</span>	如果runid或<span class="keyword">offset</span>有一个不满足，执行全量复制 #执行步骤<span class="number">2</span>	</span><br><span class="line"><span class="number">7.</span>master	<span class="operator">-</span>	如果runid和<span class="keyword">offset</span>校验通过，<span class="keyword">offset</span>与本机<span class="keyword">offset</span>相同，忽略</span><br><span class="line"><span class="number">7.</span>master	<span class="operator">-</span>	如果runid和<span class="keyword">offset</span>校验通过，<span class="keyword">offset</span>与本机<span class="keyword">offset</span>不相同，发送<span class="string">&#x27;+CONTINUE offset&#x27;</span></span><br><span class="line">				通过socket发送复制缓冲区中<span class="keyword">offset</span>到本机<span class="keyword">offset</span>的数据</span><br><span class="line"><span class="number">8.</span>slave		<span class="operator">-</span>	收到<span class="string">&#x27;+CONTINUE&#x27;</span>，保存master的<span class="keyword">offset</span>，接收消息后，执行bgrewriteaof恢复数据</span><br><span class="line"></span><br><span class="line">相关: #配置文件</span><br><span class="line">· repl<span class="operator">-</span>backlog<span class="operator">-</span>size <span class="number">1</span>mb				设置复制缓冲区大小</span><br><span class="line">· slave<span class="operator">-</span>serve<span class="operator">-</span>stale<span class="operator">-</span>data yes<span class="operator">|</span><span class="keyword">no</span>		slave在同步期间是否关闭对外服务</span><br><span class="line"></span><br><span class="line">· master一般占用内存的<span class="number">50</span><span class="operator">%</span><span class="number">-70</span><span class="operator">%</span>，剩下的<span class="number">30</span><span class="operator">%</span><span class="number">-50</span><span class="operator">%</span>给bgsave和缓冲区用</span><br><span class="line">· 同时请求复制，发送的RDB文件多，所以需要错峰请求</span><br><span class="line">· 或者采用拓扑结构，一主多从改成树状结构，但是一致性会变差</span><br></pre></td></tr></table></figure></li>
<li>阶段三：命令传播阶段<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>master发送命令:ping	<span class="operator">/</span>	slave发送命令:replconf ack <span class="keyword">offset</span></span><br><span class="line"><span class="number">2.</span>master	<span class="operator">-</span>	接收命令，判定<span class="keyword">offset</span>是否在复制缓冲区内</span><br><span class="line"><span class="number">3.</span>master	<span class="operator">-</span>	如果不在缓冲区，则执行全量复制</span><br><span class="line"><span class="number">3.</span>master	<span class="operator">-</span>	如果在缓冲区，且<span class="keyword">offset</span>与<span class="keyword">offset</span>相同，忽略</span><br><span class="line"><span class="number">3.</span>master	<span class="operator">-</span>	如果在缓冲区，且<span class="keyword">offset</span>与<span class="keyword">offset</span>不同，发送<span class="string">&#x27;+CONTINUE offset&#x27;</span></span><br><span class="line">				通过socket发送复制缓冲区中<span class="keyword">offset</span>到本机<span class="keyword">offset</span>的数据</span><br><span class="line"><span class="number">4.</span>slave		<span class="operator">-</span>	收到<span class="string">&#x27;+CONTINUE&#x27;</span>，保存master的<span class="keyword">offset</span>，接收消息后，执行bgrewriteaof恢复数据</span><br><span class="line"></span><br><span class="line">相关:</span><br><span class="line"># 心跳机制     master:ping     slave:REPLCONF ACK</span><br><span class="line">· repl<span class="operator">-</span>ping<span class="operator">-</span>slave<span class="operator">-</span><span class="keyword">period</span> <span class="number">10</span>		master不断<span class="string">&#x27;ping&#x27;</span>的周期，判断slave是否在线</span><br><span class="line"># 当slave数量少于<span class="number">2</span>个，或者所有slave的延迟都大于等于<span class="number">10</span>秒时，强制关闭master写功能，停止数据同步 </span><br><span class="line">· min<span class="operator">-</span>slaves<span class="operator">-</span><span class="keyword">to</span><span class="operator">-</span>write <span class="number">2</span>		#保障数据稳定性</span><br><span class="line">· min<span class="operator">-</span>slaves<span class="operator">-</span>max<span class="operator">-</span>lag <span class="number">10</span>		#发送 REPLCONF ACK 命令  获取当前数量与延迟</span><br><span class="line"></span><br><span class="line">闪断闪联: 忽略</span><br><span class="line">短时间中断: 部分复制</span><br><span class="line">长时间终端: 全量复制</span><br></pre></td></tr></table></figure>
主从复制常见问题:<br><img src="/images/2021-03-29/7.jpg" alt="在这里插入图片描述"><br><img src="/images/2021-03-29/8.jpg" alt="在这里插入图片描述"><br><img src="/images/2021-03-29/8-1.jpg" alt="在这里插入图片描述"><br><img src="/images/2021-03-29/9.jpg" alt="在这里插入图片描述"><br><img src="/images/2021-03-29/10.jpg" alt="在这里插入图片描述"></li>
</ul>
<h2 id="2-哨兵"><a href="#2-哨兵" class="headerlink" title="2. 哨兵"></a>2. 哨兵</h2><p>思路:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>宕机master下线</span><br><span class="line"><span class="number">2.</span>找一个slave成为新master</span><br><span class="line"><span class="number">3.</span>通知所有slave连接新master</span><br><span class="line"><span class="number">4.</span>启动新的master与slave</span><br><span class="line"><span class="number">5.</span>全量复制<span class="operator">/</span>部分复制</span><br><span class="line"></span><br><span class="line">其中观测下线服务器以及推选新master的服务器，就被称为哨兵。</span><br></pre></td></tr></table></figure>
<p>结构与作用:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;分布式系统，监控全部&#x27;</span></span><br><span class="line">· 监控				检查master和slave是否正常</span><br><span class="line">· 通知				出问题时，通知哨兵和客户端</span><br><span class="line">· 自动故障转移		断开master和slave连接，推选新的master，其他slave连接到新master，告知客户端新地址</span><br><span class="line"></span><br><span class="line">注:</span><br><span class="line"><span class="number">1.</span>哨兵也是redis服务器，只是不提供数据</span><br><span class="line"><span class="number">2.</span>哨兵数量通常为单数，便于投票选举</span><br></pre></td></tr></table></figure>
<p>哨兵基础配置文件与启动:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">· port <span class="number">26379</span>											服务端口 通常最前加<span class="number">2</span></span><br><span class="line">· dir &quot;/.../redis/data&quot;									哨兵工作信息储存目录</span><br><span class="line">· sentinel monitor mymaster <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379</span> <span class="number">2</span>			监控的主服务器 当有<span class="number">2</span>个哨兵觉得它挂了，它就算挂了 #数量一半<span class="operator">+</span><span class="number">1</span> </span><br><span class="line">· sentinel down<span class="operator">-</span>after<span class="operator">-</span>milliseconds mymaster <span class="number">30000</span>		<span class="number">30</span>秒连接无响应，该哨兵认定它挂了</span><br><span class="line">· sentinel failover<span class="operator">-</span>timeout mymaster <span class="number">180000</span>				<span class="number">180</span>秒未同步完成，认定同步超时</span><br><span class="line">· sentinel parallel<span class="operator">-</span>syncs mymaster <span class="number">1</span>					重连了以后，一次一台进行同步</span><br><span class="line"></span><br><span class="line">· redis<span class="operator">-</span>sentinel sentinel<span class="operator">-</span>port.conf						启动哨兵</span><br><span class="line">启动顺序: 主<span class="operator">-</span>从<span class="operator">-</span>哨</span><br></pre></td></tr></table></figure>
<p>哨兵工作原理:<br><img src="/images/2021-03-29/11.jpg" alt="在这里插入图片描述"></p>
<p><img src="/images/2021-03-29/12.jpg" alt="监控阶段"><br><img src="/images/2021-03-29/13.jpg" alt="在这里插入图片描述"><br><img src="/images/2021-03-29/14.jpg" alt="在这里插入图片描述"></p>
<h2 id="3-集群"><a href="#3-集群" class="headerlink" title="3. 集群"></a>3. 集群</h2><p>简介:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">当redis单机提供的服务OPS不足，或者单机内存容量不足时，可用采用集群的方式解决上述问题。</span><br><span class="line"></span><br><span class="line">架构:</span><br><span class="line">· 集群就是使用网络将若干台计算机联通起来，并提供统一的管理方式，使其对外呈现单机的服务效果</span><br><span class="line"></span><br><span class="line">作用:</span><br><span class="line">· 分散单台服务器的访问压力，实现负载均衡</span><br><span class="line">· 分散单台服务器的存储压力，实现可扩展性</span><br><span class="line">· 降低单台服务器宕机带来的业务灾难</span><br></pre></td></tr></table></figure>
<p>设计:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">数据存储设计:</span><br><span class="line">· 通过算法设计，计算出key应该保存的位置</span><br><span class="line">· 将所有的存储空间计划切割成<span class="number">16384</span>份，每台主机保存一部分 #槽</span><br><span class="line">  每份代表的是一个储存空间，不少一个key的保存空间</span><br><span class="line">· 将key按照计算出的结结果放到对应的存储空间</span><br><span class="line"></span><br><span class="line">· 当一台新的服务器加入集群时，每台服务器拿出一部分存储空间(槽)给新的服务器，即可将新的服务器加入集群</span><br><span class="line">· 增强可扩展性</span><br><span class="line"></span><br><span class="line">内部通讯设计:</span><br><span class="line">· 每个服务器数据库互相通信，保存各个库里储存空间(槽)的编号数据</span><br><span class="line">· 如果客户端访问的数据库中有想要的数据，直接返回 #一次命中，直接返回</span><br><span class="line">· 如果客户端访问的数据库中没有想要的数据，根据编号数据，去新的库里找 #一次未命中，告知具体位置</span><br><span class="line"># 这样可以保证最多查询两次，可以返回结果，提高查询效率</span><br></pre></td></tr></table></figure>
<p>相关配置与命令:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">配置:</span><br><span class="line">· clusetr<span class="operator">-</span>enabled yes<span class="operator">|</span><span class="keyword">no</span>				设置加入cluster，成为其中的节点</span><br><span class="line">· cluster<span class="operator">-</span>config<span class="operator">-</span>file <span class="operator">&lt;</span>filename.conf<span class="operator">&gt;</span>	cluster配置文件名，该文件自动生成，仅用于查找文件并查询文件内容</span><br><span class="line">· cluster<span class="operator">-</span>node<span class="operator">-</span>timeout <span class="operator">&lt;</span>milliseconds<span class="operator">&gt;</span>	响应超时判定，判定该节点是否下线或切换为从节点 #一秒连接一次</span><br><span class="line">· cluster<span class="operator">-</span>migration<span class="operator">-</span>barrier <span class="operator">&lt;</span>count<span class="operator">&gt;</span>		master连接的slave最小数量</span><br><span class="line"></span><br><span class="line">命令:</span><br><span class="line">· cluster nodes							查看集群节点信息</span><br><span class="line">· cluster replicate <span class="operator">&lt;</span>master<span class="operator">-</span>id<span class="operator">&gt;</span>			进入一个从节点redis，切换其主节点</span><br><span class="line">· cluster meet ip:port					发现一个新节点，新增主节点</span><br><span class="line">· cluster forget <span class="operator">&lt;</span>id<span class="operator">&gt;</span>					忽略一个没有solt的节点</span><br><span class="line">· cluster failover						手动故障转移</span><br><span class="line"></span><br><span class="line">集群构建启动:</span><br><span class="line">· 先把服务端全部启动，按照上面的配置文件</span><br><span class="line">· .<span class="operator">/</span>redis<span class="operator">-</span>trib.rb <span class="keyword">create</span> <span class="comment">--replicas 1 127.0.0.1:6379</span></span><br><span class="line"># <span class="number">1</span>代表一个master连一个slave 后面写master的IP:PORT</span><br><span class="line"></span><br><span class="line">集群操控:</span><br><span class="line">· redis<span class="operator">-</span>cli <span class="operator">-</span>c							登陆集群的客户端</span><br><span class="line">· redis<span class="operator">-</span>cli <span class="operator">-</span>c <span class="operator">-</span>p <span class="number">6382</span></span><br></pre></td></tr></table></figure>
<h1 id="九、企业级解决方案"><a href="#九、企业级解决方案" class="headerlink" title="九、企业级解决方案"></a>九、企业级解决方案</h1><h2 id="1-缓存预热"><a href="#1-缓存预热" class="headerlink" title="1. 缓存预热"></a>1. 缓存预热</h2><p>情况</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">启动后迅速宕机</span><br></pre></td></tr></table></figure>
<p>问题排查</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 请求数量较高</span><br><span class="line"><span class="number">2.</span> 主从之间数据吞吐量较大，数据同步操作频度较高</span><br></pre></td></tr></table></figure>
<p>解决方案</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">前置准备工作:</span><br><span class="line"><span class="number">1.</span> 日常例行统计数据访问记录，统计访问频度较高的热点数据</span><br><span class="line"><span class="number">2.</span> 利用LRU数据删除策略，构建数据留存队列  (例如: storm与kafka配合)</span><br><span class="line">准备工作:</span><br><span class="line"><span class="number">3.</span> 将统计结果中的数据分类，设置级别，redis优先加载级别较高的热点数据</span><br><span class="line"><span class="number">4.</span> 利用分布式多服务器同时进行数据读取，提速数据加载过程</span><br><span class="line">实施:</span><br><span class="line"><span class="number">1.</span> 使用脚本程序固定触发数据预热过程</span><br><span class="line"><span class="number">2.</span> 如果条件允许，使用了CDN(内容分发网络)，效果会更好</span><br></pre></td></tr></table></figure>
<p>总结</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">· 缓存预热就是系统启动前，提前将相关的缓存数据直接加载到缓存系统。</span><br><span class="line">· 避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题。</span><br><span class="line">  用户直接查询事先被预热的缓存数据。</span><br></pre></td></tr></table></figure>
<h2 id="2-缓存雪崩"><a href="#2-缓存雪崩" class="headerlink" title="2. 缓存雪崩"></a>2. 缓存雪崩</h2><p>情况</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 系统平稳运行过程中，忽然数据库连接量激增</span><br><span class="line"><span class="number">2.</span> 应用服务器无法及时处理请求</span><br><span class="line"><span class="number">3.</span> 大量<span class="number">408</span><span class="operator">/</span><span class="number">500</span>错误页面出现</span><br><span class="line"><span class="number">4.</span> 客户反复刷新页面获取数据</span><br><span class="line"><span class="number">5.</span> 数据库崩溃</span><br><span class="line"><span class="number">6.</span> 应用服务器崩溃</span><br><span class="line"><span class="number">7.</span> 重启应用服务器无效</span><br><span class="line"><span class="number">8.</span> Redis服务器崩溃</span><br><span class="line"><span class="number">9.</span> Redis集群崩溃</span><br><span class="line"><span class="number">10.</span> 重启数据库后再次被瞬间流量放倒</span><br></pre></td></tr></table></figure>
<p>问题排查</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 在一个较短的时间内，缓存中较多的key集中过期</span><br><span class="line"><span class="number">2.</span> 此周期内请求访问过期的数据，redis未命中，redis向数据库获取数据</span><br><span class="line"><span class="number">3.</span> 数据库同时接收到大量的请求无法及时处理</span><br><span class="line"><span class="number">4.</span> Redis大量请求被积压，开始出现超时现象</span><br><span class="line"><span class="number">5.</span> 数据库流量激增，数据库崩溃</span><br><span class="line"><span class="number">6.</span> 重启后仍然面对缓存中无数据可用</span><br><span class="line"><span class="number">7.</span> Redis服务器资源被严重占用，Redis服务器崩溃</span><br><span class="line"><span class="number">8.</span> Redis集群呈现崩塌，集群瓦解</span><br><span class="line"><span class="number">9.</span> 应用服务器无法及时得到数据响应请求，来自客户端的请求数量越来越多，应用服务器崩溃</span><br><span class="line"><span class="number">10.</span> 应用服务器<span class="operator">/</span>redis<span class="operator">/</span>数据库全部重启，效果不理想</span><br></pre></td></tr></table></figure>
<p>解决方案(理论)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>更多的页面静态化处理</span><br><span class="line">(减少请求)</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>构建多级缓存架构</span><br><span class="line">(Nginx缓存<span class="operator">+</span>redis缓存<span class="operator">+</span>ehcache缓存)</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>检测Mysql严重耗时业务进行优化</span><br><span class="line">(对数据库的瓶颈排查:例如超时查询、耗时较高事务等)</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>灾难预警机制</span><br><span class="line">监控redis服务器性能指标:</span><br><span class="line">· CPU占用、CPU使用率</span><br><span class="line">· 内存容量</span><br><span class="line">· 查询平均响应时间</span><br><span class="line">· 线程数</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>限流、降级</span><br><span class="line">(短时间范围内牺牲一些客户体验，限制一部分请求访问，降低应用服务器压力，待业务低速运转后再逐步放开访问)</span><br></pre></td></tr></table></figure>
<p>解决方案(方法)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>LRU与LFU切换</span><br><span class="line">(内存替换算法)</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>数据有效期策略调整</span><br><span class="line">· 根据业务数据有效期进行分类错峰 eg:A类<span class="number">90</span>分钟，B类<span class="number">80</span>分钟，C类<span class="number">70</span>分钟</span><br><span class="line">· 过期时间使用固定时间<span class="operator">+</span>随机值的形式，稀释集中到期的key的数量</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>超热数据使用永久key</span><br><span class="line">(避免key过期)</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>定期维护(自动<span class="operator">+</span>人工)</span><br><span class="line">(对即将过期数据做访问量分析，确认是否延时，配合访问量统计，做热点数据的延时)</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>加锁</span><br><span class="line">(慎用<span class="operator">!</span>)</span><br></pre></td></tr></table></figure>
<p>总结</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">· 缓存雪崩就是瞬间过期数据量太大，导致对数据库服务器造成压力。</span><br><span class="line">· 如能够有效避免过期时间集中，可以有效解决雪崩现象的出现(约<span class="number">40</span><span class="operator">%</span>)，</span><br><span class="line">  配合其他策略一起使用，并监控服务器的运行数据，根据运行记录做快速调整。</span><br></pre></td></tr></table></figure>
<h2 id="3-缓存击穿"><a href="#3-缓存击穿" class="headerlink" title="3. 缓存击穿"></a>3. 缓存击穿</h2><p>情况</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 系统平稳运行过程中</span><br><span class="line"><span class="number">2.</span> 数据库连接量瞬间激增</span><br><span class="line"><span class="number">3.</span> Redis服务器无大量key过期</span><br><span class="line"><span class="number">4.</span> Redis内存平稳，无波动</span><br><span class="line"><span class="number">5.</span> Redis服务器CPU正常</span><br><span class="line"><span class="number">6.</span> 数据库崩溃</span><br></pre></td></tr></table></figure>
<p>问题排查&#x2F;分析</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> Redis中某个key过期，该key访问量巨大</span><br><span class="line"><span class="number">2.</span> 多个数据请求从服务器直接压到Redis后，均未命中</span><br><span class="line"><span class="number">3.</span> Redis在短时间内发起了大量对数据库中同一数据的访问</span><br><span class="line"></span><br><span class="line">· 单个key高热数据</span><br><span class="line">· key过期</span><br></pre></td></tr></table></figure>
<p>解决方案</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>预先设定</span><br><span class="line">· 以电商为例，每个商家根据店铺等级，指定若干款主打商品，在购物节期间，加大此类信息key的过期时长</span><br><span class="line">· 注意: 购物节不仅仅指当天，以及后续若干天，访问峰值呈现逐渐降低的趋势</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>现场调整</span><br><span class="line">(监控访问量，对自然流量激增的数据延长过期时间或设置为永久性key)</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>后台刷新数据</span><br><span class="line">(启动定时任务，高峰期来临之前,刷新数据有效期，确保不丢失)</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>二级缓存</span><br><span class="line">(设置不同的失效时间，保障不会被同时淘汰就行)</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>加锁</span><br><span class="line">(分布式锁，防止被击穿，但是要注意也是性能瓶颈，慎重<span class="operator">!</span>)</span><br></pre></td></tr></table></figure>
<p>总结</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">· 缓存击穿就是单个高热数据过期的瞬间，数据访问量较大，未命中redis后，</span><br><span class="line">  发起了大量对同一数据的数据库访问，导致对数据库服务器造成压力。</span><br><span class="line">· 应对策略应该在业务数据分析与预方面进行，配合运行监控测试与即时调整策略，</span><br><span class="line">  毕竟单个key的过期监控难度较高，配合雪崩处理策略即可。</span><br></pre></td></tr></table></figure>
<h2 id="4-缓存穿透"><a href="#4-缓存穿透" class="headerlink" title="4. 缓存穿透"></a>4. 缓存穿透</h2><p>情况</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 系统平稳运行过程中</span><br><span class="line"><span class="number">2.</span> 应用服务器流量随时间增量较大</span><br><span class="line"><span class="number">3.</span> Redis服务器命中率随时间逐步降低</span><br><span class="line"><span class="number">4.</span> Redis内存平稳，内存无压力</span><br><span class="line"><span class="number">5.</span> Redis服务器CPU占用激增</span><br><span class="line"><span class="number">6.</span> 数据库服务器压力激增</span><br><span class="line"><span class="number">7.</span> 数据库崩溃</span><br></pre></td></tr></table></figure>
<p>问题排查&#x2F;分析</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> Redis中大面积出现未命中</span><br><span class="line"><span class="number">2.</span> 出现非正常URL访问</span><br><span class="line"></span><br><span class="line">· 获取的数据在数据库中也不存在,数据库查询未得到对应数据</span><br><span class="line">· Redis获取到<span class="keyword">null</span>数据未进行持久化，直接返回</span><br><span class="line">· 下次此类数据到达重复上述过程</span><br><span class="line">· 出现黑客攻击服务器</span><br></pre></td></tr></table></figure>
<p>解决方案</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>缓存<span class="keyword">null</span></span><br><span class="line">(对查询结果为<span class="keyword">null</span>的数据进行缓存(长期使用，定期清理)，设定短时限，例如<span class="number">30</span><span class="number">-60</span>秒，最高<span class="number">5</span>分钟)</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>白名单策略</span><br><span class="line">· 提前预热各种分类数据id对应的bitmaps，id作为bitmaps的<span class="keyword">offset</span>，相当于设置了数据白名单。</span><br><span class="line">  当加载正常数据时，放行，加载异常数据时直接拦截(效率偏低)</span><br><span class="line">· 使用布隆过滤器(有关布隆过滤器的命中问题对当前状况可以忽略)</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>．实施监控</span><br><span class="line">实时监控redis命中率(业务正常范围时，通常会有一个波动值)与<span class="keyword">null</span>数据的占比</span><br><span class="line">· 非活动时段波动:通常检测<span class="number">3</span><span class="number">-5</span>倍，超过<span class="number">5</span>倍纳入重点排查对象</span><br><span class="line">· 活动时段波动:通常检测<span class="number">10</span><span class="number">-50</span>倍，超过<span class="number">50</span>倍纳入重点排查对象</span><br><span class="line">根据倍数不同，启动不同的排查流程。然后使用黑名单进行防控(运营)</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> key加密</span><br><span class="line">问题出现后，临时启动防灾业务key，对key进行业务层传输加密服务，设定校验程序，过来的key校验</span><br><span class="line">例如每天随机分配<span class="number">60</span>个加密串，挑选<span class="number">2</span>到<span class="number">3</span>个，混淆到页面数据id中，发现访问key不满足规则，驳回数据访问</span><br></pre></td></tr></table></figure>
<p>总结</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">· 缓存击穿访问了不存在的数据，跳过了合法数据的redis数据缓存阶段，每次均访问数据库，导致对数据库服务器造成压力。</span><br><span class="line">· 通常此类数据的出现量是一个较低的值，当出现此类情况时要及时处理并报警。</span><br><span class="line">  应对策略应该在临时预案防范方面多做文章。无论是黑名单还是白名单，都是对整体系统的压力，警报解除后尽快移除。</span><br></pre></td></tr></table></figure>
<h2 id="5-性能监控指标"><a href="#5-性能监控指标" class="headerlink" title="5. 性能监控指标"></a>5. 性能监控指标</h2><p><img src="/images/2021-03-29/15.jpg" alt="在这里插入图片描述"><br>benchmark</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">· 命令</span><br><span class="line">redis<span class="operator">-</span>benchmark [<span class="operator">-</span>h] [<span class="operator">-</span>p] [<span class="operator">-</span>c] [<span class="operator">-</span>n <span class="operator">&lt;</span>requests]<span class="operator">&gt;</span> [<span class="operator">-</span>k]</span><br><span class="line"></span><br><span class="line">· 范例<span class="number">1</span></span><br><span class="line">redis<span class="operator">-</span>benchmark</span><br><span class="line">说明:<span class="number">50</span>个连接，<span class="number">10000</span>次请求对应的性能</span><br><span class="line"></span><br><span class="line">· 范例<span class="number">2</span></span><br><span class="line">redis<span class="operator">-</span>benchmark <span class="operator">-</span>c <span class="number">100</span> <span class="operator">-</span>n <span class="number">5000</span></span><br><span class="line">说明:<span class="number">100</span>个连接，<span class="number">5000</span>次请求对应的性能</span><br></pre></td></tr></table></figure>
<p>monitor</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">· 命令</span><br><span class="line">monitor</span><br><span class="line">打印服务器调试信息</span><br></pre></td></tr></table></figure>
<p>slowlog</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">· 命令</span><br><span class="line">slowlog [operator]</span><br><span class="line">	· <span class="keyword">get</span>:获取慢查询日志</span><br><span class="line">	· len:获取慢查询日志条目数</span><br><span class="line">	· reset:重置慢查询日志</span><br><span class="line"></span><br><span class="line">· 相关配置</span><br><span class="line">slowlog<span class="operator">-</span>log<span class="operator">-</span>slower<span class="operator">-</span>than <span class="number">1000</span> #设置慢查询的时间下线，单位:微妙</span><br><span class="line">slowlog<span class="operator">-</span>max<span class="operator">-</span>len <span class="number">100</span> #设置慢查询命令对应的日志显示长度，单位:命令数</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>C++网络编程学习：心跳机制与定时发送数据</title>
    <url>/2021/05/08/20210508_C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%AE%9A%E6%97%B6%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="网络编程学习记录"><a href="#网络编程学习记录" class="headerlink" title="网络编程学习记录"></a>网络编程学习记录</h1><ul>
<li>使用的语言为C&#x2F;C++</li>
<li>源码支持的平台为：Windows（本文中内容使用windows平台下vs2019开发，故本文项目不完全支持linux平台）</li>
</ul>
<p><a href="https://blog.csdn.net/qq_45698148/article/details/116137196">点我查看之前的代码开发记录</a></p>
<h1 id="0：本次增改内容"><a href="#0：本次增改内容" class="headerlink" title="0：本次增改内容"></a>0：本次增改内容</h1><ol>
<li>更改服务端中，客户端对象储存的方式，由vector改为map。</li>
<li>改变任务队列中任务储存方式，由任务基类改为匿名函数。</li>
<li>加入心跳检测机制，及时剔除未响应客户端。</li>
<li>加入定时发送消息检测机制，及时发送缓冲区内的内容。</li>
<li>将内存池静态库分离，使客户端源码也可以引用。</li>
</ol>
<span id="more"></span>

<h1 id="1：更改客户端储存方式"><a href="#1：更改客户端储存方式" class="headerlink" title="1：更改客户端储存方式"></a>1：更改客户端储存方式</h1><p>&emsp;&emsp;之前，我的服务端程序储存客户端对象<code>ClientSocket</code>的方式是<code>std::vector&lt;ClientSocket*&gt;</code>，在select筛选后的fd_set中使用<code>FD_ISSET</code>函数获取需接收报文的客户端。<br>&emsp;&emsp;但是<code>FD_ISSET</code>函数是使用for循环进行暴力检索，消耗较大，我们可以改为使用<code>std::map::find</code>进行检索。这样就需要把储存客户端对象的方式改为<code>std::map</code>。因为我们需要通过socket进行查找，所以我把<code>std::map</code>的键设为SOCKET，值设为客户端对象<code>ClientSocket</code>的指针，这样我们需要改为<code>std::map&lt;SOCKET,ClientSocket*&gt;</code>。<br>&emsp;&emsp;在改变储存数据结构后，若想获取客户端socket，则调用<code>iter-&gt;first</code>；若想获取客户端对象指针，则调用<code>iter-&gt;second</code>；获取已连接客户端数量则还是<code>_clients.size()</code>。<br>&emsp;&emsp;在更换数据结构后，我们通过<code>fdRead.fd_count</code>进行循环，由于linux下fd_set内容与windows下不一致，所以本次要分环境进行检索，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; (<span class="type">int</span>)fdRead.fd_count; n++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">auto</span> iter = _clients.<span class="built_in">find</span>(fdRead.fd_array[n]);</span><br><span class="line">			<span class="keyword">if</span> (iter != _clients.<span class="built_in">end</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="number">-1</span> == <span class="built_in">RecvData</span>(iter-&gt;second))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (_pNetEvent)<span class="comment">//主线程中删除客户端 </span></span><br><span class="line">					&#123;</span><br><span class="line">						_pNetEvent-&gt;<span class="built_in">OnNetLeave</span>(iter-&gt;second);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="built_in">closesocket</span>(iter-&gt;first);</span><br><span class="line">					<span class="keyword">delete</span> iter-&gt;second;</span><br><span class="line">					_clients.<span class="built_in">erase</span>(iter);<span class="comment">//移除</span></span><br><span class="line">					_client_change = <span class="literal">true</span>;<span class="comment">//客户端退出 需要通知系统重新录入fdset集合 </span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		std::vector&lt;ClientSocket*&gt; ClientSocket_temp;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> iter = _clients.<span class="built_in">begin</span>(); iter != _clients.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(iter-&gt;first, &amp;fdRead))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="number">-1</span> == <span class="built_in">RecvData</span>(iter-&gt;second))<span class="comment">//处理请求 客户端退出的话 </span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (_pNetEvent)<span class="comment">//主线程中删除客户端 </span></span><br><span class="line">					&#123;</span><br><span class="line">						_pNetEvent-&gt;<span class="built_in">OnNetLeave</span>(iter-&gt;second);</span><br><span class="line">					&#125;</span><br><span class="line">					ClientSocket_temp.<span class="built_in">push_back</span>(iter-&gt;second);</span><br><span class="line">					_clients.<span class="built_in">erase</span>(iter);<span class="comment">//移除</span></span><br><span class="line">					_client_change = <span class="literal">true</span>;<span class="comment">//客户端退出 需要通知系统重新录入fdset集合 </span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> client : ClientSocket_temp)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">closesocket</span>(client-&gt;<span class="built_in">GetSockfd</span>());</span><br><span class="line">			_clients.<span class="built_in">erase</span>(client-&gt;<span class="built_in">GetSockfd</span>());</span><br><span class="line">			<span class="keyword">delete</span> client;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _WIN32</span></span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将所有相关位置的代码进行更改后，即可完成 客户端对象储存 数据结构的更改。</p>
<h1 id="2：更改任务队列储存方式"><a href="#2：更改任务队列储存方式" class="headerlink" title="2：更改任务队列储存方式"></a>2：更改任务队列储存方式</h1><p>&emsp;&emsp;之前，我是声明了一个抽象任务基类，通过重写基类的<code>DoTask()</code>方法来规定如何执行任务。但是这样利用多态可以执行重写后的任务。但是对于每一个新的任务类型，都需要定义一个新类重写一次<code>DoTask()</code>方法，有点麻烦。所以我使用C++11中新引入的匿名函数，来更改任务队列的储存方式，定义一个匿名函数类型，使任务内容可以更加灵活。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>()&gt; CellTask;</span><br><span class="line"><span class="comment">//任务数据 </span></span><br><span class="line">std::list&lt;CellTask&gt;_tasks;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理任务</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> pTask : _tasks)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">pTask</span>();	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用lambda式添加匿名函数</span></span><br><span class="line">_tasks.<span class="built_in">push_back</span>([pClient,pHead]() </span><br><span class="line">&#123;</span><br><span class="line">	pClient-&gt;<span class="built_in">SendData</span>(pHead);</span><br><span class="line">	<span class="keyword">delete</span> pHead;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="3：加入心跳检测机制"><a href="#3：加入心跳检测机制" class="headerlink" title="3：加入心跳检测机制"></a>3：加入心跳检测机制</h1><p>&emsp;&emsp;首先，心跳检测的前提是存在一个计时器，这里我在动态库中新实现了一个计时器类<code>HBtimer</code>(代码如下)，通过调用<code>getNowMillSec</code>方法，返回当前时间戳。这样通过一个变量来储存上一次获取的时间戳，从而可以计算两次获取时间戳之间的时间差，从而实现计时功能。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">__declspec</span>(dllexport) HBtimer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HBtimer</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">HBtimer</span>();</span><br><span class="line">    <span class="comment">//获取当前时间戳 (毫秒)</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">time_t</span> <span class="title">getNowMillSec</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">time_t</span> <span class="title">HBtimer::getNowMillSec</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取高精度当前时间(毫秒) high_resolution_clock::now();</span></span><br><span class="line">    <span class="comment">//duration_cast是类型转换方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">duration_cast</span>&lt;milliseconds&gt;(high_resolution_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;随后我在客户端类中定义一个心跳计时变量，并且声明两个相关方法，实现对心跳计时变量的归零与检测操作。当心跳计时器超过规定的客户端死亡时间后，<code>CheckHeart</code>方法会返回true告知该客户端已死亡。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//客户端死亡时间 20000毫秒</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLIENT_HREAT_TIME 20000</span></span><br><span class="line"><span class="comment">//心跳计时器</span></span><br><span class="line"><span class="type">time_t</span> _dtHeart;</span><br><span class="line"><span class="comment">//计时变量归零</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClientSocket::ResetDtHeart</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_dtHeart = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//dt为时间差 传入两次检测之间的时间差，检测心跳计时器是否超过心跳检测的阈值</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ClientSocket::CheckHeart</span><span class="params">(<span class="type">time_t</span> dt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_dtHeart += dt;</span><br><span class="line">	<span class="keyword">if</span> (_dtHeart &gt;= CLIENT_HREAT_TIME)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;CheakHeart dead:%d,time=%lld\n&quot;</span>,_sockfd,_dtHeart);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;接着需要在合适的函数中进行客户端的心跳检测。我在子线程的<code>OnRun</code>方法中，即对客户端进行select操作的方法中，加入<code>CheckTime</code>方法，之后对客户端相关的检测操作均在此方法中进行。在<code>CheckTime</code>中，我们首先要获取两次<code>checktime</code>之间的时间差，随后遍历所有客户端对象，挨个使用<code>CheckHeart</code>方法进行检测是否超时，若发现超时，则主动断开与该客户端之间的连接。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CellServer::CheckTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//获取时间差</span></span><br><span class="line">	<span class="type">time_t</span> nowTime = HBtimer::<span class="built_in">getNowMillSec</span>();</span><br><span class="line">	<span class="type">time_t</span> dt = nowTime - _oldTime;</span><br><span class="line">	_oldTime = nowTime;</span><br><span class="line">	<span class="comment">//遍历所有客户端对象</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> iter = _clients.<span class="built_in">begin</span>(); iter != _clients.<span class="built_in">end</span>();)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//检测心跳是否超时</span></span><br><span class="line">		<span class="keyword">if</span> (iter-&gt;second-&gt;<span class="built_in">CheckHeart</span>(dt) == <span class="literal">true</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (_pNetEvent)<span class="comment">//主线程中删除客户端 </span></span><br><span class="line">			&#123;</span><br><span class="line">				_pNetEvent-&gt;<span class="built_in">OnNetLeave</span>(iter-&gt;second);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">closesocket</span>(iter-&gt;second-&gt;<span class="built_in">GetSockfd</span>());</span><br><span class="line">			<span class="keyword">delete</span> iter-&gt;second;</span><br><span class="line">			_clients.<span class="built_in">erase</span>(iter++);<span class="comment">//移除</span></span><br><span class="line">			_client_change = <span class="literal">true</span>;<span class="comment">//客户端退出 需要通知系统重新录入fdset集合 </span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		iter++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;接着是心跳信号，可以在每次收到客户端报文时都对心跳计时变量归零，也可以声明单独的心跳报文，当接收到此报文时，重置心跳计时变量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//包6 心跳 client to server</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C2S_Heart</span> : <span class="keyword">public</span> DataHeader</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">C2S_Heart</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_C2S_HEART;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(C2S_Heart);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包7 心跳 server to client</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S2C_Heart</span> : <span class="keyword">public</span> DataHeader</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">S2C_Heart</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_S2C_HEART;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(S2C_Heart);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="4：加入定时发送缓存消息机制"><a href="#4：加入定时发送缓存消息机制" class="headerlink" title="4：加入定时发送缓存消息机制"></a>4：加入定时发送缓存消息机制</h1><p>&emsp;&emsp;之前，我仅进行了客户端消息定量发送功能，即当客户端对象发送缓冲区满后，进行消息的发送。这样当消息发送效率不够高时，很容易造成消息反馈的延迟，于是本次也实现了定时发送的功能。<br>&emsp;&emsp;上面实现心跳检测时，已经新建了<code>CellServer::CheckTime</code>方法，这个定时发送检测，我们也可以放在这个方法里。思路和心跳检测大同小异，也是在客户端类中定义一个发送计时变量，并且声明两个相关方法，实现对发送计时变量的归零与检测操作。<br>&emsp;&emsp;当发现需要发送消息时，需要一个方法把客户端对象发送缓冲区内的内容全部发送，并且清空缓冲区(指针归零)，随后重置计时变量。该方法为<code>ClientSocket::SendAll</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//客户端定时发送时间 200毫秒</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLIENT_AUTOMATIC_SEND_TIME 200</span></span><br><span class="line"><span class="comment">//定时发送计时器</span></span><br><span class="line"><span class="type">time_t</span> _dtSend;</span><br><span class="line"><span class="comment">//重置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClientSocket::ResetDtSend</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_dtSend = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ClientSocket::CheckSend</span><span class="params">(<span class="type">time_t</span> dt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_dtSend += dt;</span><br><span class="line">	<span class="keyword">if</span> (_dtSend &gt;= CLIENT_AUTOMATIC_SEND_TIME)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//printf(&quot;AutomaticSend:%d,time=%lld\n&quot;, _sockfd, _dtSend);</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//发送缓冲区内全部消息</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ClientSocket::SendAll</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ret = SOCKET_ERROR;</span><br><span class="line">	<span class="keyword">if</span> (_Len_Send_buf &gt; <span class="number">0</span> &amp;&amp; SOCKET_ERROR != _sockfd)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//发送 </span></span><br><span class="line">		ret = <span class="built_in">send</span>(_sockfd, (<span class="type">const</span> <span class="type">char</span>*)_Msg_Send_buf, _Len_Send_buf, <span class="number">0</span>);</span><br><span class="line">		<span class="comment">//发送后缓冲区归零 </span></span><br><span class="line">		_Len_Send_buf = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//重置发送计时器</span></span><br><span class="line">		<span class="built_in">ResetDtSend</span>();</span><br><span class="line">		<span class="comment">//发送错误 </span></span><br><span class="line">		<span class="keyword">if</span> (SOCKET_ERROR == ret)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;error 发送失败&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检测</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CellServer::CheckTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//获取时间差</span></span><br><span class="line">	<span class="type">time_t</span> nowTime = HBtimer::<span class="built_in">getNowMillSec</span>();</span><br><span class="line">	<span class="type">time_t</span> dt = nowTime - _oldTime;</span><br><span class="line">	_oldTime = nowTime;</span><br><span class="line">	<span class="comment">//遍历所有客户端对象</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> iter = _clients.<span class="built_in">begin</span>(); iter != _clients.<span class="built_in">end</span>();)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//检测是否到定时发送消息</span></span><br><span class="line">		<span class="keyword">if</span> (iter-&gt;second-&gt;<span class="built_in">CheckSend</span>(dt) == <span class="literal">true</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			iter-&gt;second-&gt;<span class="built_in">SendAll</span>();</span><br><span class="line">			iter-&gt;second-&gt;<span class="built_in">ResetDtSend</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		iter++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5：将内存池静态库分离"><a href="#5：将内存池静态库分离" class="headerlink" title="5：将内存池静态库分离"></a>5：将内存池静态库分离</h1><p>&emsp;&emsp;没什么好说的，简单在vs2019上建一个空项目，随后把项目属性改为静态库，随后把内存池源码搬过去就好。需要注意的一点是静态库分 <strong>Debug &#x2F; Release</strong> 版本，记得让源码连接合适的版本。</p>
<h1 id="※-项目源码-github"><a href="#※-项目源码-github" class="headerlink" title="※ - 项目源码 (github)"></a>※ - 项目源码 (github)</h1><p><strong>提交名：v1.0 定时检测</strong><br><a href="https://github.com/zgg2001/guguMeet">github项目连接</a><br><img src="/images/2021-05-08/1.jpg" alt="1"></p>
<ul>
<li><strong>guguServer</strong>为服务端项目</li>
<li><strong>guguAlloc</strong>为内存池静态库项目</li>
<li><strong>guguDll</strong>为相关动态库项目</li>
<li><strong>debugLib</strong>内为debug模式的静态库文件</li>
<li><strong>lib</strong>内为release模式的静态库和动态库文件</li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习记录：C++连接MySql数据库</title>
    <url>/2021/05/22/20210522_C++%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9AC++%E8%BF%9E%E6%8E%A5MySql%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<p>&emsp;&emsp;之前学习了MySql数据库相关的内容，但是并没有在编写C++代码中用到MySql相关内容。<br>&emsp;&emsp;本篇笔记记录了个人在 <strong>VS2019</strong> 中使用 <strong>C++</strong> 连接 <strong>MySql</strong> 数据库的过程。使C++代码中可以实现连接数据库、执行语句、显示查询结果等基础功能。</p>
<span id="more"></span>

<h1 id="一、基础准备"><a href="#一、基础准备" class="headerlink" title="一、基础准备"></a>一、基础准备</h1><h2 id="1-在目录中添加路径"><a href="#1-在目录中添加路径" class="headerlink" title="1. 在目录中添加路径"></a>1. 在目录中添加路径</h2><p>&emsp;&emsp;首先找到 <strong>MySql</strong> 所在的文件夹，其中有<code>include</code>和<code>lib</code>文件夹，随后打开VS项目属性页，把<code>include</code>文件夹路径填入 <strong>包含目录</strong> 内，把 <code>lib</code> 文件夹路径填入 <strong>库目录</strong> 内。<br><img src="/images/2021-05-22/1.jpg" alt="在这里插入图片描述"></p>
<p><img src="/images/2021-05-22/2.jpg" alt="在这里插入图片描述"></p>
<h2 id="2-添加依赖项"><a href="#2-添加依赖项" class="headerlink" title="2. 添加依赖项"></a>2. 添加依赖项</h2><p>&emsp;&emsp;在<code>lib</code>文件夹中找到这个<code>libmysql.lib</code>库文件，在VS项目属性页中，把该库文件添加至 <strong>附加依赖项</strong> 即可。<br><img src="/images/2021-05-22/3.jpg" alt="在这里插入图片描述"><br><img src="/images/2021-05-22/4.jpg" alt="在这里插入图片描述"></p>
<h2 id="3-移动DLL文件"><a href="#3-移动DLL文件" class="headerlink" title="3. 移动DLL文件"></a>3. 移动DLL文件</h2><p>&emsp;&emsp;为了使动态库可以正确被使用，我们需要把<code>lib</code>文件夹内的<code>libmysql.dll</code>文件复制到之后编译生成的可执行文件目录下，随后程序方可正常运行。<br><img src="/images/2021-05-22/5.jpg" alt="在这里插入图片描述"></p>
<h2 id="※-注意"><a href="#※-注意" class="headerlink" title="※ 注意"></a>※ 注意</h2><ol>
<li>注意自己的 <strong>MySQL</strong> 版本位数，由此在编译器中选择 <strong>32位&#x2F;64位</strong> 编译。</li>
<li>如果<code>libmysql.dll</code>文件放置的位置不对，会报错找不到<code>libmysql.dll</code>文件。</li>
</ol>
<h1 id="二、代码相关"><a href="#二、代码相关" class="headerlink" title="二、代码相关"></a>二、代码相关</h1><h2 id="0-基础"><a href="#0-基础" class="headerlink" title="0. 基础"></a>0. 基础</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MySQL的相关头文件是：</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mysql.h&gt;</span></span></span><br><span class="line">连接数据库：</span><br><span class="line"><span class="built_in">mysql_real_connect</span>(...);</span><br><span class="line">执行MySQL语句:</span><br><span class="line"><span class="built_in">mysql_query</span>(...);</span><br><span class="line">获取上一条MySQL语句执行结果：</span><br><span class="line"><span class="built_in">mysql_store_result</span>(...);</span><br><span class="line">获取上一条MySQL语句执行结果行数：</span><br><span class="line"><span class="built_in">mysql_affected_rows</span>(...);</span><br><span class="line"></span><br><span class="line">等等...</span><br></pre></td></tr></table></figure>
<h2 id="1-样例代码"><a href="#1-样例代码" class="headerlink" title="1. 样例代码"></a>1. 样例代码</h2><p>&emsp;&emsp;本测试代码实现了基础的连接数据库、执行数据库语句、输出查询结果等基础功能。</p>
<h3 id="mysql-h"><a href="#mysql-h" class="headerlink" title="mysql.h"></a><code>mysql.h</code></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MY_SQL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_SQL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;WinSock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mysql.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataBase</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">DataBase</span>();</span><br><span class="line">	~<span class="built_in">DataBase</span>();</span><br><span class="line">	<span class="comment">//连接数据库 参数为ip 用户名 密码 数据库名 端口</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">Connect</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* ip, <span class="type">const</span> <span class="type">char</span>* name, <span class="type">const</span> <span class="type">char</span>* cypher, <span class="type">const</span> <span class="type">char</span>* database_name, <span class="type">const</span> <span class="type">int</span> port)</span></span>;</span><br><span class="line">	<span class="comment">//获取表内的字段数</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetTableField</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* table_name)</span></span>;</span><br><span class="line">	<span class="comment">//查询表 参数为表名</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">Query</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* table_name)</span></span>;</span><br><span class="line">	<span class="comment">//自由执行指令</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">Implement</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* sentence)</span></span>;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">bool</span> _state;<span class="comment">//连接状态 true为已连接</span></span><br><span class="line">	MYSQL* _mysql;<span class="comment">//mysql连接  </span></span><br><span class="line">	MYSQL_FIELD* _fd;<span class="comment">//字段列数组  </span></span><br><span class="line">	<span class="type">char</span> _field[<span class="number">32</span>][<span class="number">32</span>];<span class="comment">//存字段名二维数组  </span></span><br><span class="line">	MYSQL_RES* _res;<span class="comment">//这个结构代表返回行的一个查询结果集  </span></span><br><span class="line">	MYSQL_ROW _column;<span class="comment">//一个行数据的类型安全(type-safe)的表示，表示数据行的列  </span></span><br><span class="line">	<span class="type">char</span> _query[<span class="number">150</span>];<span class="comment">//查询语句  </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !MY_SQL_H</span></span></span><br></pre></td></tr></table></figure>
<h3 id="mysql-cpp"><a href="#mysql-cpp" class="headerlink" title="mysql.cpp"></a><code>mysql.cpp</code></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mysql.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">DataBase::<span class="built_in">DataBase</span>()</span><br><span class="line">&#123;</span><br><span class="line">    _state = <span class="literal">false</span>;</span><br><span class="line">    _mysql = <span class="keyword">new</span> MYSQL; </span><br><span class="line">    _fd = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">memset</span>(_field, <span class="literal">NULL</span>, <span class="built_in">sizeof</span>(_field));</span><br><span class="line">    _res = <span class="literal">nullptr</span>;</span><br><span class="line">    _column = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">memset</span>(_query, <span class="literal">NULL</span>, <span class="built_in">sizeof</span>(_query));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DataBase::~<span class="built_in">DataBase</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DataBase::Connect</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* ip, <span class="type">const</span> <span class="type">char</span>* name, <span class="type">const</span> <span class="type">char</span>* cypher, <span class="type">const</span> <span class="type">char</span>* database_name, <span class="type">const</span> <span class="type">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span> == _state)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Database connected\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化mysql  </span></span><br><span class="line">    <span class="built_in">mysql_init</span>(_mysql);</span><br><span class="line">    <span class="comment">//返回false则连接失败，返回true则连接成功  </span></span><br><span class="line">    <span class="keyword">if</span> (!(<span class="built_in">mysql_real_connect</span>(_mysql, ip, name, cypher, database_name, port, <span class="literal">NULL</span>, <span class="number">0</span>))) <span class="comment">//中间分别是主机，用户名，密码，数据库名，端口号（可以写默认0或者3306等），可以先写成参数再传进去  </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error connecting to database:%s\n&quot;</span>, <span class="built_in">mysql_error</span>(_mysql));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        _state = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Connected succeed\n\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DataBase::GetTableField</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* table_name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span> == _state)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Database not connected\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查询内容</span></span><br><span class="line">    <span class="built_in">sprintf_s</span>(_query, <span class="string">&quot;desc %s&quot;</span>, table_name); <span class="comment">//desc 语句获取字段数</span></span><br><span class="line">    <span class="comment">//设置编码格式（SET NAMES GBK也行），否则cmd下中文乱码 </span></span><br><span class="line">    <span class="built_in">mysql_query</span>(_mysql, <span class="string">&quot;set names gbk&quot;</span>);</span><br><span class="line">    <span class="comment">//返回0 查询成功，返回1查询失败  </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mysql_query</span>(_mysql, _query))    <span class="comment">//执行SQL语句</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Query failed (%s)\n&quot;</span>, <span class="built_in">mysql_error</span>(_mysql));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取结果集  </span></span><br><span class="line">    <span class="keyword">if</span> (!(_res = <span class="built_in">mysql_store_result</span>(_mysql)))   <span class="comment">//获得sql语句结束后返回的结果集  </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Couldn&#x27;t get result from %s\n&quot;</span>, <span class="built_in">mysql_error</span>(_mysql));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//数据行数即为字段个数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mysql_affected_rows</span>(_mysql);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DataBase::Query</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* table_name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span> == _state)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Database not connected\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取字段数</span></span><br><span class="line">    <span class="type">int</span> field = <span class="built_in">GetTableField</span>(table_name);</span><br><span class="line">    <span class="comment">//查询内容</span></span><br><span class="line">    <span class="built_in">sprintf_s</span>(_query, <span class="string">&quot;select * from %s&quot;</span>, table_name); <span class="comment">//执行查询语句 </span></span><br><span class="line">    <span class="comment">//设置编码格式（SET NAMES GBK也行），否则cmd下中文乱码 </span></span><br><span class="line">    <span class="built_in">mysql_query</span>(_mysql, <span class="string">&quot;set names gbk&quot;</span>);</span><br><span class="line">    <span class="comment">//返回0 查询成功，返回1查询失败  </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mysql_query</span>(_mysql, _query))    <span class="comment">//执行SQL语句</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Query failed (%s)\n&quot;</span>, <span class="built_in">mysql_error</span>(_mysql));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;query success\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取结果集  </span></span><br><span class="line">    <span class="keyword">if</span> (!(_res = <span class="built_in">mysql_store_result</span>(_mysql)))   <span class="comment">//获得sql语句结束后返回的结果集  </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Couldn&#x27;t get result from %s\n&quot;</span>, <span class="built_in">mysql_error</span>(_mysql));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印数据行数  </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;number of dataline returned: %lld\n&quot;</span>, <span class="built_in">mysql_affected_rows</span>(_mysql));</span><br><span class="line">    <span class="comment">//获取字段的信息  </span></span><br><span class="line">    <span class="type">char</span>* str_field[<span class="number">32</span>];  <span class="comment">//定义一个字符串数组存储字段信息  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; field; i++)  <span class="comment">//在已知字段数量的情况下获取字段名  </span></span><br><span class="line">    &#123;</span><br><span class="line">        str_field[i] = <span class="built_in">mysql_fetch_field</span>(_res)-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; field; i++)  <span class="comment">//打印字段  </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%10s\t&quot;</span>, str_field[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="comment">//打印获取的数据  </span></span><br><span class="line">    <span class="keyword">while</span> (_column = <span class="built_in">mysql_fetch_row</span>(_res))   <span class="comment">//在已知字段数量情况下，获取并打印下一行  </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; field; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%10s\t&quot;</span>, _column[i]);  <span class="comment">//column是列数组  </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DataBase::Implement</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* sentence)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span> == _state)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Database not connected\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查询内容</span></span><br><span class="line">    <span class="built_in">sprintf_s</span>(_query, <span class="string">&quot;%s&quot;</span>, sentence); <span class="comment">//desc 语句获取字段数</span></span><br><span class="line">    <span class="comment">//设置编码格式（SET NAMES GBK也行），否则cmd下中文乱码 </span></span><br><span class="line">    <span class="built_in">mysql_query</span>(_mysql, <span class="string">&quot;set names gbk&quot;</span>);</span><br><span class="line">    <span class="comment">//执行SQL语句</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mysql_query</span>(_mysql, _query))    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Query failed (%s)\n&quot;</span>, <span class="built_in">mysql_error</span>(_mysql));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a><code>main.cpp</code></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;mysql.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DataBase* d1 = <span class="keyword">new</span> DataBase;</span><br><span class="line">	<span class="comment">//连接</span></span><br><span class="line">	d1-&gt;<span class="built_in">Connect</span>(<span class="string">&quot;localhost&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="comment">//查询表</span></span><br><span class="line">	d1-&gt;<span class="built_in">Query</span>(<span class="string">&quot;t_student&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="comment">//添加内容</span></span><br><span class="line">	d1-&gt;<span class="built_in">Implement</span>(<span class="string">&quot;insert into t_student values(201916010001, &#x27;赵四&#x27;, &#x27;2019-09-09&#x27;, now())&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="comment">//查询表</span></span><br><span class="line">	d1-&gt;<span class="built_in">Query</span>(<span class="string">&quot;t_student&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三、GitHub项目"><a href="#三、GitHub项目" class="headerlink" title="三、GitHub项目"></a>三、GitHub项目</h1><p><a href="https://github.com/zgg2001/MySql">点我跳转github</a></p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>C++网络编程学习：线程退出安全优化</title>
    <url>/2021/05/28/20210528_C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E7%BA%BF%E7%A8%8B%E9%80%80%E5%87%BA%E5%AE%89%E5%85%A8%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<ul>
<li>使用的语言为C&#x2F;C++</li>
<li>源码支持的平台为：Windows（本文中内容使用windows平台下vs2019开发，故本文项目不完全支持linux平台）</li>
</ul>
<p>C++网络编程学习：心跳机制与定时发送数据 &emsp;<a href="https://blog.csdn.net/qq_45698148/article/details/116487836">点我查看之前的代码开发记录</a></p>
<h1 id="0：本次增改方向"><a href="#0：本次增改方向" class="headerlink" title="0：本次增改方向"></a>0：本次增改方向</h1><ol>
<li>封装自己的线程类，使其可以控制线程及时关闭</li>
<li>使得程序可以按合适的顺序正常退出，避免因退出顺序问题引发崩溃</li>
</ol>
<span id="more"></span>

<h1 id="1：封装线程类相关"><a href="#1：封装线程类相关" class="headerlink" title="1：封装线程类相关"></a>1：封装线程类相关</h1><p>&emsp;&emsp;首先，为何要及时使得线程退出？因为我的<strong>接收、发送线程</strong>与<strong>主线程</strong>是分离的，当我在主线程中析构线程类时，线程中所使用的变量遂被释放，但此时接收、发送线程可能还未从上次循环中结束，仍然在调用已被释放的变量，此时就会出现崩溃等问题。所以我需要自己封装一个线程类，来实现对线程退出的控制，使得可以获得线程已经正常退出的信号，从而再安全的释放各种变量。<br>&emsp;&emsp;对此，该如何实现？首先可以采用本方法：即新建一个<code>bool</code>类型的信号量，在主线程发出关闭线程信号后，使用<code>while(1)</code>进行阻塞。当线程退出时，更改bool信号量的状态，当while(1)中检测到信号量发生变化后，则跳出循环解除阻塞，正常向下运行释放变量。伪代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">主线程内：</span><br><span class="line">&#123;</span><br><span class="line">	_state = <span class="literal">false</span>;<span class="comment">//线程是否运行</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(_semaphore == <span class="literal">true</span>)<span class="comment">//查看信号量状态</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	释放变量等;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">子线程内:</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(_state)</span><br><span class="line">	&#123;</span><br><span class="line">		工作;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;线程已退出\n&quot;</span>);</span><br><span class="line">	_semaphore = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如上，好处是可以确保线程可以按顺序退出，使得释放变量等操作不会出错。但是坏处是这个<code>while(1)</code>循环会占用大量的系统资源，影响程序效率。以及可能出现信号量未能正确变化，从而陷入死循环。首先是占用资源太多的问题，我们可以引用C++11中的<code>condition_variable</code>条件变量，其中含有的<code>wait()</code>可以减少资源消耗，且使用<code>notify_one()</code>可以进行唤醒。伪代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span><span class="comment">//条件变量</span></span></span><br><span class="line"></span><br><span class="line">std::condition_variable _cv;</span><br><span class="line"></span><br><span class="line">主线程内：</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;<span class="comment">//需上锁</span></span><br><span class="line">	_state = <span class="literal">false</span>;<span class="comment">//线程是否运行</span></span><br><span class="line">	_cv.<span class="built_in">wait</span>(lock);<span class="comment">//阻塞等待</span></span><br><span class="line">	释放变量等;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">子线程内:</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(_state)</span><br><span class="line">	&#123;</span><br><span class="line">		工作;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;线程已退出\n&quot;</span>);</span><br><span class="line">	_cv.<span class="built_in">notify_one</span>();<span class="comment">//唤醒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如上，阻塞资源消耗太大的问题已经得到了改善，接下来将着重于如何避免死循环状态。首先新建信号量类<code>CellSemaphore</code>，对信号量操作进行封装，使得线程类内可以直接调用信号量相关操作。结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CellSemaphore</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CellSemaphore</span>();</span><br><span class="line">	~<span class="built_in">CellSemaphore</span>();</span><br><span class="line">	<span class="comment">//开始阻塞</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//唤醒</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">wakeup</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//等待数</span></span><br><span class="line">	<span class="type">int</span> _wait = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//唤醒数</span></span><br><span class="line">	<span class="type">int</span> _wakeup = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//条件变量</span></span><br><span class="line">	std::condition_variable _cv;</span><br><span class="line">	<span class="comment">//锁</span></span><br><span class="line">	std::mutex _mutex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如上，<code>CellSemaphore</code>封装了<code>wait</code>和<code>wakeup</code>方法，通过调用这两个方法，即可实现阻塞与唤醒。而成员变量方面，我声明了一个等待计数器<code>_wait</code>和一个唤醒计数器<code>_wakeup</code>。每当成功调用<code>wakeup</code>方法，都会使等待计数器和唤醒计数器加一；而每当成功调用<code>wait</code>方法，都会使等待计数器和唤醒计数器减一。所以正常情况下，一组操作后，两个计数器的值都为0。而由此也可以判断不同的情况，比如当调用<code>wait</code>方法时，唤醒计数器的值大于0，则说明之前已经进行了唤醒操作，则直接跳过阻塞即可。而当调用<code>wakeup</code>方法时，若等待计数器数值不正常，则也直接跳过唤醒操作。相关代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//开始阻塞</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CellSemaphore::wait</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (--_wait &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//阻塞开始 等待唤醒</span></span><br><span class="line">		_cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]()-&gt;<span class="type">bool</span> </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> _wakeup &gt; <span class="number">0</span>;</span><br><span class="line">		&#125;);</span><br><span class="line">		--_wakeup;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//唤醒</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CellSemaphore::wakeup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (++_wait &lt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		++_wakeup;</span><br><span class="line">		_cv.<span class="built_in">notify_one</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;由此，信号量相关的封装完成了，接下来将进行线程类相关的封装。首先，线程类中需要有一个<code>CellSemaphore</code>信号量对象以便于我们对线程的掌握。其次，线程的基础函数：<strong>启动</strong><code>Start()</code>、<strong>关闭</strong><code>Close()</code>、<strong>退出</strong><code>Exit()</code>、<strong>是否运行</strong><code>isRun()</code>需要存在。接着，是最重要的线程<strong>工作函数</strong><code>OnWork()</code>。在工作函数<code>OnWork()</code>中，我预计执行三个匿名函数：_onCreate、_onRun、 _onDestory，这三个匿名函数分别执行<strong>线程创建时的操作</strong>、<strong>线程运行时的操作</strong>、<strong>线程销毁时的操作</strong>。最后还需要一个锁和一个bool变量来保证数据的正常更改以及线程运行状态的判定。线程类<code>CellThread</code>结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CellThread</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>(CellThread*)&gt; EventCall;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//启动线程</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">(EventCall onCreate = <span class="literal">nullptr</span>, EventCall onRun = <span class="literal">nullptr</span>, EventCall onDestory = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">	<span class="comment">//关闭线程</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Close</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//工作中退出</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Exit</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//是否运行中</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">isRun</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">//工作函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">OnWork</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//三个事件 匿名函数</span></span><br><span class="line">	EventCall _onCreate;</span><br><span class="line">	EventCall _onRun;</span><br><span class="line">	EventCall _onDestory;</span><br><span class="line">	<span class="comment">//改变数据时 需要加锁</span></span><br><span class="line">	std::mutex _mutex;</span><br><span class="line">	<span class="comment">//控制线程的终止与退出</span></span><br><span class="line">	CellSemaphore _semaphore;</span><br><span class="line">	<span class="comment">//线程是否启动</span></span><br><span class="line">	<span class="type">bool</span> _state = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在启动线程时，需要传入三个匿名函数(默认为空)；当关闭线程时，需要调用<code>wait()</code>方法；而当退出线程时，由于一般都是出现错误时调用该方法，所以不需要阻塞，直接停止线程即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//启动线程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CellThread::Start</span><span class="params">(EventCall onCreate, EventCall onRun, EventCall onDestory)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//上锁</span></span><br><span class="line">	<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (!_state)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//事件赋值</span></span><br><span class="line">		<span class="keyword">if</span> (onCreate)</span><br><span class="line">			_onCreate = onCreate;</span><br><span class="line">		<span class="keyword">if</span> (onRun)</span><br><span class="line">			_onRun = onRun;</span><br><span class="line">		<span class="keyword">if</span> (onDestory)</span><br><span class="line">			_onDestory = onDestory;</span><br><span class="line">		<span class="comment">//线程启动</span></span><br><span class="line">		_state = <span class="literal">true</span>;</span><br><span class="line">		<span class="function">std::thread <span class="title">t</span><span class="params">(std::mem_fn(&amp;CellThread::OnWork), <span class="keyword">this</span>)</span></span>;</span><br><span class="line">		t.<span class="built_in">detach</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭线程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CellThread::Close</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//上锁</span></span><br><span class="line">	<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (_state)</span><br><span class="line">	&#123;</span><br><span class="line">		_state = <span class="literal">false</span>;</span><br><span class="line">		_semaphore.<span class="built_in">wait</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//退出线程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CellThread::Exit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//上锁</span></span><br><span class="line">	<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (_state)</span><br><span class="line">	&#123;</span><br><span class="line">		_state = <span class="literal">false</span>;</span><br><span class="line">		<span class="comment">//这里的目的是退出线程 没必要阻塞等信号量</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线程是否运行</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CellThread::isRun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> _state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>OnWork</code>方法内按顺序依次执行三个匿名函数，当销毁阶段函数执行后，调用信号量类的唤醒操作，来告知线程已安全退出。由此，封装线程类相关操作已经完成。我们可以通过相关方法来更精准的操作线程。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CellThread::OnWork</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//开始事件</span></span><br><span class="line">	<span class="keyword">if</span> (_onCreate)</span><br><span class="line">		_onCreate(<span class="keyword">this</span>);</span><br><span class="line">	<span class="comment">//运行</span></span><br><span class="line">	<span class="keyword">if</span> (_onRun)</span><br><span class="line">		_onRun(<span class="keyword">this</span>);</span><br><span class="line">	<span class="comment">//销毁</span></span><br><span class="line">	<span class="keyword">if</span> (_onDestory)</span><br><span class="line">		_onDestory(<span class="keyword">this</span>);</span><br><span class="line">	_semaphore.<span class="built_in">wakeup</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2：退出顺序相关"><a href="#2：退出顺序相关" class="headerlink" title="2：退出顺序相关"></a>2：退出顺序相关</h1><p>&emsp;&emsp;在上文完成线程类的封装后，我对源码中的线程相关进行更换。如下，即为线程的创建与关闭操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//启动接收线程</span></span><br><span class="line">	_thread.<span class="built_in">Start</span>(</span><br><span class="line">		<span class="comment">//onCreate</span></span><br><span class="line">			<span class="literal">nullptr</span>,</span><br><span class="line">		<span class="comment">//onRun</span></span><br><span class="line">		[<span class="keyword">this</span>](CellThread*)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">OnRun</span>(&amp;_thread);<span class="comment">//工作函数OnRun</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="comment">//onDestory</span></span><br><span class="line">			<span class="literal">nullptr</span>);</span><br><span class="line"><span class="comment">//关闭接收线程</span></span><br><span class="line">	_thread.<span class="built_in">Close</span>();</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;接下来对程序退出的顺序进行规范，大制思路如下：</p>
<ol>
<li>在TcpServer(<strong>主线程</strong>)宣布程序退出时，首先对<strong>接收</strong>线程类进行析构，进入<strong>接收</strong>线程的析构函数。</li>
<li>在<strong>接收</strong>线程的析构函数中，首先对<strong>接收</strong>线程类中配套的<strong>发送</strong>线程类进行析构，进入<strong>发送</strong>线程的析构函数。</li>
<li>在<strong>发送</strong>线程的析构函数中，调用<strong>发送</strong>线程的<code>Close()</code>操作，在线程关闭后，释放<strong>发送</strong>线程内的相关变量。</li>
<li>在<strong>发送</strong>线程的析构结束后，调用<strong>接收</strong>线程的<code>Close()</code>操作，在线程关闭后，释放<strong>接收</strong>线程内的相关变量，随后挨个释放储存的客户端连接对象。</li>
<li>在释放客户端连接对象时，会进入其析构函数，进行释放相关变量以及关闭socket连接的操作。</li>
<li>此时<strong>接收</strong>线程的析构函数完毕，若还有未释放的<strong>接收</strong>线程，则重复上述操作。</li>
<li>当<strong>子线程</strong>全部析构后，回到第一步<strong>主线程</strong>的退出函数中，此时执行关闭主机socket、清除环境、释放变量等操作。</li>
<li>至此程序安全退出。</li>
</ol>
<p>&emsp;&emsp;具体更改就不一一叙述了，按照上述思路即可。下图为四条接收&#x2F;发送线程情况下，程序各部分的退出日志。其中exit为线程退出日志，start&#x2F;end为析构函数日志。<br><img src="/images/2021-05-28/1.jpg" alt="在这里插入图片描述"></p>
<h1 id="※-项目源码-github"><a href="#※-项目源码-github" class="headerlink" title="※ - 项目源码 (github)"></a>※ - 项目源码 (github)</h1><p><strong>提交名：v1.1 线程退出优化</strong><br><a href="https://github.com/zgg2001/guguMeet">github项目连接</a><br><img src="/images/2021-05-28/2.jpg" alt="在这里插入图片描述"></p>
<ul>
<li><strong>guguServer</strong>为服务端项目</li>
<li><strong>guguAlloc</strong>为内存池静态库项目</li>
<li><strong>guguDll</strong>为相关动态库项目</li>
<li><strong>debugLib</strong>内为debug模式的静态库文件</li>
<li><strong>lib</strong>内为release模式的静态库和动态库文件</li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习记录：C++连接Redis数据库</title>
    <url>/2021/05/23/20210523_C++%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9AC++%E8%BF%9E%E6%8E%A5Redis%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<p>&emsp;&emsp;之前学习了Redis数据库相关的内容，但是并没有在编写C++代码中用到Redis相关内容。<br>&emsp;&emsp;本篇笔记记录了个人在 <strong>Linux</strong> 环境下使用 <strong>C++</strong> 连接 <strong>Redis</strong> 数据库的过程。实现了一个简单的排行榜功能。<br>&emsp;&emsp;由于现在的主流是使用 <strong>java</strong> 连接 <strong>redis</strong>，所以在网上查询 <strong>C语言</strong> 的API消耗了一部分时间，在本篇笔记中，我将记录相关数据结构和API的使用方法。</p>
<span id="more"></span>

<h1 id="一、基础准备"><a href="#一、基础准备" class="headerlink" title="一、基础准备"></a>一、基础准备</h1><h2 id="1-找到hiredis-h"><a href="#1-找到hiredis-h" class="headerlink" title="1. 找到hiredis.h"></a>1. 找到<code>hiredis.h</code></h2><p>&emsp;&emsp;一般来讲，这个文件在你的redis文件夹下<code>deps/hiredis</code>目录中。将其<code>include</code>到源码中即可使用redis的API。<br><img src="/images/2021-05-23/1.jpg" alt="在这里插入图片描述"></p>
<h2 id="2-编译并且连接库"><a href="#2-编译并且连接库" class="headerlink" title="2. 编译并且连接库"></a>2. 编译并且连接库</h2><p>&emsp;&emsp;此时可以尝试写一个基础代码，随后编译。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*此文件位于redis文件夹下 test.cpp*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;deps/hiredis/hiredis.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;随后编译：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">g++ test.cpp -o test -l hiredis</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;若可以正常编译，则说明没问题。若是提示找不到hiredis库文件，则按下面进行操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先进入redis文件夹中，安装</span></span><br><span class="line"><span class="meta"># cd redis-x.x.xx</span></span><br><span class="line"><span class="meta"># make</span></span><br><span class="line"><span class="meta"># make install</span></span><br><span class="line"><span class="comment">//随后进入 redis/deps/hiredis 文件夹中，安装</span></span><br><span class="line"><span class="meta"># cd deps/hiredis/</span></span><br><span class="line"><span class="meta"># make</span></span><br><span class="line"><span class="meta"># make install</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;随后即可正常编译。</p>
<h2 id="3-运行"><a href="#3-运行" class="headerlink" title="3. 运行"></a>3. 运行</h2><p>&emsp;&emsp;找到上面编译生成的文件，运行，若成功执行即可跳过本节内容。<br>&emsp;&emsp;若提示找不到链接文件，则说明动态库无法被正确连接。则按下面步骤操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进入动态库链接文件</span></span><br><span class="line"><span class="meta"># vim /etc/ld.so.conf</span></span><br><span class="line"><span class="comment">//在新的一行中加入库文件所在目录</span></span><br><span class="line">添加： .../redis-x.x.x/deps/hiredis</span><br><span class="line"><span class="comment">//更新/etc/ld.so.cache文件</span></span><br><span class="line"><span class="meta"># ldconfig</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;随后即可正常运行编译生成的文件。</p>
<h1 id="二、代码相关"><a href="#二、代码相关" class="headerlink" title="二、代码相关"></a>二、代码相关</h1><h2 id="1-常用"><a href="#1-常用" class="headerlink" title="1. 常用"></a>1. 常用</h2><ul>
<li>建立redis连接<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">redisContext* myredis = <span class="built_in">redisConnect</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6379</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果 myredis-&gt;err = true，则说明连接失败</span></span><br><span class="line"><span class="comment">字符串 myredis-&gt;errstr 即为失败原因</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li>执行redis语句并接收结果<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">redisReply* reply = (redisReply*)<span class="built_in">redisCommand</span>(myredis, <span class="string">&quot;set zzz 1&quot;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">语句执行的结果，储存在 redisReply结构体类型 的 reply 中</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li>释放reply结构体<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">freeReplyObject</span>(reply);</span><br></pre></td></tr></table></figure></li>
<li>断开redis连接<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">redisFree</span>(myredis);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-redisReply结构体"><a href="#2-redisReply结构体" class="headerlink" title="2. redisReply结构体"></a>2. <code>redisReply</code>结构体</h2><p>&emsp;&emsp;我感觉这算是redis相关内容中比较重要的内容了，语句执行的结果全在这个结构体中。</p>
<ul>
<li>下面是这个结构体的定义：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">redisReply</span> &#123;</span><br><span class="line">    <span class="type">int</span> type; <span class="comment">/* 返回值类型 */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> integer; <span class="comment">/* 当返回类型为 REDIS_REPLY_INTEGER 时 */</span></span><br><span class="line">    <span class="type">size_t</span> len; <span class="comment">/* 返回的字符串长度 */</span></span><br><span class="line">    <span class="type">char</span> *str; <span class="comment">/* 当返回值类型为 REDIS_REPLY_ERROR 和 REDIS_REPLY_STRING */</span></span><br><span class="line">    <span class="type">size_t</span> elements; <span class="comment">/* 返回的数组长度 */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">redisReply</span> **element; <span class="comment">/* 当返回值类型为 REDIS_REPLY_ARRAY */</span></span><br><span class="line">&#125; redisReply;</span><br></pre></td></tr></table></figure>
<ul>
<li>type的类型</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">REDIS_REPLY_STRING： <span class="number">1</span> </span><br><span class="line">REDIS_REPLY_ARRAY： <span class="number">2</span></span><br><span class="line">REDIS_REPLY_INTEGER：<span class="number">3</span> </span><br><span class="line">REDIS_REPLY_NIL： <span class="number">4</span></span><br><span class="line">REDIS_REPLY_STATUS： <span class="number">5</span></span><br><span class="line">REDIS_REPLY_ERROR： <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>我们首先通过<code>type</code>来确认返回值的类型：</p>
<ol>
<li>返回值为1即为字符串，通过<code>reply-&gt;str</code>获取。</li>
<li>返回值为2即为数组，通过<code>reply-&gt;element</code>获取到redisReply数组，再遍历该数组，通过<code>type</code>正确获取其中信息。</li>
<li>返回值为3即为数字，通过<code>reply-&gt;integer</code>获取。</li>
<li>返回值为4即为空。</li>
<li>返回值为5即为执行语句的状态，通过<code>reply-&gt;str</code>获取，若结果为”OK”即为成功执行。</li>
<li>返回值为6即为执行错误。</li>
</ol>
<p>&emsp;&emsp;返回值的类型和执行语句的类型是相关的，例如我执行<code>get</code>命令，则<code>type</code>应该为1；若我执行<code>zrevrange</code>命令，则<code>type</code>应该为2。在下文中，我简单实现了一个排行榜功能，其中使用的结构为<code>sorted_set</code>，则其返回的排行榜结果<code>type</code>应为2，通过遍历其<code>element</code>数组，即可获取排行榜信息。</p>
<h1 id="三、一个简单的排行榜demo"><a href="#三、一个简单的排行榜demo" class="headerlink" title="三、一个简单的排行榜demo"></a>三、一个简单的排行榜demo</h1><h2 id="1-思路"><a href="#1-思路" class="headerlink" title="1. 思路"></a>1. 思路</h2><p>&emsp;&emsp;简单来说就是获取key和范围，使用<code>sprintf</code>拼接redis查询语句，通过返回的<code>redisReply</code>结构体输出结果。</p>
<h2 id="2-代码"><a href="#2-代码" class="headerlink" title="2. 代码"></a>2. 代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;deps/hiredis/hiredis.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">redisContext* myredis = <span class="keyword">new</span> redisContext;</span><br><span class="line">redisReply* reply = <span class="keyword">new</span> redisReply;</span><br><span class="line"><span class="type">char</span> query[<span class="number">150</span>];<span class="comment">//查询语句  </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_rank</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* key_name, <span class="type">int</span> start, <span class="type">int</span> stop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sprintf</span>(query, <span class="string">&quot;zrevrange %s %d %d&quot;</span>, key_name, start, stop);</span><br><span class="line">    reply = (redisReply *)<span class="built_in">redisCommand</span>(myredis, query);</span><br><span class="line">    <span class="comment">//printf(&quot;命令执行结果 reply type: %d\n&quot;, reply-&gt;type);</span></span><br><span class="line">    <span class="keyword">if</span> (reply-&gt;type == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;reply-&gt;elements;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(reply-&gt;element[i]-&gt;type != <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Error-Please check that the input is correct\n&quot;</span>);</span><br><span class="line">                <span class="built_in">freeReplyObject</span>(reply);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\nRANK:\n|----------|\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;| %2d -- %2s |\n&quot;</span>, i<span class="number">+1</span>, reply-&gt;element[i]-&gt;str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;|----------|\n\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error-Please check that the input is correct\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">freeReplyObject</span>(reply);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_rank_withscores</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* key_name, <span class="type">int</span> start, <span class="type">int</span> stop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   	<span class="built_in">sprintf</span>(query, <span class="string">&quot;zrevrange %s %d %d withscores&quot;</span>, key_name, start, stop);</span><br><span class="line">    reply = (redisReply *)<span class="built_in">redisCommand</span>(myredis, query);</span><br><span class="line">    <span class="comment">//printf(&quot;命令执行结果 reply type: %d\n&quot;, reply-&gt;type);</span></span><br><span class="line">    <span class="keyword">if</span> (reply-&gt;type == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;reply-&gt;elements;i+=<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(reply-&gt;element[i]-&gt;type != <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Error-Please check that the input is correct\n&quot;</span>,reply-&gt;element[i]-&gt;type);</span><br><span class="line">                <span class="built_in">freeReplyObject</span>(reply);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\nRANK:\n|-----------------|\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;| %2d -- %2s -- %3s |\n&quot;</span>, i/<span class="number">2</span><span class="number">+1</span>, reply-&gt;element[i]-&gt;str, reply-&gt;element[i<span class="number">+1</span>]-&gt;str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;|-----------------|\n\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error-Please check that the input is correct\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">freeReplyObject</span>(reply);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    myredis = <span class="built_in">redisConnect</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">    <span class="keyword">if</span>(myredis-&gt;err)<span class="comment">//if error</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Connection Error:&quot;</span> &lt;&lt; myredis-&gt;errstr &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//查询key:score的前十名</span></span><br><span class="line">    <span class="built_in">get_rank</span>(<span class="string">&quot;score&quot;</span>, <span class="number">0</span>, <span class="number">9</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//查询key:score的前十名 并且带上分数</span></span><br><span class="line">    <span class="built_in">get_rank_withscores</span>(<span class="string">&quot;score&quot;</span>, <span class="number">0</span> ,<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">redisFree</span>(myredis);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-执行结果"><a href="#3-执行结果" class="headerlink" title="3. 执行结果"></a>3. 执行结果</h2><p>（上为不带分数 下为带分数）<br><img src="/images/2021-05-23/2.jpg" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql学习记录：基础总结</title>
    <url>/2021/03/22/20210322_MySql%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>&emsp;&emsp;本文将个人在MySql数据库学习中记录的知识点进行了总结，方便日后的复习以及对明年春招实习的准备。</p>
<span id="more"></span>

<h1 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h1><p>启动&#x2F;停止MySql服务：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">net <span class="keyword">start</span><span class="operator">/</span>stop mysql;</span><br></pre></td></tr></table></figure>
<p>MySql登录：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">-</span>u用户 <span class="operator">-</span>p密码</span><br><span class="line"></span><br><span class="line">此处推荐先不填密码直接回车，随后输入密码。因为上面直接输入密码有密码泄露的风险。</span><br><span class="line">mysql <span class="operator">-</span>u用户 <span class="operator">-</span>p</span><br><span class="line">Enter password: <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br></pre></td></tr></table></figure>
<p>MySql中数据类型：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="type">varchar</span>		可变长度字符串 智能节省空间 但是速度慢</span><br><span class="line"><span class="type">char</span>		不可变长度字符串 速度快 但是不会智能节省空间	</span><br><span class="line"><span class="type">int</span> 		整数型(<span class="number">11</span>)</span><br><span class="line"><span class="type">bigint</span>		长整型</span><br><span class="line"><span class="type">float</span>		单精度浮点数</span><br><span class="line"><span class="keyword">double</span>		双精度浮点数</span><br><span class="line"><span class="type">date</span>		短日期	年<span class="operator">-</span>月<span class="operator">-</span>日		 	<span class="operator">%</span>Y<span class="operator">-</span><span class="operator">%</span>m<span class="operator">-</span><span class="operator">%</span>d</span><br><span class="line">datetime	长日期	年<span class="operator">-</span>月<span class="operator">-</span>日 时:分:秒 	<span class="operator">%</span>Y<span class="operator">-</span><span class="operator">%</span>m<span class="operator">-</span><span class="operator">%</span>d <span class="operator">%</span>h:<span class="operator">%</span>i:<span class="operator">%</span>s</span><br><span class="line"><span class="type">clob</span>		字符大对象 最大<span class="number">4</span>G字符串 超过<span class="number">255</span>字节的都用它</span><br><span class="line"><span class="type">blob</span>		图片、声音、视频的等媒体二进制数据</span><br></pre></td></tr></table></figure>
<p>导入&#x2F;导出数据库文件：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#导出数据库</span><br><span class="line">mysqldump 库<span class="operator">/</span>表 <span class="operator">&gt;</span> 地址.<span class="keyword">sql</span> <span class="operator">-</span>uroot <span class="operator">-</span>p密码;</span><br><span class="line"></span><br><span class="line">#导入数据库</span><br><span class="line">source 地址;</span><br></pre></td></tr></table></figure>

<h1 id="二、关键字-show-use-describe"><a href="#二、关键字-show-use-describe" class="headerlink" title="二、关键字 show / use / describe"></a>二、关键字 <code>show / use / describe</code></h1><h2 id="1-show"><a href="#1-show" class="headerlink" title="1. show"></a>1. show</h2><p>查看所有数据库：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> databases;</span><br></pre></td></tr></table></figure>
<p>查看当前库的表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> tables;</span><br></pre></td></tr></table></figure>
<p>查看数据库支持的储存引擎：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">写法一：<span class="keyword">show</span> engines;</span><br><span class="line">写法二：<span class="keyword">show</span> engines \g</span><br><span class="line">写法三：<span class="keyword">show</span> engines \G</span><br><span class="line"></span><br><span class="line">写法一和二结果是一样的，写法三是以每一行来显示。因为\g和;都是结束符，所以加一个即可。</span><br></pre></td></tr></table></figure>
<p>查看数据库变量：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;have%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#此句即为模糊搜索have开头的变量。</span><br></pre></td></tr></table></figure>
<p>查看建表语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> 表名;</span><br><span class="line"></span><br><span class="line">#其中最下面一行信息为：使用的储存引擎、默认编码方式</span><br><span class="line">ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_0900_ai_ci</span><br></pre></td></tr></table></figure>
<h2 id="2-use"><a href="#2-use" class="headerlink" title="2. use"></a>2. use</h2><p>选择使用数据库：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use 数据库名;</span><br></pre></td></tr></table></figure>

<h2 id="3-describe"><a href="#3-describe" class="headerlink" title="3. describe"></a>3. describe</h2><p>查看表结构：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">describe</span> 表名;</span><br><span class="line"><span class="keyword">desc</span> 表名; (缩写)</span><br></pre></td></tr></table></figure>

<h1 id="三、关键字-create-drop-alter"><a href="#三、关键字-create-drop-alter" class="headerlink" title="三、关键字 create / drop / alter"></a>三、关键字 <code>create / drop / alter</code></h1><h2 id="1-create"><a href="#1-create" class="headerlink" title="1. create"></a>1. create</h2><p>创建数据库：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database 数据库名;</span><br></pre></td></tr></table></figure>
<p>创建表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#表名推荐 t_ 或 tbl_ 开头  数据类型看最上面</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名( </span><br><span class="line">	字段<span class="number">1</span> 数据类型<span class="number">1</span> <span class="keyword">default</span> 默认值(可选),</span><br><span class="line">	字段<span class="number">2</span> 数据类型<span class="number">2</span> 列级约束(可选),</span><br><span class="line">	字段<span class="number">3</span> 数据类型<span class="number">3</span>,</span><br><span class="line">	...</span><br><span class="line">	表级约束(可选), #约束的内容在后面</span><br><span class="line">	)</span><br><span class="line">	ENGINE<span class="operator">=</span>指定引擎 <span class="keyword">default</span> CHARSET<span class="operator">=</span>指定字符编码方式 #此句可选</span><br><span class="line">	;</span><br><span class="line">	</span><br><span class="line">	MySql默认储存引擎为：InnoDB</span><br><span class="line">	默认字符编码方式为：utf8mb4</span><br><span class="line"></span><br><span class="line">#将一个<span class="keyword">select</span>查询结构建立为新表</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名 <span class="keyword">as</span> <span class="keyword">select</span> _______; </span><br></pre></td></tr></table></figure>
<h2 id="2-drop"><a href="#2-drop" class="headerlink" title="2. drop"></a>2. drop</h2><p>删除数据库：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> database 数据库名;</span><br><span class="line"><span class="keyword">drop</span> database if <span class="keyword">exists</span> 数据库名; #如果数据库存在则进行删库操作</span><br></pre></td></tr></table></figure>
<p>删除表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> 表名;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> 表名; #如果表存在则进行删表操作</span><br></pre></td></tr></table></figure>
<h2 id="3-alter"><a href="#3-alter" class="headerlink" title="3. alter"></a>3. alter</h2><p>改表名：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 老名字 rename 新名字;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 老名字 rename <span class="keyword">to</span> 新名字;</span><br></pre></td></tr></table></figure>
<p>改字段名：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 change 原字段名 新字段名 数据类型;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 change <span class="keyword">column</span> 原字段名 新字段名 数据类型;</span><br></pre></td></tr></table></figure>
<p>添加字段：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> <span class="keyword">column</span> 字段名 数据类型;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> <span class="keyword">column</span> 字段名 数据类型 after 字段名;</span><br></pre></td></tr></table></figure>

<p>删除字段：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> <span class="keyword">column</span> 字段名;</span><br></pre></td></tr></table></figure>
<h1 id="四、分组函数"><a href="#四、分组函数" class="headerlink" title="四、分组函数"></a>四、分组函数</h1><h2 id="1-单行处理函数"><a href="#1-单行处理函数" class="headerlink" title="1. 单行处理函数"></a>1. 单行处理函数</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>中函数使用:</span><br><span class="line"><span class="keyword">select</span> 函数(字段名) <span class="keyword">from</span> 表名;</span><br><span class="line"></span><br><span class="line"><span class="built_in">lower</span>(数据)									全小写</span><br><span class="line"><span class="built_in">upper</span>(数据)									全大写</span><br><span class="line">substr(数据,起始下标,长度)					取字符串		#和c<span class="operator">+</span><span class="operator">+</span>的substr差不多 不过下标是从<span class="number">1</span>开始</span><br><span class="line">length(数据)								取长度</span><br><span class="line">str_to_date(数据,<span class="string">&#x27;格式&#x27;</span>)						字符串转日期 </span><br><span class="line">date_format(数据,<span class="string">&#x27;格式&#x27;</span>)						格式化日期</span><br><span class="line">format(数据,保留小数位数,分隔符位置(可选))	格式化</span><br><span class="line">round(数据)									四舍五入</span><br><span class="line">rand()										取随机数</span><br><span class="line">ifnull(数据,变值)							把<span class="keyword">null</span>转为具体值</span><br><span class="line">concat(数据<span class="number">1</span>，数据<span class="number">2</span>,...)						拼接字符串</span><br><span class="line"><span class="built_in">trim</span>(数据)									去前后空格</span><br></pre></td></tr></table></figure>
<h2 id="2-多行处理函数"><a href="#2-多行处理函数" class="headerlink" title="2. 多行处理函数"></a>2. 多行处理函数</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">单行处理函数即为：对某一字段一行的数据进行处理</span><br><span class="line">多行处理函数即为：对该字段下所有数据进行处理</span><br><span class="line"></span><br><span class="line"><span class="built_in">count</span>(字段)			计数 即统计数据个数	<span class="built_in">count</span>(<span class="operator">*</span>)为总行数</span><br><span class="line"><span class="built_in">sum</span>(字段)			求和</span><br><span class="line"><span class="built_in">avg</span>(字段)			平均值</span><br><span class="line"><span class="built_in">max</span>(字段)			最大值</span><br><span class="line"><span class="built_in">min</span>(字段)			最小值</span><br></pre></td></tr></table></figure>
<h1 id="五、关键字-select-distinct-及查询相关"><a href="#五、关键字-select-distinct-及查询相关" class="headerlink" title="五、关键字 select  / distinct 及查询相关"></a>五、关键字 <code>select  / distinct</code> 及查询相关</h1><h2 id="1-select"><a href="#1-select" class="headerlink" title="1. select"></a>1. select</h2><p>查看版本号：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> version();</span><br></pre></td></tr></table></figure>
<p>查看当前选择的数据库：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> database();</span><br></pre></td></tr></table></figure>
<p>查看表:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#查多个字段则逗号隔开</span><br><span class="line"><span class="keyword">select</span> 字段名(<span class="keyword">as</span> 别名) <span class="keyword">from</span> 表名;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名; #查看整张表 </span><br></pre></td></tr></table></figure>
<h2 id="2-distinct"><a href="#2-distinct" class="headerlink" title="2. distinct"></a>2. distinct</h2><p>去重关键字：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> 字段名<span class="number">1</span>,字段名<span class="number">2</span>,... <span class="keyword">from</span> 表名;</span><br><span class="line"></span><br><span class="line">字段内容去重，该关键字只能放在最前面，表示对后面 字段集合 查询结果进行去重。</span><br></pre></td></tr></table></figure>
<h2 id="3-查询语句顺序"><a href="#3-查询语句顺序" class="headerlink" title="3. 查询语句顺序"></a>3. 查询语句顺序</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">语法顺序：</span><br><span class="line">select... 		查询</span><br><span class="line">from...			获取数据</span><br><span class="line">where...		筛选</span><br><span class="line"><span class="keyword">group</span> by...		分组</span><br><span class="line">having...		分组后筛选</span><br><span class="line"><span class="keyword">order</span> by...		排序</span><br><span class="line">limit...		取指定条数数据</span><br><span class="line"></span><br><span class="line">执行顺序：</span><br><span class="line">from...			获取数据</span><br><span class="line">where...		筛选</span><br><span class="line"><span class="keyword">group</span> by...		分组</span><br><span class="line">having...		分组后筛选</span><br><span class="line">select...		查询</span><br><span class="line"><span class="keyword">order</span> by...		排序</span><br><span class="line">limit...		取指定条数数据</span><br></pre></td></tr></table></figure>
<h2 id="4-条件查询相关"><a href="#4-条件查询相关" class="headerlink" title="4. 条件查询相关"></a>4. 条件查询相关</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">条件查询关键字：<span class="keyword">where</span></span><br><span class="line">例：<span class="keyword">select</span> 字段 <span class="keyword">from</span> 表 <span class="keyword">where</span> 字段 <span class="operator">=</span> 值;</span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span>					小于</span><br><span class="line"><span class="operator">&lt;=</span>					小于等于</span><br><span class="line"><span class="operator">&gt;</span>					大于</span><br><span class="line"><span class="operator">&gt;=</span>					大于等于</span><br><span class="line"><span class="operator">!=</span> 或 <span class="operator">&lt;&gt;</span>			不等于</span><br><span class="line">between...and...	两个值之间，即 <span class="operator">&gt;=</span> <span class="keyword">and</span> <span class="operator">&lt;=</span></span><br><span class="line"><span class="keyword">is</span> <span class="keyword">null</span>				为空 </span><br><span class="line"><span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span> 		不为空</span><br><span class="line"><span class="keyword">and</span>					并且</span><br><span class="line"><span class="keyword">or</span>					或者</span><br><span class="line"><span class="keyword">in</span>(值<span class="number">1</span>,值<span class="number">2</span>,...)		包含</span><br><span class="line"><span class="keyword">not</span> <span class="keyword">in</span>(值<span class="number">1</span>,值<span class="number">2</span>,...)	不包含</span><br><span class="line"><span class="keyword">not</span>					可以取非 主要用于 <span class="keyword">in</span> 和 <span class="keyword">is</span> 中</span><br><span class="line"><span class="keyword">like</span>				模糊搜索 <span class="operator">%</span>为多个字符 _为一个字符 例：<span class="operator">%</span>z<span class="operator">%</span> 即为包含z的字符串</span><br></pre></td></tr></table></figure>
<h2 id="5-分组查询相关"><a href="#5-分组查询相关" class="headerlink" title="5. 分组查询相关"></a>5. 分组查询相关</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">多行处理函数的原理是先对数据进行分组，随后对该组数据进行处理。</span><br><span class="line">所以多行处理函数需要在分组后才能使用(会默认进行分组)。</span><br><span class="line"></span><br><span class="line">所以在<span class="keyword">where</span>语句后面无法使用多行处理函数。</span><br><span class="line">因为此时还没进行分组操作，详情请看上面的执行顺序。</span><br><span class="line"></span><br><span class="line">当你需要对函数操作后的数据进行判断时，例如该行数据是否等于此组数据的平均值，就需要使用<span class="keyword">group</span> <span class="keyword">by</span>进行分组。</span><br><span class="line">分组后，使用<span class="keyword">having</span>进行判定。</span><br><span class="line"></span><br><span class="line">例：<span class="keyword">select</span> count,name <span class="keyword">from</span> t_student <span class="keyword">group</span> <span class="keyword">by</span> count,name <span class="keyword">having</span> count <span class="operator">=</span> <span class="built_in">avg</span>(count);</span><br><span class="line">此句中，对分数与姓名进行分组，当分数等于分数的平均值时，输出学生姓名与分数。</span><br><span class="line"></span><br><span class="line">注：<span class="keyword">group</span> <span class="keyword">by</span>分组后，<span class="keyword">select</span>后只能跟参加分组的字段，以及分组函数。</span><br></pre></td></tr></table></figure>
<p><strong>重点：</strong> having的效率是偏低的，我们尽量用where进行筛选。where实在实现不了时，再用having进行筛选。</p>
<h2 id="6-连接查询相关"><a href="#6-连接查询相关" class="headerlink" title="6. 连接查询相关"></a>6. 连接查询相关</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">当我们需要对多张表的内容进行查询汇总时，例如取表<span class="number">1</span>里的a字段与表<span class="number">2</span>里的b字段，就需要进行表的连接。</span><br><span class="line"></span><br><span class="line">表的连接分为内连接和外连接。而连接的机制类似两个集合相乘，所以当无限制连接查询时，会产生笛卡尔积现象。</span><br><span class="line"></span><br><span class="line">我们尽量要少进行表的连接，因为过多的连接会大大增大遍历的次数。</span><br></pre></td></tr></table></figure>
<ul>
<li>内连接<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span>即为内连接，内连接查询后的结果不含<span class="keyword">NULL</span>，只包含符合条件的结果。</span><br><span class="line"></span><br><span class="line">SQL99写法: (推荐)                       	SQL92写法: (不推荐)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> 字段								<span class="keyword">select</span> 字段</span><br><span class="line"><span class="keyword">from</span> 表<span class="number">1</span>,								<span class="keyword">from</span> 表<span class="number">1</span>,表<span class="number">2</span></span><br><span class="line">(<span class="keyword">inner</span>)<span class="keyword">join</span> 表<span class="number">2</span>,						<span class="keyword">where</span> 条件;</span><br><span class="line"><span class="keyword">on</span> 条件(连接条件),</span><br><span class="line"><span class="keyword">where</span> 条件(查询条件);</span><br><span class="line"></span><br><span class="line">可以看出，sql99语法将连接条件分离出来，使连接操作更加清晰明了。</span><br></pre></td></tr></table></figure></li>
<li>外连接<br><img src="/images/2021-03-22/1.jpg" alt="外连接"><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">outer</span> <span class="keyword">join</span>即为外连接，外连接中分为左外连接与右外连接。</span><br><span class="line">如上图，左<span class="operator">/</span>右即为包含左<span class="operator">/</span>右表的全部内容，以及另外一张表里符合条件的内容。</span><br><span class="line"></span><br><span class="line">外连接结果去掉含<span class="keyword">NULL</span>的结果，即为内连接查询结果。</span><br><span class="line"></span><br><span class="line">左外连接：                				右外连接：    </span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> 字段								<span class="keyword">select</span> 字段</span><br><span class="line"><span class="keyword">from</span> 表<span class="number">1</span>,								<span class="keyword">from</span> 表<span class="number">1</span>,	</span><br><span class="line"><span class="keyword">left</span> (<span class="keyword">outer</span>) <span class="keyword">join</span> 表<span class="number">2</span>,					<span class="keyword">right</span> (<span class="keyword">outer</span>) <span class="keyword">join</span> 表<span class="number">2</span>,		</span><br><span class="line"><span class="keyword">on</span> 条件(连接条件),						<span class="keyword">on</span> 条件(连接条件),</span><br><span class="line"><span class="keyword">where</span> 条件(查询条件);					<span class="keyword">where</span> 条件(查询条件);</span><br><span class="line"></span><br><span class="line">当查询中不存在主表，只需要符合条件的结果时，使用内连接。</span><br><span class="line">当存在主表，需要依据主表得出结果时，使用外连接。</span><br></pre></td></tr></table></figure>
&emsp;&emsp;<strong>一个连接查询语句中，可以连接多个表，且内连接和外连接可以混合。</strong></li>
<li>union 合并</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> _________</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> _________;</span><br><span class="line"></span><br><span class="line">将两次查询的结果合并，要求列数相同，数据类型一致。</span><br><span class="line">好处是减少连接，效率高。</span><br></pre></td></tr></table></figure>
<h2 id="7-order-by-与-limit"><a href="#7-order-by-与-limit" class="headerlink" title="7. order by 与 limit"></a>7. order by 与 limit</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> 字段名 <span class="keyword">desc</span>; 	降序排序</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> 字段名 <span class="keyword">asc</span>; 	升序排序(默认)</span><br><span class="line"></span><br><span class="line">limit 起始下标,长度;		显示从起始下标开始的指定数量信息。起始下标从<span class="number">0</span>开始。(这个重要)</span><br></pre></td></tr></table></figure>
<h1 id="六、关键字-insert-update-delete"><a href="#六、关键字-insert-update-delete" class="headerlink" title="六、关键字 insert  / update / delete"></a>六、关键字 <code>insert  / update / delete</code></h1><h2 id="1-insert"><a href="#1-insert" class="headerlink" title="1. insert"></a>1. insert</h2><p> 插入数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名(字段<span class="number">1</span>,字段<span class="number">2</span>,...) <span class="keyword">values</span> (值<span class="number">1</span>,值<span class="number">2</span>,...);</span><br><span class="line"></span><br><span class="line">#表名后面那一部分可以省略，如省略则等于全写，后面值 得按顺序写全。</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名 <span class="keyword">values</span> (值<span class="number">1</span>,值<span class="number">2</span>,...);</span><br><span class="line"></span><br><span class="line">#同时插入多条数据</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名(字段<span class="number">1</span>,字段<span class="number">2</span>,...) <span class="keyword">values</span> (值<span class="number">1</span>,值<span class="number">2</span>,...),(值<span class="number">1</span>,值<span class="number">2</span>,...),(值<span class="number">1</span>,值<span class="number">2</span>,...);</span><br></pre></td></tr></table></figure>
<h2 id="2-update"><a href="#2-update" class="headerlink" title="2. update"></a>2. update</h2><p> 修改数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> 表名 <span class="keyword">set</span> 字段<span class="number">1</span><span class="operator">=</span>值<span class="number">1</span>,字段<span class="number">2</span><span class="operator">=</span>值<span class="number">2</span>,... <span class="keyword">where</span> 条件;</span><br><span class="line"></span><br><span class="line">如果无条件，则对整张表进行修改</span><br></pre></td></tr></table></figure>
<h2 id="3-delete-与-truncate"><a href="#3-delete-与-truncate" class="headerlink" title="3. delete 与 truncate"></a>3. delete 与 truncate</h2><p> 删除数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#条件删除</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 条件;</span><br><span class="line">空间不释放，效率低，但是在开启事务时支持回滚。</span><br><span class="line"></span><br><span class="line">#此为删除整张表 </span><br><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> 表名;</span><br><span class="line">物理删除，非常快，但是不支持回滚。</span><br></pre></td></tr></table></figure>
<h1 id="七、约束"><a href="#七、约束" class="headerlink" title="七、约束"></a>七、约束</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">约束一共有四种：</span><br><span class="line"></span><br><span class="line">非空约束：		<span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">唯一性约束：		<span class="keyword">unique</span></span><br><span class="line">主键约束：		<span class="keyword">primary</span> key</span><br><span class="line">外键约束：		<span class="keyword">foreign</span> key</span><br><span class="line"></span><br><span class="line">列级约束：直接<span class="keyword">create</span>建表时在字段后加。</span><br><span class="line">表级约束：在建表语句后面添加，详情看上面的<span class="keyword">create</span>关键字相关。</span><br></pre></td></tr></table></figure>
<ul>
<li>not null<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">顾名思义，添加此约束后，此字段不能为空。</span><br></pre></td></tr></table></figure></li>
<li>unique<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">添加此约束后，该字端内容唯一，不会重复。在尝试<span class="keyword">insert</span>重复信息后，会报错。</span><br><span class="line">可以 <span class="keyword">unique</span>(字段<span class="number">1</span>,字段<span class="number">2</span>,...) 添加联合唯一表级约束。</span><br></pre></td></tr></table></figure></li>
<li>primary key<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">主键约束即为 不可重复 且 不为空。</span><br><span class="line">mysql中同时添加非空约束和唯一约束，则自动添加主键约束。</span><br><span class="line"><span class="keyword">primary</span> key auto_increment 自增主键，从<span class="number">1</span>开始。</span><br><span class="line">主键分为 业务主键 和 自然主键(和业务无关)，一般推荐自然主键，方便日后的修改。</span><br></pre></td></tr></table></figure></li>
<li>foreign key<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">外键约束即为将 此字段 与 另外一张表内的指定字段 相关。</span><br><span class="line">使得该字段内的值，只能为另外一张表内的指定字段的内容。</span><br><span class="line"><span class="keyword">foreign</span> key(字段) <span class="keyword">references</span> 表名(字段) #添加外键约束</span><br><span class="line">			 子					  父</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="八、事务"><a href="#八、事务" class="headerlink" title="八、事务"></a>八、事务</h1><h2 id="1-transaction"><a href="#1-transaction" class="headerlink" title="1. transaction"></a>1. transaction</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">事务即为 <span class="string">&#x27;一个完整的业务逻辑&#x27;</span> ，是最小工作单元。</span><br><span class="line">批量的DML语句 同时成功 或 同时失败，即为事务transaction。</span><br><span class="line"> (即增删改)</span><br><span class="line"> </span><br><span class="line">#首先应该开启事务</span><br><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"></span><br><span class="line">#提交事务	相当于存档</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line">#回滚事务	相当于读档</span><br><span class="line"><span class="keyword">rollback</span>;</span><br><span class="line"></span><br><span class="line">特性：</span><br><span class="line">原子性 ———— 最小工作单元，不可分</span><br><span class="line">一致性 ———— 同时成功<span class="operator">/</span>失败</span><br><span class="line">隔离性 ———— 两事务直接存在隔离</span><br><span class="line">持久性 ———— 事务结束的一个保障</span><br></pre></td></tr></table></figure>
<h2 id="2-隔离级别"><a href="#2-隔离级别" class="headerlink" title="2. 隔离级别"></a>2. 隔离级别</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">事务隔离级别一共有四种：</span><br><span class="line"><span class="number">1.</span>read uncommited	读未提交</span><br><span class="line"><span class="number">2.</span>read commited		读已提交</span><br><span class="line"><span class="number">3.</span>repeatable read	可重复读(mysql默认隔离级别)</span><br><span class="line"><span class="number">4.</span>serializable		序列化<span class="operator">/</span>串行化</span><br><span class="line">以上四种级别，隔离程度由低到高。</span><br><span class="line"></span><br><span class="line">#设置级别</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> transaction level 级别;</span><br><span class="line"></span><br><span class="line">#查看当前隔离级别</span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@tx_isolation</span>;</span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@transaction_isolation</span>;</span><br><span class="line">以上有一个可用。</span><br></pre></td></tr></table></figure>
<ul>
<li>read uncommited<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">事务A可读取到事务B的未提交数据。</span><br><span class="line">也就是说事务B输入了DML语句，但是没有<span class="keyword">commit</span>，从事务A中也可以读到没有<span class="keyword">commit</span>的结果。</span><br><span class="line">可能造成<span class="string">&#x27;脏读&#x27;</span>，即读入脏数据。</span><br></pre></td></tr></table></figure></li>
<li>read commited<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">事务A只可读取到事务B提交后的数据。</span><br><span class="line">即事务A中只可以读到事务B <span class="keyword">commit</span>后的结果。</span><br></pre></td></tr></table></figure></li>
<li>repeatable read<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">事务A读取一次数据后，以后每次读取数据都和第一次读到的数据一样(开启事务时的数据)。</span><br><span class="line">即使事务B <span class="keyword">commit</span>数据后，事务A读取到的还是一开始的数据。</span><br><span class="line">应用场景为：事务A只想查询一个时间的数据，随后<span class="keyword">commit</span>的数据不影响事务A的查询。</span><br><span class="line">由此可能造成<span class="string">&#x27;幻影读&#x27;</span>。</span><br></pre></td></tr></table></figure></li>
<li>serializable<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">最强的隔离，当事务B未<span class="keyword">commit</span>时，事务A查不到东西。</span><br><span class="line">即事务不可并发执行，效率最低，但是隔离性最高。</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="九、视图"><a href="#九、视图" class="headerlink" title="九、视图"></a>九、视图</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">视图相当于一个<span class="string">&#x27;表&#x27;</span>，由一个DQL语句查询结果建成。</span><br><span class="line">与表不同的是，在对视图对象进行增删改时，原表上的数据也会发生改变。</span><br><span class="line"></span><br><span class="line">所以我们可以面向视图更新原表。</span><br><span class="line">好处是利于维护，简化开发。</span><br><span class="line"></span><br><span class="line">#建立视图</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> 视图名 <span class="keyword">as</span> <span class="keyword">select</span> ______;</span><br><span class="line"></span><br><span class="line">#删除视图</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> 视图名;</span><br></pre></td></tr></table></figure>

<h1 id="十、索引"><a href="#十、索引" class="headerlink" title="十、索引"></a>十、索引</h1><h2 id="1-关于索引"><a href="#1-关于索引" class="headerlink" title="1. 关于索引"></a>1. 关于索引</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">查询有两种：</span><br><span class="line"><span class="number">1.</span>全表查询</span><br><span class="line"><span class="number">2.</span>根据索引检索</span><br><span class="line"></span><br><span class="line">索引index 由B<span class="operator">-</span>Tree实现底层，通过地址查询。</span><br><span class="line">主键会自动添加索引，<span class="keyword">unique</span>也会。</span><br><span class="line"></span><br><span class="line">索引分类：</span><br><span class="line">单一索引 	———— 	一个字段上添加索引。</span><br><span class="line">复合索引 	————	两个字段或者更多的字段上添加索引。</span><br><span class="line">主键索引 	————	主键上添加索引。</span><br><span class="line">唯一性索引	————	具有<span class="keyword">unique</span>约束的字段上添加索引。</span><br><span class="line">注意:唯一性比较弱的字段上添加索引用处不大。</span><br><span class="line"></span><br><span class="line">添加索引的前提：</span><br><span class="line"><span class="number">1.</span>数据量庞大</span><br><span class="line"><span class="number">2.</span>经常出现在<span class="keyword">where</span>后，即字段总是被扫描</span><br><span class="line"><span class="number">3.</span>很少DML操作，即增删改</span><br><span class="line"></span><br><span class="line">#创建索引</span><br><span class="line"><span class="keyword">create</span> index 对象别名 <span class="keyword">on</span> 表名(字段名);</span><br><span class="line"></span><br><span class="line">#删除索引</span><br><span class="line"><span class="keyword">drop</span> index 对象别名 <span class="keyword">on</span> 表名;</span><br><span class="line"></span><br><span class="line">#查看<span class="keyword">select</span>执行详情</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 条件;</span><br><span class="line">type栏中，<span class="keyword">all</span>为无索引，<span class="keyword">ref</span>为有索引。</span><br></pre></td></tr></table></figure>
<h2 id="2-索引失效"><a href="#2-索引失效" class="headerlink" title="2. 索引失效"></a>2. 索引失效</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">某些情况下，可能会出现索引失效的情况。</span><br><span class="line"><span class="number">1.</span> 模糊查询，并且以<span class="operator">%</span>开头。少用<span class="keyword">like</span><span class="operator">%</span></span><br><span class="line"><span class="number">2.</span> <span class="keyword">or</span>两边字段若有一个没有索引，则索引失效。少用<span class="keyword">or</span></span><br><span class="line"><span class="number">3.</span> 复合索引，若没有使用左侧的字段查找，则失效。</span><br><span class="line"><span class="number">4.</span> 索引字段参与运算。例如id是索引字段，<span class="string">&#x27;where id+1 = 2&#x27;</span> 则索引失效。</span><br><span class="line"><span class="number">5.</span> 索引字段使用函数也会失效。</span><br></pre></td></tr></table></figure>

<h1 id="十一、常用储存引擎"><a href="#十一、常用储存引擎" class="headerlink" title="十一、常用储存引擎"></a>十一、常用储存引擎</h1><ul>
<li>MyISAM<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">使用三个文件表示每个表：</span><br><span class="line"><span class="number">1.</span>定义 .frm</span><br><span class="line"><span class="number">2.</span>内容 .MYD</span><br><span class="line"><span class="number">3.</span>索引 .MYI</span><br><span class="line">特点:</span><br><span class="line">可转换为压缩只读表，从而节省空间。</span><br></pre></td></tr></table></figure></li>
<li>InnoDB <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">分为三部分：</span><br><span class="line"><span class="number">1.</span>目录 .frm</span><br><span class="line"><span class="number">2.</span>表空间 tablespace 里面存了表内容和索引</span><br><span class="line"><span class="number">3.</span>日志文件 处理事务</span><br><span class="line">特点:</span><br><span class="line">非常安全，支持事务，支持崩溃后自动恢复机制，但是效率较低。</span><br></pre></td></tr></table></figure></li>
<li>MEMORY<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">由一个.frm文件储存。</span><br><span class="line">特点:</span><br><span class="line">储存在内存中，查询效率最高。但是不安全，关机后数据消失，数据和索引都在内存中。</span><br><span class="line">且不支持<span class="type">blob</span>字段。</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="十二、数据库设计三范式"><a href="#十二、数据库设计三范式" class="headerlink" title="十二、数据库设计三范式"></a>十二、数据库设计三范式</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">一：必须有主键，字段原子性不可再分。</span><br><span class="line">二：在一的基础上，所有非主键字段完全依赖主键，不产生部分依赖。</span><br><span class="line">三：在二的基础上，所有非主键字段直接依赖主键，不产生传递依赖。</span><br><span class="line"></span><br><span class="line">但是以满足客户需求为主。</span><br><span class="line">有时候不拆表，空间占用大，冗余大，但是查询速度快且开发较为容易。根据情况选择。</span><br></pre></td></tr></table></figure>

<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>&emsp;&emsp;目前数据库基础学习已经告一段落，随后如果再次进行数据库的学习的话，可能就会对底层一点的东西进行研究了，例如索引的底层之类的。<br>&emsp;&emsp;马上要开始redis的学习了，在redis学习结束后，我预备写一个关于sql和redis的小demo加深印象。本篇笔记的内容日后也会不断完善，希望一切顺利。</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>学习记录：二层网络环路相关</title>
    <url>/2021/07/18/20210718_%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E4%BA%8C%E5%B1%82%E7%BD%91%E7%BB%9C%E7%8E%AF%E8%B7%AF%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<ul>
<li>上周实习过程中由于对此相关内容不熟悉，造成了事故。由此对相关内容加强学习，特此记录。</li>
</ul>
<span id="more"></span>

<h1 id="一、交换机相关"><a href="#一、交换机相关" class="headerlink" title="一、交换机相关"></a>一、交换机相关</h1><p>&emsp;&emsp;总的来说，交换机是一种基于MAC地址识别，能完成封装转发数据包功能的网络设备。<br>&emsp;&emsp;在实习中，我接触到的应该都是第二层交换机(数据链路层)。其内部存在着一个映射表，记录着设备MAC地址与交换机端口之间的关系。<br>&emsp;&emsp;当交换机从某端口收到一个数据包，它首先读取包头中的源MAC地址，这样它就知道源MAC地址的机器是连在哪个端口上的。随后它再去读取包头中的目的MAC地址，并在地址表中查找相应的端口，如果表中有与这目的MAC地址对应的端口，则把数据包通过该端口进行传输；如果在表中找不到相应的端口则把数据包广播到所有端口上，当目的机器对源机器回应时，交换机又可以记录目的MAC地址与哪个端口对应，在下次传送数据时就不再需要对所有端口进行广播了。</p>
<ul>
<li><strong>总结</strong><br>&emsp;&emsp;交换机内维护了一张表，其中记录了MAC地址与端口的对应关系。<strong>当交换机收到包时</strong>，会首先更新包源MAC地址与端口的关系。随后读取包的目标MAC地址，接着在映射表内进行查询，此时有两种结果：<br>&emsp;&emsp;1.如果目标MAC地址已经被记录，则直接通过对应的端口进行转发。<br>&emsp;&emsp;2.如果目标MAC地址未被记录，则所有的端口都进行发包操作即广播(即<strong>泛洪</strong>)，来确保包能被交换机转发出去。<br>&emsp;&emsp;而当目标MAC地址的设备收到包进行回应时，则回到流程第一步的“<strong>当交换机收到包时</strong>”，此时会更新映射表，添加该MAC地址与端口的对应关系。今后这两台设备进行通信时，交换机则不会再进行广播操作而是直接找到相应端口进行转发。</li>
</ul>
<h1 id="二、网络环路的产生"><a href="#二、网络环路的产生" class="headerlink" title="二、网络环路的产生"></a>二、网络环路的产生</h1><p>&emsp;&emsp;环路大概就是：A交换机网络从B交换机网络收到了要发给X的消息，随后再次转发给B交换机网络(其中A和B网络所属可能是同一台交换机)，这样该消息就会在A和B网络中不断被转发，造成环路问题。<br>&emsp;&emsp;原因大多是因为线路连接问题或是硬件设备自身的问题。</p>
<h1 id="三、网络环路的影响"><a href="#三、网络环路的影响" class="headerlink" title="三、网络环路的影响"></a>三、网络环路的影响</h1><p>&emsp;&emsp;首先的影响就是<strong>MAC地址表震荡</strong>。因为交换机收到包时会进行表的更新，即交换机在收到包时会更新该包源端口与设备MAC之间的映射关系。但是如果构成环路的话，则代表该路由器会在不同的端口收到同一个包，该包源MAC地址是相同的，则MAC地址表中的映射关系会一直发生“跳跃”，即表内同一个MAC地址在不同的端口上进行“跳跃”，这便是MAC地址表的震荡。<br>&emsp;&emsp;随后最大的影响便是<strong>广播风暴</strong>。因为造成了环路，且在二层交换机中是没有TTL机制来约束包的转发的，所以数据包会在环路内被无限次的转发，由此造成广播风暴。更严重的是可能数据包在环路内不是单播而是广播(比如说该包的源和目的相同，则由于MAC地址表震荡造成泛洪)，由此对相关资源的消耗更为巨大。<br>&emsp;&emsp;同时网络环路也可能造成<strong>重复数据帧</strong>。当拓扑关系出现问题时，可能会出现多端口可致目的MAC地址，则数据可能会在广播中被复制转发，目的地则会收到相同的两份数据。当出现环路时，这两份数据会转发给初始交换机，重复上述操作，造成数据不断的被复制，从而占用越来越多的资源。</p>
<h1 id="四、如何避免网络环路"><a href="#四、如何避免网络环路" class="headerlink" title="四、如何避免网络环路"></a>四、如何避免网络环路</h1><p>&emsp;&emsp;最简单的方法就是设定生存时间值TTL，来避免无限次的转发从而避免环路带来的广播风暴等影响。但是二层交换机不支持该内容，且这样是治标不治本，环路并没有被解决。<br>&emsp;&emsp;随后我们可以引入一些算法和破坏协议来避免网络环路，使可以及时发现并切断网络环路。<br>&emsp;&emsp;当然在日常接线中，也要注意，从根本上避免网络环路的产生。例如：</p>
<ol>
<li>例如A与B已连接交换机C，则A与B之间不可再连线。</li>
<li>不可用网线连接同一交换机的两个端口。</li>
<li>假如A连接了B，B连接了C，则A不可连接C。</li>
<li>等等…</li>
</ol>
<h1 id="五、二层环路的直观异常情况"><a href="#五、二层环路的直观异常情况" class="headerlink" title="五、二层环路的直观异常情况"></a>五、二层环路的直观异常情况</h1><p><img src="/images/2021-07-18/1.jpg" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>linux学习记录：用户与/etc/passwd与/etc/shadow</title>
    <url>/2021/08/18/20210818_linux%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E7%94%A8%E6%88%B7%E4%B8%8Epasswd/</url>
    <content><![CDATA[<ul>
<li>这部分内容也是在实习中接触到的，其中关于各个伪用户关联的内容，我都一一进行了查询，于是记录一下相关内容，方便日后查看。</li>
</ul>
<span id="more"></span>

<h1 id="一、-etc-passwd"><a href="#一、-etc-passwd" class="headerlink" title="一、&#x2F;etc&#x2F;passwd"></a>一、&#x2F;etc&#x2F;passwd</h1><p>&emsp;&emsp;这个文件中储存了系统中的各个用户，它记录了用户的一些基本属性。如下图，其中每一行都是一个用户。<br><img src="/images/2021-08-18/1.jpg" alt="图1"><br>&emsp;&emsp;可以很明显的看出来每一行的开头都是一个用户名，而各个字段直接之间是由<code>:</code>来进行分隔的。其中字段格式与含义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注册名：口令：用户标识号：组标识号：用户名：用户主目录：命令解释器</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>注册名</strong><br>&emsp;&emsp;用于区分不同的用户。在同一系统中注册名是惟一的，且用户名是区分大小写的。</p>
</li>
<li><p><strong>口令</strong><br>&emsp;&emsp;通俗来讲就是密码，用来验证用户的合法性。但是目前来看，现在的口令不再直接保存在passwd文件中，通常将passwd文件中的口令字段使用一个<code>x</code>来代替，而真正的口令储存在<code>/etc/shadow</code>中。所以可以看到上图中，第二个字段的内容均为 <code>x</code> 。</p>
</li>
<li><p><strong>用户标识号</strong><br>&emsp;&emsp;英文缩写叫做UID，它是一个数值，是Linux系统中惟一的用户标识，用于区别不同的用户。在系统内部管理进程和文件保护时使用 UID字段。在Linux系统中，注册名和UID都可以用于标识用户，只不过对于系统来说UID更为重要。而对于用户来说注册名使用起来更方便。在某些特定目的下，系统中可以存在多个拥有不同注册名、但UID相同的用户，事实上，这些使用不同注册名的用户实际上是同一个用户。<br>&emsp;&emsp;在find命令中可以使用<code>-uid</code>来对用户标识号进行检索，例如<code>-uid +0</code>即为检索所有UID大于0的内容。<br>&emsp;&emsp;<strong>在linux系统中(linux7及以上)，UID为0的即为管理员用户，UID在1~999的为系统用户，UID在1000及往上的为普通用户。所以一个很简单的给普通用户管理员权限的方法就是把他的UID改为0。</strong></p>
</li>
<li><p><strong>组标识号</strong><br>&emsp;&emsp;英文缩写叫做GID，是用户的工作组标识，而每个用户可以同时属于多个组。在<code>/etc/passwd</code>文件中指定一个用户归属的基本组，而在<code>/etc/group</code>文件中指明一个组所包含的用户。 </p>
</li>
<li><p><strong>描述性信息</strong><br>&emsp;&emsp;这个字段包含用户的一些信息，可以算作一个小备注。就我的体验来看没有什么。</p>
</li>
<li><p><strong>用户主目录</strong><br>&emsp;&emsp;这个字段标明了各个用户的个人主目录。在shell中可以通过<code>cd ~</code>来进入自己的个人主目录。<br>&emsp;&emsp;就一般的规则来看，root用户的个人主目录为<code>/root</code>，而普通用户的个人主目录为<code>/home</code>下的同用户名目录。</p>
</li>
<li><p><strong>命令解释器</strong><br>&emsp;&emsp;这个字段的内容是指定用户的shell程序，可以看到上图中root的shell为<code>/bin/bash</code>。通过命令<code>cat /etc/shells</code>可以查看本系统下支持的shell。</p>
</li>
</ul>
<h1 id="二、-etc-shadow"><a href="#二、-etc-shadow" class="headerlink" title="二、&#x2F;etc&#x2F;shadow"></a>二、&#x2F;etc&#x2F;shadow</h1><p>&emsp;&emsp;这个文件中储存了系统中的各个用户的密码信息，被称为”影子文件”。<br><img src="/images/2021-08-18/2.jpg" alt="2"><br>&emsp;&emsp;可以很明显的看出来每一行的开头都是一个用户名，而各个字段直接之间也是由<code>:</code>来进行分隔的。其中字段格式与含义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户名 : 加密密码 : 最后一次修改时间 : 最小修改时间间隔 : 密码有效期 : \</span><br><span class="line">密码需要变更前的警告天数 : 密码过期后的宽限时间 : 账号失效时间 : 保留字段</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>用户名</strong><br>&emsp;&emsp;和上文中passwd文件中的用户名含义一样，也是用于区分不同的账户。</p>
</li>
<li><p><strong>加密密码</strong><br>&emsp;&emsp;这里保存的是真正加密的密码。目前 Linux 的密码采用的是 SHA512 散列加密算法，原来采用的是 MD5 或 DES 加密算法。SHA512 散列加密算法的加密等级更高，也更加安全。<br>&emsp;&emsp;而且这部分加密后的密码是不能更改的，更改后会无法登录。当使用<code>usermod -L</code>命令禁用账户时，也是在这部分最前面加上了<code>!</code>来达到使账户无法登录的目的。<br>&emsp;&emsp;所有伪用户的密码都是 “!!” 或 “*”，代表没有密码是不能登录的。当然，新创建的用户如果不设定密码，那么它的密码项也是 “!!”，代表这个用户没有密码，不能登录。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">星号代表帐号被锁定，将无法登录；双叹号表示这个密码已经过期了， </span><br><span class="line">如果是\$x\$xxxxxxxx\$的形式，则代表密码正常。</span><br><span class="line"></span><br><span class="line">$<span class="number">6</span>$ 表明是用SHA<span class="number">-512</span>加密的，密文长度<span class="number">86</span></span><br><span class="line">$<span class="number">1</span>$ 表明是用MD5加密的，密文长度<span class="number">22</span>个字符</span><br><span class="line">$<span class="number">2</span>$ 是用Blowfish加密的，</span><br><span class="line">$<span class="number">5</span>$ 是用 SHA<span class="number">-256</span>加密的，密文长度<span class="number">43</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>最后一次修改时间</strong><br>&emsp;&emsp;此字段表示最后一次修改密码的时间，在1970 年 1 月 1 日的基准上，加上该字段显示的天数，即为最后修改的时间。通过命令<code>date -d &quot;1970-01-01 18818 days&quot;</code>可以获取具体是哪一天。</p>
</li>
<li><p><strong>最小修改时间</strong><br>&emsp;&emsp;最小修改间隔时间，也就是说，该字段规定了从第 3 字段（最后一次修改密码的日期）起，多长时间之内不能修改密码。如果是 0，则密码可以随时修改；如果是 10，则代表密码修改后 10 天之内不能再次修改密码。</p>
</li>
<li><p><strong>密码有效期</strong><br>&emsp;&emsp;这个字段可以指定距离第 3 字段（最后一次更改密码）多长时间内需要再次变更密码，否则该账户密码进行过期阶段。<br>&emsp;&emsp;该字段的默认值为 99999，也就是 273 年，可认为是永久生效。如果改为 90，则表示密码被修改 90 天之后必须再次修改，否则该用户即将过期。管理服务器时，通过这个字段强制用户定期修改密码。</p>
</li>
<li><p><strong>密码需要变更前的警告天数</strong><br>&emsp;&emsp;与第 5 字段相比较，当账户密码有效期快到时，系统会发出警告信息给此账户，提醒用户密码需要变更。<br>&emsp;&emsp;该字段的默认值是 7，也就是说，距离密码有效期的第 7 天开始，每次登录系统都会向该账户发出 “修改密码” 的警告信息。</p>
</li>
<li><p><strong>密码过期后的宽限时间</strong><br>&emsp;&emsp;也称为“口令失效日”，简单理解就是，在密码过期后，用户如果还是没有修改密码，则在此字段规定的宽限天数内，用户还是可以登录系统的；如果过了宽限天数，系统将不再让此账户登陆，也不会提示账户过期，是完全禁用。<br>&emsp;&emsp;比如说，此字段规定的宽限天数是 10，则代表密码过期 10 天后失效；如果是 0，则代表密码过期后立即失效；如果是 -1，则代表密码永远不会失效。</p>
</li>
<li><p><strong>账号失效时间</strong><br>&emsp;&emsp;同第 3 个字段一样，使用自  1970 年 1 月 1 日以来的总天数作为账户的失效时间。该字段表示，账号在此字段规定的时间之外，不论你的密码是否过期，都将无法使用。</p>
</li>
<li><p><strong>保留字段</strong><br>&emsp;&emsp;目前没有功能，保留。</p>
</li>
</ul>
<h1 id="三、如何禁用一个用户？"><a href="#三、如何禁用一个用户？" class="headerlink" title="三、如何禁用一个用户？"></a>三、如何禁用一个用户？</h1><p>&emsp;&emsp;从结果来看，只要让这个用户没办法登录，就可以说是禁用这个用户了。所以可以通过以下方式来实现禁用。</p>
<h2 id="1-修改-etc-passwd"><a href="#1-修改-etc-passwd" class="headerlink" title="1. 修改&#x2F;etc&#x2F;passwd"></a>1. 修改&#x2F;etc&#x2F;passwd</h2><p>&emsp;&emsp;把想要禁用的用户的解释器选项配置为<code>/sbin/nologin</code>即可。</p>
<h2 id="2-修改-etc-shadow"><a href="#2-修改-etc-shadow" class="headerlink" title="2. 修改&#x2F;etc&#x2F;shadow"></a>2. 修改&#x2F;etc&#x2F;shadow</h2><p>&emsp;&emsp;改动一下第二个密码字段即可，可以在该字段<strong>添加一些字符</strong>或者更改为<code>*</code>或<code>!</code>或<code>!!</code>即可使得该账户无法登录。</p>
<h2 id="3-使用usermod命令"><a href="#3-使用usermod命令" class="headerlink" title="3. 使用usermod命令"></a>3. 使用usermod命令</h2><p>&emsp;&emsp;<code>usermod -L user</code>禁用用户， <code>usermod -U user</code>解禁用户。经过执行可以发现，其实这个命令的原理其实就是在<code>/etc/shadow</code>中的密码字段前添加<code>!</code>。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构实操：STL标准红黑树(一)</title>
    <url>/2021/08/02/20210802_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E6%93%8D%EF%BC%9ASTL%E6%A0%87%E5%87%86%E7%BA%A2%E9%BB%91%E6%A0%91(%E4%B8%80)/</url>
    <content><![CDATA[<ul>
<li>之前一直在看侯捷大佬的《STL源码剖析》，透过标准库里的代码学到了许多。随后便想着按照STL标准来<strong>简单</strong>重写一个红黑树。当然，这里的简单是指对空间配置器结构的一些省略。</li>
<li>代码部分本来在6月底就基本完成了，但是因为7月忙着吸收总结实习中学习的内容，所以一直搁置了红黑树的总结。由于《STL源码剖析》中并没有红黑树节点删除相关以及一些小细节的讲解，所以相关的内容是我在别的地方学习后根据STL标准自己补全的代码，如有纰漏，还请提醒。</li>
<li>本次总结预计分为三篇，(一)中主要记录相关的代码<strong>思路结构</strong>，(二)中重点分析<strong>添加红黑树节点</strong>相关的内容，(三)中重点分析<strong>删除红黑树节点</strong>相关的内容。</li>
</ul>
<span id="more"></span>

<h1 id="零、我认为的STL标准"><a href="#零、我认为的STL标准" class="headerlink" title="零、我认为的STL标准"></a>零、我认为的STL标准</h1><p>&emsp;&emsp;首先，对于STL中的数据结构，不难发现它们除了自身的数据结构外还配套有空间配置器以及专属的迭代器。其中空间配置器中维护了一个内存池，符合标准的内存申请均从中获取；而迭代器则是为了更方便的对数据结构进行遍历，或是为了配合在之后STL中的算法模块。<br>&emsp;&emsp;所以，我认为<strong>数据结构+空间配置器+专属迭代器&#x3D;STL标准数据结构</strong>。但是由于篇幅有限，且我主要是为了学习红黑树相关的内容，所以在本文中对空间配置器进行了一些省略——直接进行new和delete操作。<br>&emsp;&emsp;当然，STL里更直观的一个特点就是无数被<code>typedef</code>封装的详细(繁琐)的类型名，在下面的记录中，将会直观的展示它。</p>
<h1 id="一、本文中红黑树的结构"><a href="#一、本文中红黑树的结构" class="headerlink" title="一、本文中红黑树的结构"></a>一、本文中红黑树的结构</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">总体分为三大块：</span><br><span class="line"><span class="number">1.</span>红黑树的空间配置器</span><br><span class="line"><span class="number">2.</span>红黑树的迭代器</span><br><span class="line"><span class="number">3.</span>红黑树数据结构相关</span><br><span class="line"></span><br><span class="line"><span class="comment">/* *** ***** *** */</span></span><br><span class="line">其中红黑树的数据结构包括：</span><br><span class="line"><span class="number">1.</span>红黑树节点相关的定义</span><br><span class="line">	<span class="number">1.1</span> 红黑树节点颜色的定义(即红/黑)</span><br><span class="line">	<span class="number">1.2</span> 红黑数节点数据结构的定义(包括父/孩子节点、值、寻子节点最大/最小值函数)</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>红黑树相关的定义(围绕着红黑树节点)</span><br><span class="line">	<span class="number">2.1</span> 红黑树节点的创建、删除、获取(调用空间配置器)</span><br><span class="line">	<span class="number">2.2</span> 红黑树中获取节点内容(父/孩子节点、值等)的函数</span><br><span class="line">	<span class="number">2.3</span> 红黑树基础操作函数(插入、删除、寻找)</span><br><span class="line">	<span class="number">2.4</span> 一些基础的STL函数，例如begin()、end()、size()等等</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>红黑树的一些操作函数</span><br><span class="line">	<span class="number">3.1</span> 红黑树的左旋右旋操作函数</span><br><span class="line">	<span class="number">3.2</span> 红黑树的平衡性调整函数</span><br><span class="line"></span><br><span class="line"><span class="comment">/* *** ***** *** */</span></span><br><span class="line">其中空间配置器包括：</span><br><span class="line"><span class="number">1.</span>空间配置器的基础定义</span><br><span class="line">	<span class="number">1.1</span> 分配内存</span><br><span class="line">	<span class="number">1.2</span> 释放内存</span><br><span class="line"></span><br><span class="line"><span class="comment">/* *** ***** *** */</span></span><br><span class="line">其中迭代器包括：</span><br><span class="line"><span class="number">1.</span>迭代器的基础定义</span><br><span class="line">	<span class="number">1.1</span> 由于是双向迭代器，所以要有基础的前进和后退功能(++/--重载)</span><br><span class="line">	<span class="number">1.2</span> 要能实现提领和成员访问功能，所以要进行一些操作符重载</span><br></pre></td></tr></table></figure>

<h1 id="二、红黑树的数据结构"><a href="#二、红黑树的数据结构" class="headerlink" title="二、红黑树的数据结构"></a>二、红黑树的数据结构</h1><h2 id="1-红黑树的节点"><a href="#1-红黑树的节点" class="headerlink" title="1. 红黑树的节点"></a>1. 红黑树的节点</h2><h3 id="1-1-节点颜色"><a href="#1-1-节点颜色" class="headerlink" title="1.1 节点颜色"></a>1.1 节点颜色</h3><p>&emsp;&emsp;红黑树之所以叫做红黑树，是因为它的节点除了基础的值外，还具有颜色的属性，即红色和黑色。所以首先需要对红色和黑色进行定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//颜色类型定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">bool</span> _rb_tree_color_type;</span><br><span class="line"><span class="type">const</span> _rb_tree_color_type _rb_tree_red = <span class="literal">false</span>;<span class="comment">//红色为0</span></span><br><span class="line"><span class="type">const</span> _rb_tree_color_type _rb_tree_black = <span class="literal">true</span>;<span class="comment">//黑色为1</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-基础节点结构"><a href="#1-2-基础节点结构" class="headerlink" title="1.2 基础节点结构"></a>1.2 基础节点结构</h3><p>&emsp;&emsp;随后，我们对红黑树的基础单位——节点进行定义，其中节点数据结构中除了常规树节点里的左右孩子节点还需要有父节点以及颜色定义。其中，还需要声明两个函数，其作用是寻找到当前节点下最大和最小的孩子。由于红黑树是满足二叉排序树的特性的，所以最大子节点即为最右节点、最小子节点即为最左节点。定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//rb_tree 基础节点结构定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_rb_tree_node_base</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> _rb_tree_color_type color_type;</span><br><span class="line">	<span class="keyword">typedef</span> _rb_tree_node_base* base_ptr;</span><br><span class="line"></span><br><span class="line">	color_type color;<span class="comment">//节点颜色</span></span><br><span class="line">	base_ptr parent;<span class="comment">//父亲</span></span><br><span class="line">	base_ptr left;<span class="comment">//左孩子</span></span><br><span class="line">	base_ptr right;<span class="comment">//右孩子</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//找孩子最小值</span></span><br><span class="line">	<span class="function"><span class="type">static</span> base_ptr <span class="title">minimum</span><span class="params">(base_ptr x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (x-&gt;left != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			x = x-&gt;left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//找孩子最大值</span></span><br><span class="line">	<span class="function"><span class="type">static</span> base_ptr <span class="title">maximux</span><span class="params">(base_ptr x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (x-&gt;right != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			x = x-&gt;right;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-完整节点结构"><a href="#1-3-完整节点结构" class="headerlink" title="1.3 完整节点结构"></a>1.3 完整节点结构</h3><p>&emsp;&emsp;上面是对于基础节点的定义，但是很明显，其中并没有值。要声明值的话就需要用到泛型，而上面的基础定义不需要用到，由此可以进行分离。我感觉STL里很多东西都分离的很细，应该是为了逻辑和方便修改吧。再说到值，我们可以继承上面的base类型并引入泛型，创造出完整的红黑树节点数据结构：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//rb_tree 节点结构定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Value</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_rb_tree_node</span> : <span class="keyword">public</span> _rb_tree_node_base</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> _rb_tree_node&lt;Value&gt;* link_type;</span><br><span class="line">	Value value_field;<span class="comment">//节点值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;由此，一个完整的红黑树节点数据结构<code>_rb_tree_node</code>就被构造出来了，随后可以在节点的基础上，来构造红黑树以及它的相关操作函数。</p>
<h2 id="2-红黑树"><a href="#2-红黑树" class="headerlink" title="2. 红黑树"></a>2. 红黑树</h2><h3 id="2-1-构造思路"><a href="#2-1-构造思路" class="headerlink" title="2.1 构造思路"></a>2.1 构造思路</h3><p>&emsp;&emsp;由于前面已经构造出了红黑树的节点，那么可以像链表的数据结构一样，创建一个<code>header</code>头结点，这样就可以通过操作这个头结点来控制整个红黑树，这里先暂且不谈这个头结点里储存的内容(后面插入函数部分会说)。<br>&emsp;&emsp;有了这个基础思路之后，我们就可以以该头结点为媒介和底层，定义各式各样的函数来操作或是获取以该头结点为根的红黑树中的内容。例如每个STL数据结构都有的<code>begin()</code>和<code>end()</code>，或是<code>insert()</code>和<code>erase()</code>等等<strong>非静态函数</strong>。然后是一些<strong>静态函数</strong>，方便获取传入节点的内容，毕竟对于用户而言，红黑树节点这个数据结构是被封装的，是不明的，所以需要一些静态函数来获取其中的内容。当然，也得有<strong>树&#x2F;节点的构造&#x2F;析构函数</strong>，这是建树的基础。</p>
<h3 id="2-2-泛型内容"><a href="#2-2-泛型内容" class="headerlink" title="2.2 泛型内容"></a>2.2 泛型内容</h3><p>&emsp;&emsp;在真正构造红黑树的数据结构前，还需要考虑的一个东西是其泛型的结构。那么都需要准备什么泛型呢？首先红黑树是二叉排序树，这就需要在插入中进行比较，所以需要引入键值对概念。由此这里就需要两种泛型，一个是<code>key</code>的泛型，一个是<code>value</code>的泛型。此外，前文对节点的定义中只存在值，所以需要有一个获取<code>key</code>的函数。对此，STL的做法是传入一个仿函数泛型来获取<code>key</code>。此外还需要传入一个比较函数(仿函数)来比较<code>key</code>，以及传入一个空间配置器泛型，所以标准的STL红黑树一共有五个泛型。<strong>但是</strong>，这里我省略了空间配置器泛型，来减少任务量，所以一共只有四个泛型，即<strong>键、值、取键函数、比较函数</strong>。</p>
<h3 id="2-3-静态函数"><a href="#2-3-静态函数" class="headerlink" title="2.3 静态函数"></a>2.3 静态函数</h3><p>&emsp;&emsp;其中，我们需要定义一些构造函数，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下六个函数获取节点x的成员</span></span><br><span class="line"><span class="function"><span class="type">static</span> link_type&amp; <span class="title">left</span><span class="params">(link_type x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (link_type&amp;)(x-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> link_type&amp; <span class="title">right</span><span class="params">(link_type x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (link_type&amp;)(x-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> link_type&amp; <span class="title">parent</span><span class="params">(link_type x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (link_type&amp;)(x-&gt;parent);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> reference <span class="title">value</span><span class="params">(link_type x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x-&gt;value_field;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">const</span> Key&amp; <span class="title">key</span><span class="params">(link_type x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (key_type)<span class="built_in">KeyOfValue</span>()(<span class="built_in">value</span>(x));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> color_type&amp; <span class="title">color</span><span class="params">(link_type x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (color_type&amp;)(x-&gt;color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以下六个函数获取节点x的成员</span></span><br><span class="line"><span class="function"><span class="type">static</span> link_type&amp; <span class="title">left</span><span class="params">(base_ptr x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (link_type&amp;)(x-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> link_type&amp; <span class="title">right</span><span class="params">(base_ptr x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (link_type&amp;)(x-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> link_type&amp; <span class="title">parent</span><span class="params">(base_ptr x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (link_type&amp;)(x-&gt;parent);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> reference <span class="title">value</span><span class="params">(base_ptr x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ((link_type)x)-&gt;value_field;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">const</span> Key&amp; <span class="title">key</span><span class="params">(base_ptr x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (key_type)<span class="built_in">KeyOfValue</span>()(<span class="built_in">value</span>((link_type)x));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> color_type&amp; <span class="title">color</span><span class="params">(base_ptr x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (color_type&amp;)((link_type)x-&gt;color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求极大值和极小值 节点基类方法已实现</span></span><br><span class="line"><span class="function"><span class="type">static</span> link_type <span class="title">minimum</span><span class="params">(link_type x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (link_type)_rb_tree_node_base::<span class="built_in">minimum</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> link_type <span class="title">maximum</span><span class="params">(link_type x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (link_type)_rb_tree_node_base::<span class="built_in">maximum</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;其中包含了基础的取父、孩子节点的函数和取键值、颜色的函数，使得使用者不需要直接操作节点结构，而是通过红黑树里封装好的<code>link_type</code>以及上面定义的这些函数来获取自己想要得到的内容。</p>
<h3 id="2-4-树-节点的构造-析构函数"><a href="#2-4-树-节点的构造-析构函数" class="headerlink" title="2.4 树&#x2F;节点的构造&#x2F;析构函数"></a>2.4 树&#x2F;节点的构造&#x2F;析构函数</h3><p>&emsp;&emsp;首先，需要最基础的配置和释放空间的函数，这里通过调用空间配置器内的函数来完成操作，空间配置器的内容在下文。<br>&emsp;&emsp;随后，是创建节点函数，在获取到空间后，调用其构造函数赋值。STL中也存在一个<code>clone_node()</code>来复制一个节点的颜色和值。<br>&emsp;&emsp;最后就是销毁函数，不用多说什么了。这一部分具体代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">全局：</span><br><span class="line"><span class="comment">//构造函数调用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">construct</span><span class="params">(T1* p, <span class="type">const</span> T2&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">new</span> (p) <span class="built_in">T1</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构函数调用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">(T* pointer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pointer-&gt;~<span class="built_in">T</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">红黑树内<span class="keyword">protected</span>：</span><br><span class="line">	<span class="function">link_type <span class="title">get_node</span><span class="params">()</span><span class="comment">//获取节点(配置空间)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> rb_tree_node_allocator::<span class="built_in">allocate</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">put_node</span><span class="params">(link_type p)</span><span class="comment">//释放节点(回收空间)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		rb_tree_node_allocator::<span class="built_in">deallocate</span>(p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">link_type <span class="title">create_node</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span><span class="comment">//创建节点</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		link_type temp = <span class="built_in">get_node</span>();</span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">construct</span>(&amp;temp-&gt;value_field, x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp;)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">put_node</span>(temp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">link_type <span class="title">clone_node</span><span class="params">(link_type x)</span><span class="comment">//复制节点值与色</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		link_type temp = <span class="built_in">create_node</span>(x-&gt;value_field);</span><br><span class="line">		temp-&gt;color = x-&gt;color;</span><br><span class="line">		temp-&gt;left = <span class="number">0</span>;</span><br><span class="line">		temp-&gt;right = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">destroy_node</span><span class="params">(link_type p)</span><span class="comment">//销毁节点</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">destroy</span>(&amp;p-&gt;value_field);<span class="comment">//析构内容</span></span><br><span class="line">		<span class="built_in">put_node</span>(p);<span class="comment">//释放内存</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-非静态函数思路"><a href="#2-5-非静态函数思路" class="headerlink" title="2.5 非静态函数思路"></a>2.5 非静态函数思路</h3><p>&emsp;&emsp;总体来说就是一些服务于红黑树的函数，例如初始化、插入、移除、寻找等等。还有一些基础的<code>empty()</code>、<code>size</code>、<code>begin()</code>、<code>end()</code>等等，服务于后面的迭代器和STL的算法部分。插入和移除等后面会细说，其余的也没有什么说的必要，就略过了。</p>
<h3 id="2-6-红黑树数据结构部分代码"><a href="#2-6-红黑树数据结构部分代码" class="headerlink" title="2.6 红黑树数据结构部分代码"></a>2.6 红黑树数据结构部分代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//红黑树的定义与声明</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">KeyOfValue</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">rb_tree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:<span class="comment">//基础</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">void</span>* void_pointer;</span><br><span class="line">	<span class="keyword">typedef</span> _rb_tree_node_base* base_ptr;</span><br><span class="line">	<span class="keyword">typedef</span> _rb_tree_node&lt;Value&gt; rb_tree_node;</span><br><span class="line">	<span class="keyword">typedef</span> _rb_tree_color_type color_type;</span><br><span class="line"><span class="keyword">public</span>:<span class="comment">//类型封装</span></span><br><span class="line">	<span class="keyword">typedef</span> Key key_type;</span><br><span class="line">	<span class="keyword">typedef</span> Value value_type;</span><br><span class="line">	<span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">const</span> value_type* const_pointer;</span><br><span class="line">	<span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">const</span> value_type&amp; const_reference;</span><br><span class="line">	<span class="keyword">typedef</span> rb_tree_node* link_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line">	<span class="comment">//空间配置器</span></span><br><span class="line">	<span class="keyword">typedef</span> _rb_tree_node_allocator&lt;Value&gt; rb_tree_node_allocator;</span><br><span class="line"><span class="keyword">protected</span>:<span class="comment">//内存管理相关</span></span><br><span class="line">	<span class="function">link_type <span class="title">get_node</span><span class="params">()</span><span class="comment">//获取节点(配置空间)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> rb_tree_node_allocator::<span class="built_in">allocate</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">put_node</span><span class="params">(link_type p)</span><span class="comment">//释放节点(回收空间)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		rb_tree_node_allocator::<span class="built_in">deallocate</span>(p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">link_type <span class="title">create_node</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span><span class="comment">//创建节点</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		link_type temp = <span class="built_in">get_node</span>();</span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">construct</span>(&amp;temp-&gt;value_field, x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp;)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">put_node</span>(temp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">link_type <span class="title">clone_node</span><span class="params">(link_type x)</span><span class="comment">//复制节点值与色</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		link_type temp = <span class="built_in">create_node</span>(x-&gt;value_field);</span><br><span class="line">		temp-&gt;color = x-&gt;color;</span><br><span class="line">		temp-&gt;left = <span class="number">0</span>;</span><br><span class="line">		temp-&gt;right = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">destroy_node</span><span class="params">(link_type p)</span><span class="comment">//销毁节点</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">destroy</span>(&amp;p-&gt;value_field);<span class="comment">//析构内容</span></span><br><span class="line">		<span class="built_in">put_node</span>(p);<span class="comment">//释放内存</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:<span class="comment">//基本数据与方法</span></span><br><span class="line">	size_type node_count;<span class="comment">//节点数量</span></span><br><span class="line">	link_type header;<span class="comment">//树根头 树根为parent 最小值为left 最大值为right</span></span><br><span class="line">	Compare key_compare;<span class="comment">//节点间键值比较准则</span></span><br><span class="line">	<span class="comment">//以下三个函数获取header的成员</span></span><br><span class="line">	<span class="function">link_type&amp; <span class="title">root</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (link_type&amp;)header-&gt;parent;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">link_type&amp; <span class="title">leftmost</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (link_type&amp;)header-&gt;left;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">link_type&amp; <span class="title">rightmost</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (link_type&amp;)header-&gt;right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//以下六个函数获取节点x的成员</span></span><br><span class="line">	<span class="function"><span class="type">static</span> link_type&amp; <span class="title">left</span><span class="params">(link_type x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (link_type&amp;)(x-&gt;left);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> link_type&amp; <span class="title">right</span><span class="params">(link_type x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (link_type&amp;)(x-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> link_type&amp; <span class="title">parent</span><span class="params">(link_type x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (link_type&amp;)(x-&gt;parent);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> reference <span class="title">value</span><span class="params">(link_type x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x-&gt;value_field;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">const</span> Key&amp; <span class="title">key</span><span class="params">(link_type x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (key_type)<span class="built_in">KeyOfValue</span>()(<span class="built_in">value</span>(x));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> color_type&amp; <span class="title">color</span><span class="params">(link_type x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (color_type&amp;)(x-&gt;color);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//以下六个函数获取节点x的成员</span></span><br><span class="line">	<span class="function"><span class="type">static</span> link_type&amp; <span class="title">left</span><span class="params">(base_ptr x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (link_type&amp;)(x-&gt;left);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> link_type&amp; <span class="title">right</span><span class="params">(base_ptr x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (link_type&amp;)(x-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> link_type&amp; <span class="title">parent</span><span class="params">(base_ptr x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (link_type&amp;)(x-&gt;parent);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> reference <span class="title">value</span><span class="params">(base_ptr x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> ((link_type)x)-&gt;value_field;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">const</span> Key&amp; <span class="title">key</span><span class="params">(base_ptr x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (key_type)<span class="built_in">KeyOfValue</span>()(<span class="built_in">value</span>((link_type)x));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> color_type&amp; <span class="title">color</span><span class="params">(base_ptr x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (color_type&amp;)((link_type)x-&gt;color);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//求极大值和极小值 节点基类方法已实现</span></span><br><span class="line">	<span class="function"><span class="type">static</span> link_type <span class="title">minimum</span><span class="params">(link_type x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (link_type)_rb_tree_node_base::<span class="built_in">minimum</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> link_type <span class="title">maximum</span><span class="params">(link_type x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (link_type)_rb_tree_node_base::<span class="built_in">maximum</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:<span class="comment">//迭代器封装</span></span><br><span class="line">	<span class="keyword">typedef</span> _rb_tree_iterator&lt;value_type, reference, pointer&gt; iterator;</span><br><span class="line"><span class="keyword">private</span>:<span class="comment">//一些私有方法</span></span><br><span class="line">	iterator _insert(base_ptr x_, base_ptr y_, <span class="type">const</span> value_type&amp; v);</span><br><span class="line">	<span class="type">void</span> _erase(link_type x);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span><span class="comment">//初始化header</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		header = <span class="built_in">get_node</span>();<span class="comment">//产生应该节点空间，令header指向它</span></span><br><span class="line">		<span class="built_in">color</span>(header) = _rb_tree_red;<span class="comment">//header为红色 与root区分</span></span><br><span class="line">		<span class="built_in">root</span>() = <span class="number">0</span>;<span class="comment">//root为空</span></span><br><span class="line">		<span class="built_in">leftmost</span>() = header;<span class="comment">//令header的左子节点为自己</span></span><br><span class="line">		<span class="built_in">rightmost</span>() = header;<span class="comment">//令header的右子节点为自己</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:<span class="comment">//构造与析构</span></span><br><span class="line">	<span class="built_in">rb_tree</span>(<span class="type">const</span> Compare&amp; comp = <span class="built_in">Compare</span>())</span><br><span class="line">		: <span class="built_in">node_count</span>(<span class="number">0</span>), <span class="built_in">key_compare</span>(comp)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">init</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">rb_tree</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//clear();</span></span><br><span class="line">		<span class="built_in">put_node</span>(header);</span><br><span class="line">	&#125;</span><br><span class="line">	rb_tree&lt;Key, Value, KeyOfValue, Compare&gt;&amp; <span class="comment">//重载=</span></span><br><span class="line">		<span class="keyword">operator</span>=(<span class="type">const</span> rb_tree&lt;Key, Value, KeyOfValue, Compare&gt;&amp; x);</span><br><span class="line"><span class="keyword">public</span>:<span class="comment">//STL的一些基础方法</span></span><br><span class="line">	<span class="function">Compare <span class="title">Key_comp</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> key_compare;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">leftmost</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> header;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> node_count == <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> node_count;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//不可重复插入</span></span><br><span class="line">	<span class="function">std::pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert_unique</span><span class="params">(<span class="type">const</span> value_type&amp; v)</span></span>;</span><br><span class="line">	<span class="comment">//可重复插入</span></span><br><span class="line">	<span class="function">iterator <span class="title">insert_equal</span><span class="params">(<span class="type">const</span> value_type&amp; v)</span></span>;</span><br><span class="line">	<span class="comment">//删除-传入迭代器</span></span><br><span class="line">	<span class="function">iterator <span class="title">erase</span><span class="params">(iterator x)</span></span>;</span><br><span class="line">	<span class="comment">//删除-传入值</span></span><br><span class="line">	<span class="function">iterator <span class="title">erase</span><span class="params">(value_type&amp; v)</span></span>;</span><br><span class="line">	<span class="comment">//寻找</span></span><br><span class="line">	<span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; k)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-红黑树的操作函数"><a href="#3-红黑树的操作函数" class="headerlink" title="3. 红黑树的操作函数"></a>3. 红黑树的操作函数</h2><h3 id="3-1-左旋函数"><a href="#3-1-左旋函数" class="headerlink" title="3.1 左旋函数"></a>3.1 左旋函数</h3><p>&emsp;&emsp;首先这是一个全局函数，是用来调整树的平衡性的。红黑树相比普通树查找快的原因就是它是平衡二叉树，有着较平衡的查找次数，由此需要左旋以及右旋函数来调整平衡性；但它又没有AVL树那么严格的平衡要求，所以总体插入&#x2F;查找效率达到最大化。<br><img src="/images/2021-08-02/1.jpg" alt="左旋"><br>&emsp;&emsp;左旋示意图如上，可以看到简而言之就是旋转点x变为其右子节点y的左子节点，随后y的左子节点变为x的右子节点。代码如下，其中需要注意边界条件以及父子关系的改变：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//rb_tree 左旋函数</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> _rb_tree_rotate_left(_rb_tree_node_base* x, _rb_tree_node_base*&amp; root)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//printf(&quot;左旋\n&quot;);</span></span><br><span class="line">	<span class="comment">//x为旋转点，root为树根</span></span><br><span class="line">	_rb_tree_node_base* y = x-&gt;right;<span class="comment">//新建y为旋转点的右子节点</span></span><br><span class="line">	x-&gt;right = y-&gt;left;<span class="comment">//令x的右子节点为y的左子节点</span></span><br><span class="line">	<span class="keyword">if</span> (y-&gt;left != <span class="number">0</span>)<span class="comment">//若y的左子树不为空</span></span><br><span class="line">	&#123;</span><br><span class="line">		y-&gt;left-&gt;parent = x;<span class="comment">//y的左子树的父亲改为x</span></span><br><span class="line">	&#125;</span><br><span class="line">	y-&gt;parent = x-&gt;parent;<span class="comment">//y的父亲改为x的父亲</span></span><br><span class="line">	<span class="comment">//令y顶替x的位置</span></span><br><span class="line">	<span class="keyword">if</span> (x == root)<span class="comment">//当x为根</span></span><br><span class="line">	&#123;</span><br><span class="line">		root = y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (x == x-&gt;parent-&gt;left)<span class="comment">//当x为parent的左子节点</span></span><br><span class="line">	&#123;</span><br><span class="line">		x-&gt;parent-&gt;left = y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span><span class="comment">//当x为parent的左子节点</span></span><br><span class="line">	&#123;</span><br><span class="line">		x-&gt;parent-&gt;right = y;</span><br><span class="line">	&#125;</span><br><span class="line">	y-&gt;left = x;<span class="comment">//x、y父子关系互换</span></span><br><span class="line">	x-&gt;parent = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-右旋函数"><a href="#3-2-右旋函数" class="headerlink" title="3.2 右旋函数"></a>3.2 右旋函数</h3><p>&emsp;&emsp;总体来说右旋函数和左旋函数差不多，只是操作方法变了一些。总体就是旋转点x变为其左子节点y的右子节点，随后y的右子节点变为x的左子节点。右旋示意图以及相关代码如下，仍然需要注意边界条件以及父子关系的改变：<br><img src="/images/2021-08-02/2.jpg" alt="右旋"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//rb_tree 右旋函数</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> _rb_tree_rotate_right(_rb_tree_node_base* x, _rb_tree_node_base*&amp; root)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//printf(&quot;右旋\n&quot;);</span></span><br><span class="line">	<span class="comment">//x为旋转点，root为树根</span></span><br><span class="line">	_rb_tree_node_base* y = x-&gt;left;<span class="comment">//新建y为旋转点的左子节点</span></span><br><span class="line">	x-&gt;left = y-&gt;right;<span class="comment">//令x的左子节点为y的右子节点</span></span><br><span class="line">	<span class="keyword">if</span> (y-&gt;right != <span class="number">0</span>)<span class="comment">//若y的右子树不为空</span></span><br><span class="line">	&#123;</span><br><span class="line">		y-&gt;right-&gt;parent = x;<span class="comment">//y的右子树的父亲改为x</span></span><br><span class="line">	&#125;</span><br><span class="line">	y-&gt;parent = x-&gt;parent;<span class="comment">//y的父亲改为x的父亲</span></span><br><span class="line">	<span class="keyword">if</span> (x == root)<span class="comment">//当x为根</span></span><br><span class="line">	&#123;</span><br><span class="line">		root = y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (x == x-&gt;parent-&gt;right)<span class="comment">//当x为parent的右子节点</span></span><br><span class="line">	&#123;</span><br><span class="line">		x-&gt;parent-&gt;right = y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span><span class="comment">//当x为parent的左子节点</span></span><br><span class="line">	&#123;</span><br><span class="line">		x-&gt;parent-&gt;left = y;</span><br><span class="line">	&#125;</span><br><span class="line">	y-&gt;right = x;<span class="comment">//x、y父子关系互换</span></span><br><span class="line">	x-&gt;parent = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-平衡性调整函数"><a href="#3-3-平衡性调整函数" class="headerlink" title="3.3 平衡性调整函数"></a>3.3 平衡性调整函数</h3><p>&emsp;&emsp;平衡性调整函数可以说是红黑树里最重要也是最精髓的点，这里不过多解释，待后面记录插入、删除过程时再细细分析。</p>
<h1 id="三、红黑树的空间配置器"><a href="#三、红黑树的空间配置器" class="headerlink" title="三、红黑树的空间配置器"></a>三、红黑树的空间配置器</h1><p>&emsp;&emsp;关于红黑树的空间配置器，我只是简单留了个接口，算是有了空间配置器的形式，也方便日后更改(<del>虽然也不大可能会改了</del> )，就是把new和delete的部分改一下就好。具体如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//rb_tree 空间配置器</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Value</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_rb_tree_node_allocator</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> Value value_type;</span><br><span class="line">	<span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">	<span class="keyword">typedef</span> _rb_tree_node&lt;Value&gt; rb_tree_node;</span><br><span class="line">	<span class="keyword">typedef</span> _rb_tree_node&lt;Value&gt;* link_type;</span><br><span class="line">	<span class="comment">//分配内存</span></span><br><span class="line">	<span class="function"><span class="type">static</span> link_type <span class="title">allocate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		link_type temp = <span class="keyword">new</span> rb_tree_node;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//释放内存</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(link_type p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">delete</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">红黑树结构内相关调用：</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">//空间配置器</span></span><br><span class="line">	<span class="keyword">typedef</span> _rb_tree_node_allocator&lt;Value&gt; rb_tree_node_allocator;</span><br><span class="line"><span class="keyword">protected</span>:<span class="comment">//内存管理相关</span></span><br><span class="line">	<span class="function">link_type <span class="title">get_node</span><span class="params">()</span><span class="comment">//获取节点(配置空间)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> rb_tree_node_allocator::<span class="built_in">allocate</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">put_node</span><span class="params">(link_type p)</span><span class="comment">//释放节点(回收空间)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		rb_tree_node_allocator::<span class="built_in">deallocate</span>(p);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<h1 id="四、红黑树的迭代器"><a href="#四、红黑树的迭代器" class="headerlink" title="四、红黑树的迭代器"></a>四、红黑树的迭代器</h1><p>&emsp;&emsp;上面提到过，STL中完整的红黑树节点是继承红黑树基础节点来完善的。由此，STL中红黑树的迭代器的层次结构也有两层，其中基础迭代器<code>iterator_base</code>对应基础红黑树节点<code>node_base</code>，而完整迭代器<code>iterator</code>则对应完整红黑树节点<code>node</code>。</p>
<h2 id="1-基础迭代器结构"><a href="#1-基础迭代器结构" class="headerlink" title="1. 基础迭代器结构"></a>1. 基础迭代器结构</h2><p>&emsp;&emsp;先来看基础迭代器结构。在我看来，迭代器就相当于一种封装的指针类型，指向被STL数据结构封装后的一个”节点”。而人们通过操作这个”节点”，就可以遍历整个数据结构，而不用操纵底层的结构。比如在本文的红黑树数据结构中，如果想遍历整个树，就不需要自己声明底层的节点结构类型，而是直接用迭代器就好。<br>&emsp;&emsp;由上，迭代器中必然有一个底层一些的结构指针来指向可操作的单元，在这个基础迭代器中，这个结构指针就是<code>_rb_tree_node_base::base_ptr</code>，即<code>_rb_tree_node_base*</code>。所以说基础迭代器<code>iterator_base</code>对应基础红黑树节点<code>node_base</code>。<br>&emsp;&emsp;迭代器最重要的就是”可移动”，即可以指向逻辑上的上一个和下一个，由此需要实现迭代器增加和减少函数。随后还需要重载一些运算符，让迭代器变得好用和方便。由于基础节点中只存在关系并不存在值，所以我们不需要重载<code>*</code>、<code>-&gt;</code>、<code>==</code>等操作符，因为它们都涉及到值。由此在这里只需要把重点放到迭代器增加和减少上。<br>&emsp;&emsp;由于红黑树是二叉排序树，所以一个节点的左子树一定小于等于它，它的右子树一定大于它。按照这个规律，迭代器增加即为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>如果有右子节点，则先向右走，随后向左走到底</span><br><span class="line"><span class="number">2.</span>如果没有右子节点，则上溯父节点</span><br><span class="line">	<span class="number">2.1</span>若当前节点为右子节点，则接着上溯直到不为右子节点</span><br><span class="line">		<span class="number">2.1</span><span class="number">.1</span>若此时的右子节点不等于此时的父节点，其父节点即为解答</span><br><span class="line">		<span class="number">2.1</span><span class="number">.2</span>否则直接返回即可(这两个判断主要是防止上溯到根节点)</span><br></pre></td></tr></table></figure>
<p>随后即可找到第一个比它大的节点。<br>迭代器减少即为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>如果是根节点，则右子节点为解答(这个涉及到根节点的设计，以后会分析)</span><br><span class="line"><span class="number">2.</span>如果有左子节点，则先向左走，随后一直向右走</span><br><span class="line"><span class="number">3.</span>如果非根节点也无左子节点，上溯直至当前节点不为左子节点，其父节点即为解答</span><br></pre></td></tr></table></figure>
<p>随后即可找到第一个比它小的节点。<br>详细代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//rb_tree 基础迭代器结构定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_rb_tree_iterator_base</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> _rb_tree_node_base::base_ptr base_ptr;</span><br><span class="line">	base_ptr node;<span class="comment">//当前节点</span></span><br><span class="line">	<span class="comment">//迭代器增加</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (node-&gt;right != <span class="number">0</span>)<span class="comment">//如果有右子节点，则先向右走，随后向左走到底</span></span><br><span class="line">		&#123;</span><br><span class="line">			node = node-&gt;right;</span><br><span class="line">			<span class="keyword">while</span> (node-&gt;left != <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				node = node-&gt;left;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//如果没有右子节点，则上溯父节点</span></span><br><span class="line">		&#123;</span><br><span class="line">			base_ptr y = node-&gt;parent;</span><br><span class="line">			<span class="keyword">while</span> (node == y-&gt;right)<span class="comment">//若当前节点为右子节点，则接着上溯直到不为右子节点</span></span><br><span class="line">			&#123;</span><br><span class="line">				node = y;</span><br><span class="line">				y = y-&gt;parent;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (node-&gt;right != y)<span class="comment">//若此时的右子节点不等于此时的父节点，其父节点即为解答</span></span><br><span class="line">			&#123;</span><br><span class="line">				node = y;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//迭代器减少</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">decrement</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (node-&gt;color == _rb_tree_red &amp;&amp; node-&gt;parent-&gt;parent == node)<span class="comment">//为根节点</span></span><br><span class="line">		&#123;<span class="comment">//若当前节点为红色，且父亲的父亲为自身，则右子节点为解答</span></span><br><span class="line">			node = node-&gt;right;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;left != <span class="number">0</span>)<span class="comment">//若有左子节点，则先向左走，随后一直向右走</span></span><br><span class="line">		&#123;</span><br><span class="line">			base_ptr y = node-&gt;left;</span><br><span class="line">			<span class="keyword">while</span> (y-&gt;right != <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				y = y-&gt;right;</span><br><span class="line">			&#125;</span><br><span class="line">			node = y;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//既非根节点也无左子节点</span></span><br><span class="line">		&#123;</span><br><span class="line">			base_ptr y = node-&gt;parent;</span><br><span class="line">			<span class="keyword">while</span> (node == y-&gt;left)<span class="comment">//上溯直至当前节点不为左子节点</span></span><br><span class="line">			&#123;</span><br><span class="line">				node = y;</span><br><span class="line">				y = node-&gt;parent;</span><br><span class="line">			&#125;</span><br><span class="line">			node = y;<span class="comment">//则父节点即为小值</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-完整迭代器结构"><a href="#2-完整迭代器结构" class="headerlink" title="2. 完整迭代器结构"></a>2. 完整迭代器结构</h2><p>&emsp;&emsp;完整迭代器<code>iterator</code>对应完整红黑树节点<code>node</code>，其中引入了值泛型，所以在完整迭代器中需要进行操作符的重载。由于在之后的使用中，也是操作这个完整迭代器，所以需要定义构造函数。关于重载，重点就是在<code>++</code>和<code>--</code>上，其核心就是调用上面基础迭代器中的增加和减少函数。具体代码如下，非常清晰：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//rb_tree 迭代器结构定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">Ref</span>, <span class="keyword">class</span> <span class="title class_">Ptr</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_rb_tree_iterator</span> : <span class="keyword">public</span> _rb_tree_iterator_base</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> Value value_type;</span><br><span class="line">	<span class="keyword">typedef</span> Ref reference;</span><br><span class="line">	<span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">	<span class="keyword">typedef</span> _rb_tree_iterator&lt;Value, Value&amp;, Value*&gt; iterator;</span><br><span class="line">	<span class="keyword">typedef</span> _rb_tree_iterator&lt;Value,<span class="type">const</span> Value&amp;,<span class="type">const</span> Value*&gt; const_iterator;</span><br><span class="line">	<span class="keyword">typedef</span> _rb_tree_iterator&lt;Value, Ref, Ptr&gt; self;</span><br><span class="line">	<span class="keyword">typedef</span> _rb_tree_node&lt;Value&gt;* link_type;</span><br><span class="line">	<span class="comment">//三种构造</span></span><br><span class="line">	_rb_tree_iterator()</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	_rb_tree_iterator(link_type x)</span><br><span class="line">	&#123;</span><br><span class="line">		node = x;</span><br><span class="line">	&#125;</span><br><span class="line">	_rb_tree_iterator(<span class="type">const</span> iterator&amp; it)</span><br><span class="line">	&#123;</span><br><span class="line">		node = it.node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重载操作符</span></span><br><span class="line">	reference <span class="keyword">operator</span>*() <span class="type">const</span><span class="comment">//提领</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">link_type</span>(node)-&gt;value_field;</span><br><span class="line">	&#125;</span><br><span class="line">	pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span><span class="comment">//箭头</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> iterator&amp; y) <span class="type">const</span><span class="comment">//==</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;node == y.node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> iterator&amp; y) <span class="type">const</span><span class="comment">//!=</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;node != y.node;</span><br><span class="line">	&#125;</span><br><span class="line">	self&amp; <span class="keyword">operator</span>++()<span class="comment">//++i</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">increment</span>();</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	self <span class="keyword">operator</span>++(<span class="type">int</span>)<span class="comment">//i++</span></span><br><span class="line">	&#123;</span><br><span class="line">		self temp = *<span class="keyword">this</span>;</span><br><span class="line">		<span class="built_in">increment</span>();</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">	self&amp; <span class="keyword">operator</span>--()<span class="comment">//--i</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">decrement</span>();</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	self <span class="keyword">operator</span>--(<span class="type">int</span>)<span class="comment">//i--</span></span><br><span class="line">	&#123;</span><br><span class="line">		self temp = *<span class="keyword">this</span>;</span><br><span class="line">		<span class="built_in">decrement</span>();</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构与算法</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux学习记录：Makefile</title>
    <url>/2021/08/08/20210808_Linux%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9AMakefile/</url>
    <content><![CDATA[<ul>
<li>这是本人在学习makefile时的记录，方便日后查询。</li>
<li>所有我遇到的makefile相关的内容都会被记录在这篇笔记中，所以在之后接触到makefile相关的新内容后，会对这篇笔记的内容进行更新。</li>
<li>相关内容学习主要在<strong>B站</strong>和<strong>C语言中文网</strong>上进行。</li>
</ul>
<span id="more"></span>

<h1 id="零、Makefile简介"><a href="#零、Makefile简介" class="headerlink" title="零、Makefile简介"></a>零、Makefile简介</h1><ol>
<li><p>描述了整个工程的编译、链接规则<br> · 工程中的哪些源文件需要编译以及如何编译<br> · 需要创建哪些库文件以及如何创建这些库文件<br> · 如何产生期望得到的最终可执行文件<br> · 可以快速的构建和管理工程</p>
</li>
<li><p>make的执行机制<br> · makefile文件的命名: <code>Makefile</code> 或 <code>makefile</code><br> · 在make执行时，会依次寻找GNUmakefile、Makefile、makefile，如未找到则报错，找到则执行此makefile文件。<br> · 在执行makefile文件时，make会检测每一条命令的返回值，如果失败的话会报错并终止make，否则会继续进行。<br> · 可以使用 <code>make -f</code> 来指定make命令读取的脚本名</p>
</li>
<li><p>makefile的执行流程<br> · 从makefile的第一个目标开始执行(从上往下数第一个)<br> · 首先看该目标的依赖项，看依赖项是否存在<br> · 如果不存在依赖项，则执行命令后结束。<br> · 如果存在就先执行依赖项相关目标(然后看依赖项目标是否有依赖项…以此不断寻找最内层，有点<strong>dfs</strong>的感觉)</p>
</li>
</ol>
<p>PS: 这里简单提一嘴编译和链接的过程…</p>
<table>
<thead>
<tr>
<th>步骤号</th>
<th>执行前</th>
<th>要干嘛</th>
<th>过程</th>
<th>执行后</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>源文件(.c, .cpp, .h)</td>
<td>预处理器(Preprocessor)进行预处理</td>
<td>引入头文件、进行宏替换等</td>
<td>预编译文件(.i, .ii)</td>
</tr>
<tr>
<td>2</td>
<td>预编译文件(.i, .ii)</td>
<td>编译器(Compiler)进行编译处理</td>
<td>比如使用gcc或者g++进行编译</td>
<td>汇编码(.s)</td>
</tr>
<tr>
<td>3</td>
<td>汇编码(.s)</td>
<td>汇编程序(Assembler)进行汇编</td>
<td>把汇编码转为机器码</td>
<td>机器码(.o, .obj)</td>
</tr>
<tr>
<td>4</td>
<td>机器码(.o, .obj)</td>
<td>链接器(Linker)进行链接</td>
<td>对静态库(.lib, .a)进行连接</td>
<td>得到可执行文件</td>
</tr>
</tbody></table>
<h1 id="一、基础语法"><a href="#一、基础语法" class="headerlink" title="一、基础语法"></a>一、基础语法</h1><p><strong>基础语法如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">target...: prerequisttes...</span><br><span class="line">	command...</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">其中：</span><br><span class="line"><span class="number">1.</span>target为目标文件，可以是obj文件也可以是可执行文件</span><br><span class="line"><span class="number">2.</span>prerequisttes为依赖性，即生成目标文件所关联到的文件</span><br><span class="line"><span class="number">3.</span>command为指令，即make所需要执行的指令</span><br></pre></td></tr></table></figure>
<h2 id="1-单源文件例子"><a href="#1-单源文件例子" class="headerlink" title="1. 单源文件例子"></a>1. 单源文件例子</h2><p><strong>下面是一个简单的单源文件makefile例子：</strong><br><img src="/images/2021-08-08/1.jpg" alt="图1"><br>&emsp;&emsp;如上图所示，在当前文件夹内有两个文件 main.c 和 makefile，而文件中的内容分别如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* main.c</span></span><br><span class="line"><span class="comment">* 为简单的打印HelloWorld</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;HelloWorld\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* makefile</span></span><br><span class="line"><span class="comment">* 设定目标文件为main，依赖项为main.c，命令语句为gcc main.c -o main</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">main: main.c</span><br><span class="line">        gcc main.c -o main</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如下图，执行make命令后，可以看到它执行了预设的gcc命令，随后正常生成了main可执行文件，并可以正常执行。由此，一个最简单的基础makefile示例就完成了。<br><img src="/images/2021-08-08/2.jpg" alt="图2"></p>
<h2 id="2-多源文件例子"><a href="#2-多源文件例子" class="headerlink" title="2. 多源文件例子"></a>2. 多源文件例子</h2><p><strong>下面是一个简单的多源文件makefile例子：</strong><br>&emsp;&emsp;如下，是一个文件夹里的四个文件：<code>func.h</code>、<code>func.c</code>、<code>main.c</code>、<code>makefile</code>，具体内容都列在下方。其中func为一个简单的加法函数，而makefile中涉及了变量和伪目标的概念，具体内容在下面都会记录。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*func.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _FUNC_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _FUNC_H_</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*func.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;func.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;func.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;HelloWorld\n1 + 2 = %d\n&quot;</span>, <span class="built_in">func</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*makefile 涉及到变量和伪目标，具体概念都在下文*/</span></span><br><span class="line">TARGET = main</span><br><span class="line">cc = gcc</span><br><span class="line">FILE = main.c func.o</span><br><span class="line"></span><br><span class="line">TARGET: $(FILE)</span><br><span class="line">        $(CC) $(FILE) -w -o $(TARGET)</span><br><span class="line">func.o: func.c</span><br><span class="line">        $(CC) -c func.c</span><br><span class="line"></span><br><span class="line">.PHONY: clean</span><br><span class="line">clean:</span><br><span class="line">        rm $(TARGET) *.o</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如下图，执行<code>make</code>命令，可以看到gcc命令由下向上执行(<strong>因为从最内层依赖项开始生成</strong>)，生成了最终目标文件<code>main</code>，执行main发现func函数正常被调用，说明make成功。<br><img src="/images/2021-08-08/3.jpg" alt="3"><br>&emsp;&emsp;如下图，执行<code>make clean</code>命令，可以看到<code>rm</code>命令被正常执行，删除了main文件和所有.o后缀的文件。说明伪目标clean建立成功。自此该多源文件例子已经完成。<br><img src="/images/2021-08-08/4.jpg" alt="4"></p>
<h1 id="二、变量相关"><a href="#二、变量相关" class="headerlink" title="二、变量相关"></a>二、变量相关</h1><h2 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h2><p><strong>变量简介：</strong><br>&emsp;&emsp;makefile脚本中可以引入变量来使得编写更加简便以及清晰。变量的声明非常简单，格式为 <code>变量名 = 值</code> ；而调用变量的格式则为 <code>$(变量名)</code>， 由此即可使用变量。</p>
<p><strong>一个简单的例子：</strong><br>&emsp;&emsp;对上文单文件例子中的makefile进行简单修改，引入一些变量。修改如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*修改前*/</span></span><br><span class="line">main: main.c</span><br><span class="line">        gcc main.c -o main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*修改后*/</span></span><br><span class="line">TARGET = main</span><br><span class="line">cc = gcc</span><br><span class="line">FILE = main.c</span><br><span class="line">$(TARGET): $(FILE)</span><br><span class="line">        $(CC) $(FILE) -o $(TARGET)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如下图，在修改完makefile后，make仍可正常进行。通过变量，可以方便日后的修改，比如说想把gcc换成g++，就可以把编译器设为变量，想更换编译器时直接修改变量值即可，可以大大减少修改量。<br><img src="/images/2021-08-08/5.jpg" alt="在这里插入图片描述"></p>
<h2 id="2-一些变量相关符号"><a href="#2-一些变量相关符号" class="headerlink" title="2. 一些变量相关符号"></a>2. 一些变量相关符号</h2><table>
<thead>
<tr>
<th>符号</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;</td>
<td>是最基本的赋值</td>
</tr>
<tr>
<td>:&#x3D;</td>
<td>是覆盖之前的值</td>
</tr>
<tr>
<td>?&#x3D;</td>
<td>是如果没有被赋值过就赋予等号后面的值</td>
</tr>
<tr>
<td>+&#x3D;</td>
<td>是添加等号后面的值</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">之前一直纠结makefile中“=”和“:=”的区别到底有什么区别，因为给变量赋值时，两个符号都在使用。</span><br><span class="line">看一篇博客，无意中发现作者对于这个问题做了很好的解答。</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、“=”</span><br><span class="line"></span><br><span class="line">make会将整个makefile展开后，再决定变量的值。</span><br><span class="line">也就是说，变量的值将会是整个makefile中最后被指定的值。看例子：</span><br><span class="line"></span><br><span class="line">x = foo</span><br><span class="line">y = $(x) bar</span><br><span class="line">x = xyz</span><br><span class="line"></span><br><span class="line">在上例中，y的值将会是 xyz bar ，而不是 foo bar 。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、“:=”</span><br><span class="line"></span><br><span class="line">“:=”表示变量的值决定于它在makefile中的位置，而不是整个makefile展开后的最终值。</span><br><span class="line"></span><br><span class="line">x := foo</span><br><span class="line">y := $(x) bar</span><br><span class="line">x := xyz</span><br><span class="line"></span><br><span class="line">在上例中，y的值将会是 foo bar ，而不是 xyz bar 了。</span><br></pre></td></tr></table></figure>

<h1 id="三、伪目标"><a href="#三、伪目标" class="headerlink" title="三、伪目标"></a>三、伪目标</h1><p>&emsp;&emsp;通常makefile中第一个目标为最终目标，后续目标和最终目标有依赖关系。但是有时候想要执行<strong>清空生成的文件</strong>等一些单独执行的命令时，很明显这些命令并不会生成目标文件，由此和生成最终目标也没有必要关系，需要与普通的command进行区分，这时就出现了伪目标的概念。<br>&emsp;&emsp;伪目标不是一个输出文件，而是一个标签。在执行make指令时，并不会主动执行伪目标的命令(因为伪目标没有依赖项)，想要执行伪目标就必须使用命令 <code>make 伪目标名</code> 或者把伪目标放到makefile最上面。而显式声明伪目标的语法为 <code>.PHONY: 伪目标名</code>，随后设定调用此伪目标时执行的命令即可。</p>
<p><strong>一个简单的例子：</strong><br>&emsp;&emsp;对上文单文件例子中的makefile进行简单修改(多文件例子中已经存在clean)，在末尾引入伪目标，使其可以删除掉生成的main可执行文件。修改如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*修改后*/</span></span><br><span class="line">TARGET = main</span><br><span class="line">cc = gcc</span><br><span class="line">FILE = main.c</span><br><span class="line">$(TARGET): $(FILE)</span><br><span class="line">        $(CC) $(FILE) -o $(TARGET)</span><br><span class="line">.PHONY: clean</span><br><span class="line">clean:</span><br><span class="line">        rm $(TARGET)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如下图，在执行伪目标clean后，删除掉了设定好的最终目标main。在make后，再次生成最终目标main文件。<br><img src="/images/2021-08-08/6.jpg" alt="在这里插入图片描述"></p>
<h1 id="四、make嵌套执行"><a href="#四、make嵌套执行" class="headerlink" title="四、make嵌套执行"></a>四、make嵌套执行</h1><p>&emsp;&emsp;在大的工程会把源文件分为很多个目录，为了逻辑上的简单，会为每个子目录写一个makefile文件，而最上层的makefile文件被称为总控makefile。通过执行总控makefile，即可自动执行下层的makefile文件，从而使得项目总体进行make操作。</p>
<p><strong>下面是一个例子：</strong><br>&emsp;&emsp;我在当前文件夹内创建了三个新文件夹：<code>main</code>存放main.c源码、<code>func</code>存放func.h&#x2F;c源码、<code>build</code>中存放obj文件和最终可执行文件。并且三个文件夹内都有自己的makefile文件，而当前文件夹下有总控makefile文件。源码如下：</p>
<ul>
<li>.&#x2F;func:<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* func.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _FUNC_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _FUNC_H_</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* func.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;func.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* makefile */</span></span><br><span class="line">CC = gcc</span><br><span class="line"></span><br><span class="line">func.o: func.c</span><br><span class="line">        $(CC) -c func.c -o func.o</span><br><span class="line">        cp func.o ../build/func.o</span><br><span class="line"></span><br><span class="line">.PHONY: clean</span><br><span class="line">clean:</span><br><span class="line">        rm *.o</span><br></pre></td></tr></table></figure></li>
<li>.&#x2F;main:<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;../func/func.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;HelloWorld\n1 + 2 = %d\n&quot;</span>, <span class="built_in">func</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* makefile */</span></span><br><span class="line">CC = gcc</span><br><span class="line"></span><br><span class="line">main.o: main.c</span><br><span class="line">        $(CC) -c main.c -o main.o</span><br><span class="line">        cp main.o ../build/main.o</span><br><span class="line"></span><br><span class="line">.PHONY: clean</span><br><span class="line">clean:</span><br><span class="line">        rm *.o</span><br></pre></td></tr></table></figure></li>
<li>.&#x2F;build:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CC = gcc</span><br><span class="line"></span><br><span class="line">test: func.o main.o</span><br><span class="line">        $(CC) func.o main.o -I ../func -o test</span><br><span class="line"></span><br><span class="line">.PHONY: clean</span><br><span class="line">clean:</span><br><span class="line">        rm test *.o</span><br></pre></td></tr></table></figure>
<ul>
<li>.&#x2F;:<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.PHONY: all</span><br><span class="line">all:</span><br><span class="line">        cd func;make</span><br><span class="line">        cd main;make</span><br><span class="line">        cd build;make</span><br><span class="line"></span><br><span class="line">.PHONY: clean</span><br><span class="line">clean:</span><br><span class="line">        cd build;make clean</span><br><span class="line">        cd main;make clean</span><br><span class="line">        cd func;make clean</span><br></pre></td></tr></table></figure>
<img src="/images/2021-08-08/7.jpg" alt="5"></li>
</ul>
<p>&emsp;&emsp;可以看到上面四部分文件存在一个总控makefile和三个子makefile，通过make最终在build文件夹内生成可执行文件test，而test输出HelloWorld已经一个简单的加法式子。<br><img src="/images/2021-08-08/8.jpg" alt="6"><br>&emsp;&emsp;由上图可以看到，在执行<code>make</code>命令后，其按顺序依次进入各个文件夹并执行<code>make</code>命令(蓝框内)，在make完成后，挨个查看各个文件夹，发现文件均正常生成。最后执行可执行文件test，发现正常执行，说明本次make成功。<br><img src="/images/2021-08-08/9.jpg" alt="7"><br>&emsp;&emsp;由上图可以看到，在执行<code>make clean</code>命令后，其按顺序进入各个文件夹并执行<code>make clean</code>命令，随后相关文件均被清除。自此该例子完成，其已经实现了make嵌套的功能。</p>
<h1 id="五、条件判断"><a href="#五、条件判断" class="headerlink" title="五、条件判断"></a>五、条件判断</h1><h2 id="1-ifeq-ifneq"><a href="#1-ifeq-ifneq" class="headerlink" title="1. ifeq &#x2F; ifneq"></a>1. ifeq &#x2F; ifneq</h2><table>
<thead>
<tr>
<th>关键字</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>ifeq</td>
<td>判断参数是否不相等，相等为 true，不相等为 false。</td>
</tr>
<tr>
<td>ifneq</td>
<td>判断参数是否不相等，不相等为 true，相等为 false。</td>
</tr>
</tbody></table>
<ul>
<li>使用方式如下，<code>ifeq</code>和<code>ifneq</code>使用方法相同。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ifeq (ARG1, ARG2)</span><br><span class="line">ifeq <span class="string">&#x27;ARG1&#x27;</span> <span class="string">&#x27;ARG2&#x27;</span></span><br><span class="line">ifeq <span class="string">&quot;ARG1&quot;</span> <span class="string">&quot;ARG2&quot;</span></span><br><span class="line">ifeq <span class="string">&quot;ARG1&quot;</span> <span class="string">&#x27;ARG2&#x27;</span></span><br><span class="line">ifeq <span class="string">&#x27;ARG1&#x27;</span> <span class="string">&quot;ARG2&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>例子如下，例子中进行判定，若编译器为gcc则链接gnu库，否则不链接库。其中用到了<code>ifeq</code>、<code>else</code>、<code>endif</code>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">libs_for_gcc= -lgnu</span><br><span class="line">normal_libs=</span><br><span class="line">foo:$(objects)</span><br><span class="line">ifeq($(CC),gcc)</span><br><span class="line">    $(CC) -o foo $(objects) $(libs_for_gcc)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    $(CC) -o foo $(objects) $(normal_libs)</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>

<h2 id="2-ifdef-ifndef"><a href="#2-ifdef-ifndef" class="headerlink" title="2. ifdef &#x2F; ifndef"></a>2. ifdef &#x2F; ifndef</h2><table>
<thead>
<tr>
<th>关键字</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>ifdef</td>
<td>判断是否有值，有值为 true，没有值为 false。</td>
</tr>
<tr>
<td>ifndef</td>
<td>判断是否有值，没有值为 true，有值为 false。</td>
</tr>
</tbody></table>
<ul>
<li>使用方法如下，<code>ifdef</code>和<code>ifndef</code> 使用方法相同。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ifdef VARIABLE-NAME</span><br></pre></td></tr></table></figure>
<ul>
<li>两个例子</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  例1  */</span></span><br><span class="line">bar =</span><br><span class="line">foo = $(bar)</span><br><span class="line">all:</span><br><span class="line">ifdef foo</span><br><span class="line">    @echo yes</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    @echo  no</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  例2  */</span></span><br><span class="line">foo =</span><br><span class="line">all:</span><br><span class="line">ifdef foo</span><br><span class="line">    @echo yes</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    @echo  no</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;通过执行<code>make</code>可以发现例1打印的结果是yes，例2打印的结果是no。其原因就是例1中变量foo的定义是foo &#x3D; $(bar)，虽然变量bar的值为空，但是ifdef的判断结果为真。这种方式判断显然是不行的，所以当需要判断一个变量的值是否为空的时候需要使用<code>ifeq</code>而不是<code>ifdef</code>。如下即可进行判空：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#ifeq(变量,) </span></span><br></pre></td></tr></table></figure>

<h1 id="六、shell特殊变量"><a href="#六、shell特殊变量" class="headerlink" title="六、shell特殊变量"></a>六、shell特殊变量</h1><table>
<thead>
<tr>
<th>变量名</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>$@</td>
<td>表示目标文件</td>
</tr>
<tr>
<td>$^</td>
<td>表示所有的依赖文件</td>
</tr>
<tr>
<td>$&lt;</td>
<td>表示第一个依赖文件</td>
</tr>
<tr>
<td>$?</td>
<td>表示比目标还要新的依赖文件列表</td>
</tr>
</tbody></table>
<h1 id="七、通配符"><a href="#七、通配符" class="headerlink" title="七、通配符"></a>七、通配符</h1><p>&emsp;&emsp;在makefile文件中也可以使用通配符来模糊指定，比如说上面就存在<code>rm *.o</code>来删除所有的.o文件，通配符的具体用法如下：</p>
<table>
<thead>
<tr>
<th>通配符</th>
<th>使用说明</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>匹配0个或者是任意个字符</td>
</tr>
<tr>
<td>?</td>
<td>匹配任意一个字符</td>
</tr>
<tr>
<td>[]</td>
<td>可以指定匹配的字符放在 “[]” 中</td>
</tr>
<tr>
<td>&emsp;&emsp;但是有一点需要注意，当需要在变量中使用通配符时，比如想要用变量OBJ来指向所有.c文件，写成<code>OBJ = *.c</code>是错误的，因为这里是把OBJ的值设为一个叫<code>*.c</code>的文件。这里需要使用关键字<code>wildcard</code>来告诉系统这里用到了通配符，所以正确写法是<code>OBJ = $(wildcard *.c)</code>，这算是通配符相关的一个重点。</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>还有一个和通配符<code>*</code>相类似的字符，这个字符是<code>%</code>，也是匹配任意个字符，使用在相关规则当中。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">test:test.o test<span class="number">1.</span>o</span><br><span class="line">    gcc -o $@ $^</span><br><span class="line">%.o:%.c</span><br><span class="line">    gcc -o $@ $^</span><br></pre></td></tr></table></figure>
&emsp;&emsp;如上面这个例子， <code>%.o</code>把需要的所有的<code>.o</code>文件组合成为一个列表，从列表中挨个取出的每一个文件，则<code>%</code>表示取出来文件的文件名（不包含后缀），然后找到文件中和 <code>%</code>名称相同的<code>.c</code>文件，执行下面的命令，直到列表中的文件全部被取出来为止。<br>&emsp;&emsp;这个属于Makefile中静态模规则：规则存在多个目标，并且不同的目标可以根据目标文件的名字来自动构造出依赖文件。与多规则目标的意思相近，但是又不相同。</li>
</ul>
<h1 id="八、目标文件搜索"><a href="#八、目标文件搜索" class="headerlink" title="八、目标文件搜索"></a>八、目标文件搜索</h1><h2 id="1-一般搜索-VPATH"><a href="#1-一般搜索-VPATH" class="headerlink" title="1. 一般搜索 VPATH"></a>1. 一般搜索 VPATH</h2><p>语法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单文件：</span></span><br><span class="line">VPATH := src</span><br><span class="line"></span><br><span class="line"><span class="comment">//多文件：</span></span><br><span class="line">VPATH := src car</span><br><span class="line">VPATH := src:car</span><br><span class="line"></span><br><span class="line"><span class="comment">//例子：</span></span><br><span class="line">VPATH=src car</span><br><span class="line">test:test.o</span><br><span class="line">	gcc -o $@ $^</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;注意：无论你定义了多少路径，make 执行的时候会先搜索当前路径下的文件，当前目录下没有我们要找的文件，才去 VPATH 的路径中去寻找。如果当前目录下有我们要使用的文件，那么 make 就会使用我们当前目录下的文件。</p>
<h2 id="2-选择搜索vpath"><a href="#2-选择搜索vpath" class="headerlink" title="2. 选择搜索vpath"></a>2. 选择搜索vpath</h2><p>区别：VPATH 是搜索路径下所有的文件，而 vpath 更像是添加了限制条件，会过滤出一部分再去寻找。语法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vpath支持模糊搜索</span><br><span class="line">%.c 代表.c文件</span><br><span class="line"></span><br><span class="line"><span class="comment">//单文件：</span></span><br><span class="line">vpath test.c src			<span class="comment">//在src目录下寻找test.c文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//多文件：</span></span><br><span class="line">vpath test.c src car    	<span class="comment">//在src car目录下寻找test.c文件             </span></span><br><span class="line">vpath test.c src : car</span><br><span class="line"></span><br><span class="line"><span class="comment">//清除符合文件 test.c 的搜索目录</span></span><br><span class="line">vpath test.c</span><br><span class="line"></span><br><span class="line"><span class="comment">//清除所有已被设置的文件搜索路径</span></span><br><span class="line">vpath</span><br></pre></td></tr></table></figure>

<h1 id="九、include文件包含"><a href="#九、include文件包含" class="headerlink" title="九、include文件包含"></a>九、include文件包含</h1><p>&emsp;&emsp;当 make 读取到 <code>include</code>关键字的时候，会暂停读取当前的 Makefile，而是去读<code>include</code>包含的文件，读取结束后再继读取当前的 Makefile 文件。其使用的具体方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include &lt;filenames&gt;</span><br></pre></td></tr></table></figure>
<p>其中 filenames 是 shell 支持的文件名（可以使用通配符表示的文件）。 </p>
<p>&emsp;&emsp;使用时，通常用<code>-include</code>来代替<code>include</code>来忽略文件不存在或者是无法创建的错误提示，使用格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-include &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>使用方法和 “include” 的使用方法相同。</p>
<ul>
<li>使用<code>include &lt;filenames&gt;</code>，make 在处理程序的时候，文件列表中的任意一个文件不存在的时候或者是没有规则去创建这个文件的时候，make 程序将会提示错误并保存退出。</li>
<li>使用<code>-include &lt;filenames&gt;</code>，当包含的文件不存在或者是没有规则去创建它的时候，make 将会继续执行程序，只有真正由于不能完成终极目标重建的时候我们的程序才会提示错误保存退出。</li>
</ul>
<p><code>include</code>通常使用在以下的场合：</p>
<ul>
<li>在一个工程文件中，每一个模块都有一个独立的 Makefile 来描述它的重建规则。它们需要定义一组通用的变量定义或者是模式规则。通用的做法是将这些共同使用的变量或者模式规则定义在一个文件中，需要的时候用<code>include</code>包含这个文件。</li>
<li>当根据源文件自动产生依赖文件时，我们可以将自动产生的依赖关系保存在另一个文件中。然后在 Makefile 中包含这个文件。</li>
</ul>
<h1 id="十、字符串处理函数"><a href="#十、字符串处理函数" class="headerlink" title="十、字符串处理函数"></a>十、字符串处理函数</h1><h2 id="1-patsubst"><a href="#1-patsubst" class="headerlink" title="1. patsubst"></a>1. patsubst</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</span><br><span class="line"></span><br><span class="line">函数说明：函数功能是查找 text 中的单词是否符合模式 pattern，如果匹配的话，</span><br><span class="line">则用 replacement 替换。返回值为替换后的新字符串。</span><br><span class="line"></span><br><span class="line">实例： <span class="comment">//执行 make 命令，我们可以得到的值是 &quot;1.o 2.o 3.o&quot;</span></span><br><span class="line">    OBJ=$(patsubst %.c,%.o,<span class="number">1.</span>c <span class="number">2.</span>c <span class="number">3.</span>c)</span><br><span class="line">    all:</span><br><span class="line">        @echo $(OBJ)</span><br></pre></td></tr></table></figure>
<h2 id="2-subst"><a href="#2-subst" class="headerlink" title="2. subst"></a>2. subst</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> $(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt;)</span><br><span class="line"></span><br><span class="line">函数说明：函数的功能是把字符串中的 form 替换成 to，返回值为替换后的新字符串。</span><br><span class="line"></span><br><span class="line">实例： <span class="comment">//执行 make 命令，我们得到的值是&quot;fEEt on the strEEt&quot;</span></span><br><span class="line">    OBJ=$(subst ee,EE,feet on the street)</span><br><span class="line">    all:</span><br><span class="line">        @echo $(OBJ)</span><br></pre></td></tr></table></figure>

<h2 id="3-strip"><a href="#3-strip" class="headerlink" title="3. strip"></a>3. strip</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> $(strip &lt;string&gt;)</span><br><span class="line"></span><br><span class="line">函数说明：函数的功能是去掉字符串的开头和结尾的字符串，</span><br><span class="line">并且将其中的多个连续的空格合并成为一个空格。返回值为去掉空格后的字符串。</span><br><span class="line"></span><br><span class="line">实例： <span class="comment">//执行完 make 之后，结果是“a b c”</span></span><br><span class="line">    OBJ=$(strip    a       b c)</span><br><span class="line">    all:</span><br><span class="line">        @echo $(OBJ)</span><br></pre></td></tr></table></figure>
<h2 id="4-findstring"><a href="#4-findstring" class="headerlink" title="4. findstring"></a>4. findstring</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> $(findstring &lt;find&gt;,&lt;in&gt;)</span><br><span class="line"></span><br><span class="line">函数说明：函数的功能是查找  in 中的 find ,如果我们查找的目标字符串存在。</span><br><span class="line">返回值为目标字符串，如果不存在就返回空。</span><br><span class="line"></span><br><span class="line">实例： <span class="comment">//执行 make 命令，得到的返回的结果就是&quot;a&quot;</span></span><br><span class="line">    OBJ=$(findstring a,a b c)</span><br><span class="line">    all:</span><br><span class="line">        @echo $(OBJ)</span><br></pre></td></tr></table></figure>
<h2 id="5-filter"><a href="#5-filter" class="headerlink" title="5. filter"></a>5. filter</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> $(filter &lt;pattern&gt;,&lt;text&gt;)</span><br><span class="line"> </span><br><span class="line">函数说明：函数的功能是过滤出 text 中符合模式 pattern 的字符串，</span><br><span class="line">可以有多个 pattern 。返回值为过滤后的字符串。</span><br><span class="line"></span><br><span class="line">实例： <span class="comment">//执行 make 命令，我们得到的值是&quot;1.c 2.o&quot;</span></span><br><span class="line">    OBJ=$(filter %.c %.o,<span class="number">1.</span>c <span class="number">2.</span>o <span class="number">3.</span>s)</span><br><span class="line">    all:</span><br><span class="line">        @echo $(OBJ)</span><br></pre></td></tr></table></figure>
<h2 id="6-filter-out"><a href="#6-filter-out" class="headerlink" title="6. filter-out"></a>6. filter-out</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> $(filter-out &lt;pattern&gt;,&lt;text&gt;)</span><br><span class="line"> </span><br><span class="line">函数说明：函数的功能是功能和 filter 函数正好相反，但是用法相同。</span><br><span class="line">去除符合模式  pattern 的字符串，保留符合的字符串。返回值是保留的字符串。</span><br><span class="line"></span><br><span class="line">实例： <span class="comment">//执行 make 命令，打印的结果是&quot;3.s&quot;</span></span><br><span class="line">    OBJ=$(filter-out <span class="number">1.</span>c <span class="number">2.</span>o ,<span class="number">1.</span>o <span class="number">2.</span>c <span class="number">3.</span>s)</span><br><span class="line">    all：</span><br><span class="line">        @echo $(OBJ)</span><br></pre></td></tr></table></figure>
<h2 id="7-sort"><a href="#7-sort" class="headerlink" title="7. sort"></a>7. sort</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> $(sort &lt;list&gt;)</span><br><span class="line"> </span><br><span class="line">函数说明：函数的功能是将 &lt;list&gt; 中的单词排序（升序）。返回值为排列后的字符串。</span><br><span class="line"></span><br><span class="line">实例： <span class="comment">//执行 make 命令，我们得到的值是&quot;bar foo lost&quot;</span></span><br><span class="line">    OBJ=$(sort foo bar foo lost)</span><br><span class="line">    all:</span><br><span class="line">        @echo $(OBJ)</span><br><span class="line"></span><br><span class="line">注意：sort会去除重复的字符串。</span><br></pre></td></tr></table></figure>
<h2 id="8-word"><a href="#8-word" class="headerlink" title="8. word"></a>8. word</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> $(word &lt;n&gt;,&lt;text&gt;)</span><br><span class="line"> </span><br><span class="line">函数说明：函数的功能是取出函数 &lt;text&gt; 中的第n个单词。</span><br><span class="line">返回值为我们取出的第 n 个单词。</span><br><span class="line"></span><br><span class="line">实例： <span class="comment">//执行 make 命令，我们得到的值是&quot;2.c&quot;</span></span><br><span class="line">    OBJ=$(word <span class="number">2</span>,<span class="number">1.</span>c <span class="number">2.</span>c <span class="number">3.</span>c)</span><br><span class="line">    all:</span><br><span class="line">        @echo $(OBJ)</span><br></pre></td></tr></table></figure>

<h1 id="十一、一些小东西"><a href="#十一、一些小东西" class="headerlink" title="十一、一些小东西"></a>十一、一些小东西</h1><h2 id="1-echo"><a href="#1-echo" class="headerlink" title="1. @echo"></a>1. @echo</h2><p>&emsp;&emsp;在makefile中执行echo命令(例<code>echo &quot;HelloWorld&quot;</code>)时，会出现<strong>回显</strong>情况，即先输出一次echo命令(<code>echo &quot;HelloWorld&quot;</code>)，再输出相关内容(<code>HelloWorld</code>)。<br>&emsp;&emsp;为了避免这种情况，可以使用@echo命令(例<code>@echo &quot;HelloZHJ&quot;</code>)，此时就只会输出内容(<code>HelloZHJ</code>)了。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux学习记录：sudo相关</title>
    <url>/2021/08/12/20210812_Linux%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9Asudo%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<ul>
<li>在实习中接触到了系统安全相关的内容，其中一个重点就是对sudo权限的控制。正好我对这块东西不太熟悉，于是对相关的内容做了笔记汇总。</li>
<li>这篇笔记中重点放在sudo的配置文件<code>/etc/sudoers</code>上，下面的关键字(或其他)基本都是这个配置文件里的内容。关于这个配置文件，它是仅可读的，使用管理员账号修改时直接使用<code>w!</code>强制修改即可。</li>
<li><del>正好了解完相关的内容把我的那台阿里云服务器完善下</del></li>
</ul>
<span id="more"></span>

<h1 id="targetpw"><a href="#targetpw" class="headerlink" title="targetpw"></a>targetpw</h1><p>使能后，让普通用户需要用root密码使用sudo</p>
<p>默认off</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Defaults    targetpw</span><br></pre></td></tr></table></figure>


<h1 id="always-set-home"><a href="#always-set-home" class="headerlink" title="always_set_home"></a>always_set_home</h1><p>使能后，sudo将HOME环境变量设置为目标用户（默认为root，除非使用-u指定）的home目录。效果相当于每次执行包含-H选项。</p>
<p>默认off</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Defaults    always_set_home</span><br></pre></td></tr></table></figure>


<h1 id="env-reset"><a href="#env-reset" class="headerlink" title="env_reset"></a>env_reset</h1><p>使能后，sudo将在一个最小集的环境变量中运行命令，此时环境变量包括：</p>
<p>a)TERM, PATH, HOME, MAIL, SHELL, LOGNAME, USER, USERNAME and SUDO_*变量；</p>
<p>b)与env_keep和env_check匹配的所有调用者的环境变量；</p>
<p>c)env_file选项指定的文件中的变量。</p>
<p><strong>在关闭此命令后 使用sudo后环境变量不会被重置为默认</strong></p>
<p>默认on</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Defaults    env_reset</span><br></pre></td></tr></table></figure>


<h1 id="authenticate"><a href="#authenticate" class="headerlink" title="authenticate"></a>authenticate</h1><p>布尔类型，如果设置(为on)的话，用户在用sudo执行命令之前必须通过口令(或者通过其他的方式)来验证身分。<br>这个默认选项可以通过设置PASSWD和NOPASSWD标签来覆盖。</p>
<p>默认on</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Defaults    authenticate</span><br></pre></td></tr></table></figure>

<h1 id="fast-glob"><a href="#fast-glob" class="headerlink" title="fast_glob"></a>fast_glob</h1><p>fast_glob控制sudo在进行路径匹配时使用的匹配函数。<br>在进行路径名匹配时，Sudo一般使用glob(3)函数做shell-style globbing，因为它会访问文件系统，<br>因此对于某些模式glob(3)可能需要很长时间才能完成，特别是当模式引用按需安装的网络文件系统（自动挂载）时。</p>
<p>fast_glob选项导致sudo使用fnmatch(3)函数，该函数不访问文件系统进行匹配。<br>fast_glob的缺点是它无法匹配相对路径名，例如.&#x2F;ls或..&#x2F;bin&#x2F;ls。<br>当包含通配符的路径名与否定运算符“!”一起使用时，会产生安全隐患，这样的规则可以被轻易绕过。</p>
<p>默认off</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Defaults    fast_glob</span><br></pre></td></tr></table></figure>


<h1 id="passwd-tries"><a href="#passwd-tries" class="headerlink" title="passwd_tries"></a>passwd_tries</h1><p>整数类型，sudo向日志中写入一个登录失败记录并退出之前允许用户输入口令的次数。</p>
<p>默认值为3</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Defaults    passwd_tries=3</span><br></pre></td></tr></table></figure>


<h1 id="timestamp-timeout"><a href="#timestamp-timeout" class="headerlink" title="timestamp_timeout"></a>timestamp_timeout</h1><p>整数类型，sudo再次询问口令之前的时间(以分钟记)。如果想要总是询问口令的话请把此值设置为0。如果设置为负数的话，用户的时间戳永远不会过期，这可以用来允许用户分别使用sudo -v和sudo -k来建立或者删除他们自己的时间戳。</p>
<p>默认值为5</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Defaults    timestamp_timeout=5</span><br></pre></td></tr></table></figure>


<h1 id="passwd-timeout"><a href="#passwd-timeout" class="headerlink" title="passwd_timeout"></a>passwd_timeout</h1><p>整数类型，sudo询问口令的超时时间(分钟记)。设置为0可以取消口令超时。</p>
<p>默认值为5</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Defaults    passwd_timeout=5</span><br></pre></td></tr></table></figure>


<h1 id="runas-default"><a href="#runas-default" class="headerlink" title="runas_default"></a>runas_default</h1><p>字符串类型，使用sudo但没有指定-u标志时使用的默认用户。</p>
<p>默认值为root</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Defaults:zhj runas_default=root</span><br></pre></td></tr></table></figure>


<h1 id="logfile"><a href="#logfile" class="headerlink" title="logfile"></a>logfile</h1><p>字符串类型，sudo日志的存放位置。设置一个路径来打开日志功能，取消设置将关闭日志功能。默认情况sudo通过syslog记录日志。</p>
<p>说明：如果启用syslog，则无需开启此选项，否则建议设置为&#x2F;var&#x2F;log&#x2F;sudo.log。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Defaults logfile=/var/log/sudo.log</span><br></pre></td></tr></table></figure>


<h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><p>一个命令可以具有与它相关联的零个或多个标签。<br>有十个可能的标记值：<br>EXEC, NOEXEC, FOLLOW, NOFOLLOW, LOG_INPUT,<br>NOLOG_INPUT, LOG_OUTPUT, NOLOG_OUTPUT, MAIL, NOMAIL, PASSWD, NOPASSWD, SETENV, NOSETENV。</p>
<p>一旦标签被设置在某个命令上，在该命令列表中随后的所有命令将继承该标记，<br>直到由相反的标记项覆盖（例如PASSWD覆盖NOPASSWD，NOEXEC覆盖EXEC），这里需要重点关注的是NOPASSWD和SETENV选项。</p>
<p>1）NOPASSWD标签：<br>默认情况下，sudo要求用户运行一个命令之前对目标用户进行验证，这种行为可以通过NOPASSWD标签进行修改，<br>使用NOPASSWD后表示此后的命令都不需要进行验证。</p>
<p>2）SETENV标签：<br>为命令设置SETENV标签后，用户可以通过-E选项从命令行禁用env_reset选项，<br>同时，在命令行上设置的环境变量不受env_check，env_delete或env_keep的限制，用户就可以使用自己的环境变量。<br>因此，只允许受信任的用户以这种方式设置变量。</p>
<h1 id="用户规则"><a href="#用户规则" class="headerlink" title="用户规则"></a>用户规则</h1><p>用户可以在#User  privilege  specification下配置用户规则，用户规则确定用户可以在指定主机上运行哪些命令（以及作为哪个用户）。<br>默认情况下，命令以root身份运行，但可以基于每个命令进行更改。<br>用户规范的基本结构是“who where &#x3D; (as_whom) what”，通常的配置格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user host = run_as [option:] command</span><br><span class="line"></span><br><span class="line">user：一位或几位用户，组对象的名称用百分号%开头；</span><br><span class="line">host：一个或几个主机名，ALL表示所有主机；</span><br><span class="line">run_as：命令运行的目标用户，常见选项是root和ALL，ALL表示所有用户；</span><br><span class="line">option：影响命令运行的选项；</span><br><span class="line">command：可执行一个或几个命令，ALL表示所有命令；</span><br><span class="line">比如：jack ALL= (root) NOPASSWD: /usr/bin/cat</span><br><span class="line">表示用户jack可以在所有主机上已root用户执行/usr/bin/cat命令，且不需要root密码。</span><br></pre></td></tr></table></figure>


<h1 id="用户规则中的命令指定"><a href="#用户规则中的命令指定" class="headerlink" title="用户规则中的命令指定"></a>用户规则中的命令指定</h1><p>用户规则中，可配置的命令包括命令名和目录。命令名称是完全限定的文件名，比如系统命令(&#x2F;bin&#x2F;ls)、自定义的命令（&#x2F;opt&#x2F;sudobin&#x2F;test）、任意脚本（&#x2F;opt&#x2F;sudobin&#x2F;a.sh），这些命令可以包含shell样式的通配符。目录是以’&#x2F;‘结尾的完全限定路径名，当指定目录时，用户将能够运行该目录中的任何文件（但不能在其中的任何子目录中）。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>公钥、私钥与证书 —— 相关内容分析与实践</title>
    <url>/2021/08/26/20210826_%E5%85%AC%E9%92%A5%E7%A7%81%E9%92%A5%E4%B8%8E%E8%AF%81%E4%B9%A6%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<ul>
<li>这是我在实习中碰到的一些内容，因为之前对这一块内容一窍不通，所以就抽了几天学习了一下，不得不说收获颇丰。</li>
<li>借着这次的学习，对加密解密这方面的概念有了一定的认识，对信息传输安全相关的内容算是打了个基础，正好之前我也有做网络编程，感觉是可以尝试加入一下加密策略，不让报文裸奔了。然后就是借着证书了解了一下http&#x2F;https，算是对网络有了一点新的个人理解吧。</li>
<li>受组里的影响，我现在所有的总结都是在有道云笔记上进行的，但是说实话上面搜索有点操蛋另外markdown不让传图，由此这种长篇大论还是适合发在CSDN上。所以我完善了一下，总结出了这一篇内容。(<del>但是不得不说有道云记小东西是真的方便，生产力upup</del> )</li>
</ul>
<span id="more"></span>

<h1 id="一、概念相关"><a href="#一、概念相关" class="headerlink" title="一、概念相关"></a>一、概念相关</h1><h2 id="1-一些关键词"><a href="#1-一些关键词" class="headerlink" title="1. 一些关键词"></a>1. 一些关键词</h2><ul>
<li><strong>密钥对</strong> 在非对称加密技术中，有两种密钥，分为私钥和公钥，私钥是密钥对所有者持有，不可公布，公钥是密钥对持有者公布给他人的。</li>
<li><strong>公钥</strong> 公钥用来给数据加密，用公钥加密的数据只能使用私钥解密。</li>
<li><strong>私钥</strong> 如上，用来解密公钥加密的数据。</li>
<li><strong>摘要</strong> 对需要传输的文本，做一个HASH计算，一般采用SHA1，SHA2来获得。</li>
<li><strong>签名</strong> 使用私钥对需要传输的文本的摘要进行加密，得到的密文即被称为该次传输过程的签名。</li>
</ul>
<h2 id="2-公私钥"><a href="#2-公私钥" class="headerlink" title="2. 公私钥"></a>2. 公私钥</h2><h3 id="2-1-公私钥的优点"><a href="#2-1-公私钥的优点" class="headerlink" title="2.1 公私钥的优点"></a>2.1 公私钥的优点</h3><p>&emsp;&emsp;在对称加密中，加密和解密用的是同一个密钥。所以一旦密钥泄露，数据传输可能就会面临风险，由此非对称加密应运而生。  </p>
<p>&emsp;&emsp;在非对称加密中，存在一个密钥对，即公钥和私钥，两者只能解密对方加密的内容。在私钥不被泄露的前提下对公钥进行散发，即使在散发的过程中公钥泄露也无法解密公钥端加密的数据，相比对称式加密更加安全。</p>
<h3 id="2-2-公私钥的定义"><a href="#2-2-公私钥的定义" class="headerlink" title="2.2 公私钥的定义"></a>2.2 公私钥的定义</h3><ul>
<li>公钥：是公布出去给别人用的，可以被很多人获取。用来加密和验签</li>
<li>私钥：只能自己持有，并且不可以被其他人知道。用来解密和签名</li>
</ul>
<h3 id="2-3-公私钥的作用"><a href="#2-3-公私钥的作用" class="headerlink" title="2.3 公私钥的作用"></a>2.3 公私钥的作用</h3><ul>
<li>公钥加密的数据私钥可以解密</li>
<li>私钥加密的内容公钥可以解密</li>
</ul>
<h3 id="2-4-公私钥的关系"><a href="#2-4-公私钥的关系" class="headerlink" title="2.4 公私钥的关系"></a>2.4 公私钥的关系</h3><ul>
<li>一个公钥对应一个私钥</li>
<li>密钥对中，让大家都知道的是公钥，自己知道是私钥</li>
<li>如果用其中一个密钥加密数据，则只有对应的那个密钥才能解密</li>
<li>如果用其中一个密钥可以进行解密数据，则该数据必然由对应密钥进行加密</li>
</ul>
<h3 id="2-5-如何确保数据安全传输"><a href="#2-5-如何确保数据安全传输" class="headerlink" title="2.5 如何确保数据安全传输"></a>2.5 如何确保数据安全传输</h3><p>&emsp;&emsp;要达到数据安全传输的目的，必须发送方和接收方都持有对方的公钥和自己私钥，即任意一方持有自己的私钥和对方的公钥。  </p>
<p>&emsp;&emsp;则为了数据的安全性，B需要使用A的公钥来给数据加密，这样只有A的私钥才可以解密数据，这样保证了数据的安全性，这是数字签名。</p>
<p>&emsp;&emsp;而为了保证数据发送方的真实性，B需要使用自己的私钥来数据加密，这样其他人用B的公钥进行解密，由于只有B私钥加密的数据，B的公钥才能解密，所以他人用B的公钥若能解密此数据，则证实数据是由B发送的，若不能解密，则证明数据不是用B的私钥加密，即不是B发送的，这样保证了发送的真实性。</p>
<h2 id="3-证书"><a href="#3-证书" class="headerlink" title="3. 证书"></a>3. 证书</h2><h3 id="3-1-证书是什么"><a href="#3-1-证书是什么" class="headerlink" title="3.1 证书是什么"></a>3.1 证书是什么</h3><ul>
<li>证书可以为公钥做认证，从而可以验证公钥是否真实可信，防止他人伪造公钥</li>
</ul>
<h3 id="3-2-何时会用到证书"><a href="#3-2-何时会用到证书" class="headerlink" title="3.2 何时会用到证书"></a>3.2 何时会用到证书</h3><p>&emsp;&emsp;很明显，在一些情况下，不存在像上文中说的那种双方均持有完善密钥对的条件，比如说访问网页。  </p>
<p>&emsp;&emsp;在申请访问网页时，本机是不存在网页端的公钥的，由此网页端在收到访问申请时，需要把公钥发送给本机。在本机接收到公钥后，便可以通过公钥与网页端进行较为安全的数据传输。但是，在网页端把公钥发送给本机的过程中，公钥可能被他人篡改(比如被替换成另一个公钥)，这样在使用此公钥数据传输时就有可能被解密，从而发生泄露(比如在网页中输入的密码之类的)。此时可以确认公钥是否被篡改的证书就出现了。</p>
<h3 id="3-3-证书的作用机制"><a href="#3-3-证书的作用机制" class="headerlink" title="3.3 证书的作用机制"></a>3.3 证书的作用机制</h3><p>&emsp;&emsp;证书其实可以看作是加密后的公钥信息，其中有公钥的摘要(<strong>所以在生成证书的时候可以指定hash加密算法</strong>)，可以在发送公钥时带着证书一起发送。在本机接收到内容后，对证书进行解密即可验证随着证书一起发送的公钥是否被篡改，由此即可保证公钥的安全性。</p>
<h3 id="3-4-CA机构"><a href="#3-4-CA机构" class="headerlink" title="3.4 CA机构"></a>3.4 CA机构</h3><p>&emsp;&emsp;如果按上面说的那个证书流程走，就会出现一个问题：谁来给公钥加密成证书？如何解密证书？此时CA机构出现了。  </p>
<p>&emsp;&emsp;CA机构即证书颁发机构，它会用自己的私钥对用户的公钥和相关信息进行加密，生成”数字证书”，然后证书中心会公布自己的公钥给所有人，用来让用户使用此公钥验证”数字证书”是否由CA颁发，即是否真实可信。  </p>
<ul>
<li>那么CA的公钥怎么获取？就目前来说主流浏览器中均内置了CA的公钥，所以这个问题是不用担心的。  </li>
<li>如何确保CA的公钥没有被篡改？这套信任链的起点是CA的根证书，其中存有CA的公钥。所以如果你接受了这个根证书，则代表对这个机构的信任，则所有此机构的证书均可通过该根证书来验证。所以只需要确保根证书是真的即可。</li>
</ul>
<h3 id="3-5-CA证书与自签名证书"><a href="#3-5-CA证书与自签名证书" class="headerlink" title="3.5 CA证书与自签名证书"></a>3.5 CA证书与自签名证书</h3><p>&emsp;&emsp;CA证书是通过验证的、可以信任的，但是在CA认证过程花费不小。所以在一般的测试或者一些情况下，可以使用自签名证书。  </p>
<p>&emsp;&emsp;自签名证书相当于自己给自己发证书，所以没有办法被验证(除非你在浏览器里安装了相应的根证书)，由此浏览器可能会提示不安全。之前12306就没有获取CA证书，所以它推荐安装自己的根证书来避免被提示不安全以及确保传输安全，不过后来还是搞了CA的证书(如下图)。<br><img src="/images/2021-08-26/1.jpg" alt="12306"></p>
<h3 id="3-6-https协议工作流程"><a href="#3-6-https协议工作流程" class="headerlink" title="3.6 https协议工作流程"></a>3.6 https协议工作流程</h3><p>&emsp;&emsp;<strong>我感觉https协议工作流程可以很好的展示公私钥与证书之间的关系，由此记录一下。</strong></p>
<table>
<thead>
<tr>
<th>客户端</th>
<th>&emsp;流向&emsp;</th>
<th>服务端</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>请求https连接</td>
<td>&emsp;&gt;&gt;&emsp;</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>&emsp;&lt;&lt;&emsp;</td>
<td>返回证书公钥</td>
<td></td>
</tr>
<tr>
<td>使用CA的公钥验证<br>看证书是否有效</td>
<td>&emsp;×&emsp;</td>
<td></td>
<td>如果出现问题<br>提示不安全</td>
</tr>
<tr>
<td>根据CA的验证结果<br>看公钥是否安全</td>
<td>&emsp;×&emsp;</td>
<td></td>
<td>如果出现问题<br>提示不安全</td>
</tr>
<tr>
<td>如果上面验证都正常<br>则生成一个对称密钥</td>
<td>&emsp;×&emsp;</td>
<td></td>
<td>这个密钥作用在<br>之后的密文通信</td>
</tr>
<tr>
<td>使用服务端的公钥<br>加密上一步生成的密钥<br>把加密结果发送给服务端</td>
<td>&emsp;&gt;&gt;&emsp;</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>&emsp;×&emsp;</td>
<td>收到加密后的密钥<br>使用私钥进行解密<br>得到对称密钥</td>
<td></td>
</tr>
<tr>
<td></td>
<td>&emsp;&lt;&lt;&emsp;</td>
<td>使用对称密钥加密信息<br>发送给客户端</td>
<td></td>
</tr>
<tr>
<td>使用对称密钥解密信息<br>得到信息</td>
<td>&emsp;×&emsp;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>使用对称密钥加密信息<br>发送给服务端</td>
<td>&emsp;&gt;&gt;&emsp;</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>&emsp;×&emsp;</td>
<td>使用对称密钥解密信息<br>得到信息</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>通过对称密钥加密<br>的密文通道</td>
</tr>
</tbody></table>
<h1 id="二、openssl工具"><a href="#二、openssl工具" class="headerlink" title="二、openssl工具"></a>二、openssl工具</h1><h2 id="1-openssl-genrsa-–-生成私钥"><a href="#1-openssl-genrsa-–-生成私钥" class="headerlink" title="1. openssl genrsa – 生成私钥"></a>1. openssl genrsa – 生成私钥</h2><p><strong>用于生成RSA私钥，不会生成公钥，因为公钥提取自私钥。</strong></p>
<p>openssl genrsa [-out filename] [-passout arg] [-des] [-des3] [-idea] [numbits]</p>
<ul>
<li><strong>-out filename</strong> ：将生成的私钥保存至filename文件,若未指定输出文件,则为标准输出。</li>
<li><strong>numbits</strong> ：指定要生成的私钥的长度,默认为1024。该项必须为命令行的最后一项参数。</li>
<li><strong>-des</strong> ：生成的密钥使用des方式进行加密。</li>
<li><strong>-des3</strong> ：生成的密钥使用des3方式进行加密。</li>
<li><strong>-passout args</strong> ：加密私钥文件时,传递密码的格式,如果要加密私钥文件时单未指定该项,则提示输入密码。传递密码的args的格式,可从密码、环境变量、文件、终端等输入。<br>a. <strong>pass:password</strong> ：password表示传递的明文密码<br>b. <strong>env:var</strong> ：从环境变量var获取密码值<br>c. <strong>file:filename</strong> ：filename文件中的第一行为要传递的密码。若filename同时传递给”-passin”和”-passout”选项，则filename的第一行为”-passin”的值，第二行为”-passout”的值<br>d. <strong>stdin</strong> ：从标准输入中获取要传递的密码</li>
</ul>
<h2 id="2-openssl-req-–-证书相关"><a href="#2-openssl-req-–-证书相关" class="headerlink" title="2. openssl req – 证书相关"></a>2. openssl req – 证书相关</h2><p><strong>生成证书请求文件、验证证书请求文件和创建根CA。</strong></p>
<p> openssl req<br>[-new] [-newkey rsa:bits] [-verify] [-x509] [-in filename] [-out filename]<br>[-key filename] [-passin arg] [-passout arg] [-keyout filename] [-pubkey]<br>[-nodes] [-[dgst]] [-config filename] [-subj arg] [-days n] [-set_serial n]<br>[-extensions section] [-reqexts section] [-utf8] [-nameopt] [-reqopt]<br>[-subject] [-subj arg] [-text] [-noout] [-batch] [-verbose]</p>
<p><strong>简单说明几个参数：</strong></p>
<ul>
<li><p><strong>-new</strong> ：创建一个证书请求文件，会交互式提醒输入一些信息，这些交互选项以及交互选项信息的长度值以及其他一些扩展属性在配置文件(默认为openssl.cnf，还有些辅助配置文件)中指定了默认值。<strong>如果</strong>没有指定”-key”选项，则会自动生成一个RSA私钥，该私钥的生成位置也在openssl.cnf中指定了。<strong>如果</strong>指定了-x509选项，则表示创建的是自签署证书文件，而非证书请求文件</p>
</li>
<li><p><strong>-newkey args</strong> ：类似于”-new”选项，创建一个新的证书请求，并创建私钥。args的格式是”rsa:bits”(其他加密算法请查看man)，其中bits是rsa密钥的长度，<strong>如果</strong>bits省略了(即-newkeyrsa)，则长度根据配置文件中default_bits指令的值作为默认长度，默认该值为2048.<strong>如果</strong>指定了-x509选项，则表示创建的是自签署证书文件，而非证书请求文件</p>
</li>
<li><p><strong>-nodes</strong>  ：默认情况下，openssl req自动创建私钥时都要求加密并提示输入加密密码，指定该选项后则禁止对私钥文件加密</p>
</li>
<li><p><strong>-key filename</strong>  ：指定私钥的输入文件，创建证书请求时需要</p>
</li>
<li><p><strong>-keyout filename</strong> ：指定自动创建私钥时私钥的存放位置，若未指定该选项，则使用配置文件中default_keyfile指定的值，默认该值为privkey.pem</p>
</li>
<li><p><strong>-x509</strong> ：指定该选项时，将生成一个自签署证书，而不是创建证书请求。一般用于测试或者为根CA创建自签名证书</p>
</li>
<li><p><strong>-days n</strong>  ：指定自签名证书的有效期限，默认30天，需要和”-x509”一起使用。</p>
</li>
<li><p><strong>-[dgst]</strong>  ：指定对创建请求时提供的申请者信息进行数字签名时的单向加密算法，如-md5&#x2F;-sha1&#x2F;-sha512等.</p>
</li>
<li><p><strong>-out filename</strong>  ：证书请求或自签署证书的输出文件，也可以是其他内容的输出文件，不指定时默认stdout</p>
</li>
<li><p><strong>-text</strong>  ：以文本格式打印证书请求</p>
</li>
<li><p><strong>-noout</strong>  ：不输出部分信息 -subject ：输出证书请求文件中的subject(如果指定了x509，则打印证书中的subject)</p>
</li>
<li><p><strong>-pubkey</strong>  ：输出证书请求文件中的公钥</p>
</li>
</ul>
<h2 id="3-openssl-rsa-–-提取公钥"><a href="#3-openssl-rsa-–-提取公钥" class="headerlink" title="3. openssl rsa – 提取公钥"></a>3. openssl rsa – 提取公钥</h2><p><strong>Rsa命令用于处理RSA密钥、格式转换和打印信息。</strong>  </p>
<p>openssl rsa<br>[-inform PEM|NET|DER] [-outform PEM|NET|DER] [-in filename] [-passin arg]<br>[-out filename] [-passout arg] [-sgckey]<br>[-text] [-noout] [-modulus] [-check] [-pubin] [-pubout]<br>[-engine id] [-des] [-des3] [-idea]</p>
<p><strong>简单说明几个例子：</strong></p>
<p>从私钥中提取公钥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl rsa -in private.key -pubout -out public.key</span><br></pre></td></tr></table></figure>
<p>查看公钥信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl rsa -pubin -in pubkey.key -text</span><br></pre></td></tr></table></figure>
<p>查看私钥信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl rsa -in prikey.key -passin pass:&quot;123456&quot; -text</span><br></pre></td></tr></table></figure>
<h2 id="4-openssl-rsautl-–-加解密"><a href="#4-openssl-rsautl-–-加解密" class="headerlink" title="4. openssl rsautl – 加解密"></a>4. openssl rsautl – 加解密</h2><p><strong>rsautl命令用于依据公私钥加解密数据。</strong></p>
<p><strong>下面是几个示例：</strong></p>
<p>公钥进行加密 (被加密文件为testFile 加密后文件为temp)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl rsautl -encrypt -in testFile -inkey pub_test.key -pubin -out temp   </span><br></pre></td></tr></table></figure>
<p>私钥进行解密 (被解密文件为temp 解密后文件为newFile)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl rsautl -decrypt -in temp -inkey pri_test.key -out newFile   </span><br></pre></td></tr></table></figure>
<p>私钥进行加密(签名) (被加密文件为testFile 加密后文件为temp)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl rsautl -sign -in testFile -inkey pri_test.key -out temp </span><br></pre></td></tr></table></figure>
<p>公钥进行解密 (被解密文件为temp 解密后文件为newFile)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl rsautl -verify -in temp -inkey pub_test.key -pubin -out newFile </span><br></pre></td></tr></table></figure>
<h2 id="5-openssl示例-–-公私钥、证书与加密"><a href="#5-openssl示例-–-公私钥、证书与加密" class="headerlink" title="5. openssl示例 – 公私钥、证书与加密"></a>5. openssl示例 – 公私钥、证书与加密</h2><p><strong>下面是一组示例。</strong></p>
<p>使用des3加密生成一个叫做pri_test.key的私钥，长度为2048</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl genrsa -des3 -out pri_test.key 2048 </span><br></pre></td></tr></table></figure>
<p>从私钥中提取出公钥，公钥取名为pub_test.key</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl rsa -in pri_test.key -pubout -out pub_test.key  </span><br></pre></td></tr></table></figure>
<p>生成一个叫做req1.csr的证书请求，规定证书签名算法为sha256</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl req -new -key pri_test.key -out req1.csr -sha256    </span><br></pre></td></tr></table></figure>
<p>查看证书请求req1.csr的信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl req -in req1.csr -text </span><br></pre></td></tr></table></figure>
<p>验证证书请求是否被修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl req -verify -in req1.csr    </span><br></pre></td></tr></table></figure>
<p>依据证书请求文件创建自签名证书CA1.pem，有效期365天</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl req -x509 -key pri_test.key -in req1.csr -out CA1.pem -days 365</span><br></pre></td></tr></table></figure>
<p>当然也可以直接通过私钥创建自签名证书CA2.pem</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl req -new -x509 -key pri_test.key -out CA2.pem -days 365</span><br></pre></td></tr></table></figure>

<p><strong>由此公私钥、自签名证书创建完毕，下面是加密相关。</strong></p>
<p>创建测试文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim testFile </span><br><span class="line">Hi~</span><br><span class="line">This 1s @ test 文件!</span><br></pre></td></tr></table></figure>
<p>公钥进行加密 (被加密文件为testFile 加密后文件为temp)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl rsautl -encrypt -in testFile -inkey pub_test.key -pubin -out temp   </span><br></pre></td></tr></table></figure>
<p>私钥进行解密 (被解密文件为temp 解密后文件为newFile)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl rsautl -decrypt -in temp -inkey pri_test.key -out newFile   </span><br></pre></td></tr></table></figure>
<p>私钥进行加密(签名) (被加密文件为testFile 加密后文件为temp)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl rsautl -sign -in testFile -inkey pri_test.key -out temp </span><br></pre></td></tr></table></figure>
<p>公钥进行解密 (被解密文件为temp 解密后文件为newFile)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl rsautl -verify -in temp -inkey pub_test.key -pubin -out newFile </span><br></pre></td></tr></table></figure>
<h1 id="三、在C语言中使用openssl库"><a href="#三、在C语言中使用openssl库" class="headerlink" title="三、在C语言中使用openssl库"></a>三、在C语言中使用openssl库</h1><h2 id="1-前期准备"><a href="#1-前期准备" class="headerlink" title="1. 前期准备"></a>1. 前期准备</h2><p>首先得确保当前环境下存在openssl库。官网下载地址:<a href="https://www.openssl.org/source/">https://www.openssl.org/source/</a></p>
<p>具体步骤可以去网上搜一下。大致就是下载后解压，然后<code>./config</code>和<code>make</code>命令进行配置与编译，最后<code>make install</code>安装一下就好了。安装好以后就可以使用openssl的库文件了。</p>
<h2 id="2-程序实例-–-公私钥加密解密"><a href="#2-程序实例-–-公私钥加密解密" class="headerlink" title="2. 程序实例 – 公私钥加密解密"></a>2. 程序实例 – 公私钥加密解密</h2><p>这个例子来自于我在网上找到的代码，我对它进行了一些注释和改动，主要目的是为了看一下openssl在C语言中相关的接口函数。</p>
<p><strong>注意∶</strong>编译时应加上参数<code>-lcrypto</code>来连接相关的动态库</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;openssl/rsa.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;openssl/pem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;openssl/err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OPENSSLKEY <span class="string">&quot;pri_test.key&quot;</span><span class="comment">//私钥</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUBLICKEY <span class="string">&quot;pub_test.key&quot;</span><span class="comment">//公钥</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFSIZE 1024</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">my_encrypt</span><span class="params">(<span class="type">char</span> *str,<span class="type">char</span> *path_key)</span>;<span class="comment">//加密</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">my_decrypt</span><span class="params">(<span class="type">char</span> *str,<span class="type">char</span> *path_key)</span>;<span class="comment">//解密</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">char</span> *source=<span class="string">&quot;Hi~ \nThis 1s @ test 文件&quot;</span>;<span class="comment">//要加密的文件</span></span><br><span class="line">    <span class="type">char</span> *ptr_en,*ptr_de;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;source is    :\n%s\n&quot;</span>,source);<span class="comment">//加密前</span></span><br><span class="line">    ptr_en=my_encrypt(source,PUBLICKEY);<span class="comment">//加密</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;after encrypt:\n%s\n&quot;</span>,ptr_en);<span class="comment">//加密后</span></span><br><span class="line">    ptr_de=my_decrypt(ptr_en,OPENSSLKEY);<span class="comment">//解密</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;after decrypt:\n%s\n&quot;</span>,ptr_de);<span class="comment">//解密后</span></span><br><span class="line">    <span class="keyword">if</span>(ptr_en!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">free</span>(ptr_en);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ptr_de!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">free</span>(ptr_de);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加密</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">my_encrypt</span><span class="params">(<span class="type">char</span> *str,<span class="type">char</span> *path_key)</span>&#123;</span><br><span class="line">    <span class="type">char</span> *p_en;</span><br><span class="line">    RSA *p_rsa;</span><br><span class="line">    FILE *file;</span><br><span class="line">    <span class="type">int</span> flen,rsa_len;</span><br><span class="line">    <span class="keyword">if</span>((file=fopen(path_key,<span class="string">&quot;r&quot;</span>))==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open key file error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((p_rsa=PEM_read_RSA_PUBKEY(file,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>))==<span class="literal">NULL</span>)&#123;<span class="comment">//读公钥</span></span><br><span class="line">        ERR_print_errors_fp(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    flen=<span class="built_in">strlen</span>(str);</span><br><span class="line">    rsa_len=RSA_size(p_rsa);</span><br><span class="line">    p_en=(<span class="type">unsigned</span> <span class="type">char</span> *)<span class="built_in">malloc</span>(rsa_len+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(p_en,<span class="number">0</span>,rsa_len+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(RSA_public_encrypt(rsa_len,(<span class="type">unsigned</span> <span class="type">char</span> *)str,(<span class="type">unsigned</span> <span class="type">char</span>*)p_en,p_rsa,RSA_NO_PADDING)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="comment">//这里进行加密</span></span><br><span class="line">    RSA_free(p_rsa);</span><br><span class="line">    fclose(file);</span><br><span class="line">    <span class="keyword">return</span> p_en;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解密</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">my_decrypt</span><span class="params">(<span class="type">char</span> *str,<span class="type">char</span> *path_key)</span>&#123;</span><br><span class="line">    <span class="type">char</span> *p_de;</span><br><span class="line">    RSA *p_rsa;</span><br><span class="line">    FILE *file;</span><br><span class="line">    <span class="type">int</span> rsa_len;</span><br><span class="line">    <span class="keyword">if</span>((file=fopen(path_key,<span class="string">&quot;r&quot;</span>))==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open key file error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((p_rsa=PEM_read_RSAPrivateKey(file,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>))==<span class="literal">NULL</span>)&#123;<span class="comment">//读私钥</span></span><br><span class="line">        ERR_print_errors_fp(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rsa_len=RSA_size(p_rsa);</span><br><span class="line">    p_de=(<span class="type">unsigned</span> <span class="type">char</span> *)<span class="built_in">malloc</span>(rsa_len+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(p_de,<span class="number">0</span>,rsa_len+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(RSA_private_decrypt(rsa_len,(<span class="type">unsigned</span> <span class="type">char</span> *)str,(<span class="type">unsigned</span> <span class="type">char</span>*)p_de,p_rsa,RSA_NO_PADDING)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="comment">//这里进行解密</span></span><br><span class="line">    RSA_free(p_rsa);</span><br><span class="line">    fclose(file);</span><br><span class="line">    <span class="keyword">return</span> p_de;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如下图为执行结果：</strong><br><img src="/images/2021-08-26/2.jpg" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux学习记录：shell脚本</title>
    <url>/2021/08/31/20210831_linux%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9Ashell%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<ul>
<li>这是本人在学习shell脚本时的记录，方便日后查询。</li>
<li>里面会记录一些自己写的shell脚本，都是在实习中用到的。由此这篇笔记的内容也会不断扩充，也算是记录一下心路历程。</li>
<li>默认使用解释器<code>/bin/bash</code></li>
</ul>
<span id="more"></span>

<h1 id="零、shell基础"><a href="#零、shell基础" class="headerlink" title="零、shell基础"></a>零、shell基础</h1><p>&emsp;&emsp;通过命令<code>cat /etc/shells</code>可以查看当前系统支持的解释器。如下图，可以看到这个系统支持解释器<code>sh</code>和<code>bash</code>。可以直接执行解释器文件来进入新的shell命令行，相当于套娃，并可以输入命令<code>exit</code>来退出shell命令行。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/3d18973468af009d7b489f4959880d57.png" alt="1"></p>
<p>&emsp;&emsp;然后是几个很常见的<strong>快捷键</strong>。<br>&emsp;&emsp;<code>bash</code>和<code>sh</code>都是支持使用键盘的上下方向键来查询历史记录的。这样在操作有共同之处时，就可以对之前的命令进行简单修改来更快捷的执行命令。此时<code>ctrl a</code>与<code>ctrl e</code>就会显得很好用，可以避免光标挨个移动到头…<br>&emsp;&emsp;关于清屏的<code>ctrl l</code>，命令<code>clear</code>和它的效果是一样的。但是有一点需要注意，由于现在很多终端是支持鼠标滑轮上下翻滚的(例如图形化发行版的终端和各类模拟终端)，所以当输出太多时，清屏后的输出并不能很好的与上文分割。所以我一般会长按回车手动清屏，这样在输出刷屏后，也可以很轻易的翻出此次输出的开头。<del>而<code>ctrl l</code>带给我的，可能是一丝源自强迫症的清爽。</del> </p>
<table>
<thead>
<tr>
<th>操作</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>ctrl a</td>
<td>移动到最前</td>
</tr>
<tr>
<td>ctrl e</td>
<td>移动到最后</td>
</tr>
<tr>
<td>ctrl c</td>
<td>撤销当前命令</td>
</tr>
<tr>
<td>ctrl l</td>
<td>清屏</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;接着是很重要的<strong>输出重定向</strong>。<br>&emsp;&emsp;在shell执行完命令后，一般来说都会有输出。这个输出可能是错误输出，例如提示权限不足、参数错误等等；也可能是常规的输出，即命令正确执行后的输出。但是有时候可能只想让输出显示错误信息或正确信息或是都不显示，当然也有可能是想把输出信息保存下来，这时就需要用到输出重定向了。<br>&emsp;&emsp;这里不细说符号功能，只记录一下我在脚本中使用的感受。就目前我用到的场景来看，大部分用到的是<code>2&gt;/dev/null</code>，这个意思是忽略报错信息。比如在<code>find /</code>全盘扫描，扫到<code>/proc</code>进程目录时，由于进程信息改变，很有可能报错找不到文件，这种错误是不重要的所以可以忽略报错信息来确保输出的纯净性。<br>&emsp;&emsp;当然有时也需要把一些内容重定向输出到文件里，比如上面的<code>find</code>找到内容后可能要把找到的内容存放在一个文本文件中保存，这时候就可以使用<code>&gt;</code>或<code>&gt;&gt;</code>。这里要根据情况来选择是<code>&gt;</code>追加还是<code>&gt;&gt;</code>覆盖。总而言之输出重定向用的还是蛮多的。当然输入重定向<code>&lt;</code>我感觉用的也不少，只不过可能没有输出重定向<code>&gt;</code>用的多罢了。</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>&gt;</td>
<td>正确(覆盖)</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>正确(追加)</td>
</tr>
<tr>
<td>2&gt;</td>
<td>错误(覆盖)</td>
</tr>
<tr>
<td>2&gt;&gt;</td>
<td>错误(追加)</td>
</tr>
<tr>
<td>&amp;&gt;</td>
<td>正确&amp;错误(覆盖)</td>
</tr>
<tr>
<td>&amp;&gt;&gt;</td>
<td>正确&amp;错误(追加)</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;最后要提一嘴的是最常用的符号之一，<strong>管道</strong><code>|</code>。<br>&emsp;&emsp;这个涉及到流的概念，可以理解为把管道前面命令的结果流向管道后面的命令，使得流入的结果成为后面命令的输入。<br>&emsp;&emsp;在脚本中，可以对命令进行慢慢的涉及和尝试，所以很可能一个命令会变得很长很复杂，而其中少不了的就是这个管道。在使用管道时要注意一下参数传递的格式，例如在<code>find</code>寻找完数据后，往往要在管道后用<code>xargs</code>处理一下，把结果转为命令行参数，从而可以正常执行后续命令，这东西我感觉用的也挺多的。</p>
<h1 id="一、变量"><a href="#一、变量" class="headerlink" title="一、变量"></a>一、变量</h1><h2 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h2><p>&emsp;&emsp;格式为<code>变量名=变量值</code>，取消变量用<code>unset 变量名</code>，在引用时用<code>$变量名</code>。需要注意的是，**等号两边不能有空格，且变量不可以使用数字开头(组成：字母&#x2F;数字&#x2F;下划线)**，当变量已经存在时，会覆盖原来的值，所以如果想要添加变量的值，可以使用<code>变量=$&#123;变量&#125;要添加的值</code>这种操作扩充变量。<br>&emsp;&emsp;这里提一嘴：shell脚本里应该是没有Makefile里的<code>:=</code>等操作的，所以想扩充变量内容得使用上面那种重声明覆盖的方法(当然也有别的方法)，就这一部分来看，感觉还是Makefile那边方便点。</p>
<h2 id="2-各种变量类型"><a href="#2-各种变量类型" class="headerlink" title="2. 各种变量类型"></a>2. 各种变量类型</h2><h3 id="2-1-环境变量"><a href="#2-1-环境变量" class="headerlink" title="2.1 环境变量"></a>2.1 环境变量</h3><ul>
<li>这部分内容都储存在<code>/etc/profile</code>内，也有可能在依据某用户配置的<code>~/.bash_profile</code>内</li>
<li>使用命令<code>env</code>可以查看所有环境变量</li>
<li>个人感觉常用的环境变量有<code>PWD</code>、<code>PATH</code>、<code>UID</code>、<code>USER</code>、<code>SHELL</code>、<code>HOME</code>等</li>
</ul>
<h3 id="2-2-位置变量"><a href="#2-2-位置变量" class="headerlink" title="2.2 位置变量"></a>2.2 位置变量</h3><ul>
<li>就是bash内置的变量，储存脚本执行时的参数</li>
<li>在执行脚本时可以直接在后面加上参数，而脚本里不用声明，这就是位置变量</li>
<li>例如我写了一个脚本<code>test.sh</code>，启动命令为<code>bash test.sh hello world</code>，则<code>hello</code>和<code>world</code>均为参数(由位置变量储存)，在脚本中通过<code>$1、$2</code>这样的格式来指定($1为hello、$2为world)</li>
</ul>
<h3 id="2-3-预定义变量"><a href="#2-3-预定义变量" class="headerlink" title="2.3 预定义变量"></a>2.3 预定义变量</h3><ul>
<li>用来保存进程内相关信息</li>
<li>这些变量可以直接使用，且不能赋值</li>
<li>个人感觉<code>$?</code>是我使用最多的预定义变量</li>
</ul>
<table>
<thead>
<tr>
<th>符号</th>
<th>意义</th>
<th>在bash内直接调用的结果(bash没有位置变量)</th>
</tr>
</thead>
<tbody><tr>
<td>$0</td>
<td>当前所在进程或脚本名</td>
<td><img src="https://i-blog.csdnimg.cn/blog_migrate/fad12c1525538a59c7cc5cc959e8011c.png" alt="2"></td>
</tr>
<tr>
<td>$$</td>
<td>当前运行进程的PID号</td>
<td><img src="https://i-blog.csdnimg.cn/blog_migrate/d4ce9d93d12c1d13542e437d190f0b61.png" alt="1"></td>
</tr>
<tr>
<td>$?</td>
<td>命令执行后的状态 0为正常 其他值为异常</td>
<td><img src="https://i-blog.csdnimg.cn/blog_migrate/c543db5845da1bc2125145a8a99c2edd.png" alt="3"></td>
</tr>
<tr>
<td>$#</td>
<td>已加载的位置变量个数</td>
<td><img src="https://i-blog.csdnimg.cn/blog_migrate/a08c6be7c9b2d7f0342f104519aa5040.png" alt="4"></td>
</tr>
<tr>
<td>$*</td>
<td>所有位置变量的值</td>
<td><img src="https://i-blog.csdnimg.cn/blog_migrate/928102632d09a18431280a0d553b0c81.png" alt="5"></td>
</tr>
</tbody></table>
<h3 id="2-4-自定义变量"><a href="#2-4-自定义变量" class="headerlink" title="2.4 自定义变量"></a>2.4 自定义变量</h3><ul>
<li>就是用户自己定义的变量</li>
</ul>
<h2 id="3-变量扩展内容"><a href="#3-变量扩展内容" class="headerlink" title="3. 变量扩展内容"></a>3. 变量扩展内容</h2><h3 id="3-1-三种定界符"><a href="#3-1-三种定界符" class="headerlink" title="3.1 三种定界符"></a>3.1 三种定界符</h3><table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>单引号<code>&#39; &#39;</code></td>
<td>禁止扩展 比如<code>$</code>变量视为普通字符</td>
</tr>
<tr>
<td>双引号<code>&quot; &quot;</code></td>
<td>允许扩展 比如<code>$</code>变量会进行替换</td>
</tr>
<tr>
<td>反引号<code>``</code></td>
<td>执行反引号内的命令 并将结果返回 等同于<code>$(命令)</code></td>
</tr>
<tr>
<td><img src="https://i-blog.csdnimg.cn/blog_migrate/8bb215705a9757b1cc957435f6c8d406.png" alt="反引号实例"></td>
<td></td>
</tr>
</tbody></table>
<h3 id="3-2-read"><a href="#3-2-read" class="headerlink" title="3.2 read"></a>3.2 read</h3><ul>
<li>通过read可以从键盘接收内容使其赋值到指定变量上</li>
<li>格式为：<code>read [-p &quot;提示信息&quot;] 变量名</code></li>
<li><code>-t</code>可以指定超时时间</li>
<li><code>-s</code>可以指定是否在shell里显示输入的内容(在设定密码之类的内容时候用)</li>
</ul>
<h3 id="3-3-局部变量和全局变量"><a href="#3-3-局部变量和全局变量" class="headerlink" title="3.3 局部变量和全局变量"></a>3.3 局部变量和全局变量</h3><ul>
<li>使用<code>变量名=变量名</code>这种格式声明的变量，只能在当前shell环境下使用。一旦不在当前shell，这些变量就不存在了。<strong>这就是局部变量</strong></li>
<li>可以通过<code>export 变量名=变量名</code>这种格式来声明全局变量，这样所有的shell环境中都可以使用这个变量。<strong>这就是全局变量</strong></li>
</ul>
<h3 id="3-4-变量初始化判定"><a href="#3-4-变量初始化判定" class="headerlink" title="3.4 变量初始化判定"></a>3.4 变量初始化判定</h3><ul>
<li>有时候不知道变量是否已经存在且初始化，需要有一个默认值，可以通过这样来实现：</li>
<li><code>$&#123;变量:-关键词&#125;</code></li>
<li>当变量已初始化，则结果为变量的值；否则结果为后面的关键词<br><img src="https://i-blog.csdnimg.cn/blog_migrate/d64bd3e7b4252dcf4d689e1f25f0a231.png" alt="0"></li>
</ul>
<h1 id="二、运算"><a href="#二、运算" class="headerlink" title="二、运算"></a>二、运算</h1><h2 id="1-运算"><a href="#1-运算" class="headerlink" title="1. $[] 运算"></a>1. $[] 运算</h2><ul>
<li><code>$[]</code>等同于<code>$(())</code></li>
<li>格式为：<code>$[整数1 运算符 整数2 ... ...]</code>，其中并不支持小数运算，需要注意</li>
<li>计算结果会替换这个表达式本身，可以赋值或者直接<code>echo</code><br><img src="https://i-blog.csdnimg.cn/blog_migrate/efc126113aec3b088f327d49a51e5dab.png" alt="2"></li>
</ul>
<h2 id="2-自加自减-运算"><a href="#2-自加自减-运算" class="headerlink" title="2. 自加自减 运算"></a>2. 自加自减 运算</h2><ul>
<li>直接<code>let</code>就行，还是那一套东西<br> <img src="https://i-blog.csdnimg.cn/blog_migrate/483b1ab367bc9eb6bd4803168613a337.png" alt="3"></li>
</ul>
<h1 id="三、条件测试"><a href="#三、条件测试" class="headerlink" title="三、条件测试"></a>三、条件测试</h1><h2 id="1-字符串条件"><a href="#1-字符串条件" class="headerlink" title="1. 字符串条件"></a>1. 字符串条件</h2><table>
<thead>
<tr>
<th>格式</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>[ -z 字符串 ]</code></td>
<td>字符串是否为空</td>
</tr>
<tr>
<td><code>[ -n 字符串 ] </code></td>
<td>字符串是否存在</td>
</tr>
<tr>
<td><code>[ 字符串1 == 字符串2 ]</code></td>
<td>字符串判等</td>
</tr>
<tr>
<td><code>[ 字符串1 != 字符串2 ]</code></td>
<td>字符串判不等</td>
</tr>
</tbody></table>
<h2 id="2-整数条件"><a href="#2-整数条件" class="headerlink" title="2. 整数条件"></a>2. 整数条件</h2><ul>
<li>格式为<code>[ 整数1 参数 整数2 ]</code>，注意要有空格</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-eq</td>
<td>等于</td>
</tr>
<tr>
<td>-ne</td>
<td>不等于</td>
</tr>
<tr>
<td>-ge</td>
<td>大于等于</td>
</tr>
<tr>
<td>-le</td>
<td>小于等于</td>
</tr>
<tr>
<td>-gt</td>
<td>大于</td>
</tr>
<tr>
<td>-lt</td>
<td>小于</td>
</tr>
</tbody></table>
<h2 id="3-文件条件"><a href="#3-文件条件" class="headerlink" title="3. 文件条件"></a>3. 文件条件</h2><ul>
<li>格式为<code>[ 参数 文件或目录 ]</code>，注意要有空格</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-e</td>
<td>是否存在</td>
</tr>
<tr>
<td>-d</td>
<td>是否为目录</td>
</tr>
<tr>
<td>-f</td>
<td>是否为文件</td>
</tr>
<tr>
<td>-r</td>
<td>是否有r权限</td>
</tr>
<tr>
<td>-w</td>
<td>是否有w权限</td>
</tr>
<tr>
<td>-x</td>
<td>是否有x权限</td>
</tr>
</tbody></table>
<h2 id="4-控制符"><a href="#4-控制符" class="headerlink" title="4. 控制符"></a>4. 控制符</h2><ul>
<li>三个常用的控制符 <code>&amp;&amp;</code>、<code>||</code>、<code>;</code></li>
<li><code>;</code>用来分割语句，比如说<code>cd /etc; pwd</code>就是先执行<code>cd</code>再执行<code>pwd</code></li>
<li><code>&amp;&amp;</code>不管其前面的命令执行是否成功，均执行后面的命令</li>
<li><code>||</code>当前面的命令执行成功时就不执行后面，前面执行失败了就执行后面的命令</li>
<li><code>&amp;&amp;</code>优先级比<code>||</code>高，所以优先执行<code>&amp;&amp;</code>。比如这条命令<code>[ a == a ] &amp;&amp; echo Y || echo N</code>，输出就是Y；命令<code>[ a == b] &amp;&amp; echo Y || echo N</code>，输出就是N</li>
</ul>
<p>同理可以这么用：<br><code>[ 判断1 ] &amp;&amp; [判断2]</code>或<code>[ 判断1 ] || [判断2]</code></p>
<h1 id="四、if语句"><a href="#四、if语句" class="headerlink" title="四、if语句"></a>四、if语句</h1><p>&emsp;&emsp;最常用的句式，我一般是按下面这个结构写，<code>then</code>放上面。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件测试;then</span><br><span class="line">	操作</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;然后呢，多重判断结构语法是这样的，就是记住有个then就行。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件测试;then</span><br><span class="line">	操作</span><br><span class="line">elif 条件测试;then</span><br><span class="line">	操作</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	操作</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h1 id="五、for循环"><a href="#五、for循环" class="headerlink" title="五、for循环"></a>五、for循环</h1><p>&emsp;&emsp;有两种写法，分别是：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一种</span></span><br><span class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> 值列表</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	操作</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种</span></span><br><span class="line"><span class="keyword">for</span> ((初值;条件;步长))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	操作</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;第一种的话，我感觉用的比较多，一般是<code>find</code>或是什么检索出的结构列表，通过<code>for</code>来挨个判定操作。比如说下面这种用法：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 挨个显示/etc/passwd里的用户名</span></span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> `cat /etc/passwd | awk <span class="operator">-F</span>: &#123;<span class="string">&#x27;print $1&#x27;</span>&#125;`;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$user</span>;</span><br><span class="line">done;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;第二种的话，反正我目前没咋用过，可能以后会用到吧。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ((i=<span class="number">0</span>;i&lt;=<span class="number">5</span>;i++))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        <span class="built_in">echo</span> hello</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h1 id="六、while循环"><a href="#六、while循环" class="headerlink" title="六、while循环"></a>六、while循环</h1><p>&emsp;&emsp;语法格式是这样的：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件测试</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	操作</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;一个简单的例子：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">i=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$i</span> -<span class="type">eq</span> <span class="number">0</span> ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">	let i++</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h1 id="七、case语句"><a href="#七、case语句" class="headerlink" title="七、case语句"></a>七、case语句</h1><p>&emsp;&emsp;语法格式是这样的：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">case 变量 <span class="keyword">in</span></span><br><span class="line">模式<span class="number">1</span>)</span><br><span class="line">	操作 ;;</span><br><span class="line">模式<span class="number">2</span>)</span><br><span class="line">	操作 ;;</span><br><span class="line">...</span><br><span class="line">*)</span><br><span class="line">	操作 ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;需要注意的是，最终结尾是两个分号。这里的<code>*)</code>相当于c case里的<code>default</code>。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">x=<span class="number">4</span></span><br><span class="line">case x <span class="keyword">in</span></span><br><span class="line"><span class="number">1</span>)</span><br><span class="line">        <span class="built_in">echo</span> this is <span class="number">1</span> ;;</span><br><span class="line"><span class="number">2</span>)</span><br><span class="line">        <span class="built_in">echo</span> this is <span class="number">2</span> ;;</span><br><span class="line">*)</span><br><span class="line">        <span class="built_in">echo</span> error</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/713e0bb3eb93c62ab364569917df8d54.png" alt="7"></p>
<h1 id="八、数组"><a href="#八、数组" class="headerlink" title="八、数组"></a>八、数组</h1><p>&emsp;&emsp;定义很简单，括号括起来，元素之间用空格隔开，例如<code>test=(z h j)</code>。调用时也很简单，大括号加中括号，例如<code>echo $&#123;test[0]&#125;</code>。下面是演示。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/a518df9a853712e396561b9b3eb48423.png" alt="8"><br>&emsp;&emsp;如果不加大括号的话，就会输出数组第一个元素加上中括号内容，如下图。所以需要加上大括号来告诉系统中括号内的东西和变量是一体的。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/8de971d11acbae65c4b7f2f0b8abb2af.png" alt="8"></p>
<h1 id="九、shell函数"><a href="#九、shell函数" class="headerlink" title="九、shell函数"></a>九、shell函数</h1><p>&emsp;&emsp;语法格式是这样的：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">函数名() &#123;</span><br><span class="line">	操作</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">调用的话，直接</span><br><span class="line">函数名 [<span class="variable">$1</span> <span class="variable">$2</span> <span class="variable">$3</span> <span class="type">...</span>]</span><br><span class="line">就行</span><br></pre></td></tr></table></figure>
<p>例子如下：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/e1e00d65faabe4950beff962d99b986f.png" alt="9"></p>
<h1 id="十、中断与退出"><a href="#十、中断与退出" class="headerlink" title="十、中断与退出"></a>十、中断与退出</h1><p>&emsp;&emsp;就是三个东西：<code>continue</code>、<code>break</code>和<code>exit</code>。怎么用也不多说了，跟c里一样。</p>
<ul>
<li><code>continue</code>是结束单次循环</li>
<li><code>break</code>是结束一个循环体</li>
<li><code>exit</code>可以退出脚本</li>
</ul>
<h1 id="十一、字符串处理"><a href="#十一、字符串处理" class="headerlink" title="十一、字符串处理"></a>十一、字符串处理</h1><h2 id="1-显示指定区域"><a href="#1-显示指定区域" class="headerlink" title="1. 显示指定区域"></a>1. 显示指定区域</h2><ul>
<li>语法为<code>$&#123;变量:起始位置:长度&#125;</code>，和数组一样下标从0开始计数<br><img src="https://i-blog.csdnimg.cn/blog_migrate/bb5d0d05f79162b400a7d41901ddc02e.png" alt="11"></li>
</ul>
<h2 id="2-字符串替换"><a href="#2-字符串替换" class="headerlink" title="2. 字符串替换"></a>2. 字符串替换</h2><ul>
<li>替换一次：<code>$&#123;变量/旧字串/新字串&#125;</code></li>
<li>替换全部：<code>$&#123;变量//旧字串/新字串&#125;</code><br><img src="https://i-blog.csdnimg.cn/blog_migrate/98a42030b9e55b241454a5d5e3fb9f0c.png" alt="112"></li>
</ul>
<h2 id="3-字符串掐头"><a href="#3-字符串掐头" class="headerlink" title="3. 字符串掐头"></a>3. 字符串掐头</h2><ul>
<li>从左至右，最短匹配删除：<code>$&#123;变量#关键词&#125;</code></li>
<li>从左至右，最长匹配删除：<code>$&#123;变量##关键词&#125;</code><br><img src="https://i-blog.csdnimg.cn/blog_migrate/c42817e9b0b6339a3f0bcec263444a83.png" alt="113"></li>
</ul>
<h2 id="4-字符串截取"><a href="#4-字符串截取" class="headerlink" title="4. 字符串截取"></a>4. 字符串截取</h2><ul>
<li>语法为：<code>$&#123;变量%关键词&#125;</code><br><img src="https://i-blog.csdnimg.cn/blog_migrate/6672b53a8a48c04f17533fd805f77595.png" alt="114"></li>
</ul>
<h1 id="十二、正则表达式！"><a href="#十二、正则表达式！" class="headerlink" title="十二、正则表达式！"></a>十二、正则表达式！</h1><p>&emsp;&emsp;首先哈，我感觉这东西很常见，其次呢是非常好用很灵活。这部分内容我也用的挺多的，只能说是熟能生巧，很多符号用着用着就记住了。</p>
<p><strong>基本正则符号：</strong></p>
<table>
<thead>
<tr>
<th>符号</th>
<th>意义</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>abc</td>
<td>匹配abc</td>
<td>grep abc .&#x2F;</td>
</tr>
<tr>
<td>^</td>
<td>匹配开头</td>
<td>grep ^abc .&#x2F;</td>
</tr>
<tr>
<td>$</td>
<td>匹配结尾</td>
<td>grep abc$ .&#x2F;</td>
</tr>
<tr>
<td>[集合]</td>
<td>匹配集合</td>
<td>grep “[abc]” .&#x2F;</td>
</tr>
<tr>
<td>[^集合]</td>
<td>集合取反</td>
<td>grep “[^abc]” .&#x2F;</td>
</tr>
<tr>
<td>.</td>
<td>匹配任意单个字符</td>
<td>grep . .&#x2F;</td>
</tr>
<tr>
<td>*</td>
<td>匹配前一个字符任意次(可以是0次)</td>
<td>grep ab*c .&#x2F;</td>
</tr>
<tr>
<td>.*</td>
<td>匹配任意，即上面两个连起来(匹配单个字符任意次)</td>
<td>grep a.*c .&#x2F;</td>
</tr>
<tr>
<td>{n,m}</td>
<td>匹配前一个字符n到m次 反斜杠是为了转义 下同</td>
<td>grep “[abc]{2,3}“ .&#x2F;</td>
</tr>
<tr>
<td>{n,}</td>
<td>匹配前一个字符至少n次</td>
<td>grep “[abc]{2,}“ .&#x2F;</td>
</tr>
<tr>
<td>{n}</td>
<td>匹配前一个字符n次</td>
<td>grep “[abc]{2}“ .&#x2F;</td>
</tr>
<tr>
<td>&emsp;&emsp;上面这部分的内容是使用最多的，我个人比较常用的是<code>^</code>开头、<code>$</code>结尾以及<code>.*</code>匹配任意。</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>扩展正则符号：</strong></p>
<table>
<thead>
<tr>
<th>符号</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>匹配前面的字符至少一次</td>
</tr>
<tr>
<td>?</td>
<td>匹配前面的字符0或1次</td>
</tr>
<tr>
<td>()</td>
<td>组合和保留</td>
</tr>
<tr>
<td>|</td>
<td>或者</td>
</tr>
<tr>
<td>&emsp;&emsp;上面这部分的内容需要加上<code>-E</code>参数，即<code>grep -E 正则表达式</code>。</td>
<td></td>
</tr>
<tr>
<td>&emsp;&emsp;这部分我用过的好像也就<code>+</code>，只能说用的还是偏少，我感觉上面的基础正则已经够我当前用了。</td>
<td></td>
</tr>
</tbody></table>
<p><strong>Perl兼容正则符号：</strong></p>
<table>
<thead>
<tr>
<th>符号</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>\b</td>
<td>匹配单词边界</td>
</tr>
<tr>
<td>\w</td>
<td>匹配字符数字下划线</td>
</tr>
<tr>
<td>\W</td>
<td>和\w相反</td>
</tr>
<tr>
<td>\s</td>
<td>匹配空白</td>
</tr>
<tr>
<td>\d</td>
<td>匹配数字</td>
</tr>
<tr>
<td>\d+</td>
<td>匹配多个数字</td>
</tr>
<tr>
<td>\D</td>
<td>匹配非数字</td>
</tr>
<tr>
<td>&emsp;&emsp;上面这部分的内容需要加上<code>-P</code>参数，即<code>grep -P 正则表达式</code>。</td>
<td></td>
</tr>
<tr>
<td>&emsp;&emsp;这部分说实话没咋用过，不过在系统里找脚本学习的时候碰见过<code>\d</code>。</td>
<td></td>
</tr>
</tbody></table>
<h1 id="十三、awk"><a href="#十三、awk" class="headerlink" title="十三、awk"></a>十三、awk</h1><h2 id="1-基础-1"><a href="#1-基础-1" class="headerlink" title="1. 基础"></a>1. 基础</h2><p>&emsp;&emsp;<code>awk</code>我在写脚本的时候用的非常多，原因就是很好用，对于格式化的数据可以很轻松的筛出想要的那一部分。</p>
<ul>
<li>语法1：<code>前置命令 | awk [选项] &#39;[条件]&#123;指令&#125;&#39;</code></li>
<li>语法2：<code>awk [选项] &#39;[条件]&#123;指令&#125;&#39; 文件</code></li>
<li>如果想要使用正则，则语法为<code>/正则表达式/</code>，<code>~</code>为匹配，<code>!~</code>为不匹配</li>
</ul>
<p>&emsp;&emsp;<code>awk</code>我个人认为最常见的用法就是提取文本。例如在<code>ls -l</code>的命令中，如果只想要第一列的权限和第九列的文件名，就可以使用<code>ll / | awk &#39;&#123;print $1,$9&#125;&#39;</code>来输出第一列和第九列的内容。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/b37085b4ac30c71cf1e5a1a45868a991.png" alt="13"><br>&emsp;&emsp;由此可知，<code>awk</code>默认是以空格来分列的。但是很多情况下并不是使用空格来分割，这个时候可以使用<code>-F</code>来指定分隔符。例如如果想读取<code>/etc/passwd</code>里的用户名和它的解释器，就可以使用<code>cat /etc/passwd | awk -F : &#39;&#123;print $1,$7&#125;&#39;</code>来获取，其中指定分隔符为<code>:</code>。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/dc7877cadec580cc3259466d38faa03f.png"></p>
<h2 id="2-内部变量"><a href="#2-内部变量" class="headerlink" title="2. 内部变量"></a>2. 内部变量</h2><table>
<thead>
<tr>
<th>变量名</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>FS</td>
<td>保存或设置字段分隔符，例如<code>FS=&quot;:&quot;</code>，与<code>-F</code>功能一样</td>
</tr>
<tr>
<td>$n</td>
<td>指定分割的第n个字段，例如<code>$1</code>代表第一个字段</td>
</tr>
<tr>
<td>$0</td>
<td>当前读入的整行文本内容</td>
</tr>
<tr>
<td>NF</td>
<td>记录当前处理行的字段个数(列数)</td>
</tr>
<tr>
<td>NR</td>
<td>记录当前已读入行的数量(行数)</td>
</tr>
</tbody></table>
<h2 id="3-BEGIN和END"><a href="#3-BEGIN和END" class="headerlink" title="3. BEGIN和END"></a>3. BEGIN和END</h2><ul>
<li>在所有行前处理，BEGIN{}<br>· 读入第一行文本之前执行<br>· 一般用来初始化操作</li>
<li>逐行处理，{}<br>· 逐行读入文本执行相应处理<br>· 是最常见的编辑指令块</li>
<li>在所有行后处理，END{}<br>· 处理完最后一行文本后执行<br>· 一般用来输出处理结果</li>
</ul>
<h2 id="4-判断与比较"><a href="#4-判断与比较" class="headerlink" title="4. 判断与比较"></a>4. 判断与比较</h2><ul>
<li>在awk里是支持分支<code>if</code>语句的，并且可以使用<code>!= &gt;= &lt;</code>这样的符号来比较，下图是一个很好的例子</li>
<li>例子中判断略去第一行，只对第一行以后的进行判断，因为<code>ls -l</code>的第一行是<code>total xxx</code></li>
</ul>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/c279c3802148b9489b27c13e0ec684bc.png" alt="在这里插入图片描述"></p>
<h1 id="十四、格式化输出"><a href="#十四、格式化输出" class="headerlink" title="十四、格式化输出"></a>十四、格式化输出</h1><ul>
<li>格式为：<code>输出内容 | column -t</code></li>
<li>如下图是加与不加的区别<br><img src="https://i-blog.csdnimg.cn/blog_migrate/8e08356391988e29a8e6ee527824090d.png" alt="整改前"><br><img src="https://i-blog.csdnimg.cn/blog_migrate/376eabedebac6209118a7440a982767a.png" alt="整个后"></li>
</ul>
<h1 id="十五、一些自己写的实例"><a href="#十五、一些自己写的实例" class="headerlink" title="十五、一些自己写的实例"></a>十五、一些自己写的实例</h1><h2 id="1-寻找系统中所有可登录的用户"><a href="#1-寻找系统中所有可登录的用户" class="headerlink" title="1. 寻找系统中所有可登录的用户"></a>1. 寻找系统中所有可登录的用户</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 可以查看所有未禁用用户</span></span><br><span class="line">id=<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> `cat /etc/passwd | grep <span class="literal">-E</span> <span class="literal">-v</span> .*nologin<span class="variable">$</span> | awk <span class="operator">-F</span>: &#123;<span class="string">&#x27;print $1&#x27;</span>&#125;`;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        <span class="built_in">cat</span> /etc/shadow | grep <span class="literal">-E</span> ^<span class="variable">$user</span> | grep <span class="literal">-E</span> :\\<span class="variable">$</span>.\\<span class="variable">$</span>.*\\<span class="variable">$</span>.*: &gt; /dev/null</span><br><span class="line">        <span class="keyword">if</span> [ <span class="variable">$</span>? -<span class="type">eq</span> <span class="number">0</span> ];then</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$id:</span> <span class="variable">$user</span> -- 该用户已设置密码可登录&quot;</span>;</span><br><span class="line">                let id++;</span><br><span class="line">        elif [[ -<span class="type">z</span> `c<span class="type">at</span> /<span class="type">etc</span>/<span class="type">shadow</span> | <span class="type">grep</span> -<span class="type">E</span> ^<span class="variable">$user</span>` ]];then</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$id:</span> <span class="variable">$user</span> -- 该用户在/etc/shadow中不存在&quot;</span>;</span><br><span class="line">                let id++;</span><br><span class="line">        fi</span><br><span class="line">done;</span><br></pre></td></tr></table></figure>
<p>执行效果如下：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/e1ce3680a5039d9833b79633ea30891d.png" alt="15"><br>解析：<br>&emsp;&emsp;这个脚本我是利用了禁用用户登录的规则来判定此用户是否被禁用(如何判断可以看我的这篇笔记<a href="https://blog.csdn.net/qq_45698148/article/details/119780701">linux学习记录：用户与&#x2F;etc&#x2F;passwd与&#x2F;etc&#x2F;shadow</a>)，通过正则表达式加上awk筛出初步判定没有禁用的用户名，再前去<code>/etc/shadow</code>中通过正则表达式查看密码是否符合规范，即可得知此账号是否被禁。即可输出结果。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux问题解决：Shell中处理包含空格的文件名</title>
    <url>/2021/09/03/20210903_linux%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%EF%BC%9AShell%E4%B8%AD%E5%A4%84%E7%90%86%E5%8C%85%E5%90%AB%E7%A9%BA%E6%A0%BC%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8D/</url>
    <content><![CDATA[<p>&emsp;&emsp;今天在写脚本的时候碰见了一个问题，在使用脚本对一些文件进行权限更改的时候，报出了意料之外的错误。经过对相关内容的查看，发现罪魁祸首是文件名中的空格。</p>
<span id="more"></span>

<p><strong>下面在我的服务器上进行复现：</strong></p>
<ul>
<li>首先是<code>touch</code>一个名字里带空格的文件，这里我新建的是文件<code>test 1</code>，如下图。<br><img src="/images/2021-09-03/1.jpg" alt="1"></li>
<li>随后是以常规命令<code>chmod 777 test 1</code>来对其进行权限更改操作，如下图。<br><img src="/images/2021-09-03/2.jpg" alt="2"></li>
<li>可以看到，<code>test 1</code>被理解为了两个文件，所以操作失败，提示这两个文件不存在。对于这种情况，很明显需要加上引号来提示系统这是一个整体，或是加上<code>\</code>来对空格进行转义，如下图可以看到命令成功的被执行了。<br><img src="/images/2021-09-03/3.jpg" alt="3"></li>
<li>但是，对于shell脚本来讲没有办法这么简单的处理，尤其是脚本中需要修改的文件是通过<code>find</code>找出来的变量。由此遇到困难开始想办法解决。</li>
</ul>
<p><strong>关于解决此问题的思考：</strong></p>
<ul>
<li>首先脚本中没有办法添加引号来使得变量被划为一个整体，所以单独操作时最常用的引号无法使用。</li>
<li>其次是否可以通过shell里的字符串函数在文件名中加入转义符<code>\</code>来避免空格的影响，但是我觉得这个应该会影响处理速度。</li>
<li>最后能否从根本上直接解决问题，即将文件名中的空格先替换为别的内容，待处理完后再替换为空格。这个说实话我感觉有点麻烦，而且最重要的是在替换时选择替换为什么内容？如果替换的内容本来就在文件名中存在，那么可能在替换回去时会改变原文件名，所以我觉得这个应该不大可行。</li>
</ul>
<p><strong>最终解决方案：</strong><br>&emsp;&emsp;我在网上冲浪了一会，发现一个应该是效率最高改动最小的解决方案，即修改解释器的<strong>单词分隔符</strong>。这个东西在<code>bash</code>中被储存在变量<code>$IFS</code>中，初始值为<code> \n\t</code>，即空格、回车、tab。在<code>bash</code>处理内容时会根据这个变量来对字符串进行分割，所以对其中的内容进行修改删去空格，即可让<code>bash</code>在处理带空格字符串时，不进行分割，从而从根本上解决问题。当然在脚本执行后还得把<code>$IFS</code>改回去，避免之后出现问题。<br>&emsp;&emsp;相比上文思考中的更改字符串，我觉得还是这个更方便效率高，所以决定使用这个方法对问题进行处理。</p>
<ul>
<li>这是我更改后的代码实例，其中把分隔符IFS改为了<code>\n\b</code>，待脚本执行完毕后再切回原来的<code> \n\t</code>，从而在不影响bash的情况下完成IFS的更改。</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="comment">#由于文件名中可能有空格，所以需要更改IFS</span></span><br><span class="line"></span><br><span class="line">SAVEIFS=<span class="variable">$IFS</span></span><br><span class="line">IFS=<span class="variable">$</span>(<span class="built_in">echo</span> <span class="literal">-en</span> <span class="string">&quot;\n\b&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> `find ~ <span class="literal">-perm</span> <span class="literal">-002</span> <span class="literal">-type</span> f <span class="number">2</span>&gt;/dev/null`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    chmod o<span class="literal">-wx</span> <span class="string">&quot;<span class="variable">$file</span>&quot;</span></span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">IFS=<span class="variable">$SAVEIFS</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这是运行后的结果。可以发现，权限已经被成功的修改了。由此可以验证该写法，对于文件名包含空格的文件和文件名含<code>\\</code>的文件都可以成功的进行选取，从而正确的解决命令。<br><img src="/images/2021-09-03/4.jpg" alt="5"></li>
<li>如果不更改IFS的话，就会出现下面这个问题，所以我认为该问题已解决。<br><img src="/images/2021-09-03/5.jpg" alt="6"></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux问题解决：多种方法处理ssh暴力攻击</title>
    <url>/2021/09/10/20210910_linux%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%EF%BC%9A%E5%A4%9A%E7%A7%8D%E6%96%B9%E6%B3%95%E5%A4%84%E7%90%86ssh%E6%9A%B4%E5%8A%9B%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<p><strong>linux问题解决：多种方法处理ssh暴力攻击</strong></p>
<span id="more"></span>

<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>&emsp;&emsp;说实话挺离谱的，昨晚登我云服务器的时候，感觉root登录有点卡，然后登进去阿里云那边提醒说自上次登录至现在有xxx条登录失败结果。我一瞅，这量有点大啊，然后用命令<code>lastb</code>看了眼登录失败的日志。如下图：<br><img src="/images/2021-09-10/1.jpg" alt="1"><br>&emsp;&emsp;可以看出来，这人应该是广撒网瞎捕鱼，因为攻击频率不算高并且IP都源自一个地方<strong>江苏省宿迁市 电信</strong>。说实话我感觉这人没跳代理，应该是真实IP，结合攻击频率不够，应该是个技术不咋地的<code>**</code>。但是说实话，他给我来这么一手，正好让我可以实操相关的内容，感恩就完事了。<br>&emsp;&emsp;昨天因为有点事情没空管他，结果今天一看他还在冲我的服务器，所以把这事办了，下面记录一下我思考与实操的处理方式。</p>
<h1 id="二、处理方式"><a href="#二、处理方式" class="headerlink" title="二、处理方式"></a>二、处理方式</h1><h2 id="1-更改ssh端口"><a href="#1-更改ssh端口" class="headerlink" title="1. 更改ssh端口"></a>1. 更改ssh端口</h2><p>&emsp;&emsp;这是最简单的方式，因为这种<code>**</code>都是扫一个IP段的<code>22</code>端口暴力破解，所以改一下ssh的端口，换个别的隐藏一下ssh的端口就行。不过如果别人的目标就是我，<code>nmap</code>扫描一下也能把端口扫出来，这样改只是躲了流弹罢了。</p>
<p><strong>具体操作如下：</strong></p>
<ol>
<li><code>vim /etc/ssh/sshd_config</code> 进去ssh的配置文件</li>
<li>找到配置项 <code>Port 22</code> 改成别的端口</li>
<li>如果没 Port 配置项或者被注释掉了就自己改一下</li>
<li><code>service sshd restart</code> 重启ssh服务</li>
</ol>
<p>&emsp;&emsp;但是说实话这种处理方式有点怂，我不想这样搞。而且这样搞了的话，以后跳转登录ssh还得带个<code>-p</code>选项，我觉得麻烦，所以我就放弃这么搞了。<br>&emsp;&emsp;</p>
<h2 id="2-禁止root用户登录"><a href="#2-禁止root用户登录" class="headerlink" title="2. 禁止root用户登录"></a>2. 禁止root用户登录</h2><p>&emsp;&emsp;这是个更怂的方法，就是直接禁止root登录，通过首先登录普通用户再<code>su root</code>来实现root的登录。这玩意流程想想就麻烦，我这又不是什么机密服务器，不至于因噎废食，所以也放弃这么搞。</p>
<p><strong>禁止root用户登录的方法：</strong> （这部分内容我在笔记<a href="https://blog.csdn.net/qq_45698148/article/details/119780701?spm=1001.2014.3001.5501">用户与&#x2F;etc&#x2F;passwd与&#x2F;etc&#x2F;shadow</a>中有详细介绍）</p>
<ol>
<li>修改<code>/etc/passwd</code>或<code>/etc/shadow</code>文件</li>
<li>使用命令<code>usermod -L xxx</code><br>&emsp;&emsp;</li>
</ol>
<h2 id="3-RSA密钥登录"><a href="#3-RSA密钥登录" class="headerlink" title="3. RSA密钥登录"></a>3. RSA密钥登录</h2><p>&emsp;&emsp;就是通过生成公私钥来通过ssh协议登录，公私钥相关的内容可以看我的这篇笔记<a href="https://blog.csdn.net/qq_45698148/article/details/119939529?spm=1001.2014.3001.5501">公钥、私钥与证书 —— 相关内容分析与实践</a>。简单来说就是取消密码登录，改为通过密钥登录。优点是不用登录，缺点是每个机子都需要生成公钥再放到机子里，有点麻烦，所以我也不用这种方法。</p>
<p><del>因为我也没试过，所以我就不写步骤了</del><br>&emsp;&emsp;</p>
<h2 id="4-修改配置文件"><a href="#4-修改配置文件" class="headerlink" title="4. 修改配置文件"></a>4. 修改配置文件</h2><p>&emsp;&emsp;在linux中，存在两个文件<code>白名单 /etc/hosts.allow</code>和<code>黑名单 /etc/hosts.deny</code>，二者中可以添加IP或IP段来实现黑白名单的效果。<br>&emsp;&emsp;有一说一啊，这个可能是效果最好的处理方法了，只需要在白名单里加上自己用的IP段，再在黑名单里禁止所有IP段登录即可。因为白名单的优先级比黑名单高，所以这样可以完美的规避ssh暴力攻击。但是缺点也有，就是如果想在一个新的IP段环境下登录，必须得在白名单内添加新内容。</p>
<p><strong>我更改后的内容如下：</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">Zhao_Server</span> ~]<span class="comment"># cat /etc/hosts.allow</span></span><br><span class="line">sshd:xx.xxx.*.*:allow</span><br><span class="line">sshd:xxx.xxx.*.*:allow</span><br><span class="line">[<span class="type">root</span>@<span class="type">Zhao_Server</span> ~]<span class="comment">#</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">Zhao_Server</span> ~]<span class="comment"># cat /etc/hosts.deny</span></span><br><span class="line">sshd:all:deny</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上面的白名单IP数字被我用<code>x</code>替换掉了，<code>sshd:xx.xxx.*.*</code>即代表sshd服务允许向IP地址为<code>xx.xxx</code>开头的IP地址提供服务。而黑名单里的<code>sshd:all:deny</code>即代表sshd服务不允许向所有IP地址提供服务。<br>&emsp;&emsp;这样一来，即可避免ssh暴力攻击。</p>
<p><strong>说明：</strong></p>
<ol>
<li>一个IP请求连入，linux的检查策略是先看<code>/etc/hosts.allow</code>中是否允许，如果允许直接放行；如果没有，则再看<code>/etc/hosts.deny</code>中是否禁止，如果禁止那么就禁止连入</li>
<li>实验发现对<code>/etc/hosts.allow</code>和<code>/etc/hosts.deny</code>的配置不用重启就立即生效，但不管重启不重启当前已有会话都不会受影响；也就是说对之前已经连入的，即便IP已配置为禁止登录会话仍不会强制断开<br>&emsp;&emsp;</li>
</ol>
<h2 id="5-使用iptables工具"><a href="#5-使用iptables工具" class="headerlink" title="5. 使用iptables工具"></a>5. 使用iptables工具</h2><p>&emsp;&emsp;这个也是个很好的解决方案，<code>iptables</code>是linux下的一个防火墙工具，可以很好的实现包过滤功能。在这里我们只要能把攻击来源方的IP给ban掉，即可避免ssh暴力攻击。</p>
<p><strong>这里简单列一下可能会用到的命令：</strong></p>
<ol>
<li><code>iptables -I INPUT -s 221.0.0.0/8 -j DROP</code> 封禁整个221开头的网段</li>
<li><code>iptables -I INPUT -s 221.181.185.159 -j DROP</code> 封禁指定IP</li>
<li><code>iptables -L --line-numbers</code> 展示iptables策略列表并显示序号</li>
<li><code>iptables -D INPUT 1</code> 根据上一条显示的序号，删除INPUT链的第一条</li>
</ol>
<p>&emsp;&emsp;按照上面的命令对想要封禁的IP段进行封禁即可。</p>
<p><strong>总结：</strong><br>&emsp;&emsp;这玩意是真的好用，而且功能远不止如此，可能抽空我会在csdn上补充记录一下<code>iptables</code>的使用方法。<br>&emsp;&emsp;这个东西在重启后会失效，所以需要做持久化的措施，具体步骤我会在下面记录。<br>&emsp;&emsp;</p>
<h1 id="三、后续补充"><a href="#三、后续补充" class="headerlink" title="三、后续补充"></a>三、后续补充</h1><h2 id="1-iptables-持久化操作"><a href="#1-iptables-持久化操作" class="headerlink" title="1. iptables 持久化操作"></a>1. <code>iptables</code> 持久化操作</h2><p>&emsp;&emsp;在系统重启后，<code>iptables</code>的策略并不会保存，所以就会面临着持久化的问题。但是持久化还是相对方便的。</p>
<p><strong>下面是步骤：</strong></p>
<ol>
<li><code>iptables-save &gt; /etc/sysconfig/iptables</code> 使用该命令将 iptables 的配置保存在<code>/etc/sysconfig/iptables</code>中</li>
<li>在<code>/etc/rc.d/rc.local</code>中添加<code>iptables-restore &lt; /etc/sysconfig/iptables</code> 即在开机后自动导入之前保存的 iptables 策略</li>
</ol>
<p>&emsp;&emsp;按如上几步操作，即可完成 iptables 的持久化操作。<br>&emsp;&emsp;</p>
<h2 id="2-关于-etc-hosts-allow和-etc-hosts-deny失效的问题"><a href="#2-关于-etc-hosts-allow和-etc-hosts-deny失效的问题" class="headerlink" title="2. 关于/etc/hosts.allow和/etc/hosts.deny失效的问题"></a>2. 关于<code>/etc/hosts.allow</code>和<code>/etc/hosts.deny</code>失效的问题</h2><p>&emsp;&emsp;配好这俩文件以后，我发现没有用，还是能被攻击到。就找了哥们测试了一下，发现防火墙策略没有生效。所以就研究了下是怎么回事。</p>
<p><strong>下面是解决步骤：</strong></p>
<ol>
<li>首先是查看是否存在libwarp库，通过命令<code>ll /lib64/libwrap.so.0</code>即可查看这个库是否存在</li>
<li>如果这个库不存在的话，则使用命令<code>yum install -y tcp_wrappers</code>来安装这个库</li>
<li><code>ldd /usr/sbin/sshd | grep libwrap</code> 可以查看sshd功能是否支持libwarp库，如果没用结果则说明是不支持的问题</li>
<li>但是有一点需要注意…<strong>openssh6.7开始默认关闭TCPwrappers支持</strong>，所以想要支持libwarp库，就需要安装6.6及以下的版本，或者重新编译一次openssh。下面我预计会记录一下重新编译openssh的方法。</li>
</ol>
<p>&emsp;&emsp;</p>
<h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>&emsp;&emsp;在绿盟实习俩月多了，好歹也是安全公司，而且这段时间的实习内容也和操作系统底层的安全策略有关，所以接触学习到了很多关于系统安全的内容。这次加强我服务器安全配置的经历可以说是让我对相关内容有了更深入的了解，毕竟可以大刀阔斧的在我的系统上大改乱改。<br>&emsp;&emsp;在实习中学习并分析系统上的配置，在自己的服务器上根据自己的理解进行改动查看结果，并尝试各种操作深入理解。我觉得目前我这种学习流程还是蛮好的。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++学习记录：std::move 源码分析</title>
    <url>/2021/10/10/20211010_C-C++%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9Astd::move%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<ul>
<li>抽空扣一点感兴趣的标准库源码，这里总结一下 <code>std::move()</code> 相关的分析</li>
<li>本文中 gcc version: <strong>8.4.1 20200928 (Red Hat 8.4.1-1) (GCC)</strong></li>
<li>其中c++库安装路径为 <code>/usr/include/c++/8</code></li>
</ul>
<span id="more"></span>

<h1 id="一、源码与分析"><a href="#一、源码与分析" class="headerlink" title="一、源码与分析"></a>一、源码与分析</h1><h2 id="1-std-move-源码总览"><a href="#1-std-move-源码总览" class="headerlink" title="1. std::move 源码总览"></a>1. std::move 源码总览</h2><p>&emsp;&emsp;<code>std::move()</code> 的定义位于 <code>/usr/include/c++/8/bits/move.h</code> 中，详细内容如下：<br><img src="/images/2021-10-10/1.jpg" alt="std::move">&emsp;&emsp;可以看到 <code>std::move</code> 的定义只有短短4行…</p>
<p>&emsp;&emsp;第二行和第三行关键字 <code>constexpr</code> 和 <code>noexcept</code> 都是c++11的新增关键字。其中 <code>constexpr</code> 把后面的 <code>typename</code> 声明为常量表达式，便于编译器对代码进行优化 。而 <code>noexcept</code> 则声明此函数不会抛出异常，遇到问题直接调用 <code>std::terminate</code> 退出进程。这两个关键字可以说是为规范和优化 <code>std::move</code> 而存在的，对其实现并无参与，所以这里跳过这俩关键字，不做过多分析。</p>
<p>&emsp;&emsp;此外还存在两个东西：类型提取结构体 <code>std::remove_reference</code> 和 C++标准转换运算符<code>static_cast</code> 下面单独进行分析。<br>&emsp;</p>
<h2 id="2-std-remove-reference-源码分析"><a href="#2-std-remove-reference-源码分析" class="headerlink" title="2. std::remove_reference 源码分析"></a>2. std::remove_reference 源码分析</h2><p>&emsp;&emsp;<code>std::remove_reference</code> 的定义位于 <code>/usr/include/c++/8/type_traits</code> 中，详细内容如下：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/b4c1ddadd63e93fb1f490c792a6d7126.png" alt="std::remove_reference"><br>&emsp;&emsp;可以看到，<code>std::remove_reference</code> 结构体的实现非常简单，功能就是依靠模板把传参 <code>_Tp</code> 的类型分离出来，当调用 <code>std::remove_reference::type</code> 时即为分离出的最底层类型。</p>
<ul>
<li>测试如下内容：<br><img src="/images/2021-10-10/2.jpg" alt="test"><br>结果如下：<br><img src="/images/2021-10-10/3.jpg" alt="结果"><br>说明 <code>std::remove_reference</code> 可以很好的将类型提取出来，即 <code>int&amp;</code> 和 <code>int&amp;&amp;</code> 都可以提取出基础类型 <code>int</code><br>&emsp;</li>
</ul>
<h2 id="3-static-cast-分析"><a href="#3-static-cast-分析" class="headerlink" title="3. static_cast 分析"></a>3. static_cast 分析</h2><p>&emsp;&emsp;<code>static_cast</code> 也是c++11中的新特性，简单来说用处就是类型转换。语法为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">static_cast</span>&lt;新类型&gt;(表达式)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;其返回值为 <strong>“新类型” 类型的值</strong>，例如 <code>n = static_cast&lt;int&gt;(3.14)</code> 后，此时 <code>n = 3</code>。我个人认为可以粗略的将 <code>static_cast</code> 当作一个<strong>更高级的强制类型转换</strong>，相比传统的强制类型转换，<code>static_cast</code> 会对转换类型进行检测，所以相对更加安全。<br>&emsp;&emsp;可以说，任何具有明确定义的类型转换，只要不包含底层const，都可以使用 <code>static_cast</code>。<br>&emsp;</p>
<h2 id="4-std-move-分析"><a href="#4-std-move-分析" class="headerlink" title="4. std::move 分析"></a>4. std::move 分析</h2><p>&emsp;&emsp;由上文可知两个关键内容的作用，则可首先带入一个实例来化简分析 <code>std::move</code> 的实际作用。</p>
<p>首先是一小部分代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::string s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">std::vector&lt;std::string&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(s));</span><br></pre></td></tr></table></figure>
<p>根据 <code>std::move</code> 的流程，<code>std::move(s)</code> 中的 return 语句执行过程如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string&amp;&amp; <span class="title">move</span><span class="params">(string&amp; &amp;&amp; t)</span> <span class="comment">//此处string&amp; &amp;&amp;等于string&amp;，下文会提及</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="number">1.</span> <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(<span class="type">__t</span>);</span><br><span class="line"><span class="number">2.</span> <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> std::remove_reference&lt;string&amp;&gt;::type&amp;&amp;&gt;(s);<span class="comment">//提取出基础类型string</span></span><br><span class="line"><span class="number">3.</span> <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;string&amp;&amp;&gt;(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，某种意义上来说，<code>std::move(lvalue)</code> 就约等于 <code>static_cast&lt;T&amp;&amp;&gt;(lvalue)</code>，即将左值强制转换为右值。而 <code>std::move</code> 中封装了一个类型提取器 <code>std::remove_reference</code> 来方便使用。<br>&emsp;</p>
<h2 id="5-std-move-中的引用折叠"><a href="#5-std-move-中的引用折叠" class="headerlink" title="5. std::move 中的引用折叠"></a>5. std::move 中的引用折叠</h2><p>&emsp;&emsp;通过上文的内容，可以发现 <code>std::move</code> 中的传参类型为 <code>_Tp&amp;&amp;</code> ，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::<span class="function">type&amp;&amp;</span></span><br><span class="line"><span class="function">    <span class="title">move</span><span class="params">(_Tp&amp;&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(<span class="type">__t</span>); &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;那么，在执行过程中，传参s的类型是什么呢？<br><img src="/images/2021-10-10/4.jpg" alt="问题"><br>&emsp;&emsp;由于传参类型为 <code>_Tp&amp;&amp;</code>，那么当传参类型为 <code>string&amp;(即左值)</code> 时，当时的场景则为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::string s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">std::<span class="built_in">move</span>(s) =&gt; std::<span class="built_in">move</span>(string&amp; &amp;&amp;)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;此时的类型 <code>string&amp; &amp;&amp;</code> 又是什么？此处便涉及到了<strong>引用折叠</strong>。概念如下，简单来说就是除了右值的&amp;&amp;是右值，其他都是左值。</p>
<ul>
<li>X&amp; &amp;、X&amp;&amp; &amp;、X&amp; &amp;&amp; —— 折叠成X&amp;，用于处理左值</li>
<li>X&amp;&amp; &amp;&amp; —— 折叠成X&amp;&amp;，用于处理右值</li>
</ul>
<p>&emsp;&emsp;引用折叠的意义就是让参数可以与任何类型的实参匹配，简单说就是右值传进来还是右值，左值传进来还是左值。例如上文传进来的就是左值，最后还是左值；如果传进来的是右值则最终还是右值。另外我粗略看了下 <code>forward</code> 的源码，其实它实现完美转发也是很大程度依赖于引用折叠这个东西。<br>&emsp;</p>
<h1 id="二、总结"><a href="#二、总结" class="headerlink" title="二、总结"></a>二、总结</h1><p>&emsp;&emsp;C++的标准库源码依旧封装的很”繁琐”，以及配着贼长的命名。当然 <code>std::move</code> 这个函数还好，涉及的东西不算太多，所以看着还是非常清晰的。之前看智能指针源码才是真的给我看的烦躁无比。<br>&emsp;&emsp;小结一下，<code>std::move</code> 中只进行了一个类型转换，而各种所谓右值数据迁移基本都是在构造函数中实现的。<br>&emsp;&emsp;总的来说标准库里的源码写的还是相对很严谨和标准的，很多思路和写法确实能让我学到很多。接下来我准备再去仔细研究一下 <code>forward</code> 的实现和思路。当然 <code>std::move</code> 里那个最关键的 <code>static_cast</code> 我还是没有深入的探索，只是浅尝辄止，可能等未来实力和精力足够再来一探究竟吧。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++标准库学习</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>linux学习记录：记一次手动编译安装组件的过程</title>
    <url>/2021/09/20/20210920_linux%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%89%8B%E5%8A%A8%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E7%BB%84%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>&emsp;&emsp;本次安装的组件为 <code>Apache HTTP Server</code>，本篇笔记中记录了全部过程，以供参考。<br>&emsp;&emsp;apache组件的依赖项比较多，所以安装起来会繁杂一点，不过流程都是大同小异。本次升级中采用的是源码手动编译升级的方法，原因是遇到过没有rpm的系统…所以还是自己操作更踏实点。</p>
<span id="more"></span>

<h1 id="零、安装目录总结"><a href="#零、安装目录总结" class="headerlink" title="零、安装目录总结"></a>零、安装目录总结</h1><p>&emsp;&emsp;linux下常见的有三个和库有关系的目录，分别是<code>/lib</code>、<code>/usr/lib</code>和<code>/usr/local/lib</code>。其中<code>usr</code>并不是<code>user</code>的缩写，而是<code>unix system resource</code>的缩写，即系统资料。</p>
<p>&emsp;&emsp;那么这三个目录有何区别？简单来说，<code>/lib</code>是内核级的, <code>/usr/lib</code>是系统级的, <code>/usr/local/lib</code>是用户级的。其中<code>/lib</code>中包含的基本上都是<code>/bin</code>和<code>/sbin</code>中程序所使用的库，而另外两个其中就存放了很多用于用户程序的库。</p>
<p>&emsp;&emsp;这次安装的<code>Apache HTTP Server</code>，是用来构建web服务器的，所以很明显是用户级的。由此相关组件我均安装至<code>/usr/local/lib</code>下。</p>
<h1 id="一、安装依赖项"><a href="#一、安装依赖项" class="headerlink" title="一、安装依赖项"></a>一、安装依赖项</h1><p>&emsp;&emsp;<code>Apache HTTP Server</code>主要是有三个依赖项<code>apr</code>、<code>apr-util</code>和<code>pcre</code>，所以需要先行安装。下面会记录安装的过程。</p>
<h2 id="1-apr"><a href="#1-apr" class="headerlink" title="1. apr"></a>1. apr</h2><p>下载并解压apr库，这里选择的版本是1.7.0</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> <span class="built_in">wget</span> http://archive.apache.org/dist/apr/apr<span class="literal">-1</span>.<span class="number">7.0</span>.tar.gz</span><br><span class="line"><span class="variable">$</span> tar <span class="literal">-zxf</span> apr<span class="literal">-1</span>.<span class="number">7.0</span>.tar.gz</span><br></pre></td></tr></table></figure>
<p>进入目录并使用<code>configure</code>配置makefile，这里选择的目标路径为<code>/usr/local/lib/apr</code></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> <span class="built_in">cd</span> apr<span class="literal">-1</span>.<span class="number">7.0</span>/</span><br><span class="line"><span class="variable">$</span> ./configure <span class="literal">--prefix</span>=/usr/local/lib/apr</span><br></pre></td></tr></table></figure>
<p>编译</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> make</span><br></pre></td></tr></table></figure>
<p>安装</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> make install</span><br></pre></td></tr></table></figure>
<p>进入<code>/usr/local/lib</code>即可查看到apr目录</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> <span class="built_in">cd</span> /usr/local/lib</span><br><span class="line"><span class="variable">$</span> ll | grep apr</span><br></pre></td></tr></table></figure>
<h2 id="2-apr-util"><a href="#2-apr-util" class="headerlink" title="2. apr-util"></a>2. apr-util</h2><p>下载并解压apr-util库，这里选择的版本是1.6.1</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> <span class="built_in">wget</span> http://archive.apache.org/dist/apr/apr<span class="literal">-util-1</span>.<span class="number">6.1</span>.tar.gz</span><br><span class="line"><span class="variable">$</span> tar <span class="literal">-zxf</span> apr<span class="literal">-util-1</span>.<span class="number">6.1</span>.tar.gz</span><br></pre></td></tr></table></figure>
<p>进入目录并使用<code>configure</code>配置makefile，选择目标路径为<code>/usr/local/lib/apr-util</code>，并配置apr路径为<code>/usr/local/lib/apr</code></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> <span class="built_in">cd</span> apr<span class="literal">-util-1</span>.<span class="number">6.1</span>/</span><br><span class="line"><span class="variable">$</span> ./configure <span class="literal">--prefix</span>=/usr/local/lib/apr<span class="literal">-util</span> <span class="literal">--with-apr</span>=/usr/local/lib/apr</span><br></pre></td></tr></table></figure>
<p>编译</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> make</span><br></pre></td></tr></table></figure>
<p>此时出现报错如下，提示确实头文件<code>expat.h</code>，经查询原因为缺少expat库</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">xml/apr_xml.c:<span class="number">35</span>:<span class="number">10</span>: fatal error: expat.h: No such file or directory</span><br><span class="line"> <span class="comment">#include &lt;expat.h&gt;</span></span><br><span class="line">          ^~~~~~~~~</span><br></pre></td></tr></table></figure>
<p>安装expat库 (下载地址为 <code>https://github.com/libexpat/libexpat/releases</code> )</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> tar <span class="literal">-zxf</span> expat<span class="literal">-2</span>.<span class="number">4.1</span>.tar.gz</span><br><span class="line"><span class="variable">$</span> <span class="built_in">cd</span> expat<span class="literal">-2</span>.<span class="number">4.1</span>/</span><br><span class="line"><span class="variable">$</span> ./configure</span><br><span class="line"><span class="variable">$</span> make</span><br><span class="line"><span class="variable">$</span> make install</span><br></pre></td></tr></table></figure>
<p>再次编译 apr-util</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> make</span><br></pre></td></tr></table></figure>
<p>安装</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> make install</span><br></pre></td></tr></table></figure>
<p>进入<code>/usr/local/lib</code>即可查看到apr-util目录</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> <span class="built_in">cd</span> /usr/local/lib</span><br><span class="line"><span class="variable">$</span> ll | grep apr<span class="literal">-util</span></span><br></pre></td></tr></table></figure>
<h2 id="3-pcre"><a href="#3-pcre" class="headerlink" title="3. pcre"></a>3. pcre</h2><p>下载并解压pcre库，这里选择的版本是1.7.0</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> <span class="built_in">wget</span> http://jaist.dl.sourceforge.net/project/pcre/pcre/<span class="number">8.45</span>/pcre<span class="literal">-8</span>.<span class="number">45</span>.tar.gz</span><br><span class="line"><span class="variable">$</span> tar <span class="literal">-zxf</span> pcre<span class="literal">-8</span>.<span class="number">45</span>.tar.gz</span><br></pre></td></tr></table></figure>
<p>进入目录并使用<code>configure</code>配置makefile，这里选择的目标路径为<code>/usr/local/lib/pcre</code></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> <span class="built_in">cd</span> pcre<span class="literal">-8</span>.<span class="number">45</span>/</span><br><span class="line"><span class="variable">$</span> ./configure <span class="literal">--prefix</span>=/usr/local/lib/pcre</span><br></pre></td></tr></table></figure>
<p>编译</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> make</span><br></pre></td></tr></table></figure>
<p>安装</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> make install</span><br></pre></td></tr></table></figure>
<p>进入<code>/usr/local/lib</code>即可查看到pcre目录</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> <span class="built_in">cd</span> /usr/local/lib</span><br><span class="line"><span class="variable">$</span> ll | grep pcre</span><br></pre></td></tr></table></figure>
<p>&emsp;<br>自此，所有的依赖项就安装完成了。<br>&emsp;</p>
<h1 id="二、安装Apache-HTTP-Server"><a href="#二、安装Apache-HTTP-Server" class="headerlink" title="二、安装Apache HTTP Server"></a>二、安装Apache HTTP Server</h1><p>下载并解压apache组件，这里选择的版本是2.4.9</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> <span class="built_in">wget</span> https://mirrors.bfsu.edu.cn/apache//httpd/httpd<span class="literal">-2</span>.<span class="number">4.49</span>.tar.gz</span><br><span class="line"><span class="variable">$</span> tar <span class="literal">-zxf</span> httpd<span class="literal">-2</span>.<span class="number">4.49</span>.tar.gz</span><br></pre></td></tr></table></figure>
<p>进入目录并使用<code>configure</code>配置makefile，这里选择的目标路径为<code>/usr/local/apache</code>，并指定前面安装的三个依赖项的路径</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> <span class="built_in">cd</span> httpd<span class="literal">-2</span>.<span class="number">4.49</span>/</span><br><span class="line"><span class="variable">$</span> ./configure <span class="literal">--with-included-apr</span> <span class="literal">--prefix</span>=/usr/local/apache <span class="literal">--with-apr</span>=/usr/local/lib/apr <span class="literal">--with-apr-util</span>=/usr/local/lib/apr<span class="literal">-util</span> <span class="literal">--with-pcre</span>=/usr/local/lib/pcre</span><br></pre></td></tr></table></figure>
<p>此时出现报错如下，原因是需要将apr和apr-util的目录放到.&#x2F;srclib&#x2F;下<br><code>configure: error: Bundled APR requested but not found at ./srclib/. Download and unpack the corresponding apr and apr-util packages to ./srclib/.</code><br><strong>注：.&#x2F;srclib&#x2F;下apr和apr-util文件夹需要去掉版本号！</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> <span class="built_in">cp</span> <span class="literal">-r</span> apr<span class="literal">-1</span>.<span class="number">7.0</span> httpd<span class="literal">-2</span>.<span class="number">4.49</span>/srclib/</span><br><span class="line"><span class="variable">$</span> <span class="built_in">mv</span> httpd<span class="literal">-2</span>.<span class="number">4.49</span>/srclib/apr<span class="literal">-1</span>.<span class="number">7.0</span>/ httpd<span class="literal">-2</span>.<span class="number">4.49</span>/srclib/apr/</span><br><span class="line"><span class="variable">$</span> <span class="built_in">cp</span> <span class="literal">-r</span> apr<span class="literal">-util-1</span>.<span class="number">6.1</span> httpd<span class="literal">-2</span>.<span class="number">4.49</span>/srclib/</span><br><span class="line"><span class="variable">$</span> <span class="built_in">mv</span> httpd<span class="literal">-2</span>.<span class="number">4.49</span>/srclib/apr<span class="literal">-util-1</span>.<span class="number">6.1</span>/ httpd<span class="literal">-2</span>.<span class="number">4.49</span>/srclib/apr<span class="literal">-util</span>/</span><br></pre></td></tr></table></figure>
<p>再次生成makefile</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> <span class="built_in">cd</span> httpd<span class="literal">-2</span>.<span class="number">4.49</span>/</span><br><span class="line"><span class="variable">$</span> ./configure <span class="literal">--with-included-apr</span> <span class="literal">--prefix</span>=/usr/local/apache <span class="literal">--with-apr</span>=/usr/local/lib/apr <span class="literal">--with-apr-util</span>=/usr/local/lib/apr<span class="literal">-util</span> <span class="literal">--with-pcre</span>=/usr/local/lib/pcre</span><br></pre></td></tr></table></figure>
<p>编译</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> make</span><br></pre></td></tr></table></figure>
<p>安装</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> make install</span><br></pre></td></tr></table></figure>
<p>进入<code>/usr/local/</code>即可查看到apache目录</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> <span class="built_in">cd</span> /usr/local/</span><br><span class="line"><span class="variable">$</span> ll | grep apache</span><br></pre></td></tr></table></figure>
<p>由此<code>Apache HTTP Server</code>组件安装完成！执行如下命令可以确认</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> ./apache/bin/httpd <span class="literal">-v</span></span><br><span class="line">Server version: Apache/<span class="number">2.4</span>.<span class="number">49</span> (Unix)</span><br><span class="line">Server built:   Sep <span class="number">20</span> <span class="number">2021</span> <span class="number">23</span>:<span class="number">23</span>:<span class="number">29</span></span><br></pre></td></tr></table></figure>

<h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>&emsp;&emsp;可以看到手动编译安装组件虽然麻烦点，但是主要是麻烦在找依赖项上。安装的过程其实都是大同小异。基本都是如下三部曲：</p>
<ol>
<li><code>configure</code> 检查编译环境；</li>
<li><code>make</code> 对源代码进行编译；</li>
<li><code>make insall</code> 将生成的可执行文件安装到当前计算机中</li>
</ol>
<p>&emsp;&emsp;可以发现<code>configure</code>的很多参数也是高度相似的，我感觉其中需要重点注意的是目标路径<code>--prefix</code>。在不了解可选参数时，也可以通过<code>./configure -h</code>来查看，总而言之虽然繁杂一点，但是其实是不难的。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++学习记录：深入理解三种传参方式</title>
    <url>/2021/08/23/20210823_C_C++%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B8%89%E7%A7%8D%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>&emsp;&emsp;之前对传参这方面的东西一直是知其然不知所以然。概念用法怎么用都知道，但是其真正的内部操作流程确实是理解不足。这两天一直在总结shell脚本的笔记，写累了正好研究一下传参这方面的内容。<br>&emsp;&emsp;这篇笔记中记录了关于这方面我的理解过程和心得。关于本篇笔记的深度，也是到<strong>汇编</strong>为止不再深入，就我个人理解来看已经是足够了。</p>
<span id="more"></span>

<h1 id="一、关于三种传参方式"><a href="#一、关于三种传参方式" class="headerlink" title="一、关于三种传参方式"></a>一、关于三种传参方式</h1><h2 id="1-值传参"><a href="#1-值传参" class="headerlink" title="1. 值传参"></a>1. 值传参</h2><h3 id="1-1-简单总结"><a href="#1-1-简单总结" class="headerlink" title="1.1 简单总结"></a>1.1 简单总结</h3><p>&emsp;&emsp;这是我在编程中最早接触的传参方式，也是一开始使用最多的传参方式。它的特点很明确就是简便，非常明了。当然缺点也是被说了很多次，就是<strong>慢+占用空间+不能修改实参</strong>。因为所谓的值传参是把实参的值复制了一遍，所以会有上面的特点。</p>
<h3 id="1-2-我的疑问"><a href="#1-2-我的疑问" class="headerlink" title="1.2 我的疑问"></a>1.2 我的疑问</h3><p>&emsp;&emsp;总是说值传参的执行过程会复制实参的值，那么它的流程是怎么样的？</p>
<h2 id="2-引用传参"><a href="#2-引用传参" class="headerlink" title="2. 引用传参"></a>2. 引用传参</h2><h3 id="2-1-简单总结"><a href="#2-1-简单总结" class="headerlink" title="2.1 简单总结"></a>2.1 简单总结</h3><p>&emsp;&emsp;这是C++里的概念，C里是没有的。它解决了值<strong>传参不能修改实参的问题，另外也比传值要快</strong>。就我目前接触到的C++代码中，里面均常常用到<code>&amp;</code>和<code>const &amp;</code>，例如stl的源码。</p>
<h3 id="2-2-我的疑问"><a href="#2-2-我的疑问" class="headerlink" title="2.2 我的疑问"></a>2.2 我的疑问</h3><p>&emsp;&emsp;我看网上说传引用其实也是传的指针，所以一直对引用的流程很有兴趣。如果真的也是传指针，那么它的意义就是更简单明了的传指针吗？另外很多源码中都使用<code>const &amp;</code>，我一直很好奇传引用究竟能比传值快多少。</p>
<h2 id="3-指针传参"><a href="#3-指针传参" class="headerlink" title="3. 指针传参"></a>3. 指针传参</h2><h3 id="3-1-简单总结"><a href="#3-1-简单总结" class="headerlink" title="3.1 简单总结"></a>3.1 简单总结</h3><p>&emsp;&emsp;第一次接触传指针，还是在当时学习链表的时候。在此之前，我对于指针作用的印象仅仅是文件指针和一丢丢字符串的内容，而对于学习中碰到的那些什么<code>*p,&amp;p</code>的完全没有实际应用中的感受，甚至产生了疑问，为何大伙都说指针牛p？<br>&emsp;&emsp;在接触到链表头结点的指针后，我首次发现原来传值是不能改变内容的(<del>太菜了当时</del>)，得传指针，所以链表函数传参时，节点得取个地址传进去，由此我打开了新世界的大门，感受到了指针的牛p。以至于后面再接触java的时候感觉浑身难受，感受到了一种局限感，所以后面我决定以C&#x2F;C++为方向。<br>&emsp;&emsp;对我而言，指针传参相当于是一种 **”降维打击”**，相当于“你收拾不了他就去找他爹收拾他”。总而言之，向下层操作性很大(提领指针的内容)，可以修改实参并且速度也很快。但是，传指针相当于把传值的内容改为指针，所以指针层面也是不能被修改的(虽然我也没见过要修改最高层指针)，由于指针的大小是固定的而且很小，传指针的速度也会很快。</p>
<h3 id="3-2-我的疑问"><a href="#3-2-我的疑问" class="headerlink" title="3.2 我的疑问"></a>3.2 我的疑问</h3><p>&emsp;&emsp;底层流程是什么？是先获取地址，再走值传递那一套流程吗？</p>
<h1 id="二、汇编层面剖析"><a href="#二、汇编层面剖析" class="headerlink" title="二、汇编层面剖析"></a>二、汇编层面剖析</h1><h2 id="1-操作"><a href="#1-操作" class="headerlink" title="1. 操作"></a>1. 操作</h2><p>&emsp;&emsp;我的理解方式是通过vs2019的反汇编功能查看低层汇编代码进行比对分析，而下面是我的操作过程。<br>&emsp;&emsp;首先是实验源码如下，可以看到我声明了三个函数，分别用了三种传参方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 三种传参方式测试</span></span><br><span class="line"><span class="comment">* 2021/8/22</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//值传参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_value</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x = <span class="number">22</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引用传参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_ref</span><span class="params">(<span class="type">int</span>&amp; x_ref)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x_ref = <span class="number">2222</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针传参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_ptr</span><span class="params">(<span class="type">int</span>* x_ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	*x_ptr = <span class="number">22222</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> test_arg = <span class="number">222</span>;</span><br><span class="line">	<span class="comment">//值传参</span></span><br><span class="line">	<span class="built_in">func_value</span>(test_arg);</span><br><span class="line">	<span class="comment">//引用传参</span></span><br><span class="line">	<span class="built_in">func_ref</span>(test_arg);</span><br><span class="line">	<span class="comment">//指针传参</span></span><br><span class="line">	<span class="built_in">func_ptr</span>(&amp;test_arg);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;接着，我开启调试反汇编，查看调用三个函数时的汇编源码，结果如下：<br><img src="/images/2021-08-23-01/1.jpg" alt="1"></p>
<h2 id="2-总结"><a href="#2-总结" class="headerlink" title="2. 总结"></a>2. 总结</h2><p>&emsp;&emsp; 说实话，我没想到传引用和传指针的汇编源码竟然完全一样…而传值和另外两者的唯一区别就是第一条汇编指令。其中传值用的是<code>汇编指令mov</code>，而传引用和传指针用的都是<code>汇编指令lea</code>。<br>&emsp;&emsp;然后我搜了下，<code>mov</code>是把<strong>内容</strong>复制到寄存器eax，而<code>lea</code>是把<strong>地址</strong>复制到寄存器里。所以这里传值是把变量<code>test_arg</code>的内容复制到寄存器，而后两者是把变量<code>test_arg</code>的地址复制到寄存器。而内容复制一般复制量都比地址复制要大，这也就造成了效率上的差距。且传值修改的是复制的内容，所以实参不会受影响；但后两者修改的是传入指针里的内容，这两个指针(传参和实参指针)指向的内容是一致的，所以实参会收到影响。</p>
<ul>
<li>所以总结下，函数传参的流程如下：</li>
</ul>
<ol>
<li>执行<code>lea</code>或<code>mov</code>指令将内容或指针拷贝到寄存器上。</li>
<li>执行<code>push</code>指令把寄存器里的内容push进栈。</li>
<li>执行<code>call</code>指令调用函数。</li>
<li>执行<code>add</code>指令确保堆栈平衡，相当于执行pop操作把前面push的内容弹出。而add的值跟参数个数有关(之前push的值)。</li>
</ol>
<h1 id="三、运行时间对比实践"><a href="#三、运行时间对比实践" class="headerlink" title="三、运行时间对比实践"></a>三、运行时间对比实践</h1><p>&emsp;&emsp;一直好奇三者之间运行时间的差异，正好借着这次实践测试一下。</p>
<h2 id="1-传参类型偏小"><a href="#1-传参类型偏小" class="headerlink" title="1. 传参类型偏小"></a>1. 传参类型偏小</h2><p>&emsp;&emsp;首先是测试传参类型偏小的情况吧。这里选择的传参类型是int，在32位环境下，<code>int</code>和<code>int*</code>大小是一致的4字节。根据上面的汇编源码来看，我个人认为<code>mov</code>4字节和<code>lea</code>一个地址时间消耗可能是五五开的，于是我进行了以下的测试。</p>
<p>&emsp;&emsp;测试代码如下，其中我使用到了一个自己实现的计时器，计时器内容在这篇博客里<a href="https://blog.csdn.net/qq_45698148/article/details/113702354?spm=1001.2014.3001.5501">C++学习记录：基于chrono库的高精度计时器</a>。<br><img src="/images/2021-08-23-01/2.jpg" alt="test1"></p>
<h3 id="1-1-函数内单运算操作"><a href="#1-1-函数内单运算操作" class="headerlink" title="1.1 函数内单运算操作"></a>1.1 函数内单运算操作</h3><p>&emsp;&emsp;这部分我在函数内均仅进行单运算操作，如下。<br><img src="/images/2021-08-23-01/3.jpg" alt="test1.1"><br>&emsp;&emsp;函数执行一定次数<code>TIME</code>后的结果如下。果然在传参实际传入大小差不多的情况下，实际时间消耗也是差不多的。<strong>在我理解上，其实引用和指针传参可能也是算一种值传参吧，只不过它们传的值是指针。所以在传值大小相似的情况下时间消耗也相似。</strong><br><img src="/images/2021-08-23-01/4.jpg" alt="test1"></p>
<h3 id="1-2-函数内多运算操作"><a href="#1-2-函数内多运算操作" class="headerlink" title="1.2 函数内多运算操作"></a>1.2 函数内多运算操作</h3><p>&emsp;&emsp;然后我想到，不同的传参方式，操作传参的时间消耗一致吗？于是在函数内新增了几条运算。既然该情况下传参速度相同，如果执行速度也相同，则说明操作传参的时间消耗一致。</p>
<p>&emsp;&emsp;函数内均修改为如下操作：<br><img src="/images/2021-08-23-01/5.jpg" alt="test1.2"><br>&emsp;&emsp;函数执行一定次数<code>TIME</code>后的结果如下。果然在操作增多的情况下，实际时间消耗也是差不多的。<strong>这说明操作传参的时间消耗是一致的。</strong><br><img src="/images/2021-08-23-01/6.jpg" alt="test1.3"></p>
<h2 id="2-传参类型偏大"><a href="#2-传参类型偏大" class="headerlink" title="2. 传参类型偏大"></a>2. 传参类型偏大</h2><p><em>“在我理解上，其实引用和指针传参可能也是算一种值传参吧，只不过它们传的值是指针。所以在传值大小相似的情况下时间消耗也相似。”</em></p>
<p>&emsp;&emsp;为了证明我的这个猜测，我对传参类型进行了改变，这次选择使用的数据类型是c++的数据结构<code>std::string</code>。在32位环境下，<code>std::string</code>的大小是28字节，<code>std::string*</code>的大小还是4字节，即两者大小是七倍的关系。则如果时间消耗差距较大的话，则说明真正影响传参速度是传的大小，就说明我的猜测算是对的吧。</p>
<p>&emsp;&emsp;测试代码如下，还是用到了上文中提到的计时器。<br><img src="/images/2021-08-23-01/7.jpg" alt="test2"><br>&emsp;&emsp;这部分函数的操作如下，仅仅是简单的<code>sizeof</code>操作。<br><img src="/images/2021-08-23-01/8.jpg" alt="test2.1"><br>&emsp;&emsp;运行结果如下，可以看到时间如下，果然时间差距是非常的大。说明传参时间根本上还是受传参大小影响。不过我好奇的是为何时间差距这么大，我猜测可能是内存分配时间不同或是调用了<code>std::string</code>的构造参数吧。<br><img src="/images/2021-08-23-01/9.jpg" alt="s"></p>
<h1 id="四、体会"><a href="#四、体会" class="headerlink" title="四、体会"></a>四、体会</h1><p>&emsp;&emsp;随着和C&#x2F;C++打交道的时间越来越长，我探索的内容也越发深入、复杂。但是当真正理解了之前疑惑的内容，说实话还是很开心的。<br>&emsp;&emsp;另外吐槽下csdn上鱼龙混杂，发的大部分都是很基础没有营养的东西，或者不知道哪抄的错误百出的内容，当然也有很多大佬的内容让我受益匪浅(深表感谢orz)，现在我搜个东西都得“发掘”半天。但是从某种意义上来讲我是有一点开心的，这说明我至少已经算入门了嘛XD</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++标准库学习</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++学习记录：std::forward 源码分析 / 完美转发的作用</title>
    <url>/2021/10/11/20211011_C-C++%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9Astd::forward%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<ul>
<li>抽空扣一点感兴趣的标准库源码，这里总结一下 <code>std::forward()</code> 相关的分析</li>
<li>本文中 gcc version: <strong>8.4.1 20200928 (Red Hat 8.4.1-1) (GCC)</strong></li>
<li>其中c++库安装路径为 <code>/usr/include/c++/8</code></li>
</ul>
<span id="more"></span>

<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>&emsp;&emsp;本文是基于前文 <a href="https://blog.csdn.net/qq_45698148/article/details/120680378?spm=1001.2014.3001.5501">C&#x2F;C++学习记录：std::move 源码分析</a> 进行的。前文中分析了 <code>std::move</code> 的源码，其中涉及到的一些东西，比如说：</p>
<ol>
<li>类型提取结构体 <code>std::remove_reference </code></li>
<li>C++标准转换运算符 <code>static_cast</code></li>
<li>引用折叠的概念</li>
</ol>
<p>&emsp;&emsp;上面这三个东西在 <code>std::forward()</code> 中也有应用，因此在本文中也就不过多分析，这些东西的分析在上文中均可找到。<a href="https://blog.csdn.net/qq_45698148/article/details/120680378?spm=1001.2014.3001.5501">点我跳转</a></p>
<p>&emsp;&emsp;本文中仅记录上文中未提及的关于 <code>std::forward()</code> 的思路和写法，以及个人对完美转发这一概念的理解。<br>&emsp;</p>
<h1 id="二、源码与分析"><a href="#二、源码与分析" class="headerlink" title="二、源码与分析"></a>二、源码与分析</h1><h2 id="1-std-forward-源码总览"><a href="#1-std-forward-源码总览" class="headerlink" title="1. std::forward 源码总览"></a>1. std::forward 源码总览</h2><p>&emsp;&emsp;<code>std::forward()</code> 的定义位于 <code>/usr/include/c++/8/bits/move.h</code> 中，详细内容如下：<br><img src="/images/2021-10-11/1.jpg" alt="std::forward"><br>&emsp;&emsp;可以看到在源码中，函数 <code>std::forward</code> 有两种实现，差别在于传参的类型，前者接收的传参是一个左值，而后者接收的传参是一个右值。另外在传右值的版本中存在一个静态断言，这也算是两者的区别之一吧。<br>&emsp;</p>
<h2 id="2-std-forward-分析"><a href="#2-std-forward-分析" class="headerlink" title="2. std::forward 分析"></a>2. std::forward 分析</h2><p>&emsp;&emsp;还是先代入不同的类型来化简 <code>std::forward</code> 函数。<br>&emsp;&emsp;当模板类型 <code>_Tp</code> 为 <code>string&amp;</code> 时，即 string 的左值引用时，<code>std::forward</code> 可以化简为如下形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//string&amp; &amp;&amp; 引用折叠为 string&amp;</span></span><br><span class="line"><span class="comment">//std::remove_reference 提取出的类型为string</span></span><br><span class="line"><span class="function">string&amp;</span></span><br><span class="line"><span class="function"><span class="title">forward</span><span class="params">(string&amp; <span class="type">__t</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;string&amp;&gt;(<span class="type">__t</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string&amp;</span></span><br><span class="line"><span class="function"><span class="title">forward</span><span class="params">(string&amp;&amp; <span class="type">__t</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//此处静态断言忽略</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;string&amp;&gt;(<span class="type">__t</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;而当模板类型 <code>_Tp</code> 为 <code>string&amp;&amp;</code> 时，即 string 的右值引用时，<code>std::forward</code> 可以化简为如下形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//string&amp;&amp; &amp;&amp; 引用折叠为 string&amp;&amp;</span></span><br><span class="line"><span class="comment">//std::remove_reference 提取出的类型为string</span></span><br><span class="line"><span class="function">string&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="title">forward</span><span class="params">(string&amp; <span class="type">__t</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;string&amp;&amp;&gt;(<span class="type">__t</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="title">forward</span><span class="params">(string&amp;&amp; <span class="type">__t</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//此处静态断言忽略</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;string&amp;&amp;&gt;(<span class="type">__t</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以看到，当传入类型为左值引用时，返回值为 <code>string&amp; : return static_cast&lt;string&amp;&gt;(__t);</code>；当传入类型为右值引用时，返回值为 <code>string&amp;&amp; : return static_cast&lt;string&amp;&amp;&gt;(__t);</code>。这就实现了 <code>std::forward</code> 的功能，即<strong>完美转发</strong>。简单点来讲就是传入左值返回还是左值，传入右值返回还是右值，保持原来的值属性不变。<code>std::forward</code> <strong>就相当于一个转发点，可以将类型原封不动的转发走。</strong><br>&emsp;</p>
<h1 id="三、完美转发"><a href="#三、完美转发" class="headerlink" title="三、完美转发"></a>三、完美转发</h1><p>&emsp;&emsp;上文中说到 <code>std::forward</code> 的功能，即<strong>完美转发</strong>。那么，何时需要它的存在呢？</p>
<p>通过下面这个例子我觉得可以很好的说明：<br><img src="/images/2021-10-11/2.jpg" alt="测试"><br>执行结果如下：<br><img src="/images/2021-10-11/3.jpg" alt="结果"></p>
<p>&emsp;&emsp;可以看到，当传参为左值时，直接转发和完美转发的结果都是左值，是正确的。但是当传参是右值时，直接转发和完美转发的结果却不同了。<br>&emsp;&emsp;<strong>分析其原因，当一个右值作为传参被传入后，函数内便会分配栈空间来保存传参。此时的右值已经被传参中的变量名所指向，所以再次传入此右值时，实际传入的是指向它的变量名，即一个左值。所以会出现上图中传参为右值但是直接转发却为左值的情况。</strong><br>&emsp;&emsp;<code>std::forward</code> 完美转发的大致应用场景便是上面那种，当存在中间转发点时，如果想要保持原来类型，则可以使用 <code>std::forward</code> 来实现。比如写一个筛选站，符合条件放 <code>vector1</code> 里，不符合放 <code>vector2</code> 里，总所周知 <code>vector</code> 在 <code>push_back</code> 右值的时候会调用 <code>emplace_back</code>，它可以直接拿走右值，提高效率。所以为了可以正确的把右值push进去，就得使用<code>std::forward</code> 来进行完美转发。<br>&emsp;</p>
<h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>&emsp;&emsp;总的来说，<code>std::forward</code> 可以说是对模板、引用折叠特性的一个巧妙利用。它和 <code>std::move</code> 的思路上有很大的相似之处，实现上也可以说是很相似。<br>&emsp;&emsp;之前说实话，对模板用的并不算太多，仅仅实现了一些小东西。但是目前管中窥豹，了解了自己对于模板方面的不足，之后应该会写一些东西来熟悉，比如说尽力按STL标准写个跳表之类的。总之在模板方面还是有很大的进步空间。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++标准库学习</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>dpdk源码分析：交互式命令行的实现(一) 命令添加</title>
    <url>/2021/10/14/20211014_dpdk%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E5%AE%9E%E7%8E%B0(%E4%B8%80)%E5%91%BD%E4%BB%A4%E6%B7%BB%E5%8A%A0/</url>
    <content><![CDATA[<ul>
<li>在实习的时候就对dpdk中 <code>cmdline</code> 的实现方式感兴趣，苦于待干的事情太多，一直没有空记录。</li>
<li>最近抽出时间准备进行一次较为深入的分析，来看一下dpdk是如何使用c语言来实现 <code>cmdline</code> 的.</li>
<li>本文中使用的dpdk库版本为：<strong>16.04</strong></li>
</ul>
<span id="more"></span>

<h1 id="一、分析"><a href="#一、分析" class="headerlink" title="一、分析"></a>一、分析</h1><h2 id="1-从一段代码入手"><a href="#1-从一段代码入手" class="headerlink" title="1. 从一段代码入手"></a>1. 从一段代码入手</h2><p>本段代码摘自 <code>app/test-pmd/cmdline.c</code>，这是dpdk例程 <strong>testpmd</strong> 其中的一个命令实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* *** SHOW PORT INFO *** */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmd_showport_result</span> &#123;</span></span><br><span class="line">	<span class="type">cmdline_fixed_string_t</span> show;</span><br><span class="line">	<span class="type">cmdline_fixed_string_t</span> port;</span><br><span class="line">	<span class="type">cmdline_fixed_string_t</span> what;</span><br><span class="line">	<span class="type">uint8_t</span> portnum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">cmd_showport_parsed</span><span class="params">(<span class="type">void</span> *parsed_result,</span></span><br><span class="line"><span class="params">				__attribute__((unused)) <span class="keyword">struct</span> cmdline *cl,</span></span><br><span class="line"><span class="params">				__attribute__((unused)) <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cmd_showport_result</span> *<span class="title">res</span> =</span> parsed_result;</span><br><span class="line">	...若干实现</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">cmdline_parse_token_string_t</span> cmd_showport_show =</span><br><span class="line">	TOKEN_STRING_INITIALIZER(<span class="keyword">struct</span> cmd_showport_result, show,</span><br><span class="line">				 <span class="string">&quot;show#clear&quot;</span>);</span><br><span class="line"><span class="type">cmdline_parse_token_string_t</span> cmd_showport_port =</span><br><span class="line">	TOKEN_STRING_INITIALIZER(<span class="keyword">struct</span> cmd_showport_result, port, <span class="string">&quot;port&quot;</span>);</span><br><span class="line"><span class="type">cmdline_parse_token_string_t</span> cmd_showport_what =</span><br><span class="line">	TOKEN_STRING_INITIALIZER(<span class="keyword">struct</span> cmd_showport_result, what,</span><br><span class="line">				 <span class="string">&quot;info#stats#xstats#fdir#stat_qmap#dcb_tc&quot;</span>);</span><br><span class="line"><span class="type">cmdline_parse_token_num_t</span> cmd_showport_portnum =</span><br><span class="line">	TOKEN_NUM_INITIALIZER(<span class="keyword">struct</span> cmd_showport_result, portnum, UINT8);</span><br><span class="line"></span><br><span class="line"><span class="type">cmdline_parse_inst_t</span> cmd_showport = &#123;</span><br><span class="line">	.f = cmd_showport_parsed,</span><br><span class="line">	.data = <span class="literal">NULL</span>,</span><br><span class="line">	.help_str = <span class="string">&quot;show|clear port info|stats|xstats|fdir|stat_qmap|dcb_tc X (X = port number)&quot;</span>,</span><br><span class="line">	.tokens = &#123;</span><br><span class="line">		(<span class="type">void</span> *)&amp;cmd_showport_show,</span><br><span class="line">		(<span class="type">void</span> *)&amp;cmd_showport_port,</span><br><span class="line">		(<span class="type">void</span> *)&amp;cmd_showport_what,</span><br><span class="line">		(<span class="type">void</span> *)&amp;cmd_showport_portnum,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这便是 <strong>testpmd</strong> 中一个很关键的命令 <code>show port info X</code> 的实现。其中可以发现上面的实现，从上到下可以分为四个部分：</p>
<ol>
<li>一个 <strong>struct</strong> 定义，其中储存着命令行中输入命令的参数。这段源码中即为 <code>struct cmd_showport_result</code>，其中储存着三个 <strong>string</strong>，一个 <strong>int</strong> 成员。这四个成员则依次对应 <code>show port info X</code> 这四个部分。</li>
<li>一个回调函数，其中对命令输入的内容进行处理，命令功能的实现就在这个函数里。从上面的源码里可以看出此函数的第一个传参为输入命令解析后的结果，其类型是第一部分 <strong>struct</strong> 的结构体指针。</li>
<li>若干 <code>cmdline_parse_token</code>，与第一部分 <strong>struct</strong> 定义的内容相关。</li>
<li>一个被封装好的类型 <code>cmdline_parse_inst_t</code>，一共有四个参数，其中第一个参数为第二部分的函数，第二个部分为空，第三部分为帮助信息 <code>help_str</code>，第四部分为第三部分新建的若干令牌 <code>cmdline_parse_token</code>。</li>
</ol>
<p>&emsp;&emsp;接下来将从第四部分，最关键的 <code>cmdline_parse_inst_t</code> 来分析。<br>&emsp;</p>
<h2 id="2-命令类型-cmdline-parse-inst-t"><a href="#2-命令类型-cmdline-parse-inst-t" class="headerlink" title="2. 命令类型 cmdline_parse_inst_t"></a>2. 命令类型 cmdline_parse_inst_t</h2><p><img src="/images/2021-10-14/1.jpg" alt="cmdline_parse_inst_t "><br>&emsp;&emsp;<code>cmdline_parse_inst_t</code> 的定义在 <code>lib/librte_cmdline/cmdline_parse.h</code> 中，内容如上，可以看到其是将结构体 <code>cmdline_inst</code> 封装后的类型。联系上文内容以及此段代码内的注释，<strong>dpdk cmdline</strong> 中命令的类型已经大致清楚。</p>
<p>&emsp;&emsp;在 <strong>dpdk cmdline</strong> 中，每一个 <code>cmdline_parse_inst_t</code> 都代表一个命令，其包含有四个成员。第一个成员为一个<strong>回调函数</strong>，内容为此条命令需要执行的内容。第三个成员为帮助信息 <code>help_str</code>，在按tab或是help的时候，则会补全或是弹出相关信息。第四个成员即为一个令牌数组，其中储存着命令中的参数，这块内容接下来会进行分析。<br>&emsp;</p>
<h2 id="3-令牌类型-cmdline-parse-token-hdr-t"><a href="#3-令牌类型-cmdline-parse-token-hdr-t" class="headerlink" title="3. 令牌类型 cmdline_parse_token_hdr_t"></a>3. 令牌类型 cmdline_parse_token_hdr_t</h2><p><img src="/images/2021-10-14/2.jpg" alt="cmdline_parse_token_hdr_t"><br>&emsp;&emsp;<code>cmdline_token_hdr_t</code> 的定义也在 <code>lib/librte_cmdline/cmdline_parse.h</code> 中，内容如上。</p>
<p>&emsp;&emsp;<code>cmdline_token_hdr_t</code> 是对结构体 <code>cmdline_token_hdr</code> 封装后的类型，其中共有两个成员。其中一个是结构体 <strong>cmdline_token_ops</strong> 的指针，另一个是 <strong>uint</strong> 类型的偏移量。通过注释可以得知，此处的偏移量为解析结果存入结构的位置，但是 <strong>ops</strong> 结构体还是不知道是什么东西。<br>&emsp;</p>
<h2 id="4-结构体-cmdline-token-ops"><a href="#4-结构体-cmdline-token-ops" class="headerlink" title="4.  结构体 cmdline_token_ops"></a>4.  结构体 cmdline_token_ops</h2><p><img src="/images/2021-10-14/3.jpg" alt="ops"><br>&emsp;&emsp;<code>cmdline_token_ops</code> 的定义仍在 <code>lib/librte_cmdline/cmdline_parse.h</code> 中，内容如上。</p>
<p>&emsp;&emsp;<strong>ops</strong> 结构体里含义四个回调函数，是比较复杂的…粗略来看，需要自定义一些回调函数来实现不同种类令牌的解析与补全等操作。这四个回调函数的具体内容这里不再赘述，预计会单独开一篇记录来分析 <code>cmdline_token_ops</code> 结构体内的回调函数的功能、流程和思路。</p>
<p>&emsp;&emsp;从这里以及前文可以得知一个东西，那就是根据令牌类型的不同，某些回调函数的实现也存在差异。比如说最开始摘出的代码，其对 uint8 类型令牌的定义流程如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmd_showport_result</span> &#123;</span></span><br><span class="line">	...</span><br><span class="line">	<span class="type">uint8_t</span> portnum;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="type">cmdline_parse_token_num_t</span> cmd_showport_portnum =</span><br><span class="line">	TOKEN_NUM_INITIALIZER(<span class="keyword">struct</span> cmd_showport_result, portnum, UINT8);</span><br><span class="line">...</span><br><span class="line"><span class="type">cmdline_parse_inst_t</span> cmd_showport = &#123;</span><br><span class="line">	...</span><br><span class="line">	.tokens = &#123;</span><br><span class="line">		...</span><br><span class="line">		(<span class="type">void</span> *)&amp;cmd_showport_portnum,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以看到，在 uint8 令牌的创建流程中，令牌的类型是 <code>cmdline_parse_token_num_t</code>，而不是 <code>cmdline_parse_token_hdr_t</code>，且在构造中使用了宏函数 <code>TOKEN_NUM_INITIALIZER</code>。在向命令结构体 <code>cmd_showport</code> 中传递上面生成好的令牌时，使用 <code>(void*)</code> 进行强制转换来避免类型上的不匹配。这样可以保证多种类型共用一个 <code>cmdline_parse_token_hdr_t</code> 接口，我感觉这有点C语言多态的感觉。<br>&emsp;<br>目前来看，cmdline 中的令牌类型一共有以下四种，接下来将来简单看一下这四种类型的实现方法。</p>
<ul>
<li>字符串令牌：匹配静态字符串，静态字符串列表或任何字符串。</li>
<li>数字令牌：匹配一个可以签名或无符号的数字，从8位到32位。</li>
<li>IP地址令牌：匹配IPv4或IPv6地址或网络。</li>
<li>以太网*地址令牌：匹配MAC地址。<br>&emsp;</li>
</ul>
<h2 id="5-子令牌类型-以-cmdline-parse-token-num-t-为例"><a href="#5-子令牌类型-以-cmdline-parse-token-num-t-为例" class="headerlink" title="5.  子令牌类型 以 cmdline_parse_token_num_t 为例"></a>5.  子令牌类型 以 cmdline_parse_token_num_t 为例</h2><p>相关路径为：<code>lib/librte_cmdline/cmdline_parse_num.h</code><br><img src="/images/2021-10-14/4.jpg" alt="num"><br>&emsp;&emsp;可以看到在num类型的令牌结构体中，其中包含有两个成员，第一个为一个 <code>cmdline_token_hdr</code> 结构体(即总令牌结构体，其中包含一个ops结构体和一个偏移量)，第二个则是一个 <code>cmdline_token_num_data</code> 结构体，其定义如下。<br><img src="/images/2021-10-14/5.jpg" alt="结构体"><br>&emsp;&emsp;<code>cmdline_token_num_data</code> 结构体中存储着一个枚举类型 <code>type</code>，即为num的具体类型，可以看到支持8到64位的无符号&#x2F;有符号整型。<br><img src="/images/2021-10-14/6.jpg" alt="定义"><br>&emsp;&emsp;最上面的样例代码中，一个num类型的令牌是按如上的步骤来生成的，此令牌的类型即为 <code>cmdline_parse_token_num_t</code>，然后等号后是一个宏函数，传入参数为命令结果结构体、该令牌对应的结构体中的参数以及该令牌中的 numtype。其中宏函数的定义如下：<br><img src="/images/2021-10-14/7.jpg" alt="宏"><br>&emsp;&emsp;其中hdr相关内容中，ops结构体是已经定义好的 <code>cmdline_token_num_ops</code>，这是依据num类型令牌定制的ops结构体。下面就是offset偏移量，其为一个宏函数，定义为 <code>#define offsetof(type, field)  ((size_t) &amp;( ((type *)0)-&gt;field) )</code>，通过这个宏函数，即可计算出指定成员在其所属结构体内的位置，实现的非常优雅可以说。然后最后则是一个numtype，储存具体类型。</p>
<p>&emsp;&emsp;等于说子令牌类型，相比于令牌类型 <code>cmdline_parse_token_hdr_t</code> 来讲，在hdr结构体的基础上，增加了一个type。而在传的时候，用一个 <code>(void*)</code> 来进行强制转换，个人感觉算是一种C风格的向上转型吧。</p>
<p><strong>总结：每个子令牌类型都有其独特的ops结构体，储存在hdr结构体中；hdr结构体中还有一个offset，来储存指定成员的位置，从而可以把处理结果放进成员中。另外还存在一个type来储存类型的具体内容，从而配合ops中定制的回调函数。</strong></p>
<p>&emsp;</p>
<h1 id="二、新增命令流程总结"><a href="#二、新增命令流程总结" class="headerlink" title="二、新增命令流程总结"></a>二、新增命令流程总结</h1><h2 id="1-新建命令结构体"><a href="#1-新建命令结构体" class="headerlink" title="1. 新建命令结构体"></a>1. 新建命令结构体</h2><p>&emsp;&emsp;如下新建命令结构体 <code>test</code>，定义其回调函数为 <code>fun_test</code>，其 <strong>token</strong> 令牌仅一个，为 <code>cmd_test</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">cmdline_parse_inst_t</span> test = &#123;</span><br><span class="line">	.f = fun_test,</span><br><span class="line">	.data = <span class="literal">NULL</span>,</span><br><span class="line">	.help_str = <span class="string">&quot;这里是帮助信息&quot;</span>, </span><br><span class="line">	.tokens = &#123;</span><br><span class="line">		(<span class="type">void</span> *)&amp;cmd_test,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2-新建命令参数结构体"><a href="#2-新建命令参数结构体" class="headerlink" title="2. 新建命令参数结构体"></a>2. 新建命令参数结构体</h2><p>&emsp;&emsp;如下新建命令参数结构体 <code>test_result</code>，其中只含一个 <strong>string</strong> 类型的成员 <code>cmd</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test_result</span> &#123;</span></span><br><span class="line">	<span class="type">cmdline_fixed_string_t</span> cmd;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="3-生成相关令牌"><a href="#3-生成相关令牌" class="headerlink" title="3. 生成相关令牌"></a>3. 生成相关令牌</h2><p>&emsp;&emsp;如下生成 <strong>string</strong> 类型令牌 <code>cmd_test</code>，其对应的命令为 test。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">cmdline_parse_token_string_t</span> cmd_test =</span><br><span class="line">	TOKEN_STRING_INITIALIZER(<span class="keyword">struct</span> test_result, cmd, <span class="string">&quot;test&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="4-编写回调函数"><a href="#4-编写回调函数" class="headerlink" title="4. 编写回调函数"></a>4. 编写回调函数</h2><p>&emsp;&emsp;如下编写回调函数 <code>fun_test</code>，规定当输入命令 <code>test</code> 后的操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">fun_test</span><span class="params">(<span class="type">void</span> *parsed_result,</span></span><br><span class="line"><span class="params">				__attribute__((unused)) <span class="keyword">struct</span> cmdline *cl,</span></span><br><span class="line"><span class="params">				__attribute__((unused)) <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">test_result</span> *<span class="title">res</span> =</span> parsed_result;</span><br><span class="line">	...若干实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;由此，一个新的命令就添加完毕了。这就是添加命令的大致流程，只不过例子中的参数较少，所以比较简略，而且省去了最难的回调函数的编写过程。<br>&emsp;</p>
<h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>&emsp;&emsp;三个月前第一次看dpdk的源码时，可以说是看的非常艰难，其中各式各样的回调函数，以及封装了一层又一层的类型可以说是最大的阻碍。而且其中还包含不少关于硬件的知识点，我当时可以说是一窍不通。但是三个月的实习中，我逐渐是了解一些基础的内容，可以说是逐渐理解了编写的思路和一些知识点。<br>&emsp;&emsp;dpdk的源码中，使用C实现了不少类似于多态、接口的东西，从中我学习到了很多C的写法，可以说令我叹为观止。目前我准备先研究一下cmdline的实现，看一下dpdk中是如何解析和传递命令的，剩下的(大部分)内容应该会简单了解，对有兴趣的点再尝试深入一点分析。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>源码阅读</tag>
        <tag>C/C++</tag>
        <tag>dpdk</tag>
      </tags>
  </entry>
  <entry>
    <title>golang学习记录：二进制文件判断实现与思路</title>
    <url>/2021/10/24/20211024_golang%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E5%88%A4%E6%96%AD%E5%AE%9E%E7%8E%B0%E4%B8%8E%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<ul>
<li>go version go1.15.14 linux&#x2F;amd64</li>
<li>相关项目地址为：<a href="https://github.com/zgg2001/StringFinderZ">点我跳转</a></li>
</ul>
<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>&emsp;&emsp;最近在写一个golang实现的字符串搜索与替换程序练手，其中一个很大的问题就是程序不能识别二进制文件与文本文件，导致搜索出来的内容会乱码，非常的不雅观。如果再不小心替换一下的话，就会造成很大的影响，所以这个问题必须解决。</p>
<p>&emsp;&emsp;我简单看了一下相关的标准库函数，发现golang标准库内并没有提供相关的函数来实现分辨二进制文件的功能。于是学习了一下编码相关的知识来自己实现一个二进制文件判断的功能。</p>
<span id="more"></span>

<h1 id="二、思路"><a href="#二、思路" class="headerlink" title="二、思路"></a>二、思路</h1><p>&emsp;&emsp;文本文件其实本质也是二进制文件，只不过可以被计算机内置的编码方式来解读为可阅读的文本。所以本文中需要解决的问题实质为如何识别出无法被正常编码的文件。</p>
<p>&emsp;&emsp;总所周知，ASCII为最初的编码方式，故基础字母数字和操作符都可以按照ASCII标准被编码。但是查看ASCII编码中的内容，可以发现其中一些内容是不可读的，比如编码为0-6的一些状态符。假如文件中出现了这类编码，那么肯定此文件不是正常的可读文本文件，即二进制文件。</p>
<p>&emsp;&emsp;简单看一下ASCII表的内容，可以总结出正常的可视编码为<code>32~127</code>、<code>\r(13)</code>、<code>\n(10)</code>、<code>\t(9)</code>，那么当文件中所有的字节都属于这个范围时，则此文件必定可以按ASCII编码正常显示，则为文本文件。</p>
<p>&emsp;&emsp;但是这仅仅是英文，在文件中常常会出现中文等内容。对此，需要将常见的<strong>Unicode</strong>编码、<strong>GBK</strong>编码或者<strong>UTF8</strong>等编码考虑进去。这三种编码方式都是在ASCII编码的基础上实现的，其主要原理就是将ASCII编码中未使用的<code>128~255</code>范围进行使用，再使用多字节来组合出不同的内容。<strong>其均默认一个共识，即低字节(0-127)保持ASCII原本的内容，高字节(128-255)为新编码方式中定义的内容。</strong> 故将白名单编码范围扩展到<code>32~255</code>即可，主要的辨别对象还是<code>0~31</code>中的内容。</p>
<p>&emsp;&emsp;故，主要的思路即为判定字节的内容，若存在非常规内容，即可进行判定。</p>
<h1 id="三、实现"><a href="#三、实现" class="headerlink" title="三、实现"></a>三、实现</h1><p>&emsp;&emsp;我本来是直接遍历文件的前100个字节，若属于<code>32~255</code>、<code>\r(13)</code>、<code>\n(10)</code>、<code>\t(9)</code>则continue，否则则说明为二进制文件。但是这样在实际中存在一些问题。比如说100个字节可以不够，即可能文件的前100个字符都是正常的。另外判定方式也有一些参差，比如说<code>\a</code>响铃符也是可能存在的(<del>之前我就写过音乐软件练手</del>)。<br><img src="/images/2021-10-24/1.jpg" alt="初版"><br>&emsp;&emsp;初版写法如上，此种写法可以识别大多数的二进制文件，但是也有部分的漏网之鱼，所以还存在改进的空间。</p>
<p>&emsp;&emsp;然后今天我抽空上网冲浪了一会，找到了一种更全面的算法(<strong>zlib的算法</strong>)，本文中的最终版本识别二进制文件也是使用的这种算法，算法内容如下：</p>
<ol>
<li>将一个字节的内容分为三类，白名单中包括<code>32~255</code>、<code>\r(13)</code>、<code>\n(10)</code>、<code>\t(9)</code>；灰名单中包括<code>\a(7)</code>、<code>\b(8)</code>、<code>\v(11)</code>、<code>\f(12)</code>、 <code>sub(26)</code>、<code>esc(27)</code>；黑名单中包括<code>0~6</code>、<code>14~31</code></li>
<li>如果文件包含至少一个白名单中的字节，而且不包含黑名单中的字节，其即为文本文件；否则则为二进制文件</li>
</ol>
<p>&emsp;&emsp;算法主要就是上面那个，很简单，但是判定了空文件等若干情况。在此次的完善中，我规定的读取范围为前1024个字节，因为之前实现中100个字节有些少，但是全文读取又会影响效率，所以读取1024个字节。核心的判定算法更改为上文中的那个。代码如下：(github地址：<a href="https://github.com/zgg2001/StringFinderZ/blob/master/src/detect/detect_binary.go">点我跳转</a>)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> detect</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DetectBinary</span><span class="params">(path <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"></span><br><span class="line">    file, err := os.Open(path)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    ┊   log.Printf(<span class="string">&quot;\033[31merror : IO error - \033[0m%s&quot;</span>, err)</span><br><span class="line">    ┊   <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">    r := bufio.NewReader(file)</span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">    n, err := r.Read(buf)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> white_byte <span class="type">int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">    ┊   <span class="keyword">if</span> (buf[i] &gt;= <span class="number">0x20</span> &amp;&amp; buf[i] &lt;= <span class="number">0xff</span>) ||</span><br><span class="line">    ┊   ┊   buf[i] == <span class="number">9</span>  ||</span><br><span class="line">    ┊   ┊   buf[i] == <span class="number">10</span> ||</span><br><span class="line">    ┊   ┊   buf[i] == <span class="number">13</span> &#123;</span><br><span class="line">    ┊   ┊   white_byte++</span><br><span class="line">    ┊   &#125; <span class="keyword">else</span> <span class="keyword">if</span> buf[i] &lt;= <span class="number">6</span> || (buf[i] &gt;= <span class="number">14</span> &amp;&amp; buf[i] &lt;= <span class="number">31</span>) &#123;</span><br><span class="line">    ┊   ┊   <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    ┊   &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> white_byte &gt;= <span class="number">1</span> &#123;</span><br><span class="line">    ┊   <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如上即为实现，返回值为true即为二进制文件。就我进行的测试来看，可以很好的判定二进制文件。<br><img src="/images/2021-10-24/2.jpg" alt="测试"></p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>dpdk源码分析：交互式命令行的实现(二) 初始化与退出</title>
    <url>/2021/11/21/20211121_dpdk%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E5%AE%9E%E7%8E%B0(%E4%BA%8C)%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E9%80%80%E5%87%BA/</url>
    <content><![CDATA[<ul>
<li>本文中使用的dpdk库版本为：<strong>16.04</strong></li>
<li>此文为分析的第二篇，接上文 <a href="https://blog.csdn.net/qq_45698148/article/details/120766552">dpdk源码分析：交互式命令行的实现(一) 命令添加</a></li>
<li>上一篇中已经分析了命令添加相关的实现和写法，接下来目标为交互式命令行初始化和退出相关内容的分析。</li>
</ul>
<span id="more"></span>

<h1 id="一、从一段代码入手"><a href="#一、从一段代码入手" class="headerlink" title="一、从一段代码入手"></a>一、从一段代码入手</h1><p>&emsp;&emsp;下面这段代码为dpdk例程 <code>examples/qos_sched/cmdline.c</code> 中的内容，是对封装好的交互式命令行内容进行调用的完整流程。<br><img src="/images/2021-11-21/1.jpg" alt="例程"><br>&emsp;&emsp;可以看到，此段代码总共有两个部分，第一部分为 <code>main_ctx[]</code> 的定义过程，第二部分为一个函数 <code>prompt()</code>。</p>
<p>&emsp;&emsp;根据上一篇的内容，可以知道 <code>main_ctx[]</code> 中定义的内容为具体的命令。图中代码中一共定义了11组命令，此篇笔记中不再进行赘述。</p>
<p>&emsp;&emsp;第二部分为函数 <code>prompt()</code>，其中一共调用了三个函数，另外此处的 <code>struct cmdline</code> 即为命令行的结构体。根据传参的内容、函数的返回值以及函数名称，即可简单的猜出这三个函数的作用：</p>
<ol>
<li><code>cmdline_stdin_new</code>：传参为命令组以及提示符，返回值为一个 <code>struct cmdline</code>。联系下文中对空值的判定以及函数名，即可推断出此函数作用大致为<strong>传入命令组与提示符生成相对应命令行</strong>。</li>
<li><code>cmdline_interact</code>：传参为 <code>cmdline_stdin_new</code> 函数生成的命令行，返回值不详。联系函数名可推断出此函数作用大致为<strong>开始与指定命令行的交互(interact)，即开始接收并解析命令</strong>。</li>
<li><code>cmdline_stdin_exit</code>：传参为 <code>cmdline_stdin_new</code> 函数生成的命令行，返回值不详。联系函数名可推断出此函数作用大致为<strong>退出指定的交互式命令行</strong>。</li>
</ol>
<p>&emsp;&emsp;接下来，将对初始化和退出这两个函数的流程和实现进行分析。<br>&emsp;</p>
<h1 id="二、初始化函数-cmdline-stdin-new"><a href="#二、初始化函数-cmdline-stdin-new" class="headerlink" title="二、初始化函数 cmdline_stdin_new()"></a>二、初始化函数 cmdline_stdin_new()</h1><p>&emsp;&emsp;首选查看其定义，其定义位于<code>lib/librte_cmdline/cmdline_socket.c</code>。<br><img src="/images/2021-11-21/2.jpg" alt="new"><br>&emsp;&emsp;从上图源码中可以发现，此函数有两个传参，传参一为命令组，传参二为提示符。简单来看，函数中大概可以分为两部分，第一部分是对终端设置的操作，第二部分是调用了一个新的函数<code>cmdline_new()</code>。<br>&emsp;</p>
<h2 id="1-终端设置"><a href="#1-终端设置" class="headerlink" title="1. 终端设置"></a>1. 终端设置</h2><p>&emsp;&emsp;首先看一下第一部分，一共是五行。</p>
<ol>
<li>此行调用函数 <code>tcgetattr</code>，作用是获取指定终端的设置并储存至一个 <code>termios</code> 结构体内。此处传参一为0，即文件操作符为0的流，为此进程的<strong>标准输入流</strong>；传参二为获取到的内容储存的位置，为函数中声明的结构体 <code>oldterm</code>。</li>
<li>此行调用函数 <code>memcpy</code>，将 <code>oldterm</code> 中的内容(即上一行中获取到的设置)copy至 <code>term</code> 中。</li>
<li>此行为修改 <code>term</code> 中的输入模式标志 <code>c_lflag</code>，此处为<strong>关闭</strong>三个设置：ICANON(使用标准输入模式)、ECHO(显示输入字符)、ISIG(当输入INTR、QUIT、SUSP或DSUSP时，产生相应的信号)。</li>
<li>此行调用函数 <code>tcsetattr</code>，作用是设置终端参数。此函数的参数一为终端的文件描述符；参数二为用于控制修改起作用的时间；参数三为结构体 <code>struct termios</code>，其中储存了输入输出模式等设置参数。此处传参一为0，即此进程的<strong>标准输入流</strong>；传参二为 <code>TCSANOW</code>，代表不等数据传输完毕就立即改变属性；传参三为结构体 <code>term</code>，即上一行配置后的终端设置。</li>
<li>此行调用函数 <code>setbuf</code>，作用为设置用于流操作的内部缓冲区。此处传参一为标准输入流 <code>stdin</code>，传参二中缓冲区设置为 <code>NULL</code>，即关闭缓冲区。此处关闭缓冲区的意义我认为是方便后续及时对单个输入字符的处理。<br>&emsp;</li>
</ol>
<h2 id="2-cmdline-new"><a href="#2-cmdline-new" class="headerlink" title="2. cmdline_new()"></a>2. cmdline_new()</h2><p>&emsp;&emsp;接着来看一下第二部分，此处调用了函数<code>cmdline_new()</code>。首先查看一下这个函数的定义，其定义位于<code>lib/librte_cmdline/cmdline.c</code>。<br><img src="/images/2021-11-21/3.jpg" alt="cmdline_new"><br>&emsp;&emsp;此函数的传参一共有四个，根据 <code>cmdline_stdin_new</code> 中的调用来看：传参一是命令组；传参二是提示符；传参三是输入描述符(传入fd为0，即本进程输入流)；传参四为输出描述符(传入fd为1，即本进程输出流)。</p>
<p>&emsp;&emsp;函数中首先是对命令组和提示符的合法性进行了非空判定。随后是 <code>malloc</code> 并 <code>memset</code> 了一块 <code>cmdline</code> 结构体大小的空间，用来储存申请的命令行数据。接着直接对 <code>cmdline</code> 结构体内容进行赋值，输入输出流设为传入的输入输出流，命令组设为传入的命令组。最后就是若干初始化命令行的函数，下面会挨个分析。<br>&emsp;</p>
<h3 id="2-1-rdline-init"><a href="#2-1-rdline-init" class="headerlink" title="2.1 rdline_init()"></a>2.1 rdline_init()</h3><p>&emsp;&emsp;首先看一下 <code>rdline_init()</code> 其定义位于 <code>lib/librte_cmdline/cmdline_rdline.c</code>。<br><img src="/images/2021-11-21/4.jpg" alt="rdline_init"><br>&emsp;&emsp;注释如下，我也加上了一部分内容方便理解：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Init fields for a struct rdline. Call this only once at the beginning</span></span><br><span class="line"><span class="comment"> * of your program.</span></span><br><span class="line"><span class="comment"> * 只需要在初始化rdline前执行一次</span></span><br><span class="line"><span class="comment"> * \param rdl A pointer to an uninitialized struct rdline </span></span><br><span class="line"><span class="comment"> * 参数一为一个未初始化的rdline，即用户申请的cmdline中包含的rdline</span></span><br><span class="line"><span class="comment"> * \param write_char The function used by the function to write a character</span></span><br><span class="line"><span class="comment"> * 参数二为一个函数指针，指向用来写字符的函数</span></span><br><span class="line"><span class="comment"> * \param validate A pointer to the function to execute when the</span></span><br><span class="line"><span class="comment"> *                 user validates the buffer.</span></span><br><span class="line"><span class="comment"> * 参数三为一个函数指针，指向用户验证缓冲区时要执行的函数</span></span><br><span class="line"><span class="comment"> * \param complete A pointer to the function to execute when the</span></span><br><span class="line"><span class="comment"> *                 user completes the buffer.</span></span><br><span class="line"><span class="comment"> * 参数四为一个函数指针，指向用户完成缓冲区时要执行的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;再次查看 <code>cmdline_new()</code> 中的调用，来确定三个函数的位置。另外可以看到此函数中return语句调用了函数 <code>cirbuf_init()</code>，接下来将对这四个函数进行分析。<br>&emsp;</p>
<h4 id="2-1-1-cmdline-write-char"><a href="#2-1-1-cmdline-write-char" class="headerlink" title="2.1.1  cmdline_write_char()"></a>2.1.1  cmdline_write_char()</h4><p>&emsp;&emsp;其定义位于<code>lib/librte_cmdline/cmdline.c</code>。<br><img src="/images/2021-11-21/5.jpg" alt="2.1.1"><br>&emsp;&emsp;此函数中，首先是根据 <code>rdline</code> 获取到其所属的 <code>cmdline</code>，随后进行检测，当输出流中存在内容时，使用 <code>write</code> 函数进行单个字符的写入。<br>&emsp;</p>
<h4 id="2-1-2-cmdline-valid-buffer"><a href="#2-1-2-cmdline-valid-buffer" class="headerlink" title="2.1.2  cmdline_valid_buffer()"></a>2.1.2  cmdline_valid_buffer()</h4><p>&emsp;&emsp;其定义位于<code>lib/librte_cmdline/cmdline.c</code>。<br><img src="/images/2021-11-21/6.jpg" alt="2.1.2"><br>&emsp;&emsp;此函数中，首先是根据 <code>rdline</code> 获取到其所属的 <code>cmdline</code>，随后使用命令行解析函数 <code>cmdline_parse()</code> (此篇笔记中不对此函数进行分析)对传入的字符串进行解析，根据解析的结果进行验证和提示。<br>&emsp;</p>
<h4 id="2-1-3-cmdline-complete-buffer"><a href="#2-1-3-cmdline-complete-buffer" class="headerlink" title="2.1.3  cmdline_complete_buffer()"></a>2.1.3  cmdline_complete_buffer()</h4><p>&emsp;&emsp;其定义位于<code>lib/librte_cmdline/cmdline.c</code>。<br><img src="/images/2021-11-21/7.jpg" alt="2.1.3"><br>&emsp;&emsp;此函数中，首先是根据 <code>rdline</code> 获取到其所属的 <code>cmdline</code>，随后使用缓冲区操作函数 <code>cmdline_complete_buffer()</code> (此篇笔记中不对此函数进行分析)对缓冲区进行处理。<br>&emsp;</p>
<h4 id="2-1-4-cirbuf-init"><a href="#2-1-4-cirbuf-init" class="headerlink" title="2.1.4  cirbuf_init()"></a>2.1.4  cirbuf_init()</h4><p>&emsp;&emsp;其定义位于<code>lib/librte_cmdline/cmdline_cirbuf.c</code>。<br><img src="/images/2021-11-21/8.jpg" alt="2.1.4"><br>&emsp;&emsp;此函数的作用是初始化循环缓冲区。此处函数里主要是对 <code>&amp;rdline-&gt;history</code> 这部分初始化，包括大小、起始、缓冲区地址等。<br>&emsp;</p>
<h3 id="2-2-cmdline-set-prompt"><a href="#2-2-cmdline-set-prompt" class="headerlink" title="2.2 cmdline_set_prompt()"></a>2.2 cmdline_set_prompt()</h3><p>&emsp;&emsp;在执行此函数前，<code>cmdline_new()</code> 中先执行 <code>cl-&gt;rdl.opaque = cl;</code>，作用是将 <code>cmdline cl</code> 中含有的 <code>rdline rdl</code> 与其所属 <code>cmdline cl</code> 绑定。随后来看函数<code>cmdline_set_prompt()</code>，其定义位于<code>lib/librte_cmdline/cmdline.c</code>。<br><img src="/images/2021-11-21/9.jpg" alt="2.2"><br>&emsp;&emsp;此处的传参二为命令行提示符，此处的主要作用就是将提示符设置进 <code>cmdline</code> 中。这里使用格式化写入函数 <code>snprintf</code>，将提示符写入 <code>cmdline-&gt;prompt</code> 部分。<br>&emsp;</p>
<h3 id="2-3-rdline-newline"><a href="#2-3-rdline-newline" class="headerlink" title="2.3 rdline_newline()"></a>2.3 rdline_newline()</h3><p>&emsp;&emsp;其定义位于<code>lib/librte_cmdline/cmdline_rdline.c</code>。<br><img src="/images/2021-11-21/10.jpg" alt="2.3"><br>&emsp;&emsp;此函数里主要是对 <code>rdline</code> 中的元素进行初始化，包括左右缓冲区(rdline-&gt;left&#x2F;right)和 <code>rdline</code> 对应的提示符相关内容等。<br>&emsp;&emsp;这里值得一提的是 <code>write_char</code> 函数实际是 <code>2.1.1  cmdline_write_char()</code> 传入的函数，所以这里的实际操作是将输出流内的内容存入<code>rdline-&gt;prompt</code>。我思考了一下这部分的逻辑，觉得应该是为了让输出流中的提示符与 <code>rdline</code> 中的提示符相对应，也有可能是为了清除缓冲区。<br>&emsp;<br>&emsp;&emsp;至此，初始化函数 <code>cmdline_stdin_new()</code> 结束，可以看到其中主要流程为：</p>
<ol>
<li>对终端之前的设置进行保存，设置三个终端选项。</li>
<li><code>cmdline</code> 的初始化，设定输入输出流、命令组以及提示符等。</li>
<li><code>rdline</code> 的初始化，设定三个回调函数(写字符、检测、完成)，对历史命令缓冲区、左右缓冲区进行初始化，以及对提示符的设定等。<br>&emsp;</li>
</ol>
<h1 id="三、交互函数-cmdline-interact-略过"><a href="#三、交互函数-cmdline-interact-略过" class="headerlink" title="三、交互函数 cmdline_interact() (略过)"></a>三、交互函数 cmdline_interact() (略过)</h1><p>&emsp;&emsp;本篇笔记主要记录初始化和退出部分，解析部分暂且略过，在之后的笔记中记录分析。<br>&emsp;</p>
<h1 id="四、退出函数-cmdline-stdin-exit"><a href="#四、退出函数-cmdline-stdin-exit" class="headerlink" title="四、退出函数 cmdline_stdin_exit()"></a>四、退出函数 cmdline_stdin_exit()</h1><p>&emsp;&emsp;首选查看其定义，其定义位于<code>lib/librte_cmdline/cmdline_socket.c</code>。<br><img src="/images/2021-11-21/11.jpg" alt="在这里插入图片描述"><br>&emsp;&emsp;其中函数 <code>tcsetattr</code> 的作用是设置linux下终端参数。此函数的参数一为终端的文件描述符；参数二为用于控制修改起作用的时间；参数三为结构体 <code>struct termios</code>，其中储存了输入输出模式等设置参数。具体含义如下：</p>
<ul>
<li>参数一为 <code>fileno(stdin)</code>，其中 <code>fileno()</code> 的作用是获取传参流的文件描述符，此处传入输入流 <code>stdin</code> 并获取到其文件操作符。</li>
<li>参数二为 <code>TCSANOW</code>，代表不等数据传输完毕就立即改变属性。</li>
<li>参数三为 <code>&amp;c1-&gt;oldterm</code>，为在调用 <code>cmdline_stdin_new</code> 创建 <code>cmdline</code> 时保存的未修改的终端设置，即交互式命令行创建之前的终端设置。</li>
</ul>
<p>&emsp;&emsp;所以，退出函数 <code>cmdline_stdin_exit</code> 的实际操作仅仅是恢复了创建交互式命令行之前的终端设置。<br>&emsp;</p>
<h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>&emsp;&emsp;总的来说，dpdk中这部分源码非常严谨，参数、宏非常多。其中一些概念，比如说vt100，我也是搜了一下才知道是什么。<br>&emsp;&emsp;源码中对 <code>cmdline</code> 和 <code>rdline</code> 结构体的定义，都可以说是非常的“庞大”，<strong>本篇笔记中记录的初始化和退出相关的内容，涉及到非常多的函数，但实际上都是为了初始化这两个结构体</strong>。发现了这一点之后，再汇总一下初始化的内容，整体就非常清晰了。<br>&emsp;&emsp;其中一些对流的操作，我还是没有理解透彻，比如说 <code>rdline_newline()</code> 中为何要执行 <code>rdl-&gt;write_char()</code>，在接下来我应该会再去更深入的了解一下linux下流的内容，来理解源码中的意图和意义。当然，这系列中还剩最后也是最重要的一部分——命令解析，在下一篇中会进行分析。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>源码阅读</tag>
        <tag>C/C++</tag>
        <tag>dpdk</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11学习记录：核心语言功能特性</title>
    <url>/2021/12/02/20211202_C++11%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E6%A0%B8%E5%BF%83%E8%AF%AD%E8%A8%80%E5%8A%9F%E8%83%BD%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<ul>
<li>本篇笔记汇总了C++11中的主要新语言功能，根据个人理解与查阅的资料进行记录。</li>
<li>主要参考地址：<a href="https://zh.cppreference.com/w/cpp/11">cppreference</a></li>
</ul>
<span id="more"></span>

<h1 id="·-模板优化"><a href="#·-模板优化" class="headerlink" title="· 模板优化"></a>· 模板优化</h1><h2 id="1-对右尖括号的优化"><a href="#1-对右尖括号的优化" class="headerlink" title="1. 对右尖括号的优化"></a>1. 对右尖括号的优化</h2><p>&emsp;&emsp; 简单来讲，就是在C++11以前，当在模板使用中出现双右尖括号的时候，编译器会解析为右移符号 <code>&gt;&gt;</code>。这就导致模板嵌套写起来不太方便，右括号之间需要用空格来空开。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此句在C++11前是错误的，因为 &gt;&gt; 会解释为右移符号</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; test;</span><br><span class="line"><span class="comment">//在C++11前，一般都加个空格给空开</span></span><br><span class="line">vector&lt; vector&lt;<span class="type">int</span>&gt; &gt; test;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在C++11中其改进了编译器的解析规则，<strong>尽可能多的将多个右尖括号</strong> <code>&gt;</code> <strong>解析成模板参数结束符</strong>，从而方便代码编写。</p>
<h2 id="2-默认模板参数"><a href="#2-默认模板参数" class="headerlink" title="2. 默认模板参数"></a>2. 默认模板参数</h2><p>&emsp;&emsp;在C++11中，模板参数支持设定默认值。<strong>当未设定模板类型时，编译器首先会根据传参进行类型推导，当推导失败时，就会使用模板参数的默认值（默认值没有的话就会报错）。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T = <span class="type">long</span>, <span class="keyword">typename</span> U = <span class="type">int</span>&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">test</span>(T t = <span class="string">&#x27;a&#x27;</span>, U u = <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; t  &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; u &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//test&lt;char, char&gt;</span></span><br><span class="line"><span class="built_in">test</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);				<span class="comment">//a - b</span></span><br><span class="line"><span class="comment">//test&lt;int, char&gt;</span></span><br><span class="line"><span class="built_in">test</span>&lt;<span class="type">int</span>&gt;(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);		<span class="comment">//97 - b</span></span><br><span class="line"><span class="comment">//test&lt;char, char&gt;</span></span><br><span class="line"><span class="built_in">test</span>&lt;<span class="type">char</span>&gt;(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);		<span class="comment">//a - b</span></span><br><span class="line"><span class="comment">//test&lt;int, char&gt;</span></span><br><span class="line"><span class="built_in">test</span>&lt;<span class="type">int</span>, <span class="type">char</span>&gt;(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);	<span class="comment">//97 - b</span></span><br><span class="line"><span class="comment">//test&lt;char, int&gt;</span></span><br><span class="line"><span class="built_in">test</span>&lt;<span class="type">char</span>, <span class="type">int</span>&gt;(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);	<span class="comment">//a - 98</span></span><br><span class="line"><span class="comment">//test&lt;long, int&gt; 无法推导</span></span><br><span class="line"><span class="built_in">test</span>();						<span class="comment">//97 - 98</span></span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h1 id="·-auto-与-decltype"><a href="#·-auto-与-decltype" class="headerlink" title="· auto 与 decltype"></a>· auto 与 decltype</h1><h2 id="1-auto"><a href="#1-auto" class="headerlink" title="1. auto"></a>1. auto</h2><p>&emsp;&emsp;C++11中，出现了一个非常有用的关键字 <code>auto</code>，即占位类型说明符，它可以自动推导出占位处的类型。在C++11中，其只能服务于变量；在C++14中，其可以服务于函数返回值；在C++17中，它可以服务于非模板形参 <code>template&lt;auto I&gt; struct A;</code>；在C++20中，其也可以服务于函数形参 <code>void f(auto);</code>。<strong>下面单就C++11中的</strong> <code>auto</code> <strong>用法(变量)进行一定的总结。</strong></p>
<p>&emsp;&emsp;首先，其基本用法为 <code>auto x = expr;</code>，此时编译器会从初始化器推导类型，具体规则参考模板实参推导的规则。所以在使用 <code>auto</code> 的时候，必须要指定初始化内容，这样才可以正确的推导出类型进行初始化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = <span class="number">3.14</span>;	<span class="comment">//double</span></span><br><span class="line"><span class="keyword">auto</span> b = <span class="number">520</span>;	<span class="comment">//int</span></span><br><span class="line"><span class="keyword">auto</span> c = <span class="string">&#x27;a&#x27;</span>;	<span class="comment">//char</span></span><br><span class="line"><span class="keyword">auto</span> d;			<span class="comment">//error未初始化</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;由于推导规则与模板实参推导规则一致，所以cv关键字的保留情况相同：</p>
<ul>
<li>当变量不是指针或者引用类型时，推导的结果中不会保留 <code>const</code>、 <code>volatile</code> 关键字。</li>
<li>当变量是指针或者引用类型时，推导的结果中会保留 <code>const</code>、 <code>volatile</code> 关键字。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> temp = <span class="number">222</span>;</span><br><span class="line"><span class="keyword">auto</span>* a = &amp;temp;	<span class="comment">//auto = int -&gt; a : int*</span></span><br><span class="line"><span class="keyword">auto</span> b = &amp;temp; 	<span class="comment">//auto = int* -&gt; b : int*</span></span><br><span class="line"><span class="keyword">auto</span>&amp; c = temp; 	<span class="comment">//auto = int -&gt; c : int&amp;</span></span><br><span class="line"><span class="keyword">auto</span> d = temp; 		<span class="comment">//auto = int -&gt; d : int</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> e = temp;	<span class="comment">//auto = int -&gt; e : const int</span></span><br><span class="line"><span class="keyword">auto</span> f = e;				<span class="comment">//auto = int -&gt; f : int (忽略const)</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp; g = temp; 	<span class="comment">//auto = int -&gt; g : const int&amp;</span></span><br><span class="line"><span class="keyword">auto</span>&amp; h = g;			<span class="comment">//auto = const int -&gt; h : const int&amp;</span></span><br><span class="line"><span class="keyword">auto</span>* i = &amp;e; 			<span class="comment">//auto = const int -&gt; i : const int*</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;另外在C++11中，<code>auto</code> 不允许使用的场景主要有四个：</p>
<ol>
<li>不能作为函数参数，因为函数调用时才会传实参，<code>auto</code> 使用要求必须要给修饰的变量赋值，二者矛盾。</li>
<li>不能用于类的非静态成员变量初始化。原因和上一条一样，因为类的非静态成员变量在没创建对象的时候也是未定义的。</li>
<li>不能使用 <code>auto</code> 关键字定义数组。<code>int array[] = &#123;...&#125;</code> 后，<code>auto a = array</code> 是被允许的，a 被推导为 <code>int*</code> 类型；而 <code>auto b[] = array</code> 是非法的，因为 <code>auto</code> 无法定义数组。</li>
<li>无法使用 <code>auto</code> 推导函数模板。<code>Test&lt;double&gt; t;</code> 后，<code>Test&lt;auto&gt; t1 = t</code> 是不被允许的，因为 <code>auto</code> 不算是一个类型，是没办法传进去的。</li>
</ol>
<h2 id="2-decltype"><a href="#2-decltype" class="headerlink" title="2. decltype"></a>2. decltype</h2><p>&emsp;&emsp;即 <code>declare type</code> 的缩写。其作用也是推导类型，其推导和 <code>auto</code> 一样都是在编译期完成的。语法为 <code>decltype(表达式)</code>，其仅用于表达式类型的推导，不会理会表达式的值。但是有一点，<code>auto</code> 只能推导已初始化的变量类型，而 <code>decltype</code> 的可以推导比较复杂的表达式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a) b = <span class="number">20</span>;					<span class="comment">//b : int </span></span><br><span class="line"><span class="keyword">decltype</span>(a * <span class="number">2</span> + <span class="number">3.14</span>) c = <span class="number">13.14</span>; 	<span class="comment">//c : double</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>decltype</code> 的主要规则如下，简单来说就是当表达式为纯右值时推导出来会剔除cv修饰(因为纯右值不能被cv修饰)，其余都会都会保存cv修饰。</p>
<ol>
<li>如果 表达式 的值类别是亡值，将会 <code>decltype</code> 产生 T&amp;&amp;。</li>
<li>如果 表达式 的值类别是左值，或者被括号 <code>()</code> 包围，将会 <code>decltype</code> 产生 T&amp;。</li>
<li>如果 表达式 的值类别是纯右值，将会 <code>decltype</code> 产生 T。</li>
</ol>
<p>&emsp;</p>
<h1 id="·-预置与弃置的函数"><a href="#·-预置与弃置的函数" class="headerlink" title="· 预置与弃置的函数"></a>· 预置与弃置的函数</h1><h2 id="1-预置"><a href="#1-预置" class="headerlink" title="1. 预置"></a>1. 预置</h2><p>&emsp;&emsp;语法为 <code>函数 = default;</code>。通过将函数体定义为 <code>default</code> 来显式预置函数定义。</p>
<p>&emsp;&emsp;在声明类或者结构体的时候，如果未创建构造参数，则编译器会自动帮你创建一个空参空函数体的默认构造函数。例子如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Test <span class="title">t</span><span class="params">()</span></span>;<span class="comment">//可以编译</span></span><br><span class="line"></span><br><span class="line">编译器生成默认构造函数的Test类:</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Test</span>() &#123;&#125;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line">所以上面才可以调用空参构造</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;但是，一旦添加了其他有参数的构造函数，编译器就不再生成缺省的构造函数了。而在C++11中，其允许我们使用 <code>= default</code> 来要求编译器生成一个默认构造函数：<code>Test() = default</code>，这样就可以在使用其余带参构造函数时也能使用默认构造函数了。</p>
<h2 id="2-弃置"><a href="#2-弃置" class="headerlink" title="2. 弃置"></a>2. 弃置</h2><p>&emsp;&emsp;语法为 <code>函数 = delete;</code>。通过将函数体定义为 <code>delete</code> 来显式弃置函数定义。其可以删除特殊成员函数以及普通成员函数和非成员函数，以阻止定义或调用它们。函数的弃置定义必须是翻译单元中的首条声明，已经声明过的函数不能声明为弃置的。</p>
<p>&emsp;&emsp;在 <code>std::unique_ptr</code> 里删除了传参为 <code>unique_ptr</code> 左值的构造参数，以及相关的 <code>=</code> 操作。这样就可以保证此智能指针的唯一性。我个人感觉还是挺有用的，这样直接删除就不用重载了。<br><img src="/images/2021-12-02/1.jpg" alt="4"><br>&emsp;</p>
<h1 id="·-final-与-override"><a href="#·-final-与-override" class="headerlink" title="· final 与 override"></a>· final 与 override</h1><h2 id="1-final"><a href="#1-final" class="headerlink" title="1. final"></a>1. final</h2><p>&emsp;&emsp;其作用为指定某个虚函数不能在派生类中被覆盖，或者某个类不能被派生。也就是说，其可以作用于函数或者类，但是作用于函数时只能是<strong>虚函数</strong>。此关键字写于虚函数或类的后面。</p>
<ol>
<li>作用于虚函数：使用 <code>final</code> 修饰虚函数，阻止子类重写父类的此函数。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">final</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
<li>作用于类：使用 <code>final</code> 修饰类，此类无法被继承。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">final</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="2-override"><a href="#2-override" class="headerlink" title="2. override"></a>2. override</h2><p>&emsp;&emsp;其作用为指定一个虚函数覆盖另一个虚函数。在成员函数的声明或定义中，<code>override</code> 说明符确保该函数为虚函数并覆盖某个基类中的虚函数。如果不是这样，那么程序会生成编译错误。</p>
<p><code>override</code> <strong>是在成员函数声明符之后使用时拥有特殊含义的标识符，其他情况下它不是保留的关键词。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>&emsp;</p>
<h1 id="·-尾随返回类型"><a href="#·-尾随返回类型" class="headerlink" title="· 尾随返回类型"></a>· 尾随返回类型</h1><p>&emsp;&emsp;尾随返回类型语法为<code>auto 函数名(传参) -&gt; decltype(表达式) &#123; 函数体 &#125;</code>，返回值类型为 <code>decltype</code> 推导出的类型。</p>
<p>&emsp;&emsp;这个东西我感觉主要是为模板服务，使用场景主要是：</p>
<ol>
<li>返回值随模板类型变化<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T x, U y)</span> -&gt; <span class="title">decltype</span><span class="params">(x + y)</span><span class="comment">//这里说一嘴，此处的decltype不能填函数体内新声明的变量，比如z</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> z = x + y;</span><br><span class="line">	<span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">double</span> b = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">auto</span> ret = <span class="built_in">add</span>(a, b);</span><br><span class="line">cout &lt;&lt; ret &lt;&lt; endl;	<span class="comment">//4.14</span></span><br></pre></td></tr></table></figure></li>
<li>返回值类型比较复杂<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fpif</span><span class="params">(<span class="type">int</span>)</span> -&gt; <span class="title">int</span><span class="params">(*)</span><span class="params">(<span class="type">int</span>)</span></span></span><br></pre></td></tr></table></figure>
&emsp;</li>
</ol>
<h1 id="·-右值引用"><a href="#·-右值引用" class="headerlink" title="· 右值引用"></a>· 右值引用</h1><p>&emsp;&emsp;C++11中增加了一个新的很好用的类型，右值引用 <code>&amp;&amp;</code>，就是对右值的引用。首先看一下左右值的区别，其实主要就是看能不能取地址：</p>
<ul>
<li>左值为 <code>locator value</code>，即 <code>lvalue</code>；右值为 <code>read value</code>，即 <code>rvalue</code>。</li>
<li>左值：储存在内存中、有明确存储地址的数据(可取地址)</li>
<li>右值：可以提供数据值的数据(不可取地址)</li>
</ul>
<p>&emsp;&emsp;那么右值引用有什么作用？<strong>主要的作用就是延长右值的生命周期，以提高效率。</strong> 那么是如何提高效率的呢？比如说如下这个场景：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;vt;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;temp&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">vt.<span class="built_in">push_back</span>(temp);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;此段代码中，先声明了二维数组 <code>vt</code>，随后声明一个一维数组 <code>temp</code> 来塞入容器 <code>vt</code>。自此一维数组 <code>temp</code> 使命完成，其储存的右值也没有作用了。在 <code>push_back()</code> 操作中，其首先会将 <code>temp</code> 以左值引用传进去，随后再使用 <code>construct</code> 来创建一个 <code>vector&lt;int&gt;</code> 拷贝储存传进来的值，最后再放入容器(如下图)。这就导致在函数中，此组数据被完整拷贝了一次，降低了效率。<br><img src="/images/2021-12-02/2.jpg" alt="2"><br>&emsp;&emsp;那么，既然 <code>temp</code> 只在此处有用，可否直接把 <code>temp</code> 放入 <code>vt</code> 中来减少那次拷贝呢？右值引用就是为了这个场景而出现的。例如上面这个问题的本质为：<code>temp</code> 的右值生命周期到此为止，想要将其生命周期延长给另一个变量 <code>vt</code>，来避免对 <code>temp</code> 右值的复制。这时就可以传入右值来提高 <code>vector::push_back()</code> 的效率。 <a href="https://blog.csdn.net/qq_45698148/article/details/120680378">std::move源码分析</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;vt;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;temp&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">vt.<span class="built_in">push_back</span>(<span class="built_in">move</span>(temp));<span class="comment">//这里的std::move的作用是将左值转为右值</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;C++11中，STL中已经重载了很多函数的传右值引用版本，比如下图中 <code>vector::push_back()</code> 的右值引用版本，其只调用了 <code>emplace_back</code> 函数来延长生命周期，从而避免使用 <code>construct</code> 重新拷贝创建。<br><img src="/images/2021-12-02/3.jpg" alt="3"><br>&emsp;&emsp;<strong>所以呢，在C++11以前，右值引用没出现时，实际面临的问题是分辨传入的是右值还是左值。</strong> 当右值引用出现后，函数就可以判断传入的是右值还是左值，从而做出更优的选择。例如 <code>vector::push_back()</code> 在接收到右值的时候，它就知道可以直接给这个右值改变”所有者”，从而提高效率。</p>
<p>&emsp;</p>
<h1 id="·-移动构造函数与移动赋值运算符"><a href="#·-移动构造函数与移动赋值运算符" class="headerlink" title="· 移动构造函数与移动赋值运算符"></a>· 移动构造函数与移动赋值运算符</h1><h2 id="1-移动构造函数"><a href="#1-移动构造函数" class="headerlink" title="1. 移动构造函数"></a>1. 移动构造函数</h2><p>&emsp;&emsp;移动构造函数其实就是传参为<strong>本类右值</strong>的构造参数，来实现将传入右值拥有的内存资源”移为已用”，这部分内容的实现被叫做<strong>移动语义</strong>。上面右值引用中举得 <code>vector::push_back(value_type&amp;&amp;)</code> 例子中，其实就是移动语义的一种实现，它延长了传入右值的存活时间。</p>
<p>&emsp;&emsp;移动构造函数在检测到传入内容为右值时，会将右值内容赋予新建的对象，并且删除右值原属主的内容，来实现<strong>移动语义</strong>。此类将内容”移为已用”的构造参数即可被称为<strong>移动构造参数</strong>。下面就是一个移动构造参数的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> n) : <span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(n))</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;copy construct&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移动构造函数</span></span><br><span class="line">    <span class="built_in">Test</span>(Test&amp;&amp; t) : <span class="built_in">num</span>(t.num)</span><br><span class="line">    &#123;</span><br><span class="line">        t.num = <span class="literal">nullptr</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;move construct&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">t</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">Test <span class="title">t1</span><span class="params">(move(t))</span></span>;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">copy construct</span><br><span class="line">move construct</span><br></pre></td></tr></table></figure>
<h2 id="2-移动赋值运算符"><a href="#2-移动赋值运算符" class="headerlink" title="2. 移动赋值运算符"></a>2. 移动赋值运算符</h2><p>&emsp;&emsp;移动赋值函数和上面的移动构造函数相似，只不过移动构造函数是在构造函数里接收右值操作，而移动赋值运算符是重载了 <code>operator =</code> 操作，使其接收一个右值，从而类可以进行 <code>类名 = 类右值</code> 这样的<strong>移动语义</strong>操作。下面是一个例子，其中移动构造函数和移动赋值运算符都有定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    std::string s;</span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">s</span>(<span class="string">&quot;测试&quot;</span>) &#123; &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; o) : <span class="built_in">s</span>(o.s) &#123; std::cout &lt;&lt; <span class="string">&quot;移动失败！\n&quot;</span>; &#125;</span><br><span class="line">    <span class="built_in">A</span>(A&amp;&amp; o) : <span class="built_in">s</span>(std::<span class="built_in">move</span>(o.s)) &#123; &#125;</span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">         s = other.s;</span><br><span class="line">         std::cout &lt;&lt; <span class="string">&quot;复制赋值\n&quot;</span>;</span><br><span class="line">         <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(A&amp;&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">         s = std::<span class="built_in">move</span>(other.s);</span><br><span class="line">         std::cout &lt;&lt; <span class="string">&quot;移动赋值\n&quot;</span>;</span><br><span class="line">         <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a1, a2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;尝试从右值临时量移动赋值 A\n&quot;</span>;</span><br><span class="line">    a1 = <span class="built_in">f</span>(<span class="built_in">A</span>()); <span class="comment">// 从右值临时量移动赋值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;尝试从亡值移动赋值 A\n&quot;</span>;</span><br><span class="line">    a2 = std::<span class="built_in">move</span>(a1); <span class="comment">// 从亡值移动赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;</p>
<h1 id="·-有作用域枚举"><a href="#·-有作用域枚举" class="headerlink" title="· 有作用域枚举"></a>· 有作用域枚举</h1><p>&emsp;&emsp;在C++11之前，枚举类型可能会出现一个问题：<strong>枚举值的重复</strong>。比如说下面这种情况：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三原色</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">LightColor</span></span><br><span class="line">&#123;</span><br><span class="line">	red,<span class="comment">//note: previous declaration ‘LightColor red’</span></span><br><span class="line">	green,</span><br><span class="line">	blue<span class="comment">//note: previous declaration ‘LightColor blue’</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//三基色</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">PaintColor</span></span><br><span class="line">&#123;</span><br><span class="line">	red,<span class="comment">//‘red’ conflicts with a previous declaration</span></span><br><span class="line">	yellow,</span><br><span class="line">	blue<span class="comment">//‘blue’ conflicts with a previous declaration</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//如上这样定义就会出现枚举值重复情况 无法正常编译</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在C++11之前为了解决这种情况都是将其放入另一个作用域(类或命名空间)中，比如下面就是放入别的命名空间：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三原色</span></span><br><span class="line"><span class="keyword">namespace</span> Light</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">enum</span> <span class="title class_">Color</span></span><br><span class="line">	&#123;</span><br><span class="line">		red,</span><br><span class="line">		green,</span><br><span class="line">		blue</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//三基色</span></span><br><span class="line"><span class="keyword">namespace</span> Paint</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">enum</span> <span class="title class_">Color</span></span><br><span class="line">	&#123;</span><br><span class="line">		red,</span><br><span class="line">		yellow,</span><br><span class="line">		blue</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line">Light::Color c1 = Light::red;</span><br><span class="line">Paint::Color c2 = Paint::red;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;但是使用命名空间或类这个解法明显有点繁琐以及浪费，于是在C++11中推出了<strong>有作用域枚举</strong>。如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三原色</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">LightColor</span></span><br><span class="line">&#123;</span><br><span class="line">	red,</span><br><span class="line">	green,</span><br><span class="line">	blue</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//三基色</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">PaintColor</span></span><br><span class="line">&#123;</span><br><span class="line">	red,</span><br><span class="line">	yellow,</span><br><span class="line">	blue</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line">LightColor c1 = LightColor::red;</span><br><span class="line">PaintColor c2 = PaintColor::red;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这样，既解决了常规枚举值重复的问题，也让整体定义和使用变得没那么繁琐。</p>
<p>&emsp;</p>
<h1 id="·-constexpr-与字面类型"><a href="#·-constexpr-与字面类型" class="headerlink" title="· constexpr 与字面类型"></a>· constexpr 与字面类型</h1><h2 id="1-constexpr"><a href="#1-constexpr" class="headerlink" title="1. constexpr"></a>1. constexpr</h2><p>&emsp;&emsp;在C语言中，<code>const</code> 关键字只有”只读”这一语义，但在C++中其引入了”常量”语义。<strong>在C++中，所谓”只读”和”常量”的区别大致在编译期间能不能直接确定初始值，若不能则被作为”只读变量”处理，若可以确定则被作为”常量”处理。</strong> 在 <code>constexpr</code> 出现之前，<code>const</code> 一直同时承担两种语义，故 <code>constexpr</code> 出现的意义便是承担”常量”这一语义。</p>
<p>&emsp;&emsp;所以，<code>constexpr</code> 表示在编译期就可以确定的内容，而 <code>const</code> 只保证运行时不直接被修改。我记得官方是建议凡是”常量”语义的场景都使用 <code>constexpr</code>，只对”只读”语义使用 <code>const</code>。另外在C++11中，<code>constexpr</code> 函数必须把一切放在单条 return 语句中，而在C++14后就无此要求了。</p>
<p>&emsp;&emsp;<code>constexpr</code> 可以修饰变量和函数。可以看到，C++标准库里的模板元编程内容都加上了 <code>constexpr</code> 修饰，因为这部分内容都是在编译期里可以被推出的。通过关键字 <code>constexpr</code> 的修饰，可以让编译器更好的优化、替换相关的常量，从而提高执行效率。当然，给一段不是常量返回值的函数加上关键字 <code>constexpr</code> 是无效的，编译器会在判定后忽略关键字。</p>
<p>&emsp;&emsp;另外存在 <code>noexcept</code> 运算符始终对常量表达式返回 true，所以它可以用于检查具体特定的 <code>constexpr</code> 函数返回是否采用常量表达式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>; </span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> b1 = <span class="built_in">noexcept</span>(<span class="built_in">f</span>()); <span class="comment">// false，constexpr 函数未定义</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> b2 = <span class="built_in">noexcept</span>(<span class="built_in">f</span>()); <span class="comment">// true，f() 是常量表达式</span></span><br></pre></td></tr></table></figure>
<h2 id="2-字面类型"><a href="#2-字面类型" class="headerlink" title="2. 字面类型"></a>2. 字面类型</h2><p>&emsp;&emsp;指明一个类型为字面类型。字面类型是 <code>constexpr</code> 变量所拥有的类型，且能通过 <code>constexpr</code> 函数构造、操作及返回它们。简单来说就是一个为了配合 <code>constexpr</code> 的理论概念。<br>&emsp;&emsp;<strong>注意：标准中并没有定义具有这个名字的具名要求。这是核心语言所定义的一种类型类别。将它作为具名要求包含于此只是为了保持一致性。</strong></p>
<p>&emsp;</p>
<h1 id="·-列表初始化"><a href="#·-列表初始化" class="headerlink" title="· 列表初始化"></a>· 列表初始化</h1><p>&emsp;&emsp;在C++11之前，变量、数组、对象等都有不同的初始化方法。而在C++11中出现了一种新的初始化方式，<strong>其统一了初始化方式并且让初始化行为具有确定的效果</strong>，即列表初始化。</p>
<p>&emsp;&emsp;列表初始化的语法就是在要初始化的内容后加上一个大括号（括号前可以加等号），其中写上初始化的内容即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Test <span class="title">t</span><span class="params">(<span class="number">520</span>)</span></span>;		<span class="comment">//普通构造</span></span><br><span class="line">Test t = <span class="number">520</span>;		<span class="comment">//隐式转换</span></span><br><span class="line">Test t = &#123;<span class="number">520</span>&#125;;		<span class="comment">//列表初始化</span></span><br><span class="line">Test t &#123;<span class="number">520</span>&#125;;		<span class="comment">//列表初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以下均为列表初始化</span></span><br><span class="line"><span class="type">int</span> i = &#123;<span class="number">1314</span>&#125;;		</span><br><span class="line"><span class="type">int</span> i &#123;<span class="number">1314</span>&#125;;		</span><br><span class="line"><span class="type">int</span> ii[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> ii[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;	</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span> &#123;<span class="number">5201314</span>&#125;;</span><br><span class="line"><span class="type">double</span> b = <span class="type">double</span> &#123;<span class="number">13.14</span>&#125;;</span><br><span class="line"><span class="type">int</span>* array = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;注意：类中的私有成员或者静态成员无法进行列表初始化。<strong>这个官方一点的总结应该是只有聚合类型才可以无条件使用列表初始化。</strong> 如果一个非聚合类也想使用列表初始化，那它必须得拥有相对应的构造函数。<a href="https://zh.cppreference.com/w/cpp/language/list_initialization">cppreference解释链接</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">test</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="type">int</span> y;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> z;</span><br><span class="line">&#125;t&#123;<span class="number">123</span>, <span class="number">321</span>&#125;;<span class="comment">//accept</span></span><br><span class="line"><span class="comment">//静态成员初始化</span></span><br><span class="line"><span class="type">int</span> test::z = <span class="number">222</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;</p>
<h1 id="·-委托与继承的构造函数"><a href="#·-委托与继承的构造函数" class="headerlink" title="· 委托与继承的构造函数"></a>· 委托与继承的构造函数</h1><h2 id="1-委托构造函数"><a href="#1-委托构造函数" class="headerlink" title="1. 委托构造函数"></a>1. 委托构造函数</h2><p>&emsp;&emsp;委托构造函数允许使用同一个类中的一个构造函数调用其他的构造函数，从而简化相关变量的初始化。我感觉这部分内容没什么好讲的，简单说就是可以通过 <code>:</code> 来调用其他的构造函数来简化操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Test</span>(<span class="type">int</span> max)</span><br><span class="line">	&#123;</span><br><span class="line">		max = max &gt; <span class="number">0</span> ? max : <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Test</span>(<span class="type">int</span> max, <span class="type">int</span> min) : <span class="built_in">Test</span>(max)</span><br><span class="line">	&#123;</span><br><span class="line">		min = min &gt; <span class="number">0</span> &amp;&amp; min &lt; max ? min : <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Test</span>(<span class="type">int</span> max, <span class="type">int</span> min, <span class="type">int</span> mid) : <span class="built_in">Test</span>(max, min)</span><br><span class="line">	&#123;</span><br><span class="line">		mid = mid &lt; max &amp;&amp; mid &gt; min ? mid : <span class="number">50</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> _max;</span><br><span class="line">	<span class="type">int</span> _min;</span><br><span class="line">	<span class="type">int</span> _middle;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2-继承构造函数"><a href="#2-继承构造函数" class="headerlink" title="2. 继承构造函数"></a>2. 继承构造函数</h2><p>&emsp;&emsp;继承构造函数可以让派生类直接使用基类的构造函数，而无需自己再写构造函数，尤其是在基类有很多构造函数的情况下，可以极大的简化派生类构造函数的编写。</p>
<p>&emsp;&emsp;比如下面这个例子，如果想要使用基类的构造函数，挨个重写 <code>Child(int i) : Base(i) &#123;&#125;</code> 明显很麻烦，但是直接使用 <code>using Base::Base;</code> 就可以直接继承基类的构造函数，方便很多。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>(<span class="type">int</span> i) : <span class="built_in">m_i</span>(i) &#123;&#125;</span><br><span class="line">	<span class="built_in">Base</span>(<span class="type">int</span> i, <span class="type">double</span> j) : <span class="built_in">m_i</span>(i), <span class="built_in">m_j</span>(j) &#123;&#125;</span><br><span class="line">	<span class="built_in">Base</span>(<span class="type">int</span> i, <span class="type">double</span> j, string k) : <span class="built_in">m_i</span>(i), <span class="built_in">m_j</span>(j), <span class="built_in">m_k</span>(k) &#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> m_i;</span><br><span class="line">	<span class="type">double</span> m_j;</span><br><span class="line">	string m_k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">using</span> Base::Base;</span><br><span class="line">	<span class="comment">//甚至可以 using Base::func 这样来继承父类的成员函数func()</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;</p>
<h1 id="·-花括号或等号初始化器"><a href="#·-花括号或等号初始化器" class="headerlink" title="· 花括号或等号初始化器"></a>· 花括号或等号初始化器</h1><p>&emsp;&emsp;如下，直接摘自<strong>cppreference</strong>。<br><img src="/images/2021-12-02/4.jpg" alt="5"><br>&emsp;</p>
<h1 id="·-nullptr"><a href="#·-nullptr" class="headerlink" title="· nullptr"></a>· nullptr</h1><p>&emsp;&emsp;在C语言中，空指针普遍使用 <code>NULL</code> 来表示，其实际定义为 <code>(void *)0</code>。但在C++中，<code>NULL</code> 的实际定义为 <code>0</code>，这是<strong>因为C++中不能将void *类型的指针隐式转换成其他指针类型</strong>。C++是一门强类型的语言，这样将0当成空指针很明显不符合语言的特性，因为 <code>NULL</code> 往往会被推导成 <code>long int</code> 类型而不是指针类型，于是在C++11中推出了 <code>nullptr</code> 来定义各个类型的空指针。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C++与C中NULL的定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> NULL</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__cplusplus)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL ((void *)0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>nullptr</code> 实际是 <code>std::nullptr_t</code> 类型的纯右值，它可以转换成任意指针类型。这样就可以解决C++中不能将(void *)类型的指针隐式转换成其他指针类型的问题，从而避免 <code>NULL</code> 歧义出现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;Pointer to integer overload\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">double</span>*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;Pointer to double overload\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std::<span class="type">nullptr_t</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;null pointer overload\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>* pi &#123;&#125;; <span class="type">double</span>* pd &#123;&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">f</span>(pi);</span><br><span class="line">    <span class="built_in">f</span>(pd);</span><br><span class="line">    <span class="built_in">f</span>(<span class="literal">nullptr</span>); <span class="comment">// 无 void f(nullptr_t) 可能有歧义</span></span><br><span class="line">    <span class="comment">// f(0);    // 歧义调用：三个函数全部为候选</span></span><br><span class="line">    <span class="comment">// f(NULL); // 若 NULL 是整数空指针常量则为歧义</span></span><br><span class="line">                <span class="comment">// （如在大部分实现中的情况）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">Pointer to integer overload</span><br><span class="line">Pointer to <span class="type">double</span> overload</span><br><span class="line">null pointer overload</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h1 id="·-long-long"><a href="#·-long-long" class="headerlink" title="· long long"></a>· long long</h1><p>&emsp;&emsp;就是C++11里新增的一组基础整数类型，简单来说其核心就是保证至少 64 位的宽度（8个字节），我觉得没什么好说的。<br><img src="/images/2021-12-02/5-0.jpg" alt="图ll"><br><img src="/images/2021-12-02/5.jpg" alt="图ll2"><br>&emsp;</p>
<h1 id="·-char16-t-与-char32-t"><a href="#·-char16-t-与-char32-t" class="headerlink" title="· char16_t 与 char32_t"></a>· char16_t 与 char32_t</h1><p>&emsp;&emsp;这两个是C++11里新增的字符类型，主要是为了服务UTF编码的。其与普通 <code>char</code> 的差别就是位宽不一样。具体定义如下：</p>
<ul>
<li><code>char16_t</code>: UTF-16 字符表示的类型，要求大到足以表示任何 UTF-16 编码单元（ 16 位）。它与 std::uint_least16_t 具有相同的大小、符号性和对齐，但它是独立的类型。使用<code>u</code>来表示utf-16字符: <code>char16_t c&#123; u&#39;a&#39; &#125;;</code></li>
<li><code>char32_t</code>: UTF-32 字符表示的类型，要求大到足以表示任何 UTF-32 编码单元（ 32 位）。它与 std::uint_least32_t 具有相同的大小、符号性和对齐，但它是独立的类型。使用<code>U</code>来表示utf-32字符:<code>char32_t c&#123; U&#39;a&#39; &#125;;</code></li>
</ul>
<p>&emsp;</p>
<h1 id="·-类型别名"><a href="#·-类型别名" class="headerlink" title="· 类型别名"></a>· 类型别名</h1><p>&emsp;&emsp;C++11中，给关键字 <code>using</code> 添加了一个新的功能：定义类型的别名。就我的使用经验来看，其和 <code>typedef</code> 是一样的效果，没有区别。虽然 <code>using</code> 看起来更简洁一点，但是我感觉已经用 <code>typedef</code> 用习惯了…</p>
<ul>
<li>使用场景一，和基础类型和函数指针搭配<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//语法</span></span><br><span class="line"><span class="keyword">using</span> 新类型 = 旧类型;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下两者相同</span></span><br><span class="line"><span class="keyword">using</span> func = <span class="built_in">void</span> (*) (<span class="type">int</span>, <span class="type">int</span>); </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*func)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span> </span>&#123;&#125;</span><br><span class="line">func f = test;</span><br></pre></td></tr></table></figure></li>
<li>使用场景二，和模板搭配，在STL源码里经常见<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyMap</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> map&lt;<span class="type">int</span>, T&gt; mapType;</span><br><span class="line">&#125;;</span><br><span class="line">MyMap&lt;<span class="type">int</span>&gt;::mapType m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> MyMap = map&lt;<span class="type">int</span>, T&gt;;</span><br><span class="line">MyMap&lt;<span class="type">int</span>&gt; m;</span><br></pre></td></tr></table></figure>
&emsp;</li>
</ul>
<h1 id="·-变参数模板"><a href="#·-变参数模板" class="headerlink" title="· 变参数模板"></a>· 变参数模板</h1><blockquote>
<p>形参包：模板形参包是接受零或更多模板实参（非类型、类型或模板）的模板形参。函数形参包是接受零或更多函数实参的函数形参，至少有一个形参包的模板被称作变参模板。</p>
</blockquote>
<p>&emsp;&emsp;在C++11中，新出现了变参数模板，即可将任意数量的模板实参实例化。语法为：<code>template&lt;class|typename ... Types&gt;</code>。其弥补了C++模板不能灵活定义参数数量的不足。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> --------------------------------------------------------------------</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span><span class="comment">//基础函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">const</span> T&amp; t, <span class="type">const</span> Args&amp;... a)</span><span class="comment">//递归变参函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test</span>(a...);<span class="comment">//递归调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test</span>(<span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>), <span class="string">&quot;world1&quot;</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> --------------------------------------------------------------------</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format)</span><span class="comment">//基础函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; format;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Targs&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, T value, Targs... Fargs)</span><span class="comment">//递归变参函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; *format != <span class="string">&#x27;\0&#x27;</span>; format++ ) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( *format == <span class="string">&#x27;%&#x27;</span> ) &#123;</span><br><span class="line">           std::cout &lt;&lt; value;</span><br><span class="line">           <span class="built_in">tprintf</span>(format<span class="number">+1</span>, Fargs...);<span class="comment">//递归调用</span></span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; *format;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">tprintf</span>(<span class="string">&quot;% world% %\n&quot;</span>,<span class="string">&quot;Hello&quot;</span>,<span class="string">&#x27;!&#x27;</span>,<span class="number">123</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如上两个例子所示，变参数模板一般都是拥有一个基础函数，以及一个变参模板函数。在变参模板函数里处理定量的传参后递归调用，直至参数处理完毕。<strong>总体而言我感觉它的思路和一般的递归函数是相似的，其基础函数即为边界。</strong></p>
<p>&emsp;</p>
<h1 id="·-推广的（非平凡）联合体"><a href="#·-推广的（非平凡）联合体" class="headerlink" title="· 推广的（非平凡）联合体"></a>· 推广的（非平凡）联合体</h1><p>&emsp;&emsp;<br>&emsp;</p>
<h1 id="·-推广的-POD-（平凡类型与标准布局类型）"><a href="#·-推广的-POD-（平凡类型与标准布局类型）" class="headerlink" title="· 推广的 POD （平凡类型与标准布局类型）"></a>· 推广的 POD （平凡类型与标准布局类型）</h1><p>&emsp;&emsp;<br>&emsp;</p>
<h1 id="·-Unicode-字符串字面量"><a href="#·-Unicode-字符串字面量" class="headerlink" title="· Unicode 字符串字面量"></a>· Unicode 字符串字面量</h1><p>&emsp;&emsp;在C++11之前，C++中只有<strong>通常字符串字面量：</strong><code>&quot;内容&quot;</code> 以及<strong>宽字符串字面量：</strong><code>L&quot;内容&quot;</code>。其中前者是最常用的一种，每个字符占一个字节；而后者则是代表每个字符占用两个字节。</p>
<p>&emsp;&emsp;上文中提到，C++11中提供了两个新字符类型 <code>char16_t</code> 与 <code>char32_t</code>，于是C++也更新了相对应的字符串字面量 <code>u&quot;内容&quot;</code> 和 <code>U&quot;内容&quot;</code>。此外还提供了另外新的两种字符串字面量 <code>u8&quot;内容&quot;</code> 和 <code>R&quot;xxx(内容)xxx&quot;</code>，这四种新的字面量的具体解释如下：</p>
<ol>
<li><code>u8&quot;内容&quot;</code>：<strong>UTF-8 字符串字面量。</strong> 字符串字面量的类型是 <code>const char[N]</code>(C++20 前) <code>const char8_t[N]</code>(C++20 起)，其中 N 是以 UTF-8 编码单元计的字符串的大小，包含空终止符。</li>
<li><code>u&quot;内容&quot;</code>：<strong>UTF-16 字符串字面量。</strong> 字符串字面量的类型是 <code>const char16_t[N]</code>，其中 N 是以 UTF-16 编码单元计的字符串的大小，包含空终止符。</li>
<li><code>U&quot;内容&quot;</code>：<strong>UTF-32 字符串字面量。</strong> 字符串字面量的类型是 <code>const char32_t[N]</code>，其中 N 是以 UTF-32 编码单元计的字符串的大小，包含空终止符。</li>
<li><code>R&quot;xxx(内容)xxx&quot;</code>：<strong>原始字符串字面量。</strong> 用于避免转义任何字符。这个我感觉还是挺有用的，在这里记录一下用法：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	在原始字符串字面量的定义内容中，将不存在任何转义。</span><br><span class="line">	比如常见的路径字符串 <span class="string">&quot;C:\\demo\\test.txt&quot;</span>，其中使用<span class="string">&quot;\\&quot;</span>的原因是避免<span class="string">&quot;\&quot;进行转义。</span></span><br><span class="line"><span class="string">	而当使用原始字符串字面量定义时，就可以直接 R&quot;</span>(C:\demo\test.txt)<span class="string">&quot;，因为字符串中不会进行任何转义，所以就不需要使用&quot;</span>\\<span class="string">&quot;了。</span></span><br><span class="line"><span class="string">eg:</span></span><br><span class="line"><span class="string">	样例输入：</span></span><br><span class="line"><span class="string">	cout &lt;&lt; R&quot;</span>(hello world \n)<span class="string">&quot;;</span></span><br><span class="line"><span class="string">	样例输出：</span></span><br><span class="line"><span class="string">	hello world \n</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	另外有些时候，字符串太长或者说需要分段，常规来讲是通过&quot;</span>\n<span class="string">&quot;和&quot;</span>\<span class="string">&quot;来实现的，比如说下面这个例子，通过连接符和回车来实现分段。</span></span><br><span class="line"><span class="string">eg:	</span></span><br><span class="line"><span class="string">	样例输入：</span></span><br><span class="line"><span class="string">	cout &lt;&lt; &quot;</span><span class="number">1</span>\n\</span><br><span class="line">    <span class="number">2</span>\n\</span><br><span class="line">    <span class="number">3</span><span class="string">&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="string">	样例输出：</span></span><br><span class="line"><span class="string">	1</span></span><br><span class="line"><span class="string">    2</span></span><br><span class="line"><span class="string">    3</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    而当使用原始字符串字面量定义时，直接按位置输入即可，字符串中会根据位置自动换行。</span></span><br><span class="line"><span class="string">eg:</span></span><br><span class="line"><span class="string">    样例输入：</span></span><br><span class="line"><span class="string">    cout &lt;&lt; R&quot;</span>(<span class="number">1</span></span><br><span class="line">    <span class="number">2</span></span><br><span class="line">    <span class="number">3</span>)<span class="string">&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="string">    样例输出：</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">    2</span></span><br><span class="line"><span class="string">    3</span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string">	另外，原始字符串字面量的那个&quot;</span>xxx<span class="string">&quot;部分我个人认为与注释相似，没有实际影响，而且得注意前后必须一致。</span></span><br><span class="line"><span class="string">eg:</span></span><br><span class="line"><span class="string">	样例输入：</span></span><br><span class="line"><span class="string">	cout &lt;&lt; R&quot;</span><span class="built_in">hello</span>(hello world \n)hello<span class="string">&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="string">	样例输出：</span></span><br><span class="line"><span class="string">	hello world \n</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>&emsp;</p>
<h1 id="·-用户定义字面量"><a href="#·-用户定义字面量" class="headerlink" title="· 用户定义字面量"></a>· 用户定义字面量</h1><p>&emsp;&emsp;C++11新标准中引入了用户自定义字面量，也叫自定义后缀操作符，即通过实现一个后缀操作符，将申明了该后缀标识的字面量转化为需要的类型。比如如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">double</span> <span class="keyword">operator</span><span class="string">&quot;&quot;</span> _mm(<span class="type">long</span> <span class="type">double</span> x) &#123; <span class="keyword">return</span> x / <span class="number">1000</span>; &#125;</span><br><span class="line"><span class="type">long</span> <span class="type">double</span> <span class="keyword">operator</span><span class="string">&quot;&quot;</span> _m(<span class="type">long</span> <span class="type">double</span> x)  &#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="type">long</span> <span class="type">double</span> <span class="keyword">operator</span><span class="string">&quot;&quot;</span> _km(<span class="type">long</span> <span class="type">double</span> x) &#123; <span class="keyword">return</span> x * <span class="number">1000</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="number">1.0</span>_mm &lt;&lt; endl; <span class="comment">//0.001</span></span><br><span class="line">    cout &lt;&lt; <span class="number">1.0</span>_m  &lt;&lt; endl; <span class="comment">//1</span></span><br><span class="line">    cout &lt;&lt; <span class="number">1.0</span>_km &lt;&lt; endl; <span class="comment">//1000</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果:</span><br><span class="line"><span class="number">0.001</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1000</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我个人而言这块内容是没有使用过，然后去网上找了一下相关的资料，感觉这东西是为了用户自定义类型的字面量解析输出…比如说下面这个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个自定义的rgb类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RGBA</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> r, g, b, a;</span><br><span class="line">	<span class="built_in">RGBA</span>(<span class="type">uint8_t</span> r, <span class="type">uint8_t</span> g, <span class="type">uint8_t</span> b, <span class="type">uint8_t</span> a):<span class="built_in">r</span>(r),<span class="built_in">g</span>(g),<span class="built_in">b</span>(b),<span class="built_in">a</span>(a)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//自定义字面量后缀</span></span><br><span class="line">RGBA <span class="keyword">operator</span><span class="string">&quot;&quot;</span> _RGBA(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* r = <span class="literal">nullptr</span>, *g = <span class="literal">nullptr</span>, *b = <span class="literal">nullptr</span>, *a = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span>* p = str; p != str + size; ++p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (*p == <span class="string">&#x27;r&#x27;</span>) r = p + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (*p == <span class="string">&#x27;g&#x27;</span>) g = p + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (*p == <span class="string">&#x27;b&#x27;</span>) b = p + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (*p == <span class="string">&#x27;a&#x27;</span>) a = p + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (r == <span class="literal">nullptr</span> || g == <span class="literal">nullptr</span> || b == <span class="literal">nullptr</span>) <span class="keyword">throw</span>;</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">RGBA</span>(<span class="built_in">atoi</span>(r),<span class="built_in">atoi</span>(g),<span class="built_in">atoi</span>(b),<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">RGBA</span>(<span class="built_in">atoi</span>(r), <span class="built_in">atoi</span>(g), <span class="built_in">atoi</span>(b),<span class="built_in">atoi</span>(a));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出运算符重载</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,<span class="type">const</span> RGBA&amp; color)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> os&lt;&lt;<span class="string">&quot;r=&quot;</span>&lt;&lt; (<span class="type">int</span>)color.r&lt;&lt;<span class="string">&quot; g=&quot;</span>&lt;&lt; (<span class="type">int</span>)color.g&lt;&lt;<span class="string">&quot; b=&quot;</span>&lt;&lt; (<span class="type">int</span>)color.b&lt;&lt;<span class="string">&quot; a=&quot;</span>&lt;&lt; (<span class="type">int</span>)color.a&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//自定义字面量来表示RGBA对象</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;r255 g255 b255 a40&quot;</span>_RGBA &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果:</span><br><span class="line">r=<span class="number">255</span> g=<span class="number">255</span> b=<span class="number">255</span> a=<span class="number">40</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;值得注意的是，用户定义字面量中，只有下面的7种参数列表才是合法的，而且后面四种会自动计算出字符串的长度，挺好用的。具体可以看下面：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="type">const</span> *</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span></span><br><span class="line"><span class="type">long</span> <span class="type">double</span></span><br><span class="line"><span class="type">char</span> <span class="type">const</span> *, <span class="type">size_t</span></span><br><span class="line"><span class="type">wchar_t</span> <span class="type">const</span> *, <span class="type">size_t</span></span><br><span class="line"><span class="type">char16_t</span> <span class="type">const</span> *, <span class="type">size_t</span></span><br><span class="line"><span class="type">char32_t</span> <span class="type">const</span> *, <span class="type">size_t</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例子</span></span><br><span class="line"><span class="type">size_t</span> <span class="keyword">operator</span><span class="string">&quot;&quot;</span> _len(<span class="type">char</span> <span class="type">const</span> * str, <span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hello&quot;</span>_len &lt;&lt;endl; <span class="comment">//结果为5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;</p>
<h1 id="·-属性"><a href="#·-属性" class="headerlink" title="· 属性"></a>· 属性</h1><p>&emsp;&emsp;C++11中新增了一个概念：属性(attributes)，其功能为<strong>为类型、对象、代码等引入由实现定义的属性</strong>。在C++11中，其语法仅为<code>[[ 属性列表 ]]</code>，标准属性也只有下图的前两个：<br><img src="/images/2021-12-02/6.jpg" alt="7"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[[gnu::always_inline]] [[gnu::hot]] [[gnu::<span class="type">const</span>]] [[nodiscard]]</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>; <span class="comment">// 声明 f 带四个属性</span></span><br><span class="line"> </span><br><span class="line">[[gnu::always_inline, gnu::<span class="type">const</span>, gnu::hot, nodiscard]]</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>; <span class="comment">// 同上，但使用含有四个属性的单个属性说明符</span></span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h1 id="·-lambda-表达式"><a href="#·-lambda-表达式" class="headerlink" title="· lambda 表达式"></a>· lambda 表达式</h1><p>&emsp;&emsp;即匿名函数表达式，其主要语法为：<code>[捕获列表] (参数列表) 函数选项 -&gt; 返回值类型 &#123; 函数体 &#125;;</code>，就是中、小、大三种括号来一遍。</p>
<ul>
<li><p>捕获列表可以指定需要”捕获”哪些变量，以及按什么方式”捕获”。简单来说，就是lambda表达式的函数体是独立的区域，如果想使用外部的变量，就必须先给它”捕获”进来。具体方式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[]			不捕获任何变量</span><br><span class="line">[&amp;]			捕获外部作用域中的所有变量，并作为引用在函数体内使用（按引用捕获）</span><br><span class="line">[=]			捕获外部作用域中的所有变量，并作为副本在函数体内使用（按值捕获）</span><br><span class="line">[=, &amp;foo]	按值捕获外部作用域中所有变量，并按照引用捕获外部变量foo</span><br><span class="line">[bar]		按值捕获bar变量，同时不捕获其他变量</span><br><span class="line">[&amp;bar]		按引用捕获bar变量，同时不捕获其他变量</span><br><span class="line">[<span class="keyword">this</span>]		捕获当前类中的<span class="keyword">this</span>指针</span><br><span class="line">	- 让lambda表达式拥有和当前类成员函数同样的访问权限</span><br><span class="line">	- 如果以及使用了&amp;或=，则默认添加此选项</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> S2 &#123; <span class="type">void</span> <span class="built_in">f</span>(<span class="type">int</span> i); &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">S2::f</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    [&amp;]&#123;&#125;;          <span class="comment">// OK：默认以引用捕获</span></span><br><span class="line">    [&amp;, i]&#123;&#125;;       <span class="comment">// OK：以引用捕获，但 i 以值捕获</span></span><br><span class="line">    [&amp;, &amp;i] &#123;&#125;;     <span class="comment">// 错误：以引用捕获为默认时后续不能以引用捕获</span></span><br><span class="line">    [&amp;, <span class="keyword">this</span>] &#123;&#125;;   <span class="comment">// OK：等价于 [&amp;]</span></span><br><span class="line">    [&amp;, <span class="keyword">this</span>, i]&#123;&#125;; <span class="comment">// OK：等价于 [&amp;, i]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S2</span> &#123; <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i)</span></span>; &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">S2::f</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    [=]&#123;&#125;;          <span class="comment">// OK：默认以复制捕获</span></span><br><span class="line">    [=, &amp;i]&#123;&#125;;      <span class="comment">// OK：以复制捕获，但 i 以引用捕获</span></span><br><span class="line">    [=, *<span class="keyword">this</span>]&#123;&#125;;   <span class="comment">// C++17 前：错误：无效语法</span></span><br><span class="line">                    <span class="comment">// C++17 起：OK：以复制捕获外围的 S2</span></span><br><span class="line">    [=, <span class="keyword">this</span>] &#123;&#125;;   <span class="comment">// C++20 前：错误：= 为默认时的 this</span></span><br><span class="line">                    <span class="comment">// C++20 起：OK：同 [=]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S2</span> &#123; <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i)</span></span>; &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">S2::f</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    [i, i] &#123;&#125;;        <span class="comment">// 错误：i 重复</span></span><br><span class="line">    [<span class="keyword">this</span>, *<span class="keyword">this</span>] &#123;&#125;; <span class="comment">// 错误：&quot;this&quot; 重复 (C++17)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>参数列表和普通函数的相似，就是小括号里写上接收什么类型的参数之类的。当没有传参的时候，可以直接写空括号 <code>()</code>，或者干脆省略括号 <code>auto f = []&#123;return 1;&#125;;</code>，但是不推荐不写因为我感觉会影响可读性。</p>
</li>
<li><p>函数选项主要有两个，<code>mutable</code> 和 <code>exception</code>：前者 <code>mutable</code> 含义为可以修改按值传递进来的拷贝(修改拷贝，不是值本身)；后者 <code>exception</code> 含义为指定函数抛出的异常，如抛出整数类型的异常，可以使用 <code>throw();</code>。这部分内容不需要可以直接省略不写，说实话我也没用过…</p>
</li>
<li><p>返回值类型是典型的”尾随返回类型”，但是一般是不写它的，因为会自动推导返回值类型。不过有一些情况下编译器无法推导返回类型，比如说返回一个初始化列表 <code>return &#123;1, 2&#125;;</code>，此时就必须指定返回值类型了。</p>
</li>
</ul>
<p>&emsp;&emsp;<strong>lambda的本质其实是一个仿函数</strong>，当以值捕获变量时，其默认是 <code>const</code> 的，所以无法更改，而选项 <code>mutable</code> 的功能就是去掉 <code>const</code> 修饰。<strong>而当一个lambda表达式未捕获任何变量时，其还可以转换成一个普通的函数指针。</strong></p>
<p>&emsp;</p>
<h1 id="·-noexcept-说明符与-noexcept-运算符"><a href="#·-noexcept-说明符与-noexcept-运算符" class="headerlink" title="· noexcept 说明符与 noexcept 运算符"></a>· noexcept 说明符与 noexcept 运算符</h1><h2 id="1-noexcept-说明符"><a href="#1-noexcept-说明符" class="headerlink" title="1. noexcept 说明符"></a>1. noexcept 说明符</h2><p>&emsp;&emsp;指定函数是否抛出异常。在函数后添加 <code>noexcept</code> 即可，也可以指定 <code>false</code>，默认即为 <code>noexcept(false)</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>; <span class="comment">// 错误：不同的异常说明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>; <span class="comment">// OK： g 的两个声明均为潜在抛出</span></span><br></pre></td></tr></table></figure>
<h2 id="2-noexcept-运算符"><a href="#2-noexcept-运算符" class="headerlink" title="2. noexcept 运算符"></a>2. noexcept 运算符</h2><p>&emsp;&emsp;<code>noexcept</code> 运算符进行编译时检查，若表达式声明为不抛出任何异常则返回 <code>true</code>。它可用于函数模板的 <code>noexcept</code> 说明符中，以声明函数将对某些类型抛出异常，但不对其他类型抛出。其语法为 <code>noexcept(表达式)</code>。</p>
<p>&emsp;&emsp;<code>noexcept </code> 运算符不对<strong>表达式</strong>求值。若<strong>表达式</strong>的潜在异常集合为空，则结果为 true，否则结果为 false。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">may_throw</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">no_throw</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">auto</span> lmay_throw = []&#123;&#125;;</span><br><span class="line"><span class="keyword">auto</span> lno_throw = []() <span class="keyword">noexcept</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ~<span class="built_in">T</span>()&#123;&#125; <span class="comment">// 析构函数妨碍了移动构造函数</span></span><br><span class="line">         <span class="comment">// 复制构造函数为 noexcept</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">U</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ~<span class="built_in">U</span>()&#123;&#125; <span class="comment">// 析构函数妨碍了移动构造函数</span></span><br><span class="line">         <span class="comment">// 复制构造函数为 noexcept(false)</span></span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">V</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  T t;</span><br><span class="line">  U u;</span><br><span class="line">  V v;</span><br><span class="line"> </span><br><span class="line">  std::cout &lt;&lt; std::boolalpha</span><br><span class="line">           &lt;&lt; <span class="string">&quot;Is may_throw() noexcept? &quot;</span> &lt;&lt; <span class="built_in">noexcept</span>(<span class="built_in">may_throw</span>()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">           &lt;&lt; <span class="string">&quot;Is no_throw() noexcept? &quot;</span> &lt;&lt; <span class="built_in">noexcept</span>(<span class="built_in">no_throw</span>()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">           &lt;&lt; <span class="string">&quot;Is lmay_throw() noexcept? &quot;</span> &lt;&lt; <span class="built_in">noexcept</span>(<span class="built_in">lmay_throw</span>()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">           &lt;&lt; <span class="string">&quot;Is lno_throw() noexcept? &quot;</span> &lt;&lt; <span class="built_in">noexcept</span>(<span class="built_in">lno_throw</span>()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">           &lt;&lt; <span class="string">&quot;Is ~T() noexcept? &quot;</span> &lt;&lt; <span class="built_in">noexcept</span>(std::<span class="built_in">declval</span>&lt;T&gt;().~<span class="built_in">T</span>()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">           <span class="comment">// 注：以下各项测试也要求 ~T() 为 noexcept</span></span><br><span class="line">           <span class="comment">// 因为 noexccept 中的表达式构造并销毁了临时量</span></span><br><span class="line">           &lt;&lt; <span class="string">&quot;Is T(rvalue T) noexcept? &quot;</span> &lt;&lt; <span class="built_in">noexcept</span>(<span class="built_in">T</span>(std::<span class="built_in">declval</span>&lt;T&gt;())) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">           &lt;&lt; <span class="string">&quot;Is T(lvalue T) noexcept? &quot;</span> &lt;&lt; <span class="built_in">noexcept</span>(<span class="built_in">T</span>(t)) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">           &lt;&lt; <span class="string">&quot;Is U(rvalue U) noexcept? &quot;</span> &lt;&lt; <span class="built_in">noexcept</span>(<span class="built_in">U</span>(std::<span class="built_in">declval</span>&lt;U&gt;())) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">           &lt;&lt; <span class="string">&quot;Is U(lvalue U) noexcept? &quot;</span> &lt;&lt; <span class="built_in">noexcept</span>(<span class="built_in">U</span>(u)) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>  </span><br><span class="line">           &lt;&lt; <span class="string">&quot;Is V(rvalue V) noexcept? &quot;</span> &lt;&lt; <span class="built_in">noexcept</span>(<span class="built_in">V</span>(std::<span class="built_in">declval</span>&lt;V&gt;())) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">           &lt;&lt; <span class="string">&quot;Is V(lvalue V) noexcept? &quot;</span> &lt;&lt; <span class="built_in">noexcept</span>(<span class="built_in">V</span>(v)) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"><span class="function">Is <span class="title">may_throw</span><span class="params">()</span> <span class="keyword">noexcept</span>? <span class="literal">false</span></span></span><br><span class="line"><span class="function">Is <span class="title">no_throw</span><span class="params">()</span> <span class="keyword">noexcept</span>? <span class="literal">true</span></span></span><br><span class="line"><span class="function">Is <span class="title">lmay_throw</span><span class="params">()</span> <span class="keyword">noexcept</span>? <span class="literal">false</span></span></span><br><span class="line"><span class="function">Is <span class="title">lno_throw</span><span class="params">()</span> <span class="keyword">noexcept</span>? <span class="literal">true</span></span></span><br><span class="line"><span class="function">Is ~<span class="title">T</span><span class="params">()</span> <span class="keyword">noexcept</span>? <span class="literal">true</span></span></span><br><span class="line"><span class="function">Is <span class="title">T</span><span class="params">(rvalue T)</span> <span class="keyword">noexcept</span>? <span class="literal">true</span></span></span><br><span class="line"><span class="function">Is <span class="title">T</span><span class="params">(lvalue T)</span> <span class="keyword">noexcept</span>? <span class="literal">true</span></span></span><br><span class="line"><span class="function">Is <span class="title">U</span><span class="params">(rvalue U)</span> <span class="keyword">noexcept</span>? <span class="literal">false</span></span></span><br><span class="line"><span class="function">Is <span class="title">U</span><span class="params">(lvalue U)</span> <span class="keyword">noexcept</span>? <span class="literal">false</span></span></span><br><span class="line"><span class="function">Is <span class="title">V</span><span class="params">(rvalue V)</span> <span class="keyword">noexcept</span>? <span class="literal">true</span></span></span><br><span class="line"><span class="function">Is <span class="title">V</span><span class="params">(lvalue V)</span> <span class="keyword">noexcept</span>? <span class="literal">false</span></span></span><br></pre></td></tr></table></figure>

<p>&emsp;</p>
<h1 id="·-alignof-与-alignas"><a href="#·-alignof-与-alignas" class="headerlink" title="· alignof 与 alignas"></a>· alignof 与 alignas</h1><h2 id="1-alignof"><a href="#1-alignof" class="headerlink" title="1. alignof"></a>1. alignof</h2><p>&emsp;&emsp;查询类型的对齐要求。其语法为 <code>alignof(类型标识)	</code>，返回 <code>std::size_t</code> 类型的值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="type">int</span>   i;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="type">char</span>  c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 注：下面的 `alignas(alignof(long double))` 如果需要可以简化为 </span></span><br><span class="line"><span class="comment">// `alignas(long double)`</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="built_in">alignof</span>(<span class="type">long</span> <span class="type">double</span>)) Foo2 &#123;</span><br><span class="line">    <span class="comment">// Foo2 成员的定义...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Empty</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">64</span>) Empty64 &#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;对齐字节数&quot;</span>  <span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;- char             ：&quot;</span> &lt;&lt; <span class="built_in">alignof</span>(<span class="type">char</span>)    &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;- 指针             ：&quot;</span> &lt;&lt; <span class="built_in">alignof</span>(<span class="type">int</span>*)    &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;- Foo 类           ：&quot;</span> &lt;&lt; <span class="built_in">alignof</span>(Foo)     &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;- Foo2 类          ：&quot;</span> &lt;&lt; <span class="built_in">alignof</span>(Foo2)     &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;- 空类             ：&quot;</span> &lt;&lt; <span class="built_in">alignof</span>(Empty)   &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;- alignas(64) Empty：&quot;</span> &lt;&lt; <span class="built_in">alignof</span>(Empty64) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">可能的输出:</span><br><span class="line">对齐字节数</span><br><span class="line">- <span class="type">char</span>             ：<span class="number">1</span></span><br><span class="line">- 指针             ：<span class="number">8</span></span><br><span class="line">- Foo 类           ：<span class="number">4</span></span><br><span class="line">- Foo2 类          ：<span class="number">16</span></span><br><span class="line">- 空类             ：<span class="number">1</span></span><br><span class="line">- <span class="built_in">alignas</span>(<span class="number">64</span>) Empty：<span class="number">64</span></span><br></pre></td></tr></table></figure>

<h2 id="2-alignas"><a href="#2-alignas" class="headerlink" title="2. alignas"></a>2. alignas</h2><p>&emsp;&emsp;指定类型或对象的对齐要求。语法为 (1)<code>alignas(表达式)</code>、(2)<code>alignas(类型标识)</code>、(3)<code>alignas(包 ...)</code>。</p>
<ol>
<li><code>alignas(表达式)</code> 必须是求值为零或合法的对齐或扩展对齐的整型常量表达式。</li>
<li>等价于 <code>alignas(alignof(类型))</code></li>
<li>等价于对同一说明应用多个 <code>alignas</code> 说明符，逐个对应于形参包的各个成员，形参包可以是类型或非类型形参包。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每个 struct_float 类型对象都将被对齐到 alignof(float) 边界</span></span><br><span class="line"><span class="comment">// （通常为 4）：</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="built_in">alignof</span>(<span class="type">float</span>)) struct_float</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义在此</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// sse_t 类型的每个对象将对齐到 32 字节边界</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">32</span>) <span class="type">sse_t</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">float</span> sse_data[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 数组 &quot;cacheline&quot; 将对齐到 64 字节边界</span></span><br><span class="line"><span class="built_in">alignas</span>(<span class="number">64</span>) <span class="type">char</span> cacheline[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">default_aligned</span> &#123; <span class="type">float</span> data[<span class="number">4</span>]; &#125; a, b, c;</span><br><span class="line">    <span class="type">sse_t</span> x, y, z;</span><br><span class="line"> </span><br><span class="line">    std::cout</span><br><span class="line">        &lt;&lt; <span class="string">&quot;alignof(struct_float) = &quot;</span> &lt;&lt; <span class="built_in">alignof</span>(struct_float) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;sizeof(sse_t) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">sse_t</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;alignof(sse_t) = &quot;</span> &lt;&lt; <span class="built_in">alignof</span>(<span class="type">sse_t</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;alignof(cacheline) = &quot;</span> &lt;&lt; <span class="built_in">alignof</span>(<span class="built_in">alignas</span>(<span class="number">64</span>) <span class="type">char</span>[<span class="number">64</span>]) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        &lt;&lt; std::hex &lt;&lt; std::showbase</span><br><span class="line">        &lt;&lt; <span class="string">&quot;&amp;a: &quot;</span> &lt;&lt; &amp;a &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;&amp;b: &quot;</span> &lt;&lt; &amp;b &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;&amp;c: &quot;</span> &lt;&lt; &amp;c &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;&amp;x: &quot;</span> &lt;&lt; &amp;x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;&amp;y: &quot;</span> &lt;&lt; &amp;y &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;&amp;z: &quot;</span> &lt;&lt; &amp;z &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">可能的输出:</span><br><span class="line"><span class="built_in">alignof</span>(struct_float) = <span class="number">4</span></span><br><span class="line"><span class="built_in">sizeof</span>(<span class="type">sse_t</span>) = <span class="number">32</span></span><br><span class="line"><span class="built_in">alignof</span>(<span class="type">sse_t</span>) = <span class="number">32</span></span><br><span class="line"><span class="built_in">alignof</span>(cacheline) = <span class="number">64</span></span><br><span class="line">&amp;a: <span class="number">0x7ffc835270d0</span></span><br><span class="line">&amp;b: <span class="number">0x7ffc835270e0</span></span><br><span class="line">&amp;c: <span class="number">0x7ffc835270f0</span></span><br><span class="line">&amp;x: <span class="number">0x7ffc83527100</span></span><br><span class="line">&amp;y: <span class="number">0x7ffc83527120</span></span><br><span class="line">&amp;z: <span class="number">0x7ffc83527140</span></span><br></pre></td></tr></table></figure>

<p>&emsp;</p>
<h1 id="·-多线程内存模型"><a href="#·-多线程内存模型" class="headerlink" title="· 多线程内存模型"></a>· 多线程内存模型</h1><p>&emsp;&emsp;应该指的是对原子操作那个库的相关支持吧，深入一点说实话我也不太了解。可以参考一下这位大佬的文：<a href="https://www.jianshu.com/p/7d237771dc94">C++11多线程-内存模型</a></p>
<p>&emsp;</p>
<h1 id="·-线程局部存储"><a href="#·-线程局部存储" class="headerlink" title="· 线程局部存储"></a>· 线程局部存储</h1><p>&emsp;&emsp;线程局部存储在其它语言中都是以库的形式提供的(库函数或类)。但在C++11中以关键字的形式，做为一种存储类型出现，由此可见C++11对线程局部存储的重视。C++11中有如下几种存储类型:</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>类型</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>auto</td>
<td>该关键字用于两种情况：<br>1. 声明变量时，根据初始化表达式自动推断变量类型。<br>2. 声明函数作为函数返回值的占位符。</td>
</tr>
<tr>
<td>2</td>
<td>static</td>
<td>static变量只初始化一次，除此之外它还有可见性的属性：<br>1. static修饰函数内的“局部”变量时，表明它不需要在进入或离开函数时创建或销毁。且仅在函数内可见。<br>2. static修饰全局变量时，表明该变量仅在当前(声明它的)文件内可见。<br>3. static修饰类的成员变量时，则该变量被该类的所有实例共享。</td>
</tr>
<tr>
<td>3</td>
<td>register</td>
<td>寄存器变量。该变量存储在CPU寄存器中，而不是RAM(栈或堆)中。<br>该变量的最大尺寸等于寄存器的大小。由于是存储于寄存器中，因此不能对该变量进行取地址操作。</td>
</tr>
<tr>
<td>4</td>
<td>extern</td>
<td>引用一个全局变量。当在一个文件中定义了一个全局变量时，就可以在其它文件中使用extern来声明并引用该变量。</td>
</tr>
<tr>
<td>5</td>
<td>mutable</td>
<td>仅适用于类成员变量。以mutable修饰的成员变量可以在const成员函数中修改。</td>
</tr>
<tr>
<td>6</td>
<td>thread_local</td>
<td>线程周期</td>
</tr>
</tbody></table>
<p><code>thread_local</code> 修饰的变量具有如下特性:</p>
<ul>
<li>变量在线程创建时生成(不同编译器实现略有差异，但在线程内变量第一次使用前必然已构造完毕)。</li>
<li>线程结束时被销毁(析构，利用析构特性，<code>thread_local</code> 变量可以感知线程销毁事件)。</li>
<li>每个线程都拥有其自己的变量副本。</li>
<li><code>thread_local</code> 可以和 <code>static</code> 或 <code>extern</code> 联合使用，这将会影响变量的链接属性。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">thread_local</span> <span class="type">unsigned</span> <span class="type">int</span> rage = <span class="number">1</span>; </span><br><span class="line">std::mutex cout_mutex;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increase_rage</span><span class="params">(<span class="type">const</span> std::string&amp; thread_name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ++rage; <span class="comment">// 在锁外修改 OK；这是线程局部变量</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(cout_mutex)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; thread_name &lt;&lt; <span class="string">&quot; 的愤怒计数：&quot;</span> &lt;&lt; rage &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">a</span><span class="params">(increase_rage, <span class="string">&quot;a&quot;</span>)</span>, <span class="title">b</span><span class="params">(increase_rage, <span class="string">&quot;b&quot;</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(cout_mutex)</span></span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;main 的愤怒计数：&quot;</span> &lt;&lt; rage &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    a.<span class="built_in">join</span>();</span><br><span class="line">    b.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">a 的愤怒计数：<span class="number">2</span></span><br><span class="line">main 的愤怒计数：<span class="number">1</span></span><br><span class="line">b 的愤怒计数：<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>&emsp;</p>
<h1 id="·-GC-接口"><a href="#·-GC-接口" class="headerlink" title="· GC 接口"></a>· GC 接口</h1><p>&emsp;&emsp;C++11中新增了对 <strong>GC(垃圾回收)</strong> 的支持，但是好像在C++23的目标里要进行删除…这部分感觉用的也挺少的，我也没怎么研究，<del>就简单贴个图过了吧。</del><br><img src="/images/2021-12-02/7.jpg" alt="6"></p>
<p>&emsp;</p>
<h1 id="·-范围-for-（基于-Boost-库）"><a href="#·-范围-for-（基于-Boost-库）" class="headerlink" title="· 范围 for （基于 Boost 库）"></a>· 范围 for （基于 Boost 库）</h1><p>&emsp;&emsp;在C++11中新增了一种范围for，这东西用的蛮多的，使用场景基本都是为了遍历各种容器，搭配 <code>auto</code> 使用非常方便。</p>
<p>&emsp;&emsp;<strong>注意：此类范围for循环在遍历过程中只会访问一次容器。</strong> 在第一次也是唯一一次访问中，其会确认边界，随后根据边界进行遍历。因此其不会每次遍历都判定条件，这也可能造成在遍历中增减元素会出现问题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;test&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="comment">//此处i为拷贝，无法修改原值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : test)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此处i为引用，可以修改原值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : test)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; i++ &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;</p>
<h1 id="·-static-assert-（基于-Boost-库）"><a href="#·-static-assert-（基于-Boost-库）" class="headerlink" title="· static_assert （基于 Boost 库）"></a>· static_assert （基于 Boost 库）</h1><p>&emsp;&emsp;其功能为编译时进行断言检查，即静态断言。语法为 <code>static_assert(布尔常量表达式, 字符串字面量)</code>，当布尔<strong>常量</strong>表达式为 <code>false</code> 时，则会出现后面指定的字符串字面量，同时编译失败。</p>
<p>&emsp;&emsp;静态断言的好处就是可以在编译期就更早的发现错误，以及减少运行时开销。我看了一小部分C++标准库源码，发现静态断言出现的频率还挺高的，感觉标准委员会是挺推崇这东西的。<br><img src="/images/2021-12-02/8.jpg" alt="1"><br>&emsp;</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++标准库学习</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++14学习记录：新语言功能特性</title>
    <url>/2021/12/08/20211208_C++14%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E6%96%B0%E8%AF%AD%E8%A8%80%E5%8A%9F%E8%83%BD%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<ul>
<li>本篇笔记汇总了C++14中的主要新语言功能特性，根据个人理解与查阅的资料进行记录。</li>
<li>主要参考地址：<a href="https://zh.cppreference.com/w/cpp/11">cppreference</a></li>
<li>C++14主要是在C++11标准之上的一些补充，所以相对的内容较少一些。</li>
</ul>
<span id="more"></span>

<h1 id="·-变量模板"><a href="#·-变量模板" class="headerlink" title="· 变量模板"></a>· 变量模板</h1><p>&emsp;&emsp;在之前的版本中，模板均为函数模板或者类模板，而从C++14起，变量也可以使用模板了。变量模板的语法为 <code>template &lt; 形参列表 &gt; 变量声明</code>，通常模板的规则都适用于变量模板，比如说特化什么的。下面是几个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">constexpr</span> T pi = <span class="built_in">T</span>(<span class="number">3.1415926535897932385L</span>);<span class="comment">// 变量模板</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">circular_area</span><span class="params">(T r)</span><span class="comment">//函数模板</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pi&lt;T&gt; * r * r; <span class="comment">//pi&lt;T&gt; 是变量模板实例化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> a = <span class="number">3</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">circular_area</span>(a) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">circular_area</span>&lt;<span class="type">double</span>&gt;(<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"><span class="number">28.2743</span></span><br><span class="line"><span class="number">12.5664</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;与其他静态成员一样，静态数据成员模板的需要一个定义。这种定义可以在类定义外提供。处于命名空间作用域的静态数据成员的模板声明也可以是类模板的非模板数据成员的定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">limits</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> T min;<span class="comment">//静态数据成员模板的声明</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> T limits::min = &#123; &#125;;<span class="comment">//静态数据成员模板的定义</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">static</span> T s;<span class="comment">//类模板的非模板静态数据成员的声明</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T X&lt;T&gt;::s = <span class="number">0</span>;<span class="comment">//类模板的非模板静态数据成员的定义</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在C++14引入变量模板前，参数化变量通常实现为类模板的静态数据成员，或返回所需值的 constexpr 函数模板，这点在STL源码里可以经常看见。<strong>但是说实话可能变量模板这个新特性比较新或者说非他不可的场景比较少，暂时我还没有用到过或者说在源码里见到过这个东西。</strong></p>
<p>&emsp;</p>
<h1 id="·-泛型-lambda"><a href="#·-泛型-lambda" class="headerlink" title="· 泛型 lambda"></a>· 泛型 lambda</h1><p>&emsp;&emsp;在C++11中，<code>lambda</code> 表达式的形参需要被声明为具体的类型。而在C++14中其放宽了这一要求，这就使得 <code>lambda</code> 表达式的形参声明中可以使用类型说明符 <code>auto</code>，从而达成<strong>泛型lambda</strong>的目的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> lambda = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">lambda</span>(<span class="number">1.1</span>, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">lambda</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">lambda</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"><span class="number">3.1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">195</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;泛型 <code>lambda</code> 表达式遵循模板参数推导的规则。上面这段代码中的泛型 <code>lambda</code> 表达式的作用与下面的代码相同:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">unnamed_lambda</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">	<span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T x, U y)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x + y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> lambda = <span class="built_in">unnamed_lambda</span>();</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这东西我感觉使用起来还是挺方便的，毕竟某些场景泛型 <code>lambda</code> 会节省很多功夫。不过就我而言需求也没那么强，因为我个人用到 <code>lambda</code> 的场景一般对于 <code>lambda</code> 的传参都已经有明确的定义了，这时就没什么泛型编程的需求。</p>
<p>&emsp;</p>
<h1 id="·-lambda-初始化捕获"><a href="#·-lambda-初始化捕获" class="headerlink" title="· lambda 初始化捕获"></a>· lambda 初始化捕获</h1><p>&emsp;&emsp;C++11的 <code>lambda</code> 表达式通过<strong>值拷贝</strong>和<strong>引用</strong>来捕获在外层作用域声明的变量。这就意味着 <code>lambda</code> 的值成员不可以是 <code>move-only</code> 类型，比如说智能指针 <code>std::unique_ptr</code>，它就是个<strong>仅移动</strong>的类型。而在C++14中，<code>lambda</code> 表达式放开限制，允许对被捕获的成员用任意的表达式初始化。</p>
<p>&emsp;&emsp;这样放开限制的第一个好处就是可以通过 <code>std::move</code> 来初始化捕获一个 <code>move-only</code> 类型的变量，如下例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt;p1 = <span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1. main() p1:&quot;</span> &lt;&lt; *p1 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">auto</span> lambda = [p1 = <span class="built_in">move</span>(p1)]()<span class="comment">//此处的第一个p1声明了新的变量，而第二个p1则表示在lambda之外声明的变量</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;2. lambda() p1:&quot;</span> &lt;&lt; *p1 &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">lambda</span>();</span><br><span class="line">    <span class="keyword">if</span>(!p1)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;3. main() p1 is empty&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"><span class="number">1.</span> <span class="built_in">main</span>() p1:<span class="number">10</span></span><br><span class="line"><span class="number">2.</span> <span class="built_in">lambda</span>() p1:<span class="number">10</span></span><br><span class="line"><span class="number">3.</span> <span class="built_in">main</span>() p1 is empty</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;而第二个好处就是可以任意声明 <code>lambda</code> 的值成员，而不需要外层作用域有一个具有相应名字的变量，如下例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> lambda = [a = <span class="number">12345</span>]()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;lambda() a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">lambda</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"><span class="built_in">lambda</span>() a:<span class="number">12345</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个新特性我觉得挺有用的，让 <code>lambda</code> 更加的灵活和方便，<del>虽然我还没用过</del>。但是有一点需要注意，声明 <code>lambda</code> 的时候会直接执行里面的捕获语句，所以被捕获的 <code>move-only</code> 类型变量会直接失效…比如下面这个，即使不执行 <code>lambda</code> 函数也会失效。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt;p1 = <span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1. main() p1:&quot;</span> &lt;&lt; *p1 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">auto</span> lambda = [p1 = <span class="built_in">move</span>(p1)]()<span class="comment">//此处的第一个p1声明了新的变量，而第二个p1则表示在lambda之外声明的变量</span></span><br><span class="line">    &#123;</span><br><span class="line">    ┊   cout &lt;&lt; <span class="string">&quot;2. lambda() p1:&quot;</span> &lt;&lt; *p1 &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//lambda();</span></span><br><span class="line">    <span class="keyword">if</span>(!p1)</span><br><span class="line">    &#123;</span><br><span class="line">    ┊   cout &lt;&lt; <span class="string">&quot;3. main() p1 is empty&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"><span class="number">1.</span> <span class="built_in">main</span>() p1:<span class="number">10</span></span><br><span class="line"><span class="number">3.</span> <span class="built_in">main</span>() p1 is empty</span><br></pre></td></tr></table></figure>

<p>&emsp;</p>
<h1 id="·-new-delete-消除"><a href="#·-new-delete-消除" class="headerlink" title="· new&#x2F;delete 消除"></a>· new&#x2F;delete 消除</h1><p>&emsp;&emsp;贴一个stackoverflow上的相关回答(渣翻)： <a href="https://stackoverflow.com/questions/30762994/are-new-and-delete-still-useful-in-c14">点我跳转</a></p>
<ul>
<li><p>问：<br>&emsp;&emsp;鉴于 <code>make_unique</code> 和 <code>make_shared</code> 的可用性，以及 <code>unique_ptr</code> 和 <code>shared_ptr</code> 的自动析构函数，在C++14中使用 <code>new</code> 和 <code>delete</code> 的情况是什么(除了支持遗留代码)？</p>
</li>
<li><p>答：<br>&emsp;&emsp;虽然在许多情况下智能指针比原始指针更可取，但 <code>new/delete</code> 在 C++14 中仍然有很多用例。<br>&emsp;&emsp;如果您需要编写任何需要就地构建的内容，例如:<br>&emsp;&emsp;&emsp;1.一个内存池<br>&emsp;&emsp;&emsp;2.一个分配器<br>&emsp;&emsp;&emsp;3.标记变体<br>&emsp;&emsp;&emsp;4.到缓冲区的二进制消息<br>&emsp;&emsp;您将需要使用 <code>new</code> 和 <code>delete</code>。<br>&emsp;&emsp;以及对于一些需要编写的容器，您可能希望使用原始指针进行存储。<br>&emsp;&emsp;即使对于标准的智能指针，如果您想使用自定义删除器，您仍然需要 <code>new</code>，因为 <code>make_unique</code> 和 <code>make_shared</code> 不允许这样做。<br>&emsp;</p>
</li>
</ul>
<h1 id="·-constexpr-函数上放松的限制"><a href="#·-constexpr-函数上放松的限制" class="headerlink" title="· constexpr 函数上放松的限制"></a>· constexpr 函数上放松的限制</h1><p>&emsp;&emsp;C++11引入了声明为 <code>constexpr</code> 的函数的概念。声明为 <code>constexpr</code> 函数的意义是：如果其参数均为合适的编译期常量，则对这个 <code>constexpr</code> 函数的调用就可用于期望常量表达式的场合(如模板的非类型参数，或枚举常量的值)。如果参数的值在运行期才能确定，或者虽然参数的值是编译期常量，但不符合这个函数的要求，则对这个函数调用的求值只能在运行期进行。然而C++11要求 <code>constexpr</code> 函数只含有一个将被返回的表达式(也可以还含有 <code>static_assert</code> 声明等其它语句，但允许的语句类型很少)。</p>
<p>&emsp;&emsp;在C++14中将放松这些限制，但 <code>goto</code> 仍然不允许在 <code>constexpr</code> 函数中出现，其中可以含有以下内容：</p>
<ul>
<li>任何声明，除了：<br>1.<code>static</code> 或 <code>thread_local</code> 变量。<br>2.没有初始化的变量声明。</li>
<li>条件分支语句 <code>if</code> 和 <code>switch</code>。</li>
<li>所有的循环语句，包括基于范围的<code>for</code>循环。</li>
<li>表达式可以改变一个对象的值，只需该对象的生命期在声明为 <code>constexpr</code> 的函数内部开始。包括对有 <code>constexpr</code> 声明的任何非 <code>const</code> 非静态成员函数的调用。</li>
</ul>
<p>&emsp;&emsp;此外，C++11指出，所有被声明为 <code>constexpr</code> 的非静态成员函数也隐含声明为 <code>const</code>(即函数不能修改*this的值)。这点已经被删除，非静态成员函数可以为非 <code>const</code>。</p>
<p>&emsp;&emsp;怎么说呢，这东西在标准库里挺常见的，因为标准库要进行泛型编程，用模板和 <code>constexpr</code> 关键字的频率很高。但是在我个人的编程中，感觉用 <code>constexpr</code> 修饰的函数比较少吧…所以还没咋用过这种复杂点的 <code>constexpr</code> 函数。</p>
<p>&emsp;</p>
<h1 id="·-二进制字面量"><a href="#·-二进制字面量" class="headerlink" title="· 二进制字面量"></a>· 二进制字面量</h1><p>&emsp;&emsp;C++14的数字可以使用二进制形式指定，其格式使用前缀 <code>0b</code> 或 <code>0B</code>，类似之前的十六进制前缀 <code>0x</code>。没啥好说的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0x666</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">0b101</span>;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"><span class="number">1638</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h1 id="·-数位分隔符"><a href="#·-数位分隔符" class="headerlink" title="· 数位分隔符"></a>· 数位分隔符</h1><p>&emsp;&emsp;C++14引入单引号 <code>&#39;</code> 作为数字分位符号，使得数值型的字面量可以具有更好的可读性。</p>
<p>&emsp;&emsp;Ada、D语言、Java、Perl、Ruby等程序设计语言使用下划线 <code>_</code> 作为数字分位符号，C++之所以不和它们保持一致，是因为下划线已被用在用户自定义字面量的语法中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> integer_literal = <span class="number">100&#x27;0000</span>;</span><br><span class="line">    <span class="keyword">auto</span> floating_point_literal = <span class="number">1.797&#x27;693&#x27;134&#x27;862&#x27;315&#x27;7E+308</span>;</span><br><span class="line">    <span class="keyword">auto</span> binary_literal = <span class="number">0b0100&#x27;1100&#x27;0110</span>;</span><br><span class="line">    <span class="keyword">auto</span> silly_example = <span class="number">1&#x27;0&#x27;0&#x27;000&#x27;00</span>;</span><br><span class="line">    cout &lt;&lt; integer_literal &lt;&lt; endl &lt;&lt; floating_point_literal &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; binary_literal &lt;&lt; endl &lt;&lt; silly_example &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"><span class="number">1000000</span></span><br><span class="line"><span class="number">1.79769e+308</span></span><br><span class="line"><span class="number">1222</span></span><br><span class="line"><span class="number">10000000</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这东西我觉得挺有用的，由上面的例子可以看出来这个 <code>&#39;</code> 是随意加的，编译器会忽略它，所以可以按自己的喜好或者约定来添加分隔符。</p>
<p>&emsp;</p>
<h1 id="·-函数的返回类型推导"><a href="#·-函数的返回类型推导" class="headerlink" title="· 函数的返回类型推导"></a>· 函数的返回类型推导</h1><p>&emsp;&emsp;C++11允许 <code>lambda</code> 表达式根据 <code>return</code> 语句的表达式类型推断返回类型。C++14为一般的函数也提供了这个能力，此外C++14还拓展了原有的规则，使得函数体并不是 <code>&#123;return expression;&#125;</code> 形式的函数也可以使用返回类型推导。</p>
<p>&emsp;&emsp;为了启用返回类型推导，函数声明必须将 <code>auto</code> 作为返回类型，但没有C++11的后置返回类型说明符：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">DeduceReturnType</span><span class="params">()</span></span>;   <span class="comment">//返回类型由编译器推断</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果函数实现中含有多个 <code>return</code> 语句，这些表达式必须可以推断为相同的类型。使用返回类型推导的函数可以前向声明，但在定义之前不可以使用。它们的定义在使用它们的翻译单元(translation unit)之中必须是可用的。这样的函数中可以存在递归，但递归调用必须在函数定义中的至少一个 <code>return</code> 语句之后：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Correct</span><span class="params">(<span class="type">int</span> i)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> i;<span class="comment">//返回类型被推断为int</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">Correct</span>(i<span class="number">-1</span>)+i;<span class="comment">//正确，可以调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Wrong</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="keyword">if</span>(i != <span class="number">1</span>)</span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">Wrong</span>(i<span class="number">-1</span>)+i;<span class="comment">//不能调用，之前没有return语句</span></span><br><span class="line">  	<span class="keyword">else</span></span><br><span class="line">    	<span class="keyword">return</span> i;<span class="comment">//返回类型被推断为int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这是我个人认为此次更新最有用的一个内容了，<code>auto</code> 返回值可以节省很多功夫。不过坏处就是不太明了，类型比较复杂的时候可读性比较差，但是我觉得一般的小场景用用还是很舒服的。</p>
<p>&emsp;</p>
<h1 id="·-带默认成员初始化器的聚合类。"><a href="#·-带默认成员初始化器的聚合类。" class="headerlink" title="· 带默认成员初始化器的聚合类。"></a>· 带默认成员初始化器的聚合类。</h1><p>&emsp;&emsp;C++11新增 <code>member initializer</code>，这是一个表达式，被应用到类作用域的成员上，如果构造函数没有初始化这个成员。聚合体的定义被改为明确排除任何含有 <code>member initializer</code> 的类，因此，他们不允许使用聚合初始化。</p>
<p>&emsp;&emsp;C++14将放松这一限制，这种类型也允许聚合初始化。如果花括号初始化列表不提供该参数的值，<code>member initializer</code> 会初始化它。<br>&emsp;</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++标准库学习</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++17学习记录：新语言功能特性</title>
    <url>/2022/01/21/20220121_C++17%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E6%96%B0%E8%AF%AD%E8%A8%80%E5%8A%9F%E8%83%BD%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<ul>
<li>本篇笔记汇总了C++17中的主要新语言功能特性，根据个人理解与查阅的资料进行记录。</li>
<li>主要参考地址：<a href="https://zh.cppreference.com/w/cpp/11">cppreference</a></li>
<li>C++17为继C++11后的第一个大版本更新，东西相较于C++14多了不少，但是基本上都是以往特性的优化与补充，这里简单进行一些主要新特性的记录。</li>
</ul>
<span id="more"></span>

<h1 id="·-折叠表达式"><a href="#·-折叠表达式" class="headerlink" title="· 折叠表达式"></a>· 折叠表达式</h1><p>&emsp;&emsp;在 <strong>C++11</strong> 中，其引入了可变参数模板，但是可变参数模板需要挨个递归处理可变参数。这就导致就算以同一种方式处理可变参数，也需要重复的函数递归，写起来很笨重。</p>
<p>&emsp;&emsp;比如下面这个例子，仅仅只需要累加求和，但是却需要写两个模板函数使得递归可行，从而遍历每一个参数，写起来相对麻烦且臃肿。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T&amp;&amp; num)</span><span class="comment">//基础函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ... Args&gt;</span></span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T&amp;&amp; num, Args&amp;&amp;... a)</span><span class="comment">//递归变参函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num + <span class="built_in">add</span>(forward&lt;Args&gt;(a)...);<span class="comment">//递归调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;折叠表达式是 <strong>C++17</strong> 新引进的语法特性。使用折叠表达式可以简化对 <strong>C++11</strong> 中引入的参数包的处理，从而在某些情况下避免使用递归。</p>
<p>&emsp;&emsp; 折叠表达式共有四种语法形式。分别为一元的左折叠和右折叠，以及二元的左折叠和右折叠。其支持所有二元运算符的简写，这里仅做简单记录，比如说上文中的例子就可以简化为如下写法(二元左折叠)：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ... Args&gt;</span></span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T&amp;&amp; num, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (num + ... + args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* g++ test.cpp -o test -std=c++17 */</span></span><br><span class="line">输出:</span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;总体而言，折叠表达式为变参模板写法提供了更多的可能性，可以在不影响原功能和代码可读性的前提下实现简化。</p>
<p>&emsp;&emsp;</p>
<h1 id="·-类模板实参推导"><a href="#·-类模板实参推导" class="headerlink" title="· 类模板实参推导"></a>· 类模板实参推导</h1><p>&emsp;&emsp;简单来说，就是在实例化类模板时，可以自动推出模板参数而不需指定。具体限制为：<strong>如果构造函数能够推导出所有模板参数，则可以跳过显式定义模板参数。</strong></p>
<p>&emsp;&emsp;下面是几个简单但方便的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; <span class="title">p1</span><span class="params">(<span class="number">2</span>, <span class="number">4.5</span>)</span></span>;		<span class="comment">//ok</span></span><br><span class="line">    <span class="function">std::pair <span class="title">p2</span><span class="params">(<span class="number">2</span>, <span class="number">4.5</span>)</span></span>;					<span class="comment">//-std=c++17 ok</span></span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v1 = &#123;<span class="number">1</span>&#125;;				<span class="comment">//ok</span></span><br><span class="line">    std::vector v2 = &#123;<span class="number">1</span>&#125;;					<span class="comment">//-std=c++17 ok</span></span><br><span class="line"></span><br><span class="line">    std::mutex mx;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(mx)</span></span>;	<span class="comment">//ok</span></span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock2</span><span class="params">(mx)</span></span>;				<span class="comment">//-std=c++17 ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这东西怎么说，我感觉虽然方便但是并不是所有都适合这么搞。因为很容易分不清类型让代码可读性降低，所以我感觉像 <code>pair</code>、<code>tuple</code>、<code>lock_guard</code>这种临时变量用一下还好(因为其中的模板参数往往已经规定，省略一下可读性影响也不大)，如果有作用域比较广的变量最好就不要用了，因为很可能需要费神来思考它的模板参数。</p>
<p>&emsp;&emsp;</p>
<h1 id="·-auto-占位的非类型模板形参"><a href="#·-auto-占位的非类型模板形参" class="headerlink" title="· auto 占位的非类型模板形参"></a>· auto 占位的非类型模板形参</h1><p>&emsp;&emsp;从 <strong>C++17</strong> 开始，可以使用 <code>auto</code> 来声明一个非类型模板参数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">auto</span> N&gt; <span class="keyword">class</span> <span class="title class_">S</span> </span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">S&lt;<span class="number">42</span>&gt; s1; <span class="comment">// OK: type of N in S is int</span></span><br><span class="line">S&lt;<span class="string">&#x27;a&#x27;</span>&gt; s2; <span class="comment">// OK: type of N in S is char</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果非类型模板形参的类型包含占位符类型 <code>auto</code>，被推导类型的占位符 (C++20 起)，或 decltype(auto)，那么它可以被推导。推导会如同在虚设的声明 <code>T x = 模板实参;</code> 中推导变量 x 的类型一样进行，其中 T 是模板形参的声明类型。如果被推导的类型不能用于非类型模板形参，那么程序非良构。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template&lt;auto n&gt;</span><br><span class="line">struct B &#123; /* ... */ &#125;;</span><br><span class="line"> </span><br><span class="line">B&lt;5&gt; b1;   // OK：非类型模板形参的类型是 int</span><br><span class="line">B&lt;&#x27;a&#x27;&gt; b2; // OK：非类型模板形参的类型是 char</span><br><span class="line">B&lt;2.5&gt; b3; // 错误（C++20 前）：非类型模板形参的类型不能是 double</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;对于类型中使用了占位符类型的非类型模板形参包，每个模板实参的类型会独立进行推导，而且不需要互相匹配：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template&lt;auto...&gt;</span><br><span class="line">struct C &#123;&#125;;</span><br><span class="line"> </span><br><span class="line">C&lt;&#x27;C&#x27;, 0, 2L, nullptr&gt; x; // OK</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<h1 id="·-编译期的-constexpr-if-语句"><a href="#·-编译期的-constexpr-if-语句" class="headerlink" title="· 编译期的 constexpr if 语句"></a>· 编译期的 constexpr if 语句</h1><p>&emsp;&emsp;<code>constexpr if</code> 是 <strong>C++17</strong> 中新特性，可以实现在编译期的条件判断。<br>&emsp;&emsp;这个东西主要是为了实现泛型编译期处理中的条件判定，可以实现根据 <code>constexpr if</code> 来编译合适的代码段，从而可以在编译期干一部分模板类型判断相关的事情，提高代码的执行效率。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(T t)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(has_foo_v&lt;T&gt;)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        t.<span class="built_in">foo</span>();</span><br><span class="line">        std::<span class="built_in">puts</span>(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::<span class="built_in">puts</span>(<span class="string">&quot;no&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">等价于:</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>=std::<span class="type">enable_if_t</span>&lt;has_foo_v&lt;T&gt;&gt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">bar</span>(T t) </span><br><span class="line">&#123;</span><br><span class="line">    t.<span class="built_in">foo</span>();</span><br><span class="line">    std::<span class="built_in">puts</span>(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(...)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="built_in">puts</span>(<span class="string">&quot;no&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>&emsp;&emsp;</p>
<h1 id="·-inline-变量"><a href="#·-inline-变量" class="headerlink" title="· inline 变量"></a>· inline 变量</h1><p>&emsp;&emsp;在 <strong>C++17</strong> 后，可以给变量加上 <code>inline</code> 标签从而使其成为内联变量。<strong>其核心目的就是为了可以在头文件中定义一个全局可用的对象。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">inline</span> std::string name = <span class="string">&quot;&quot;</span>; <span class="comment">// OK since C++17</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">inline</span> MyClass myGlobalObj; <span class="comment">// OK even if included/defined by multiple CPP files</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;另外声明为 <code>constexpr</code> 的静态成员变量(但不是命名空间作用域变量)是隐式的内联变量，即以下二者等价。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> n = <span class="number">5</span>; <span class="comment">// C++11/C++14: //声明但未定义</span></span><br><span class="line">                                <span class="comment">// since C++17: 定义</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>想深入了解可以看一下这位大佬的文章: <a href="https://blog.csdn.net/janeqi1987/article/details/100108589">点我跳转</a></p>
<p>&emsp;&emsp;</p>
<h1 id="·-结构化绑定"><a href="#·-结构化绑定" class="headerlink" title="· 结构化绑定"></a>· 结构化绑定</h1><p>&emsp;&emsp;在我的理解中，这个新特性就是可以对含有多个元素的对象进行一个映射，即绑定指定名称到初始化器的子对象或元素。可能有点类似引用，但不同于引用的是，结构化绑定的类型不必为引用类型。</p>
<p>&emsp;&emsp;第一个用法，绑定数组：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">2</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">auto</span> [x,y] = a; <span class="comment">// 创建 e[2]，复制 a 到 e，然后 x 指代 e[0]，y 指代 e[1]</span></span><br><span class="line"><span class="keyword">auto</span>&amp; [xr, yr] = a; <span class="comment">// xr 指代 a[0]，yr 指代 a[1]</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;第二个用法，绑定元组式类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> x&#123;&#125;;</span><br><span class="line"><span class="type">char</span>  y&#123;&#125;;</span><br><span class="line"><span class="type">int</span>   z&#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function">std::tuple&lt;<span class="type">float</span>&amp;,<span class="type">char</span>&amp;&amp;,<span class="type">int</span>&gt; <span class="title">tpl</span><span class="params">(x,std::move(y),z)</span></span>;</span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp; [a,b,c] = tpl;</span><br><span class="line"><span class="comment">// a 指名指代 x 的结构化绑定；decltype(a) 为 float&amp;</span></span><br><span class="line"><span class="comment">// b 指名指代 y 的结构化绑定；decltype(b) 为 char&amp;&amp;</span></span><br><span class="line"><span class="comment">// c 指名指代 tpl 的第 3 元素的结构化绑定；decltype(c) 为 const int</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;第三个用法，绑定到数据成员：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> x1 : <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">double</span> y1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">S <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> [x, y] = <span class="built_in">f</span>(); <span class="comment">// x 是标识 2 位位域的 int 左值</span></span><br><span class="line">                         <span class="comment">// y 是 const volatile double 左值</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我感觉，这个新特性的绑定元组部分还是挺有用的，包括接收返回值和范围for的取值等场景用起来都很方便和优雅。比如说下面这个例子，就可以省去取值的部分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; a&#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [x, y] : a)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<h1 id="·-if-和-switch-语句中的初始化器"><a href="#·-if-和-switch-语句中的初始化器" class="headerlink" title="· if 和 switch 语句中的初始化器"></a>· if 和 switch 语句中的初始化器</h1><p>&emsp;&emsp;简单来说就是在 <code>if</code> 和 <code>switch</code> 语句中也可以初始化变量了，类似于在 <code>for</code> 循环里声明新的变量。但是我感觉在 <code>if/switch</code> 中初始化变量的需求应该是不会太大，产生需求的主要场景应该是为了控制变量的作用域。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="type">int</span> a = <span class="number">0</span>; a == s)		<span class="comment">//A部分</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="type">int</span> b = <span class="number">1</span>; b == s)	<span class="comment">//B部分</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>						<span class="comment">//C部分</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="number">222</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span>(<span class="type">int</span> c = <span class="number">2</span>; c) </span><br><span class="line">	&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        cout &lt;&lt; <span class="number">333</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如上为在 <code>if/switch</code> 语句中初始化变量。其中在 <code>if</code> 语句部分中，变量 <code>a</code> 的作用域为 <strong>A&#x2F;B&#x2F;C</strong>，变量 <code>b</code> 的作用域为 <strong>B&#x2F;C</strong>。而在 <code>switch</code> 语句部分中，变量 <code>c</code> 的作用域为整个 <code>switch</code>。</p>
<p>&emsp;&emsp;总体而言这个新特性通过在代码块中添加大括号也可以等价实现，但是看上去可能没那么优雅，所以还是有其独特的优点的。</p>
<p>&emsp;&emsp;</p>
<h1 id="·-u8-char"><a href="#·-u8-char" class="headerlink" title="· u8-char"></a>· u8-char</h1><p>&emsp;&emsp;就是一个新的字符字面量，UTF-8字符字面量(每个字符大小为1字节)，格式如下，个人感觉没什么好说的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="string">u8&#x27;c字符&#x27;</span></span><br><span class="line"></span><br><span class="line">例:</span><br><span class="line"><span class="type">char</span> c = <span class="string">u8&#x27;a&#x27;</span>; <span class="comment">//sizeof(c) = 1</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">char</span> str[] = <span class="string">u8&quot;123456&quot;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<h1 id="·-命名空间相关"><a href="#·-命名空间相关" class="headerlink" title="· 命名空间相关"></a>· 命名空间相关</h1><p>&emsp;&emsp;<strong>简化嵌套命名空间定义：</strong> <code>namespace A::B::C &#123; ... &#125;</code> 等价于 <code>namespace A &#123; namespace B &#123; namespace C &#123; ... &#125; &#125; &#125;</code>。<br>&emsp;&emsp;<strong>using 声明多个名称：</strong> 拥有多于一个 <code>using</code> 声明符的 <code>using</code> 声明，等价于对应的单个 <code>using</code> 声明符的 <code>using</code> 声明的序列，人话讲就是可以用逗号连接多个 <code>using</code> 声明。cppreference上的例子如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">namespace</span> A &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> X &#123;</span><br><span class="line">    <span class="keyword">using</span> ::f;        <span class="comment">// 全局 f 现在作为 ::X::f 可见</span></span><br><span class="line">    <span class="keyword">using</span> A::g;       <span class="comment">// A::g 现在作为 ::X::g 可见</span></span><br><span class="line">    <span class="keyword">using</span> A::g, ::f; <span class="comment">// (C++17) OK：命名空间作用域允许双重声明</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X::<span class="built_in">f</span>(); <span class="comment">// 调用 ::f</span></span><br><span class="line">    X::<span class="built_in">g</span>(); <span class="comment">// 调用 A::g</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;但是经过我自己的测试，<strong>C++17</strong> 我只发现新增了 <code>using</code> 双重定义相关的内容，其余的使用 <strong>C++11</strong> 标准也可以编译通过。</p>
<p>&emsp;&emsp;</p>
<h1 id="·-将-noexcept-作为类型系统的一部分"><a href="#·-将-noexcept-作为类型系统的一部分" class="headerlink" title="· 将 noexcept 作为类型系统的一部分"></a>· 将 noexcept 作为类型系统的一部分</h1><p>&emsp;&emsp;在c++ 17异常处理规范成为函数类型的一部分。也就是说，下面两个函数现在有两种不同的类型:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void f1();</span><br><span class="line">void f2() noexcept; // different type</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在c++ 17之前，这两个函数都具有相同的类型。<br>&emsp;&emsp;因此，编译器现在将检测如果你使用一个函数抛出异常，而一个函数不抛出任何异常的情况:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void (*fp)() noexcept; // pointer to function that doesn’t throw</span><br><span class="line">fp = f2; // OK</span><br><span class="line">fp = f1; // ERROR since C++17</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;当然，在允许抛出函数的地方使用不抛出的函数仍然是有效的:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void (*fp2)(); // pointer to function that might throw</span><br><span class="line">fp2 = f2; // OK</span><br><span class="line">fp2 = f1; // OK</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;因此，这个新特性不会破坏那些还没有使用noexcept函数指针的程序，但是现在可以确保您不再违反函数指针中的noexcept规范。想深入了解可以看一下这位大佬的文章: <a href="https://blog.csdn.net/janeqi1987/article/details/100184127">点我跳转</a></p>
<p>&emsp;&emsp;</p>
<h1 id="·-新的求值顺序规则"><a href="#·-新的求值顺序规则" class="headerlink" title="· 新的求值顺序规则"></a>· 新的求值顺序规则</h1><p>&emsp;&emsp;具体目的和影响可以看一下 <strong>StackOverflow</strong> 上的这个问题：<a href="https://stackoverflow.com/questions/38501587/what-are-the-evaluation-order-guarantees-introduced-by-c17">点我跳转</a></p>
<ul>
<li>具体新增的顺序规则如下：(摘自cppreference)</li>
</ul>
<ol start="14">
<li>函数调用表达式中，指名函数的表达式按顺序早于每个参数表达式和每个默认实参。</li>
<li>函数调用表达式中，每个形参的初始化的值计算和副作用相对于任何其他形参的初始化的值计算和副作用是顺序不确定的。</li>
<li>用运算符写法进行调用时，每个重载的运算符均遵循其所重载的内建运算符的定序规则。</li>
<li>下标表达式 E1[E2] 中，E1 的每个值计算和副作用均按顺序早于 E2 的每个值计算和副作用。</li>
<li>成员指针表达式 E1.*E2 或 E1-&gt;*E2 中，E1 的每个值计算和副作用都按顺序早于 E2 的每个值计算和副作用（除非 E1 的动态类型不含 E2 所指的成员）。</li>
<li>移位运算符表达式 E1&lt;&lt;E2 和 E1&gt;&gt;E2 中，E1 的每个值计算和副作用都按顺序早于 E2 的每个值计算和副作用。</li>
<li>每个简单赋值表达式 E1&#x3D;E2 和每个复合赋值表达式 E1@&#x3D;E2 中，E2 的每个值计算和副作用均按顺序早于 E1 的每个值计算和副作用。</li>
<li>带括号的初始化器中的逗号分隔的表达式列表中的每个表达式，如同函数调用一般求值（顺序不确定）。</li>
</ol>
<p>&emsp;&emsp;</p>
<h1 id="·-强制的复制消除"><a href="#·-强制的复制消除" class="headerlink" title="· 强制的复制消除"></a>· 强制的复制消除</h1><p>&emsp;&emsp;简单来讲就是在对象的初始化中，当初始化器表达式是一个与变量类型相同的类类型的纯右值（忽略 cv 限定）时，<code>T x = T(T(f())); //仅调用一次 T 的默认构造函数以初始化 x</code>。比如下面这个例子，关掉g++默认的省略优化后，使用不同的标准编译，可以看出以C++17标准编译的话会进行一次复制消除（返回值优化），优化的位置是 <strong>main</strong> 函数里的无名临时量。</p>
<ul>
<li>在对象的初始化中，当源对象是无名临时量且与目标对象具有相同类型（忽略 cv 限定）时。当无名临时量为 return 语句的操作数时，称这种复制消除的变体为 RVO，”返回值优化 (return value optimization)”。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">test</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">test</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;destructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">test</span>(<span class="type">const</span> test&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;copy constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">test <span class="title">Foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   test obj;</span><br><span class="line">   <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test obj = <span class="built_in">Foo</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">编译:</span><br><span class="line">g++ -g -fno-elide-constructors -Wall t.cpp -o t -std=c+<span class="number">+11</span></span><br><span class="line">输出:</span><br><span class="line">constructor</span><br><span class="line">copy constructor</span><br><span class="line">destructor</span><br><span class="line">copy constructor</span><br><span class="line">destructor</span><br><span class="line">destructor</span><br><span class="line"></span><br><span class="line">编译:</span><br><span class="line">g++ -g -fno-elide-constructors -Wall t.cpp -o t -std=c+<span class="number">+17</span></span><br><span class="line">输出:</span><br><span class="line">constructor</span><br><span class="line">copy constructor</span><br><span class="line">destructor</span><br><span class="line">destructor</span><br></pre></td></tr></table></figure>
&emsp;&emsp;想深入了解可以看一下这位大佬的文章: <a href="https://blog.csdn.net/janeqi1987/article/details/100146445">点我跳转</a></li>
</ul>
<p>&emsp;&emsp;</p>
<h1 id="·-lambda-表达式捕获-this"><a href="#·-lambda-表达式捕获-this" class="headerlink" title="· lambda 表达式捕获 *this"></a>· lambda 表达式捕获 *this</h1><p>&emsp;&emsp;lambda中可以捕获 <code>*this</code> 辣，可以通过捕获 <code>*this</code> 来将整个当前对象复制一遍。而之前只能捕获 <code>this</code>，即以引用捕获当前对象。我感觉新增这种捕获方式的一个应用场景就是可以避免悬垂引用问题。<br>&emsp;&emsp;</p>
<h1 id="·-constexpr-的-lambda-表达式"><a href="#·-constexpr-的-lambda-表达式" class="headerlink" title="· constexpr 的 lambda 表达式"></a>· constexpr 的 lambda 表达式</h1><p>&emsp;&emsp;lambda表达式的格式为：<code>[ 捕获 ] ( 形参 ) lambda说明符 约束(可选) &#123; 函数体 &#125;</code>，而在 <strong>C++17</strong> 中其说明符部分新增了一位成员 <code>constexpr</code>。</p>
<ul>
<li>constexpr：显式指定函数调用运算符或运算符模板的任意特化为 <code>constexpr</code> 函数。如果没有此说明符但函数调用运算符或任意给定的运算符模板特化恰好满足针对 <code>constexpr</code> 函数的所有要求，那么它也会是 <code>constexpr</code> 的。</li>
</ul>
<p>&emsp;&emsp;</p>
<h1 id="·-属性命名空间不必重复"><a href="#·-属性命名空间不必重复" class="headerlink" title="· 属性命名空间不必重复"></a>· 属性命名空间不必重复</h1><p>&emsp;&emsp;简单来说就是简化下面这种情况:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">简化前:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    [[rpr::kernel, rpr::<span class="built_in">target</span>(cpu,gpu)]] <span class="comment">// 重复</span></span><br><span class="line">    <span class="built_in">doTask</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">简化后:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    [[<span class="keyword">using</span> rpr: kernel, <span class="built_in">target</span>(cpu,gpu)]]</span><br><span class="line">    <span class="built_in">doTask</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<h1 id="·-新属性-fallthrough-nodiscard-和-maybe-unused"><a href="#·-新属性-fallthrough-nodiscard-和-maybe-unused" class="headerlink" title="· 新属性 [[fallthrough]] [[nodiscard]] 和 [[maybe_unused]]"></a>· 新属性 [[fallthrough]] [[nodiscard]] 和 [[maybe_unused]]</h1><ul>
<li>[[fallthrough]](C++17)：指示从前一 case 标号直落是有意的，而在发生直落时给出警告的编译器不应该为此诊断。</li>
<li>[[nodiscard]](C++17)：鼓励编译器在返回值被舍弃时发布警告。**(印象里这个比较常用)**</li>
<li>[[maybe_unused]](C++17)：压制编译器在未使用实体上的警告，若存在。</li>
</ul>
<p>&emsp;&emsp;</p>
<h1 id="·-has-include"><a href="#·-has-include" class="headerlink" title="· __has_include"></a>· __has_include</h1><p>&emsp;&emsp;即一种新的源文件包含语法，其作用为检查一个头或源文件是否可以被包含。cppreference上的例子如下，我感觉适配不同版本头文件时可能有用吧。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> __has_include(<span class="string">&lt;optional&gt;</span>)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> has_optional 1</span></span><br><span class="line">   <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">using</span> <span class="type">optional_t</span> = std::optional&lt;T&gt;;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __has_include(<span class="string">&lt;experimental/optional&gt;</span>)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">include</span> <span class="string">&lt;experimental/optional&gt;</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> has_optional -1</span></span><br><span class="line">   <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">using</span> <span class="type">optional_t</span> = std::experimental::optional&lt;T&gt;;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> has_optional 0</span></span><br><span class="line"><span class="meta">#  <span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">V</span>&gt; <span class="keyword">class</span> <span class="title class_">optional_t</span> &#123;</span><br><span class="line">    V v_&#123;&#125;; <span class="type">bool</span> has_&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">optional_t</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">optional_t</span>(V&amp;&amp; v) : <span class="built_in">v_</span>(v), has_&#123;<span class="literal">true</span>&#125; &#123;&#125;</span><br><span class="line">    <span class="function">V <span class="title">value_or</span><span class="params">(V&amp;&amp; alt)</span> <span class="type">const</span>&amp; </span>&#123; <span class="keyword">return</span> has_ ? v_ : alt; &#125;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++标准库学习</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++20学习记录：modules 和 ＜=＞</title>
    <url>/2022/01/24/20220124_C++20%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9Amodules%E5%92%8C%3C=%3E/</url>
    <content><![CDATA[<ul>
<li>本篇笔记记录了对于 <strong>C++20</strong> 新特性中<strong>模块</strong>和<strong>三路比较运算符</strong>的一些尝试。</li>
<li>主要参考地址：<a href="https://zh.cppreference.com/w/cpp/20">cppreference</a></li>
</ul>
<span id="more"></span>

<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>&emsp;&emsp;这次抽空对 <strong>C++20</strong> 的新特性进行一点尝试，首先目标定为我比较感兴趣的模块部分和一个新的运算符 <code>&lt;=&gt;</code>。</p>
<p>&emsp;&emsp;我的环境上的 <strong>gcc</strong> 版本为 <code>8.4.1</code>，我查了一下编译器支持，发现这个版本对于 <strong>C++20</strong> 的好多新特性无法完全支持，所以首先是手动编译安装了一下 <code>11.2.0</code> 的 <strong>gcc</strong> (真的慢…编了一个多小时)，所以本文使用的测试编译器为 <code>gcc 11.2.0</code>。<br>&emsp;&emsp;</p>
<h1 id="二、模块"><a href="#二、模块" class="headerlink" title="二、模块"></a>二、模块</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>&emsp;&emsp;模块是 <strong>C++20</strong> 中我个人比较感兴趣的一部分，它的功能为支持代码的模块化，其作用根据设计思路而言主要是<strong>显著地提高与宏地隔离并大大优化编译时间</strong>，而且它也可以使得代码更加”卫生”。</p>
<p>对于C++传统的头文件系统，主要的问题如下：</p>
<ul>
<li>不够卫生：一个头文件中的代码可能会影响同一翻译单元中包含的另一个 <code>#include</code> 中的代码的含义，因此 <code>#include</code> 并非顺序无关。宏是这里的一个主要问题，尽管不是唯一的问题。</li>
<li>分离编译的不一致性：两个翻译单元中同一实体的声明可能不一致，但并非所有此类错误都被编译器或链接器捕获。</li>
<li>编译次数过多：从源代码文本编译接口比较慢。从源代码文本反复地编译同一份接口非常慢。</li>
</ul>
<p>&emsp;&emsp;由此，标准委员会推出了模块这一新特性。这一特性说实话并不算新，现在很火的py和java都是很早就使用上了模块。但是对于C++而言我觉得这一新特性挑战还是很大，因为和以往的风格有很大不同。</p>
<p>对于模块，其关键思想如下：</p>
<ul>
<li><code>export</code> 指令使实体可以被 <code>import</code> 到另一个模块中。</li>
<li><code>import</code> 指令使从另一个模块 <code>export</code> 出来的的实体能够被使用。</li>
<li><code>import</code> 的实体不会被隐式地再 <code>export</code> 出去。</li>
<li><code>import</code> 不会将实体添加到上下文中，它只会使实体能被使用（因此，未使用的 <code>import</code> 基本上是无开销的）。</li>
</ul>
<h2 id="2-代码测试"><a href="#2-代码测试" class="headerlink" title="2. 代码测试"></a>2. 代码测试</h2><p>&emsp;&emsp;由此开始记录我的测试过程。首先创建模块文件 <code>test.cpp</code> 和主文件 <code>main.cpp</code> 如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test.cpp 模块文件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> helloworld;</span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="keyword">auto</span> <span class="title">hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello C++ 20!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.cpp 主文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">import</span> helloworld;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">hello</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以看到在 <code>test.cpp</code> 中<strong>导出</strong>了 <code>helloworld</code> 模块和其中的函数 <code>hello()</code>，并在 <code>main.cpp</code> 中<strong>导入</strong>了 <code>helloworld</code> 模块。随后尝试进行编译，编译和执行过程如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -std=c++20 -fmodules-ts -c test.cpp 	#编译模块</span><br><span class="line">g++ -std=c++20 -fmodules-ts -c main.cpp 	#编译主文件</span><br><span class="line">g++ -std=c++20 test.o main.o -o App 		#编译可执行文件</span><br><span class="line"></span><br><span class="line">需要注意的是:</span><br><span class="line">模块必须优先被编译，否则会报错。</span><br><span class="line">g++ -std=c++20 -fmodules-ts test.cpp main.cpp -o App 	#正确</span><br><span class="line">g++ -std=c++20 -fmodules-ts main.cpp test.cpp -o App 	#错误</span><br><span class="line"></span><br><span class="line">执行:</span><br><span class="line">./App</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">Hello C++ 20!</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;编译完以后，可以看到目录下相比平常的编译，多了一个名叫 <code>gcm.cache</code> 的目录，如下图：<br><img src="/images/2022-01-24/1.jpg" alt="1"><br>&emsp;&emsp;进入其中，发现有一个以模块名命名的 <code>.gcm</code> 格式文件，这个就是编译好的模块文件。<br><img src="/images/2022-01-24/2.jpg" alt="2"><br>&emsp;&emsp;我看 <strong>cppreference</strong> 上说 <strong>C++20</strong> 按理是支持导入以往的标准库的，例如 <code>import &lt;iostream&gt;;</code>，但是经过我的测试，<strong>gcc</strong> 无法实现，查了一下发现 <strong>gcc</strong> 确实是没有完全支持。<br><img src="/images/2022-01-24/3.jpg" alt="3"></p>
<h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>&emsp;&emsp;目前来看可能这个新特性并没有被完全的支持，而且其相较以往的头文件格式改变比较大，受限于老代码和稳定性、支持性之类的考量，可能不会被太快的接受。但是它在编译速度上的优势我觉得还是很有前途的，现阶段主要的问题应该是老代码的模块化重构，比如说<strong>当前无法导入标准库的主要原因就是标准库还没有重构完成</strong>，也许在 <strong>C++23</strong> 会重构完成吧，到时候可能模块化就会用的更加方便、更容易被人接受。<br>&emsp;&emsp;</p>
<h1 id="三、三路比较运算符"><a href="#三、三路比较运算符" class="headerlink" title="三、三路比较运算符"></a>三、三路比较运算符</h1><h2 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>&emsp;&emsp;简单说就是一个新的运算符，功能是比较左右操作数的大小，格式为 <code>左操作数 &lt;=&gt; 右操作数		 </code>。 其逻辑如下：</p>
<ul>
<li>若 <code>左操作数 &lt; 右操作数</code> 则 <code>(a &lt;=&gt; b) &lt; 0</code></li>
<li>若 <code>左操作数 &gt; 右操作数</code> 则 <code>(a &lt;=&gt; b) &gt; 0</code></li>
<li>若 <code>左操作数 和 右操作数</code> 相等&#x2F;等价则 <code>(a &lt;=&gt; b) == 0</code></li>
</ul>
<p>&emsp;&emsp;总体而言使用还是挺简单的，一个运算符就可以进行大小的比较。下面是截的一点描述，简单来讲就是这个运算符的返回值是一个<strong>被封装了很多层的类型的右值</strong>。<br><img src="/images/2022-01-24/4.jpg" alt="4"><br>&emsp;&emsp;简单看一下源码，相关定义位于 <code>/usr/local/include/c++/11.2.0/compare</code>，最底层的枚举值为 <code>小于：-1</code>、<code>等于：0</code>、<code>大于：1</code>。<br><img src="/images/2022-01-24/5.jpg" alt="5"><br>&emsp;&emsp;然后就是各种封装内联对象，可以看到下图的定义和初始化。联系上图可以得知最底层储存类型为 <code>signed char</code>，所以十六进制下的值就是如下图一注释一样，<code>less=0xff...</code>。<br><img src="/images/2022-01-24/6.jpg" alt="6"><img src="/images/2022-01-24/7.jpg" alt="7"></p>
<h2 id="2-代码测试-1"><a href="#2-代码测试-1" class="headerlink" title="2. 代码测试"></a>2. 代码测试</h2><p>&emsp;&emsp;测试代码如下，使用起来也非常简单，没有什么好说的，但是需要注意比较结果是无法直接 <code>cout</code> 的，原因应该是作用域枚举没有重载 <code>&lt;&lt;</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;compare&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> foo = <span class="number">-0.0</span>;</span><br><span class="line">    <span class="type">double</span> bar = <span class="number">0.0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> res = foo &lt;=&gt; bar;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;-0 小于 0&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (res &gt; <span class="number">0</span>)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;-0 大于 0&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// (res == 0)</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;-0 与 0 相等&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">编译:</span><br><span class="line">g++ -std=c+<span class="number">+20</span> main.cpp -o App</span><br><span class="line"></span><br><span class="line">执行:</span><br><span class="line">./App</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"><span class="number">-0</span> 与 <span class="number">0</span> 相等</span><br></pre></td></tr></table></figure>

<h2 id="3-小结-1"><a href="#3-小结-1" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>&emsp;&emsp;这算是一个小更新，但是说实话让 <strong>C++</strong> 有了更多的看起来很秀的操作。在实际判断中这个运算符可以省去一些变量名的重复编写，我觉得可以避免一些低级的失误，比如说写错变量名之类的。总之还是挺有意思的一个小更新。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++标准库学习</tag>
        <tag>源码阅读</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++学习记录：智能指针 std::unique_ptr 源码分析</title>
    <url>/2022/02/25/20220225_C-C++%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88std::unique_ptr%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<ul>
<li>抽空扣一点感兴趣的标准库源码，这里总结一下 <code>std::unique_ptr</code> 相关的分析</li>
<li>本文中 gcc version: <strong>8.4.1 20200928 (Red Hat 8.4.1-1) (GCC)</strong></li>
<li>libstdc++:<code>libstdc++-8.4.1-1.el8.x86_64</code></li>
<li>其中c++库安装路径为 <code>/usr/include/c++/8</code></li>
</ul>
<span id="more"></span>

<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>&emsp;&emsp;在对本篇文章内容的探索之前，我已经是对 <code>std::unique_ptr</code> 有所了解并且尝试实现过，所以本篇分析主要是为了查看标准库里的具体实现和写法，学习一下细节和思路。</p>
<p>&emsp;&emsp;<del>众所周知啊</del> ，<code>std::unique_ptr</code> 的主要思路就是利用局部变量声明在栈上，会自动释放的特性，在构造函数里绑定指针，在析构函数里释放此指针的内容，从而达到<strong>智能指针</strong>的效果(自动释放)。<strong>这种机制被称为RAII机制，相关类被称为RAII类。</strong></p>
<p>&emsp;&emsp;本篇笔记中会记录我在学习标准库代码时的思路和想法，此次我看的重点是自动释放的流程和相关数据结构的实现。<br>&emsp;</p>
<h1 id="二、源码分析"><a href="#二、源码分析" class="headerlink" title="二、源码分析"></a>二、源码分析</h1><h2 id="1-从-class-unique-ptr-入手"><a href="#1-从-class-unique-ptr-入手" class="headerlink" title="1. 从 class unique_ptr 入手"></a>1. 从 class unique_ptr 入手</h2><ul>
<li><code>class unique_ptr</code> 的定义位于 <code>/usr/include/c++/8/bits/unique_ptr.h</code> 中。</li>
</ul>
<p>&emsp;&emsp;首先可以看到，在这个文件中，存在两个 <code>unique_ptr</code> 类的定义，如下两图：</p>
<ul>
<li>定义一：<br><img src="/images/2022-02-25/1.jpg" alt="定义1"></li>
<li>定义二：<br><img src="/images/2022-02-25/2.jpg" alt="定义2"></li>
</ul>
<p>&emsp;&emsp;根据注释以及部分来看代码，一百多行开始的定义一部分是针对 <code>single objects</code> 的，而四百多行开始的定义二部分是针对 <code>array objects</code> 的。简单来讲就是定义一是针对单个指针对象的，而特化版本定义二是针对存有多个指针的数组对象的。</p>
<p>&emsp;&emsp;另外，可以看到模板中有两个参数，<code>_Tp</code> 和 <code>_Dp</code>。根据之前对 <code>std::unique_ptr</code>的使用来看，第一个参数是指针所指向的类型；然后我简单看了一下源码和注释，第二个参数是删除器，即规定指针释放时的操作。</p>
<p>&emsp;&emsp;在定义一中，删除器被默认指定为 <code>default_delete&lt;_Tp&gt;</code>，在下文中会对其进行分析。而定义二中需要传入两个模板参数，指定类型和删除器，我认为原因是指针对象数组与单个指针对象析构时存在差异，所以需要单独定义删除的方法。</p>
<p>&emsp;&emsp;接着就是在智能指针中，肯定是存在一个成员变量来储存指针的，所以我决定先看一下这部分内容标准库里是怎么实现的。如下图，是 <code>std::unique_ptr</code> 的一个构造函数，其中传入 <code>pointer</code> 类型的 <code>__p</code> 并将其赋值到成员变量 <code>_M_t</code> 中。<br><img src="/images/2022-02-25/3.jpg" alt="定义"><br>&emsp;&emsp;首先查看 <code>pointer</code> 的定义，为 <code>using pointer	  = typename __uniq_ptr_impl&lt;_Tp, _Dp&gt;::pointer;</code>。可以看到一个新的类型 <code>__uniq_ptr_impl</code> 出现了。了解了 <code>pointer</code> 的定义后再看一下成员变量 <code>_M_t</code>，定义如下：<br><img src="/images/2022-02-25/4.jpg" alt="定义2"><br>&emsp;&emsp;可以看到其类型也为 <code>__uniq_ptr_impl</code>，且模板传参为指针类型与其删除器。由此可以大概了解流程，即 <code>std::unique_ptr</code> 中存在一个 <code>__uniq_ptr_impl</code> 类型的成员变量，其中储存着传入的指针以及其删除器。在传参指针传入后，会将其赋值至成员变量 <code>_M_t</code> 中，并根据传参内容来决定删除器的内容，也储存至 <code>_M_t</code> 中。而接下来，我对这个储存指针的类型 <code>__uniq_ptr_impl</code> 进行了分析和探索。<br>&emsp;</p>
<h2 id="2-储存类-class-uniq-ptr-impl"><a href="#2-储存类-class-uniq-ptr-impl" class="headerlink" title="2. 储存类 class __uniq_ptr_impl"></a>2. 储存类 class __uniq_ptr_impl</h2><ul>
<li><code>class __uniq_ptr_impl</code> 的定义位于 <code>/usr/include/c++/8/bits/unique_ptr.h</code> 中。</li>
</ul>
<p>&emsp;&emsp;由上文可以得知，在 <code>__uniq_ptr_impl</code> 类中，储存着指针和其删除器。在下文中的分析中，我的重点在于储存这两个东西的实现，以及类中有哪些方法来完善其功能。下图为相关定义的位置：<br><img src="/images/2022-02-25/5.jpg" alt="定义位置"><br>&emsp;&emsp;首先在类 <code>__uniq_ptr_impl</code> 中的最前定义了两个结构体，简单来说其作用就是传入类型 <code>a</code>，使用其内部的 <code>type</code> 即可析取出类型 <code>a</code> 的指针<code>a*</code>。其中用到了 <code>remove_reference</code> 结构体，这个在之前的 <code>std::move</code> 源码分析中有讲解，<strong>它起到去引用的功能</strong>，而在这里使用它即可保证 <code>type</code> <strong>能正确取到不带引用的指针类型</strong>。具体实现如下：<br><img src="/images/2022-02-25/6.jpg" alt="析取器"><br>&emsp;&emsp;然后接下来是对构造函数的声明以及几个定义。首先是删除器的判定类型，可以实现对删除器的正确性的判定。接下来是一个 <code>pointer</code> 类型，就是对上文的 <code>_Ptr</code> 结构体中的 <code>type</code> 类型的使用，来取指针类型。然后是三个构造函数，一个是默认的空参构造，用了 <strong>C++11</strong> 中的default关键字；一个是仅传指针的构造函数，调用 <code>_M_ptr</code> 进行赋值；最后一个是传入指针和删除器的构造函数，赋值至成员变量 <code>_M_t</code> 中，这里用了 <code>std::forward</code> 来<strong>实现完美转发</strong>，也就是说这里的删除器可以是个右值。<br><img src="/images/2022-02-25/7.jpg" alt="定义"><br>&emsp;&emsp;然后是几个取成员变量内容的方法和一个swap函数。一共是4个取成员变量内容的方法，指针和删除器各两个。两个方法中上面一个是取引用，即可以改变内容的；下面一个是const修饰的，是不可改内容的，应该是只用于查看内容。下面那个swap函数里，即为使用 <code>std::swap</code> 交换 <code>__uniq_ptr_impl</code> 类中的内容，<strong>此函数作用于 <code>std::unique_ptr</code> 中的指针所有权转让的情景。</strong><br><img src="/images/2022-02-25/8.jpg" alt="定义"><br>&emsp;&emsp;最后就是 <code>__uniq_ptr_impl</code> 类中的成员变量 <code>_M_t</code>，其使用了 <strong>C++11</strong> 中新增的数据结构 <code>std::tuple</code> 来储存指针和其删除器。所以上文中取其内容是通过 <code>std::get</code> 来取的。<br><img src="/images/2022-02-25/9.jpg" alt="成员变量"></p>
<h2 id="3-默认删除器-struct-default-delete"><a href="#3-默认删除器-struct-default-delete" class="headerlink" title="3. 默认删除器 struct default_delete"></a>3. 默认删除器 struct default_delete</h2><ul>
<li><code>struct default_delete</code> 的定义位于 <code>/usr/include/c++/8/bits/unique_ptr.h</code> 中。</li>
</ul>
<p>&emsp;&emsp;上文中看了储存类的定义，下面来看一下出现率也很高的删除器。标准库中提供了两个最基础的删除器，来当默认删除器。提供的两个删除器分别为<strong>普通对象删除器</strong>和<strong>特化版的数组对象删除器</strong>。当传入参数为一个数组时，就会走下面那个定义。</p>
<ul>
<li>定义一：<br><img src="/images/2022-02-25/10.jpg" alt="定义1"></li>
<li>定义二：<br><img src="/images/2022-02-25/11.jpg" alt="定义2"><br>&emsp;&emsp;下面两个即为这两个删除器定义不同的最关键的地方。可以看到其中都存在 <strong>C++11</strong> 中的新特性静态断言，来进行合法性判定。<strong>而关键语句一个为 <code>delete __ptr</code>(85行)，另一个为 <code>delete[] __ptr</code>(122行)。这即为默认删除器的核心语句，即单个对象通过delete释放，数组对象通过delete[]来释放</strong>。这里的实现是通过重载操作符 <code>()</code> 来实现的，算是一种仿函数的写法。<br><img src="/images/2022-02-25/12.jpg" alt="定义"><br><img src="/images/2022-02-25/13.jpg" alt="在这里插入图片描述"></li>
</ul>
<h2 id="4-回归-class-unique-ptr"><a href="#4-回归-class-unique-ptr" class="headerlink" title="4. 回归 class unique_ptr"></a>4. 回归 class unique_ptr</h2><p>&emsp;&emsp;通过上面对储存类和删除器的实现分析，已经大概了解了 <code>std::unique</code> 中的大部分封装好的内容。接下来就看一下在 <code>class unique_ptr</code> 中都有些什么东西。(此处仅记录重点内容)</p>
<p>&emsp;&emsp;首先是若干种构造函数：</p>
<ol>
<li>空参构造<br><img src="/images/2022-02-25/14.jpg" alt="1"></li>
<li>带参构造一，参数仅有指针<br><img src="/images/2022-02-25/15.jpg" alt="2"></li>
<li>带参构造二，参数为指针和其删除器<br><img src="/images/2022-02-25/16.jpg" alt="3"></li>
<li>带参构造三，传参为指针和删除器，<strong>但是都是右值</strong><br><img src="/images/2022-02-25/17.jpg" alt="4"></li>
<li>带参构造四，传参为一个空指针<br><img src="/images/2022-02-25/18.jpg" alt="5"></li>
<li>带参构造五，<strong>传参为一个 <code>std::unique</code> 对象，这里涉及到引用折叠和完美转发，来实现所有权转移的操作</strong><br><img src="/images/2022-02-25/19.jpg" alt="6"></li>
<li>带参构造六，<strong>传参为一个 <code>std::unique</code> 对象，相比上文那个更加严谨</strong><br><img src="/images/2022-02-25/20.jpg" alt="7"></li>
</ol>
<p>&emsp;&emsp;接下来是析构函数，如下图只有一种实现(单对象和数组对象都是这个)。可以看到逻辑很简单就是<strong>在析构的时候调用仿函数删除器</strong>来进行<code>delete</code>操作。这里的 <code>pointer</code> 是获取空指针用的。<br><img src="/images/2022-02-25/21.jpg" alt="1"><br>&emsp;&emsp;剩下的内容中，大部分都是对操作符 <code>=</code>、<code>*</code>、<code>-&gt;</code>等的重载来方便设定智能指针的内容，以及方便使用其内容。另外还封装了几个函数如下，来获取成员变量 <code>_M_t</code> 中的指针和删除器，上面提到的若干重载也是基于下面这几个函数来实现的。另外还有一些基础的函数，例如清空智能指针用的 <code>release()</code> 或者 <code>reset()</code>，还有交换内容的 <code>swap</code> 函数，这几个就不多说了，因为实现都比较简单。<br><img src="/images/2022-02-25/22.jpg" alt="2"><br>&emsp;&emsp;在定义的最后还有两个被禁止的操作，即对 <code>std::unique_ptr</code> 进行左值赋值操作，从而来保证逻辑的正确执行。<br><img src="/images/2022-02-25/23.jpg" alt="3"><br>&emsp;</p>
<h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>&emsp;&emsp;总而言之，<code>std::unique</code> 的主要思路还是比较简单的。但是在标准库源码中会有很多很细节的操作，所以还是有很大的收获。在源码的最后还有若干对 <code>hash</code> 相关的重载操作，在此文中就不进行记录了。<br>&emsp;&emsp;标准库的代码还是像套娃一样有很多层，前面看着会跳来跳去，但是了解底层以后，上面也就很清晰了。在接下来我应该会去看一下 <code>std::shared_ptr</code> 的实现，相对 <code>std::unique_ptr</code> 其肯定会复杂很多，但是这次搞完以后应该看起来也会轻松一点吧，毕竟思路还是有些相同点的，我的重点应该会放在其内部计数器的实现。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++标准库学习</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习记录：一个小线程池的源码分析</title>
    <url>/2022/03/14/20220314_C++%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%B0%8F%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<ul>
<li>抽空学习一些感兴趣的源码，这次学习一个小而美的C++11线程池源码。</li>
<li>项目地址：<a href="https://github.com/progschj/ThreadPool/">https://github.com/progschj/ThreadPool/</a></li>
</ul>
<span id="more"></span>

<h1 id="一、源码一览"><a href="#一、源码一览" class="headerlink" title="一、源码一览"></a>一、源码一览</h1><p>&emsp;&emsp;核心代码很简单，就是下面这不到一百行。但是其中使用了很多新C++11的新东西，写的非常优雅，有很多可以学习的地方。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> THREAD_POOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_POOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">size_t</span>);</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">auto</span> <span class="title">enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> </span></span><br><span class="line"><span class="function">        -&gt; std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="title">F</span><span class="params">(Args...)</span>&gt;::type&gt;</span>;</span><br><span class="line">    ~<span class="built_in">ThreadPool</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// need to keep track of threads so we can join them</span></span><br><span class="line">    std::vector&lt; std::thread &gt; workers;</span><br><span class="line">    <span class="comment">// the task queue</span></span><br><span class="line">    std::queue&lt; std::function&lt;<span class="type">void</span>()&gt; &gt; tasks;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// synchronization</span></span><br><span class="line">    std::mutex queue_mutex;</span><br><span class="line">    std::condition_variable condition;</span><br><span class="line">    <span class="type">bool</span> stop;       </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// the constructor just launches some amount of workers</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">ThreadPool::ThreadPool</span><span class="params">(<span class="type">size_t</span> threads)</span></span></span><br><span class="line"><span class="function">    :   stop(false)</span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>;i&lt;threads;++i)</span><br><span class="line">        workers.<span class="built_in">emplace_back</span>(</span><br><span class="line">            [<span class="keyword">this</span>]</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(;;)</span><br><span class="line">                &#123;</span><br><span class="line">                    std::function&lt;<span class="built_in">void</span>()&gt; task;</span><br><span class="line"></span><br><span class="line">                    &#123;</span><br><span class="line">                        std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(<span class="keyword">this</span>-&gt;queue_mutex);</span><br><span class="line">                        <span class="keyword">this</span>-&gt;condition.<span class="built_in">wait</span>(lock,</span><br><span class="line">                            [<span class="keyword">this</span>]&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;stop || !<span class="keyword">this</span>-&gt;tasks.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">                        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;stop &amp;&amp; <span class="keyword">this</span>-&gt;tasks.<span class="built_in">empty</span>())</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        task = std::<span class="built_in">move</span>(<span class="keyword">this</span>-&gt;tasks.<span class="built_in">front</span>());</span><br><span class="line">                        <span class="keyword">this</span>-&gt;tasks.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">task</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add new work item to the pool</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ThreadPool::enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> </span></span><br><span class="line"><span class="function">    -&gt; std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="title">F</span><span class="params">(Args...)</span>&gt;::type&gt;</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> return_type = <span class="keyword">typename</span> std::result_of&lt;<span class="built_in">F</span>(Args...)&gt;::type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> task = std::make_shared&lt; std::packaged_task&lt;<span class="built_in">return_type</span>()&gt; &gt;(</span><br><span class="line">            std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...)</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">    std::future&lt;return_type&gt; res = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// don&#x27;t allow enqueueing after stopping the pool</span></span><br><span class="line">        <span class="keyword">if</span>(stop)</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;enqueue on stopped ThreadPool&quot;</span>);</span><br><span class="line"></span><br><span class="line">        tasks.<span class="built_in">emplace</span>([task]()&#123; (*task)(); &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    condition.<span class="built_in">notify_one</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the destructor joins all threads</span></span><br><span class="line"><span class="keyword">inline</span> ThreadPool::~<span class="built_in">ThreadPool</span>()</span><br><span class="line">&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line">        stop = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    condition.<span class="built_in">notify_all</span>();</span><br><span class="line">    <span class="keyword">for</span>(std::thread &amp;worker: workers)</span><br><span class="line">        worker.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;</p>
<h1 id="二、源码分析"><a href="#二、源码分析" class="headerlink" title="二、源码分析"></a>二、源码分析</h1><h2 id="1-构造部分"><a href="#1-构造部分" class="headerlink" title="1. 构造部分"></a>1. 构造部分</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// the constructor just launches some amount of workers</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">ThreadPool::ThreadPool</span><span class="params">(<span class="type">size_t</span> threads)</span></span></span><br><span class="line"><span class="function">    :   stop(false)</span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>;i&lt;threads;++i)</span><br><span class="line">        workers.<span class="built_in">emplace_back</span>(</span><br><span class="line">            [<span class="keyword">this</span>]</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(;;)</span><br><span class="line">                &#123;</span><br><span class="line">                    std::function&lt;<span class="built_in">void</span>()&gt; task;</span><br><span class="line"></span><br><span class="line">                    &#123;</span><br><span class="line">                        std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(<span class="keyword">this</span>-&gt;queue_mutex);</span><br><span class="line">                        <span class="keyword">this</span>-&gt;condition.<span class="built_in">wait</span>(lock,</span><br><span class="line">                            [<span class="keyword">this</span>]&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;stop || !<span class="keyword">this</span>-&gt;tasks.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">                        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;stop &amp;&amp; <span class="keyword">this</span>-&gt;tasks.<span class="built_in">empty</span>())</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        task = std::<span class="built_in">move</span>(<span class="keyword">this</span>-&gt;tasks.<span class="built_in">front</span>());</span><br><span class="line">                        <span class="keyword">this</span>-&gt;tasks.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">task</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如上为线程池的构造函数部分。其中主要是根据构造传参创建对应数量的线程，线程储存在 <code>vector&lt; std::thread &gt;</code> 中，线程通过 <code>emplace_back</code> 加 <code>lambda</code> 函数直接构造进vector里。</p>
<p>&emsp;&emsp;线程的流程总体也比较简单，就是一个死循环加条件变量阻塞，当被唤醒时进行判定，如果要求线程退出则 <code>return</code> 出去，否则去任务队列 <code>queue&lt; std::function&lt;void()&gt; &gt;</code> 里取任务执行。这块内容的线程安全是通过一个 <code>std::unique_lock</code> 来保证的。</p>
<p>&emsp;&emsp;值得一提的是这里的条件变量的 <code>wait()</code> 操作中添加了判定条件，从而避免虚假唤醒情况；并且获取 <code>task</code> 也是通过右值引用来进行的。<br>&emsp;&emsp;</p>
<h2 id="2-析构部分"><a href="#2-析构部分" class="headerlink" title="2. 析构部分"></a>2. 析构部分</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// the destructor joins all threads</span></span><br><span class="line"><span class="keyword">inline</span> ThreadPool::~<span class="built_in">ThreadPool</span>()</span><br><span class="line">&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line">        stop = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    condition.<span class="built_in">notify_all</span>();</span><br><span class="line">    <span class="keyword">for</span>(std::thread &amp;worker: workers)</span><br><span class="line">        worker.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;析构部分总体也比较简单，即通过 <code>notify_all()</code> 唤醒所有条件变量，随后使用 <code>join()</code> 等待所有线程执行完毕，完成线程池的同步退出。</p>
<p>&emsp;&emsp;另外在这个线程池实现中，是通过一个变量 <code>stop</code> 来标记线程池是否退出的，线程安全也是通过一个 <code>std::unique_lock</code> 来保证的。这个锁逻辑意义上是任务队列锁，确保关于任务队列相关内容操作的线程安全。<br>&emsp;&emsp;</p>
<h2 id="3-任务入队部分"><a href="#3-任务入队部分" class="headerlink" title="3. 任务入队部分"></a>3. 任务入队部分</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add new work item to the pool</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ThreadPool::enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> </span></span><br><span class="line"><span class="function">    -&gt; std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="title">F</span><span class="params">(Args...)</span>&gt;::type&gt;</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> return_type = <span class="keyword">typename</span> std::result_of&lt;<span class="built_in">F</span>(Args...)&gt;::type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> task = std::make_shared&lt; std::packaged_task&lt;<span class="built_in">return_type</span>()&gt; &gt;(</span><br><span class="line">            std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...)</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">    std::future&lt;return_type&gt; res = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// don&#x27;t allow enqueueing after stopping the pool</span></span><br><span class="line">        <span class="keyword">if</span>(stop)</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;enqueue on stopped ThreadPool&quot;</span>);</span><br><span class="line"></span><br><span class="line">        tasks.<span class="built_in">emplace</span>([task]()&#123; (*task)(); &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    condition.<span class="built_in">notify_one</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这是我感觉整个线程池中，写的最优雅的部分，其中运用了大量C++11的新东西。首先这个部分完成实现了任务入队操作，并且可以通过 <code>std::future</code> 系列操作来实现异步获取执行结果。</p>
<p>&emsp;&emsp;其中的实现是通过 <code>std::packaged_task + std::bind</code> 封装了可以异步执行的任务函数，函数返回一个 <code>std::future</code> 对象。通过这个对象即可异步获取线程的执行结果。另外这部分也中也使用了智能指针 <code>std::shared_ptr</code>，来保证task对象部分的智能释放。</p>
<p>&emsp;&emsp;此外，其中的任务队列通过 <code>std::unique_lock</code> 来保证线程安全，并且也通过大括号来限定临界区域。在任务加入任务队列中，会通过条件变量来唤醒一个已阻塞的线程，从而继续任务处理流程。</p>
<p>&emsp;&emsp;</p>
<h1 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h1><p>&emsp;&emsp;所以这个线程池的任务处理流程就是：<strong>开辟线程 -&gt; 阻塞线程 -&gt; 任务入队 -&gt; 唤醒线程 -&gt; 执行线程 -&gt; 阻塞线程</strong>.<br>&emsp;&emsp;总体来说思路很简单，关于执行结果的接收直接通过C++11的新库 <code>std::future</code> 来实现了，并且通过 <code>std::unique_lock</code> 和 <code>std::condition_variable</code> 来保证线程安全和线程等待的的最小化消耗。其中很多功能都是直接使用了C++11封装好的库，所以看起来很清晰明了并且写的也很优雅。但是毕竟代码量很少，所以相比很多完善的线程池还有很多优化的空间，不过当一个轻量化的线程池来使用我感觉也是够用了，而且从其中我也学习到了不少C++11的新库用法。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>源码阅读</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习记录：一个协程库的源码分析</title>
    <url>/2022/03/19/20220319_C++%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%8D%8F%E7%A8%8B%E5%BA%93%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<ul>
<li>抽空学习一些感兴趣的源码，这次学习云风大佬的一个协程库源码。</li>
<li>项目地址：<a href="https://github.com/cloudwu/coroutine">https://github.com/cloudwu/coroutine</a></li>
<li>个人fork注释后的项目地址：<a href="https://github.com/zgg2001/coroutine">https://github.com/zgg2001/coroutine</a></li>
</ul>
<span id="more"></span>

<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>&emsp;&emsp;本来是想学习一下鹅厂的 <code>libco</code> 协程库来着，无奈之前没怎么接触过协程的实现，且 <code>libco</code> 源码太厚实了，啃起来太慢，所以打算先学习一个精简点的协程库，由浅入深再去啃 <code>libco</code>。</p>
<p>&emsp;&emsp;本次笔记记录的是云风大佬在2012年实现的一个短小精悍的协程库，代码总共只有200行左右，但却实现了协程的核心功能。个人感觉很适合用来学习协程的实现方法和执行流程，所以 <code>fork</code> 了一下，过了一遍并加了注释。<br>&emsp;&emsp;</p>
<h1 id="二、实现分析"><a href="#二、实现分析" class="headerlink" title="二、实现分析"></a>二、实现分析</h1><h2 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h2><p>&emsp;&emsp;首先是协程结构体，每个结构体实例对应着一条协程。可以看到其中定义了协程对应的回调函数与其传参，还有核心内存<strong>协程上下文ctx</strong>，以及每个协程对应的<strong>栈区内容</strong>等。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">coroutine</span> &#123;</span><br><span class="line">	coroutine_func func;<span class="comment">//协程回调函数</span></span><br><span class="line">	<span class="type">void</span> *ud;<span class="comment">//传参</span></span><br><span class="line">	<span class="type">ucontext_t</span> ctx;<span class="comment">//上下文</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">schedule</span> * sch;<span class="comment">//所属管理者</span></span><br><span class="line">	<span class="type">ptrdiff_t</span> cap;<span class="comment">//已经分配的内存大小</span></span><br><span class="line">	<span class="type">ptrdiff_t</span> size;<span class="comment">//协程运行时栈的保存后大小</span></span><br><span class="line">	<span class="type">int</span> status;<span class="comment">//状态</span></span><br><span class="line">	<span class="type">char</span> *stack;<span class="comment">//栈</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;其次是协程调度器结构体，其中储存了若干协程指针以及当前运行协程id等内容，用于进行协程调度等操作。其中最重要的我觉得是共享栈区<strong>stack</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">schedule</span> &#123;</span><br><span class="line">	<span class="type">char</span> stack[STACK_SIZE];<span class="comment">//栈</span></span><br><span class="line">	<span class="type">ucontext_t</span> main;<span class="comment">//主线程上下文</span></span><br><span class="line">	<span class="type">int</span> nco;<span class="comment">//当前协程数量</span></span><br><span class="line">	<span class="type">int</span> cap;<span class="comment">//协程最大数量</span></span><br><span class="line">	<span class="type">int</span> running;<span class="comment">//当前执行中的协程id</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">coroutine</span> **co;<span class="comment">//协程组</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2-整体思路"><a href="#2-整体思路" class="headerlink" title="2. 整体思路"></a>2. 整体思路</h2><p>&emsp;&emsp;了解了核心数据结构，那么协程的切换是如何实现的呢？我过了一遍源码，大致了解了云风大佬这个协程库的实现原理：</p>
<p>&emsp;&emsp;简单来讲，调度器结构体 <code>schedule</code> 中有一块栈上的内存，声明为 <code>char stack[STACK_SIZE];</code>，当协程在执行时，会将这块内存当作自己的进程栈来使用。</p>
<p>&emsp;&emsp;当协程执行挂起操作时，会通过 <code>memcpy</code> 把执行栈上的内容 <code>copy</code> 至协程自己的缓冲区，进行栈区内容的保存；而当协程进行唤醒操作时，只需要把协程缓冲区中的栈内容 <code>copy</code> 至执行栈上，即可实现栈区内容的恢复。因为所有的协程在执行中都需要使用这块栈内存，所以这种协程实现方法被称为共享栈。</p>
<p>&emsp;&emsp;除了栈区内容的切换外，也需要进行硬件上下文的切换，对此，Linux存在系统调用来进行上下文的切换与保存，其均定义在头文件 <code>ucontext.h</code> 中。此协程库中主要使用的内容有：</p>
<ul>
<li><strong>ucontext_t</strong>：上下文结构体，其中储存了上下文的内容。主要需要关注的有<code>uc_link: 下一个要执行的上下文</code>、<code>uc_stack：此上下文所使用的栈信息</code>，其余还有信号掩码、硬件上下文等内容。</li>
<li><strong>getcontext</strong>：传入一个 <code>ucontext_t</code>，初始化它并获取当前上下文环境存入其中。</li>
<li><strong>makecontext</strong>：传入一个 <code>ucontext_t</code> 和一个函数指针及其参数，作用是指定该上下文的入口函数。即在此上下文被激活后，执行这个被绑定的函数。</li>
<li><strong>swapcontext</strong>：传入两个 <code>ucontext_t</code>，作用为切换上下文环境。具体操作是保存当前上下文环境至第一个 <code>ucontext_t</code>，并激活第二个 <code>ucontext_t</code> 的上下文环境。</li>
</ul>
<p>&emsp;&emsp;所以可以说这个协程库主要就是通过系统调用切换&#x2F;保存上下文，以及保存每个协程的运行栈来实现的。<br>&emsp;&emsp;</p>
<h2 id="3-唤醒-resume"><a href="#3-唤醒-resume" class="headerlink" title="3. 唤醒 resume"></a>3. 唤醒 resume</h2><p>&emsp;&emsp;协程的核心操作<strong>唤醒</strong>的实现如下，其中已经加上了我的注释。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> </span></span><br><span class="line"><span class="function"><span class="title">coroutine_resume</span><span class="params">(<span class="keyword">struct</span> schedule * S, <span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">assert</span>(S-&gt;running == <span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">assert</span>(id &gt;=<span class="number">0</span> &amp;&amp; id &lt; S-&gt;cap);</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">coroutine</span> *C = S-&gt;co[id];<span class="comment">//确定唤醒的协程</span></span><br><span class="line">	<span class="keyword">if</span> (C == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> status = C-&gt;status;</span><br><span class="line">	<span class="keyword">switch</span>(status) &#123;</span><br><span class="line">	<span class="keyword">case</span> COROUTINE_READY:<span class="comment">//全新的协程</span></span><br><span class="line">		<span class="built_in">getcontext</span>(&amp;C-&gt;ctx);<span class="comment">//初始化并获取当前上下文环境：信号掩码/具体硬件上下文</span></span><br><span class="line">		C-&gt;ctx.uc_stack.ss_sp = S-&gt;stack;<span class="comment">//共享栈</span></span><br><span class="line">		C-&gt;ctx.uc_stack.ss_size = STACK_SIZE;<span class="comment">//共享栈大小</span></span><br><span class="line">		C-&gt;ctx.uc_link = &amp;S-&gt;main;<span class="comment">//当前context执行结束之后要执行的下一个context</span></span><br><span class="line">		S-&gt;running = id;<span class="comment">//当前执行协程id</span></span><br><span class="line">		C-&gt;status = COROUTINE_RUNNING;</span><br><span class="line">		<span class="type">uintptr_t</span> ptr = (<span class="type">uintptr_t</span>)S;</span><br><span class="line">		<span class="comment">//makecontext修改上下文结构体，设定栈空间为C-&gt;ctx-&gt;uc_stack，激活后执行mainfunc</span></span><br><span class="line">		<span class="built_in">makecontext</span>(&amp;C-&gt;ctx, (<span class="built_in">void</span> (*)(<span class="type">void</span>)) mainfunc, <span class="number">2</span>, (<span class="type">uint32_t</span>)ptr, (<span class="type">uint32_t</span>)(ptr&gt;&gt;<span class="number">32</span>));</span><br><span class="line">		<span class="built_in">swapcontext</span>(&amp;S-&gt;main, &amp;C-&gt;ctx);<span class="comment">//保存当前上下文至S-&gt;main，并激活C-&gt;ctx上下文</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> COROUTINE_SUSPEND:<span class="comment">//之前已挂起</span></span><br><span class="line">		<span class="built_in">memcpy</span>(S-&gt;stack + STACK_SIZE - C-&gt;size, C-&gt;stack, C-&gt;size);<span class="comment">//把协程栈的内存copy至调度器中</span></span><br><span class="line">		S-&gt;running = id;</span><br><span class="line">		C-&gt;status = COROUTINE_RUNNING;</span><br><span class="line">		<span class="built_in">swapcontext</span>(&amp;S-&gt;main, &amp;C-&gt;ctx);<span class="comment">//保存当前上下文至S-&gt;main，并激活C-&gt;ctx上下文</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">assert</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在新建一条协程后，其状态为 <code>COROUTINE_READY</code>。在上面的源码中，可以看到对于刚创建的协程和被挂起后的协程操作是不一致的。主要原因是因为刚创建的协程并没有初始化上下文，而且也没有指定运行栈为调度器中的共享栈，所以新的协程需要指定上下文相关的内容并绑定入口函数。</p>
<p>&emsp;&emsp;此外，<code>makecontext</code> 中的入口函数传参被拆成两部分来传入，我感觉是因为传参类型为 <code>uint</code> 而在64位环境下指针大小为8B，为了避免这部分的差异，所以把指针分为前32位和后32位来进行传入。而在随后入口函数的定义中对指针进行拼合操作，来获取正确的指针。</p>
<p>&emsp;&emsp;另外值得一提的是在对已挂起协程的恢复时，需要恢复执行栈，所以使用 <code>memcpy</code> 进行内存拷贝。由于栈地址是由高向低发展，所以这里是从后倒着找栈顶 <code>S-&gt;stack + STACK_SIZE - C-&gt;size</code>。</p>
<p>&emsp;&emsp;入口函数 <code>mainfunc</code> 定义如下，主要就是传入协程调度器，从而获取正在执行的协程，从而执行对应的回调函数。并在回调函数执行完毕后删除协程，从而宣布此协程执行完毕。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">mainfunc</span><span class="params">(<span class="type">uint32_t</span> low32, <span class="type">uint32_t</span> hi32)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//上32位和下32位组成一个指针，这里我觉得是为了避免64位与32位系统下long类型大小差异造成的影响</span></span><br><span class="line">	<span class="type">uintptr_t</span> ptr = (<span class="type">uintptr_t</span>)low32 | ((<span class="type">uintptr_t</span>)hi32 &lt;&lt; <span class="number">32</span>);</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">schedule</span> *S = (<span class="keyword">struct</span> schedule *)ptr;</span><br><span class="line">	<span class="type">int</span> id = S-&gt;running;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">coroutine</span> *C = S-&gt;co[id];</span><br><span class="line">	C-&gt;<span class="built_in">func</span>(S,C-&gt;ud);<span class="comment">//执行协程的回调函数</span></span><br><span class="line">	_co_delete(C);<span class="comment">//执行完毕删除协程</span></span><br><span class="line">	S-&gt;co[id] = <span class="literal">NULL</span>;</span><br><span class="line">	--S-&gt;nco;</span><br><span class="line">	S-&gt;running = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;</p>
<h2 id="4-挂起-yield"><a href="#4-挂起-yield" class="headerlink" title="4. 挂起 yield"></a>4. 挂起 yield</h2><p>&emsp;&emsp;协程的核心操作<strong>挂起</strong>的实现如下，其中已经加上了我的注释。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">coroutine_yield</span><span class="params">(<span class="keyword">struct</span> schedule * S)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> id = S-&gt;running;</span><br><span class="line">	<span class="built_in">assert</span>(id &gt;= <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">coroutine</span> * C = S-&gt;co[id];</span><br><span class="line">	<span class="built_in">assert</span>((<span class="type">char</span> *)&amp;C &gt; S-&gt;stack);</span><br><span class="line">	_save_stack(C,S-&gt;stack + STACK_SIZE);<span class="comment">//保存协程栈</span></span><br><span class="line">	C-&gt;status = COROUTINE_SUSPEND;</span><br><span class="line">	S-&gt;running = <span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">swapcontext</span>(&amp;C-&gt;ctx , &amp;S-&gt;main);<span class="comment">//保存当前上下文至C-&gt;ctx，并激活S-&gt;main上下文</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_save_stack(<span class="keyword">struct</span> coroutine *C, <span class="type">char</span> *top) &#123;</span><br><span class="line">	<span class="type">char</span> dummy = <span class="number">0</span>;<span class="comment">//获取当前的栈顶地址</span></span><br><span class="line">	<span class="built_in">assert</span>(top - &amp;dummy &lt;= STACK_SIZE);</span><br><span class="line">	<span class="comment">//此时栈大小就是 top - &amp;dummy</span></span><br><span class="line">	<span class="keyword">if</span> (C-&gt;cap &lt; top - &amp;dummy) &#123;<span class="comment">//协程栈大小不足时，需要重新分配内存，用于保存当前协程栈</span></span><br><span class="line">		<span class="built_in">free</span>(C-&gt;stack);</span><br><span class="line">		C-&gt;cap = top-&amp;dummy;</span><br><span class="line">		C-&gt;stack = <span class="built_in">malloc</span>(C-&gt;cap);</span><br><span class="line">	&#125;</span><br><span class="line">	C-&gt;size = top - &amp;dummy;</span><br><span class="line">	<span class="built_in">memcpy</span>(C-&gt;stack, &amp;dummy, C-&gt;size);<span class="comment">//将栈顶至栈底的内存拷贝至C-&gt;stack保存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;挂起操作相对就比较简单了，主要就是<strong>保存执行栈</strong> + <strong>切换上下文</strong>。其中主要的篇幅是在<strong>保存执行栈</strong>这一环节上，主要的逻辑是协程栈内存不足时释放并申请足够的内存，随后 <code>copy</code> 执行栈。<br>&emsp;&emsp;</p>
<h2 id="5-新建与扩容"><a href="#5-新建与扩容" class="headerlink" title="5. 新建与扩容"></a>5. 新建与扩容</h2><p>&emsp;&emsp;值得一提的是协程调度结构体中是通过一个<strong>协程指针数组</strong>来储存所管理的协程的，所以涉及到扩容问题。此协程库中采用了经典的二倍扩容法，通过 <code>realloc</code> 进行扩容，具体实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> </span></span><br><span class="line"><span class="function"><span class="title">coroutine_new</span><span class="params">(<span class="keyword">struct</span> schedule *S, coroutine_func func, <span class="type">void</span> *ud)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">coroutine</span> *co = _co_new(S, func , ud);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* 此处主要是判定管理者管理数量是否达到最大</span></span><br><span class="line"><span class="comment">	* 当达到最大时，会使用realloc对协程组空间进行扩容，扩容后大小为两倍当前大小（经典的两倍扩容），随后插入在最后端</span></span><br><span class="line"><span class="comment">	* 没达到最大时，则遍历协程组找到空闲位置插入</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">if</span> (S-&gt;nco &gt;= S-&gt;cap) &#123;<span class="comment">//扩容后，将新的协程插入到扩容后的第一个空闲处</span></span><br><span class="line">		<span class="type">int</span> id = S-&gt;cap;</span><br><span class="line">		S-&gt;co = <span class="built_in">realloc</span>(S-&gt;co, S-&gt;cap * <span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="keyword">struct</span> coroutine *));</span><br><span class="line">		<span class="built_in">memset</span>(S-&gt;co + S-&gt;cap , <span class="number">0</span> , <span class="built_in">sizeof</span>(<span class="keyword">struct</span> coroutine *) * S-&gt;cap);</span><br><span class="line">		S-&gt;co[S-&gt;cap] = co;</span><br><span class="line">		S-&gt;cap *= <span class="number">2</span>;</span><br><span class="line">		++S-&gt;nco;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;<span class="comment">//遍历整个协程组找到位置插入新协程</span></span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;S-&gt;cap;i++) &#123;</span><br><span class="line">			<span class="type">int</span> id = (i+S-&gt;nco) % S-&gt;cap;</span><br><span class="line">			<span class="keyword">if</span> (S-&gt;co[id] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">				S-&gt;co[id] = co;</span><br><span class="line">				++S-&gt;nco;</span><br><span class="line">				<span class="keyword">return</span> id;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">assert</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;</p>
<h1 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h1><p>&emsp;&emsp;这个协程库的实现比较简单明了，但是仍有很多学习的地方。通过这个协程库，我也初步了解了协程的实现原理。但是不得不说，虽然源码仅仅200行，但是其中很多思路可能是一时半会想不出来的。这种思路包括数据结构的定义&#x2F;函数的实现，我觉得都需要大量的积累，只能说我还有很多需要学习和接触的。</p>
<p>&emsp;&emsp;在之后对鹅厂 <code>libco</code> 的源码学习中，我应该会着重去了解相比此协程库其多出内容的作用和意义，希望可以让我接触到更多新的东西。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>源码阅读</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习记录：字典(dict)源码分析</title>
    <url>/2022/06/03/20220603_Redis%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E5%AD%97%E5%85%B8(dict)%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<ul>
<li>最近在看《redis设计与实现》这本书，对于其中一些部分内容我还是很感兴趣的，由此抽空会切进去学习一下实现源码，并且在CSDN上记录一下吧。</li>
<li>个人的《redis设计与实现》读书笔记记录：<a href="https://github.com/zgg2001/redis_learning">https://github.com/zgg2001/redis_learning</a></li>
</ul>
<span id="more"></span>

<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>&emsp;&emsp;字典是目前使用率蛮高的一种KV存储数据结构，简单说就是一个<strong>key</strong>对应一个<strong>value</strong>，并且可以确保通过<strong>key</strong>可以快速的获取<strong>value</strong>。<br>&emsp;&emsp;字典的具体实现还是有很大的差异的。在C++中一般字典结构被称为<strong>map</strong>，目前stl常用的字典结构有<code>std::map</code>和<code>std::unordered_map</code>，前者的底层实现是红黑树，后者的底层实现为哈希表，两者都可以实现高效率的查询&#x2F;插入操作。<br>&emsp;&emsp;回归到redis上，redis中字典的出场率很高，毕竟redis本来就是一个KV内存数据库。可以说其底层就是使用字典来实现的，而常规的增删查改也是基于字典来进行的。但是C语言中是没有内置字典数据结构的，所以redis自己构建了字典实现。</p>
<p>&emsp;</p>
<h1 id="二、redis字典的实现思路"><a href="#二、redis字典的实现思路" class="headerlink" title="二、redis字典的实现思路"></a>二、redis字典的实现思路</h1><p>&emsp;&emsp;redis的字典底层实现采用哈希表，总体思路和C++里的<code>std::unordered_map</code>思路差不多，简单来说都是<strong>哈希表+开链法</strong>。但是由于C语言里也没有自己的<code>std::vector</code>，所以redis的字典存储空间也是需要自己通过<code>malloc/free</code>管理。<br>&emsp;&emsp;从具体实现上来看，redis字典主要由三部分组成：字典部分、哈希表部分、哈希表节点部分。从关系上来看，字典部分含有两张哈希表，而哈希表中含有若干哈希表节点。<br>&emsp;&emsp;redis的字典思路其实还算是简单，但是其中很多策略和细节的实现我都蛮感兴趣的，所以还是会细看一下。其中个人比较感兴趣的部分有<strong>开链法的代码部分</strong>以及<strong>渐进式rehash的实现部分</strong>。</p>
<p>&emsp;</p>
<h1 id="三、实现源码分析"><a href="#三、实现源码分析" class="headerlink" title="三、实现源码分析"></a>三、实现源码分析</h1><h2 id="1-哈希表节点数据结构"><a href="#1-哈希表节点数据结构" class="headerlink" title="1. 哈希表节点数据结构"></a>1. 哈希表节点数据结构</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="type">void</span> *key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如上为哈希表节点的数据结构，可以说是字典结构里的最底层数据结构。简而言之一个哈希表节点由常规的<code>key</code>、<code>value</code>以及一个<code>next</code>指针组成，还是比较清晰的。<br>&emsp;&emsp;<code>key</code>的类型为<code>void</code>指针，来实现存各式各样的内容。redis字典的键部分一般都是字符串对象，所以就没有像值部分那样使用联合体来特化内容。<br>&emsp;&emsp;<code>value</code>部分使用一个联合体，其中有<code>void*</code>类型和有&#x2F;无符号64位<code>int</code>类型，另外新版本的redis中好像也添加了高精度浮点数<code>double</code>类型。这里使用联合体主要还是为了节省内存，避免存数值内容时的内存浪费。<br>&emsp;&emsp;<code>next</code>指针部分算是开链法的具体实现，即通过这个指针来把哈希冲突的节点给连接起来，来解决哈希冲突问题。</p>
<h2 id="2-哈希表数据结构"><a href="#2-哈希表数据结构" class="headerlink" title="2. 哈希表数据结构"></a>2. 哈希表数据结构</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">// 总是等于 size - 1</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该哈希表已有节点的数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line"></span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如上为哈希表的数据结构，<code>dictht</code>通过一个<code>dictEntry</code>指针数组来建表。除了基础的表结构，此数据结构中也存放了已使用大小、总大小和大小掩码。<br>&emsp;&emsp;首先是二级指针<code>table</code>，用于指向一个哈希表节点数组，来保存哈希表节点。所以这部分内存实际上是由字典直接进行管理的，不像是STL里使用<code>std::vector</code>当底层。<br>&emsp;&emsp;然后说一下<code>sizemask</code>这个属性，其值总是等于<code>size - 1</code>，其实也就是指针数组的下标范围(0 ~ size - 1)，相关公式为<code>index = hash &amp; sizemask</code>，来<strong>避免索引值超出数组范围</strong>。redis字典的扩容策略要求哈希表大小全部为2的n次方，所以这里进行减一操作就可以获取范围掩码了，还是挺巧妙的。<br>&emsp;&emsp;剩下的两个属性<code>size</code>和<code>used</code>就比较常规了，没什么好说的。</p>
<h2 id="3-字典数据结构"><a href="#3-字典数据结构" class="headerlink" title="3. 字典数据结构"></a>3. 字典数据结构</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="type">void</span> *privdata;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rehash 索引</span></span><br><span class="line">    <span class="comment">// 当 rehash 不在进行时，值为 -1</span></span><br><span class="line">    <span class="type">int</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目前正在运行的安全迭代器的数量</span></span><br><span class="line">    <span class="type">int</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line"></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如上为字典的数据结构。首先看最重要的，属性<code>ht</code>用于存放哈希表，而且可以看到是用大小为2的数组存的，主要就是为了方便进行<strong>渐进式rehash操作</strong>，而下面的<code>rehashidx</code>属性用来配合记录rehash进度，rehash部分下面会进行具体分析。<br>&emsp;&emsp;其次<code>privdata</code>属性是一个<code>void*</code>指针，指向一些特定参数，这些参数用于配合<code>dictType</code>里的回调函数。<br>&emsp;&emsp;接下来来看<code>type</code>属性，其类型为<code>dictType</code>指针。具体来看内容，<code>dictType</code>结构体里存了一组回调函数，其结构体内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算哈希值的函数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制键的函数</span></span><br><span class="line">    <span class="type">void</span> *(*keyDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制值的函数</span></span><br><span class="line">    <span class="type">void</span> *(*valDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *obj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对比键的函数</span></span><br><span class="line">    <span class="type">int</span> (*keyCompare)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key1, <span class="type">const</span> <span class="type">void</span> *key2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁键的函数</span></span><br><span class="line">    <span class="type">void</span> (*keyDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *key);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 销毁值的函数</span></span><br><span class="line">    <span class="type">void</span> (*valDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *obj);</span><br><span class="line"></span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以看到是一组用于操作指定类型键值对的函数，不同的字典配备函数也可能不同，算是为了方便进行泛型编程吧。</p>
<h2 id="4-渐进式rehash部分"><a href="#4-渐进式rehash部分" class="headerlink" title="4. 渐进式rehash部分"></a>4. 渐进式rehash部分</h2><p>&emsp;&emsp;首先讲一下redis字典的rehash策略，redis中为了防止在进行扩展&#x2F;收缩的rehash时，由于数据过多造成服务器停止服务，采用了渐进式rehash思路。即rehash不一次性进行完毕，而是分多次、渐进式的对键值对进行rehash操作。<br>&emsp;&emsp;首先实现渐进式rehash的基础就是得有可记录的、独立的两张新表，对此redis数据结构<code>dict</code>以<code>dictht</code>数组的形式存放哈希表，数组大小为2。日常使用时使用<code>[0]</code>表，在扩展&#x2F;收缩时，为<code>[1]</code>分配新表，并渐进式将<code>[0]</code>表上的键值对rehash分配到<code>[1]</code>表上。当rehash完成时，<code>[1]</code>表拥有所有键值对而<code>[0]</code>表为空，此时释放<code>[0]</code>表，并将<code>[1]</code>表设置<code>[0]</code>表，再将<code>[1]</code>表置空，此时渐进式rehash流程完全完成。<br>&emsp;&emsp;还有一个值得一提的重点就是渐进式rehash的具体过程：redis字典数据结构<code>dict</code>中有一个rehash索引<code>rehashidx</code>，每当对rehash过程中的字典进行增删查改操作时，程序除了进行指定操作外，还会将<code>[0]</code>表在<code>rehashidx</code>索引上的所有键值对rehash到<code>[1]</code>表上，随后索引<code>rehashidx</code>值自增一。当渐进式rehash过程结束后，索引<code>rehashidx</code>置为-1，意为未在rehash过程中。<br>&emsp;&emsp;此外，还需要注意的一个细节是渐进式rehash过程中增删查改的操作。在这个过程中，字典是同时使用<code>[0]</code>和<code>[1]</code>两张表的，所以删、查、改操作会同时在两张表上进行，来保证不会漏数据。例如查找一个键时，会先在<code>[0]</code>表上找，如果没有则会去<code>[1]</code>表上找，找不到再返回。而增操作则会直接将新键值对放在<code>[1]</code>表上，<code>[0]</code>表不进行任何添加操作，这主要是为了保证<code>[0]</code>表数据只减不增，并随着rehash操作最终变成空表。<br>&emsp;&emsp;然后来看一下具体的实现源码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dictRehash</span><span class="params">(dict *d, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只可以在 rehash 进行中时执行</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">dictIsRehashing</span>(d)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行 N 步迁移</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Check if we already rehashed the whole table... */</span></span><br><span class="line">        <span class="comment">// 如果 0 号哈希表为空，那么表示 rehash 执行完毕</span></span><br><span class="line">        <span class="comment">// T = O(1)</span></span><br><span class="line">        <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 释放 0 号哈希表</span></span><br><span class="line">            <span class="built_in">zfree</span>(d-&gt;ht[<span class="number">0</span>].table);</span><br><span class="line">            <span class="comment">// 将原来的 1 号哈希表设置为新的 0 号哈希表</span></span><br><span class="line">            d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 重置旧的 1 号哈希表</span></span><br><span class="line">            _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// 关闭 rehash 标识</span></span><br><span class="line">            d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">            <span class="comment">// 返回 0 ，向调用者表示 rehash 已经完成</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Note that rehashidx can&#x27;t overflow as we are sure there are more</span></span><br><span class="line"><span class="comment">         * elements because ht[0].used != 0 */</span></span><br><span class="line">        <span class="comment">// 确保 rehashidx 没有越界</span></span><br><span class="line">        <span class="built_in">assert</span>(d-&gt;ht[<span class="number">0</span>].size &gt; (<span class="type">unsigned</span>)d-&gt;rehashidx);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 略过数组中为空的索引，找到下一个非空索引</span></span><br><span class="line">        <span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) d-&gt;rehashidx++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指向该索引的链表表头节点</span></span><br><span class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</span><br><span class="line">        <span class="comment">/* Move all the keys in this bucket from the old to the new hash HT */</span></span><br><span class="line">        <span class="comment">// 将链表中的所有节点迁移到新哈希表</span></span><br><span class="line">        <span class="comment">// T = O(1)</span></span><br><span class="line">        <span class="keyword">while</span>(de) &#123;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> h;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 保存下个节点的指针</span></span><br><span class="line">            nextde = de-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Get the index in the new hash table */</span></span><br><span class="line">            <span class="comment">// 计算新哈希表的哈希值，以及节点插入的索引位置</span></span><br><span class="line">            h = <span class="built_in">dictHashKey</span>(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 插入节点到新哈希表</span></span><br><span class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新计数器</span></span><br><span class="line">            d-&gt;ht[<span class="number">0</span>].used--;</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].used++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 继续处理下个节点</span></span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将刚迁移完的哈希表索引的指针设为空</span></span><br><span class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 更新 rehash 索引</span></span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以看到在渐进式rehash的过程里，碰到空索引会跳过并且会自动找下一个非空索引，直至完成指定步数或者<code>[0]</code>表为空。当<code>[0]</code>表为空时，进行释放、交换、重置三连，并标记渐进式rehash结束。<br>&emsp;&emsp;渐进式rehash的每一步都会把一个索引处内的一条链表rehash至<code>[1]</code>表上，其中涉及到索引更新、计数器更新和置空等操作。</p>
<p><strong>最后看一下各种情况下进行rehash的源码部分：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> _dictRehashStep(dict *d) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d-&gt;iterators == <span class="number">0</span>) dictRehash(d,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;首先是封装好的进行单次rehash操作的函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dictEntry *<span class="title function_">dictAddRaw</span><span class="params">(dict *d, <span class="type">void</span> *key)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 如果条件允许的话，进行单步 rehash</span></span><br><span class="line">    <span class="comment">// T = O(1)</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;尝试插入键会触发单步rehash。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">dictGenericDelete</span><span class="params">(dict *d, <span class="type">const</span> <span class="type">void</span> *key, <span class="type">int</span> nofree)</span></span><br><span class="line">&#123;</span><br><span class="line">   	...</span><br><span class="line">    <span class="comment">// 进行单步 rehash ，T = O(1)</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;查找删除节点会触发单步rehash。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dictEntry *<span class="title function_">dictFind</span><span class="params">(dict *d, <span class="type">const</span> <span class="type">void</span> *key)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="comment">// 如果条件允许的话，进行单步 rehash</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line">    ...	</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;只进行节点查找也会触发单步rehash。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dictEntry *<span class="title function_">dictGetRandomKey</span><span class="params">(dict *d)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="comment">// 进行单步 rehash</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;随机返回任一节点也会触发单步rehash。</p>
<h2 id="5-扩容部分"><a href="#5-扩容部分" class="headerlink" title="5. 扩容部分"></a>5. 扩容部分</h2><p>&emsp;&emsp;首先来讲一下redis字典的空间分配策略，总结哈希表空间变化规律如下：</p>
<ul>
<li>当执行扩展操作时：新的大小为第一个大于等于<strong>当前已使用大小二倍</strong>的2的n次方。例如当前已使用大小为4，执行扩容操作，扩容后哈希表总大小为8(8 &gt;&#x3D; 4 * 2)。</li>
<li>当执行收缩操作时：新的大小为第一个大于等于<strong>当前已使用大小</strong>的2的n次方。例如当前已使用大小为3，执行收缩操作，收缩后哈希表总大小为4(4 &gt;&#x3D; 3)。</li>
</ul>
<p>&emsp;&emsp;哈希表扩展和收缩的情况如下：(负载因子：已使用&#x2F;总量)</p>
<ul>
<li>当负载因子<strong>小于</strong>0.1时，进行收缩操作。</li>
<li>当未执行BGSAVE&#x2F;BGREWRITEAOF命令时，负载因子<strong>大于等于</strong>1时，进行扩展操作。</li>
<li>当在执行BGSAVE&#x2F;BGREWRITEAOF命令时，负载因子<strong>大于等于</strong>5时，进行扩展操作。</li>
</ul>
<p>&emsp;&emsp;当执行BGSAVE&#x2F;BGREWRITEAOF时提高扩展所需负载因子，主要是因为执行这两个命令时都需要redis创建子进程，而此时进行rehash操作可能会触发子进程的”写时复制”机制。所以此时减少rehash操作即可避免不必要的内存写入操作，最大限度的节约内存。<br>&emsp;&emsp;然后来看一下具体的实现源码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dictExpand</span><span class="params">(dict *d, <span class="type">unsigned</span> <span class="type">long</span> size)</span>:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    // 新哈希表</span></span><br><span class="line"><span class="function">    dictht n;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据 size 参数，计算哈希表的大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> realsize = _dictNextPower(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* the size is invalid if it is smaller than the number of</span></span><br><span class="line"><span class="comment">     * elements already inside the hash table */</span></span><br><span class="line">    <span class="comment">// 不能在字典正在 rehash 时进行</span></span><br><span class="line">    <span class="comment">// size 的值也不能小于 0 号哈希表的当前已使用节点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dictIsRehashing</span>(d) || d-&gt;ht[<span class="number">0</span>].used &gt; size)</span><br><span class="line">        <span class="keyword">return</span> DICT_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate the new hash table and initialize all pointers to NULL */</span></span><br><span class="line">    <span class="comment">// 为哈希表分配空间，并将所有指针指向 NULL</span></span><br><span class="line">    n.size = realsize;</span><br><span class="line">    n.sizemask = realsize<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    n.table = <span class="built_in">zcalloc</span>(realsize*<span class="built_in">sizeof</span>(dictEntry*));</span><br><span class="line">    n.used = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以看到这部分在获取下一个大小后进行了内存申请，申请了<code>realsize</code>个<code>dictEntry</code>指针大小的内存。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果 0 号哈希表为空，那么这是一次初始化：</span></span><br><span class="line"><span class="comment">// 程序将新哈希表赋给 0 号哈希表的指针，然后字典就可以开始处理键值对了。</span></span><br><span class="line"><span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].table == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    d-&gt;ht[<span class="number">0</span>] = n;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 0 号哈希表非空，那么这是一次 rehash ：</span></span><br><span class="line"><span class="comment">// 程序将新哈希表设置为 1 号哈希表，</span></span><br><span class="line"><span class="comment">// 并将字典的 rehash 标识打开，让程序可以开始对字典进行 rehash</span></span><br><span class="line">d-&gt;ht[<span class="number">1</span>] = n;</span><br><span class="line">d-&gt;rehashidx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> DICT_OK;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这部分主要是为了进入rehash状态，当然如果是初始化就不用进rehash状态。</p>
<h2 id="6-开链法解决哈希冲突部分"><a href="#6-开链法解决哈希冲突部分" class="headerlink" title="6. 开链法解决哈希冲突部分"></a>6. 开链法解决哈希冲突部分</h2><p>&emsp;&emsp;最后我决定看一下开链法的具体实现，毕竟这么有名的思路，看一下redis源码里是怎么写的。首先看一下新增节点的源码部分：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dictEntry *<span class="title function_">dictAddRaw</span><span class="params">(dict *d, <span class="type">void</span> *key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    dictEntry *entry;</span><br><span class="line">    dictht *ht;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果条件允许的话，进行单步 rehash</span></span><br><span class="line">    <span class="comment">// T = O(1)</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get the index of the new element, or -1 if</span></span><br><span class="line"><span class="comment">     * the element already exists. */</span></span><br><span class="line">    <span class="comment">// 计算键在哈希表中的索引值</span></span><br><span class="line">    <span class="comment">// 如果值为 -1 ，那么表示键已经存在</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    <span class="keyword">if</span> ((index = _dictKeyIndex(d, key)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// T = O(1)</span></span><br><span class="line">    <span class="comment">/* Allocate the memory and store the new entry */</span></span><br><span class="line">    <span class="comment">// 如果字典正在 rehash ，那么将新键添加到 1 号哈希表</span></span><br><span class="line">    <span class="comment">// 否则，将新键添加到 0 号哈希表</span></span><br><span class="line">    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[<span class="number">1</span>] : &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 为新节点分配空间</span></span><br><span class="line">    entry = zmalloc(<span class="keyword">sizeof</span>(*entry));</span><br><span class="line">    <span class="comment">// 将新节点插入到链表表头</span></span><br><span class="line">    entry-&gt;next = ht-&gt;table[index];</span><br><span class="line">    ht-&gt;table[index] = entry;</span><br><span class="line">    <span class="comment">// 更新哈希表已使用节点数量</span></span><br><span class="line">    ht-&gt;used++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the hash entry fields. */</span></span><br><span class="line">    <span class="comment">// 设置新节点的键</span></span><br><span class="line">    <span class="comment">// T = O(1)</span></span><br><span class="line">    dictSetKey(d, entry, key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;太长不看，截取出关键部分：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//hash取下标</span></span><br><span class="line">index = _dictKeyIndex(d, key);</span><br><span class="line"><span class="comment">// 将新节点插入到链表表头</span></span><br><span class="line">entry = zmalloc(<span class="keyword">sizeof</span>(*entry));<span class="comment">//申请新结点内存</span></span><br><span class="line">entry-&gt;next = ht-&gt;table[index];<span class="comment">//执行头插操作</span></span><br><span class="line">ht-&gt;table[index] = entry;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;所以实际上redis的开链法实现就是配合着数据结构里的<code>next</code>指针，简单的把每个新节点<strong>头插</strong>在对应下标的链表上，非常的简单，也就几行代码，完全没有进行任何哈希冲突方面的判定。</p>
<p>&emsp;</p>
<h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>&emsp;&emsp;redis的字典设计的还是非常巧妙的，尤其是其中的渐进式rehash实现。通过这次看具体代码我也是学到了很多新思路，尤其是看源码前完全没想到开链法实现竟然这么简单。<br>&emsp;&emsp;就个人的感觉来看，redis的代码写的还是蛮清晰简便的，不像C++标准库套来套去非常的恶心。我感觉可能主要是因为C语言比较灵活，没有搞C++强类型那一套，所以通过<code>void*</code>就可以非常简便的实现泛型编程。其次可能就是redis的代码风格比较精简，确实读起来蛮舒服的（<strong>当然也是huangz大佬的书写的好</strong>）。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>校招面试记录：绿盟研发一二三面+意向</title>
    <url>/2022/09/16/20220916_%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95%EF%BC%9A%E7%BB%BF%E7%9B%9F%E7%A0%94%E5%8F%91%E4%B8%80%E4%BA%8C%E4%B8%89%E9%9D%A2+%E6%84%8F%E5%90%91/</url>
    <content><![CDATA[<ul>
<li>本人去年7-10月在成都绿盟进行了三个月的实习，算是第一次进入企业工作，学到了很多东西而且也认识了很多新朋友&#x2F;新老师，所以对绿盟还是很有好感的。</li>
<li>由此在我8月初开始秋招投递时首先便投递了绿盟，base选择了武汉，因为离家近而且去年有认识朋友在武汉绿盟。下面简单记录一下面经，也算是攒攒人品。</li>
</ul>
<span id="more"></span>

<h1 id="一、8-26一面"><a href="#一、8-26一面" class="headerlink" title="一、8.26一面"></a>一、8.26一面</h1><ul>
<li>8月23提醒约面，约了8月26。</li>
</ul>
<p><strong>面：简单自我介绍一下吧。</strong><br>我：balabala。<br><strong>面：去年在绿盟实习感觉咋样？</strong><br>我：balabala。<br><strong>面：去年你在某某组干了哪些内容，现在在某某厂实习干了哪些内容？简单讲一下。</strong><br>我：balabala。<br><strong>面：简单介绍下项目。</strong><br>我：balabala。<br><strong>面：问C语言项目中的命令补全怎么做的？</strong><br>我：将命令特化为令牌结构，然后匹配balabala。<br><strong>面：C&#x2F;C++项目都是自己写的吗？</strong><br>我：是的，balabala。<br><strong>面：select&#x2F;epoll区别？</strong><br>我：balabala（讲了自己的学习路径、使用场景以及底层实现，并且根据自己使用经验分析了优劣）。<br><strong>面：redis基础数据结构？</strong><br>我：balabala（这我熟，源码都看过）大概讲了基础五种数据结构，以及redis中的数据结构实现，字典、sds、跳表、压缩列表啥的。<br><strong>面：跳表怎么理解，复杂度？</strong><br>我：就是一个多层级链表，复杂度跟红黑树一样，然后简单讲了下实现。<br><strong>面：跳表使用场景？</strong><br>我：红黑树能用的地方，跳表都能用，个人认为跳表可以当作红黑树的下位替代，其优点为实现简单，而且可以比较简单的实现区间选择，红黑树区间选择得回溯，而且实现也麻烦。<br><strong>面：现在实习中，用过redis 6.0的多线程I&#x2F;O？</strong><br>我：没用过，不是瓶颈，没需求，不稳定。<br><strong>面：进入反问环节。</strong></p>
<p>&emsp;&emsp;一共15min左右，上面可能有些东西不全，凭感觉记的。感觉因为面试官的组和我去年实习的组好像有交集，所以问的也不算多，一面进行的很快，算是给实习过的同学的优待吧，毕竟技术栈比较相似，总体面试体验还是很不错的。</p>
<h1 id="二、9-7二面"><a href="#二、9-7二面" class="headerlink" title="二、9.7二面"></a>二、9.7二面</h1><ul>
<li>8月26面完过了两个多小时就来约二面了，一开始约的9月6，面试官临时有事改为9月7。</li>
</ul>
<p><strong>面：简单自我介绍一下吧。</strong><br>我：balabala。<br><strong>面：你个人比较擅长什么语言？</strong><br>我：C++ &gt; C &gt; Go。<br><strong>面：代码量如何？</strong><br>我：应该算挺多的，github上自己敲着玩的项目，再加上两段实习里敲的，几万行肯定有。<br><strong>面：去年在绿盟实习的经验讲一下？</strong><br>我：balabala。<br><strong>面：去年实习中主要都在用DPDK吧，讲一下DPDK？</strong><br>我：个人理解这个工具的主要用处就是为了高速包转发，涉及到软硬件层面的优化。比如说零拷贝技术、用户态驱动、轮询代替中断、CPU亲和性优化…balabala（面完想起来忘说大页技术和无锁编程部分了，面试还是有点紧张）<br><strong>面：讲讲为什么要搞CPU亲和性优化？</strong><br>我：因为现在CPU中一般都有L1L2L3缓冲，其中L1L2一般是多核之间不共享的，亲和性相当于绑核嘛，不绑核导致进程在多个CPU上执行，L1L2的缓冲就会失效，cache MISS增多降低执行速度balabala（核心就围绕这个讲）<br><strong>面：讲讲零拷贝，为什么有零拷贝，你怎么理解零拷贝？</strong><br>我：零拷贝简单来说就是为了降低拷贝次数，减少的拷贝一般指的是内核态与用户态的缓冲区之间数据拷贝。然后讲了下传统I&#x2F;O read&#x2F;write 4次拷贝的流程，接着讲了讲DPDK的零拷贝方案，不过感觉可能讲的有点不是太清晰。<br><strong>面：来点语言的，C++多态？</strong><br>我：虚指针balabala。<br><strong>面：C语言能搞多态吗？</strong><br>我：想跟C++一样简单来搞肯定没办法，因为语言层面没继承那套东西。但是可以通过void指针&#x2F;回调函数之类的来实现C语言形式的多态。<br><strong>面：开发怎么防止内存泄漏？</strong><br>我：可以正确使用C++11的智能指针…<br><strong>面：C语言呢？</strong><br>我：额，个人感觉只能完善编码规范，毕竟C语言比较自由和原始，感觉只能从规范上来避免。也可以多用内存泄漏工具来检测一下。小问题的话，也可以快速通过gdb看内存啥的。<br><strong>面：内存泄漏工具的原理？</strong><br>我：简单来讲就是实现了个内存池，然后重载内存申请&#x2F;释放操作，并且操作时在内存块上记录操作函数之类的内容，然后泄漏的时候看看泄漏的内存都是谁申请的。<br><strong>面：讲一下操作系统内存？</strong><br>我：讲了下虚拟内存和其需求，然后讲了下多级页表和虚拟内存转物理内存，然后顺便讲了下TLB和ASID。最后讲了下分配的流程吧，MMU啥的。<br><strong>面：聊一下进程调度？</strong><br>我：主要分两种吧，抢占和非抢占，比如时间片轮转和现来先服务。现在Linux用的是抢占式调度算法CFS，即完全公平调度算法，然后简单讲了下，nice值和底层红黑树啥的。<br><strong>面：TCP面向连接？</strong><br>我：TCP几个特点、拥塞控制、流量控制啥的熟练吟唱…就是讲的有点乱…<br><strong>面：TCP为什么要给报文分段啊？</strong><br>我：因为有MTU啊。<br><strong>面：那为啥要有MTU啊？</strong><br>我：个人理解是防止网卡堵塞之类的，可能还是网卡限制。<br><strong>面：不太对，再想想补充一下？</strong><br>我：好吧，没太接触过这块内容。（确实知识盲区，出去查了下应该是防止大报文影响其他报文发送）<br><strong>面：开聊网络编程项目</strong><br>我：讲了设计思路，网络编程的流程之类的，还有学习的流程啥的。<br><strong>面：有遇到啥困难吗，咋解决的</strong><br>我：balabala。<br><strong>面：未来想走啥方向啊</strong><br>我：想底层点吧，个人比较喜欢C&#x2F;C++这种没GC的或者Go这样能玩指针的，玩起来比较明白踏实。<br><strong>面：为啥今年不接着来绿盟实习了？</strong><br>我：今年3.4月找实习的时候，绿盟好像没开啊，然后就去某某厂了（面试官吐槽：谁说我们没开的，我们今年有招的）<br><strong>面：还有啥没问到的优点吗，可以补充一下。</strong><br>我：算法竞赛吧，大一大二混了点奖。<br><strong>面：OK，那就先这样。</strong></p>
<p>&emsp;&emsp;一共30多分钟吧，最后可能因为时间关系没反问。上面可能有些东西不全，凭感觉记的。二面问的还是相对比较偏实际工程吧，而且也确实有不会的，面完火速学习。总体面试体验挺不错，但是可能有点紧张，很多答得有点乱。</p>
<h1 id="三、综合面-测评"><a href="#三、综合面-测评" class="headerlink" title="三、综合面+测评"></a>三、综合面+测评</h1><ul>
<li>9.9约综合面，约了9月15</li>
</ul>
<p>&emsp;&emsp;一共10分钟吧，本来以为是hr面，但是除了问比如学习的方法之类的问题以外也问了一些还算深入的技术问题，所以更像是综合面。下午2点多点面完，大概6点多发了测评邮件。</p>
<h1 id="四、OC-意向"><a href="#四、OC-意向" class="headerlink" title="四、OC+意向"></a>四、OC+意向</h1><p>&emsp;&emsp;9月16号上午收到OC，随后隔了半小时发了意向，正式offer hr说要等国庆节后。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>&emsp;&emsp;绿盟去年的技术和wlb还是给我留下了很好的印象的（虽然听说现在也稍微卷起来了），但是可以说我有很多新东西和技术都是当初在绿盟实习时接触到的，所以我对绿盟还是挺有好感的，本次收到绿盟的意向还是很开心的。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>校招面试</tag>
      </tags>
  </entry>
  <entry>
    <title>golang学习记录：k8s operator内存泄露排查</title>
    <url>/2024/09/09/20240909_golang%E5%AD%A6%E5%8E%86%E8%AE%B0%E5%BD%95%EF%BC%9Ak8soperator%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%8E%92%E6%9F%A5/</url>
    <content><![CDATA[<ul>
<li><p>最近项目上某个operator在新增定时调谐逻辑后，出现了内存泄露的问题，但整体内存增长速度不是很快。</p>
</li>
<li><p>本次内存泄露使用<code>pprof</code>和<code>go tool</code>排查，这也是我第一次排查go的内存泄露问题，所以记录一下排查流程和结果</p>
</li>
</ul>
<span id="more"></span>

<h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><p>&emsp;&emsp;某个operator之前使用<code>sigs.k8s.io/controller-runtime</code>相关的库来实现，但是未配置<code>SyncPeriod</code>定时调谐；</p>
<p>&emsp;&emsp;前段时间，有需求要求新增定时调谐逻辑，遂新增此函数，每分钟定时调谐一次；但是新增此函数后，发现出现内存缓慢升高的现象：环境A内存60小时提升了100M，环境B内存60小时提升了800M，两环境唯一的差别为operator watch的实例数不同。</p>
<h1 id="二、排查过程"><a href="#二、排查过程" class="headerlink" title="二、排查过程"></a>二、排查过程</h1><ul>
<li>本次内存泄露排查，使用工具pprof进行。首先为源码引入pprof：<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">	_ <span class="string">&quot;net/http/pprof&quot;</span></span><br><span class="line">    ...</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		klog.Info(<span class="string">&quot;pprof start&quot;</span>)</span><br><span class="line">		http.ListenAndServe(<span class="string">&quot;0.0.0.0:6060&quot;</span>, <span class="literal">nil</span>) <span class="comment">// 此处应为0.0.0.0 使用127.0.0.1会导致Pod外无法直接访问</span></span><br><span class="line">	&#125;()</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>由于本次内存泄露是新增定时调谐逻辑后出现，初步猜测是定时调谐导致内存泄露，故将调谐频率由1分钟1次调整至10秒一次，随后编译镜像上传环境。<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">syncPeriod := time.Second * <span class="number">10</span> <span class="comment">// 10 s</span></span><br><span class="line">mgr, err := ctrl.NewManager(ctrl.GetConfigOrDie(), ctrl.Options&#123;</span><br><span class="line">	...</span><br><span class="line">	SyncPeriod:         &amp;syncPeriod,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>待镜像运行一段时间，pod内存占用明显升高时，采集pprof统计的内存分配信息。由于宿主机没有go环境，故使用<code>curl</code>先采集数据，拷到本地分析。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">podip</span></span><br><span class="line">curl http://xxx.xxx.xxx.xxx:6060/debug/pprof/heap &gt; heap.out</span><br></pre></td></tr></table></figure></li>
<li>使用go tool分析pprof文件，其中浏览器展示可以看图，会更直观一点，但是代码追踪没命令行分析方便。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">本地浏览器展示</span></span><br><span class="line">go tool pprof -http=:8080 heap.out</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令行展示</span></span><br><span class="line">go tool pprof /root/code/pprof/heap.out</span><br></pre></td></tr></table></figure></li>
<li>pprof(inuse_space)分析结果如下，仅截取核心部分：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting for 58.50MB, 87.89% of 66.56MB total</span><br><span class="line">Showing top 10 nodes out of 160</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">      20MB 30.05% 30.05%    40.44MB 60.76%  sigs.k8s.io/controller-runtime/pkg/internal/controller.(*Controller).reconcileHandler</span><br><span class="line">   16.44MB 24.69% 54.74%    16.44MB 24.69%  sigs.k8s.io/controller-runtime/pkg/log.(*loggerPromise).WithValues</span><br><span class="line">    6.05MB  9.09% 63.83%     6.05MB  9.09%  k8s.io/apimachinery/pkg/runtime.(*RawExtension).UnmarshalJSON</span><br><span class="line">       5MB  7.52% 71.35%        5MB  7.52%  runtime.allocm</span><br><span class="line">       3MB  4.51% 75.86%    19.44MB 29.20%  sigs.k8s.io/controller-runtime/pkg/log.(*DelegatingLogger).WithValues</span><br><span class="line">...</span><br><span class="line">(pprof)</span><br><span class="line">(pprof) list reconcileHandler</span><br><span class="line">Total: 66.56MB</span><br><span class="line">ROUTINE ======================== sigs.k8s.io/controller-runtime/pkg/internal/controller.(*Controller).reconcileHandler in /workspace/vendor/sigs.k8s.io/controller-runtime/pkg/internal/controller/controller.go</span><br><span class="line">      20MB    40.44MB (flat, cum) 60.76% of Total</span><br><span class="line">...</span><br><span class="line">      20MB    39.44MB    240:   log := c.Log.WithValues(&quot;name&quot;, req.Name, &quot;namespace&quot;, req.Namespace) # 注意</span><br><span class="line">...</span><br><span class="line">(pprof)</span><br><span class="line">(pprof) list .WithValues</span><br><span class="line">Total: 66.56MB</span><br><span class="line">ROUTINE ======================== sigs.k8s.io/controller-runtime/pkg/log.(*DelegatingLogger).WithValues in /workspace/vendor/sigs.k8s.io/controller-runtime/pkg/log/deleg.go</span><br><span class="line">       3MB    19.44MB (flat, cum) 29.20% of Total</span><br><span class="line">...</span><br><span class="line">       3MB        3MB    112:   res := &amp;DelegatingLogger&#123;Logger: l.Logger&#125;</span><br><span class="line">         .    16.44MB    113:   promise := l.promise.WithValues(res, tags...)</span><br><span class="line">...</span><br><span class="line">ROUTINE ======================== sigs.k8s.io/controller-runtime/pkg/log.(*loggerPromise).WithValues in /workspace/vendor/sigs.k8s.io/controller-runtime/pkg/log/deleg.go</span><br><span class="line">   16.44MB    16.44MB (flat, cum) 24.69% of Total</span><br><span class="line">...</span><br><span class="line">         .          .     51:func (p *loggerPromise) WithValues(l *DelegatingLogger, tags ...interface&#123;&#125;) *loggerPromise &#123;</span><br><span class="line">      15MB       15MB     52:   res := &amp;loggerPromise&#123;</span><br><span class="line">...</span><br><span class="line">    1.44MB     1.44MB     60:   p.childPromises = append(p.childPromises, res)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="三、排查结果"><a href="#三、排查结果" class="headerlink" title="三、排查结果"></a>三、排查结果</h1><p>&emsp;&emsp;如上所示，可以发现内存占用大部分都是<code>reconcileHandler()</code>和<code>WithValues()</code>内占用的，通过代码追踪可以看到这块代码是log相关的内容，但是都是第三方的库，所以优先考虑是第三方库bug。</p>
<p>&emsp;&emsp;经过去网上查issue和帖子，发现确实是第三方库<code>sigs.k8s.io/controller-runtime</code>的bug，问题大概如下：</p>
<ul>
<li><p><code>sigs.k8s.io/controller-runtime</code>内延迟log需要用户自己提供日志实现，假如用户不自己实现，则日志会堆积，直至延迟log被实现。</p>
</li>
<li><p>调谐频率越高，则日志生成越快、堆积越多，日志堆积会导致内存逐渐升高，最终导致OOM。</p>
</li>
</ul>
<p>&emsp;&emsp;所以实际上这个问题一直存在，只是之前没有定时调谐，调谐频率不高导致未被发现。</p>
<p><strong>相关issue &amp; fix如下：</strong></p>
<ul>
<li><p>issue: <a href="https://github.com/kubernetes-sigs/controller-runtime/issues/1444">https://github.com/kubernetes-sigs/controller-runtime/issues/1444</a></p>
</li>
<li><p>issue: <a href="https://github.com/kubernetes-sigs/controller-runtime/issues/1122">https://github.com/kubernetes-sigs/controller-runtime/issues/1122</a></p>
</li>
<li><p>fix: <a href="https://github.com/kubernetes-sigs/controller-runtime/pull/1309">https://github.com/kubernetes-sigs/controller-runtime/pull/1309</a></p>
</li>
</ul>
<h1 id="四、修复与测试"><a href="#四、修复与测试" class="headerlink" title="四、修复与测试"></a>四、修复与测试</h1><ul>
<li>经过调研，可以得出此问题主要有两种解决方案</li>
</ul>
<ol>
<li>升级<code>controller-runtime</code>版本至0.8.x (2021年修复)</li>
<li>为延迟log定义实现，避免日志堆积</li>
</ol>
<ul>
<li>最终选择在代码内新增空实现延迟log，丢弃日志。代码改动如下：<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">	ctrl.SetLogger(logf.NullLogger&#123;&#125;)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>编译镜像上传环境，待镜像运行一段时间，内存未明显升高，此问题解决。</li>
</ul>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><ul>
<li>pprof完整内容<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting for 58.50MB, 87.89% of 66.56MB total</span><br><span class="line">Showing top 10 nodes out of 160</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">      20MB 30.05% 30.05%    40.44MB 60.76%  sigs.k8s.io/controller-runtime/pkg/internal/controller.(*Controller).reconcileHandler</span><br><span class="line">   16.44MB 24.69% 54.74%    16.44MB 24.69%  sigs.k8s.io/controller-runtime/pkg/log.(*loggerPromise).WithValues</span><br><span class="line">    6.05MB  9.09% 63.83%     6.05MB  9.09%  k8s.io/apimachinery/pkg/runtime.(*RawExtension).UnmarshalJSON</span><br><span class="line">       5MB  7.52% 71.35%        5MB  7.52%  runtime.allocm</span><br><span class="line">       3MB  4.51% 75.86%    19.44MB 29.20%  sigs.k8s.io/controller-runtime/pkg/log.(*DelegatingLogger).WithValues</span><br><span class="line">    2.51MB  3.76% 79.62%     2.51MB  3.76%  k8s.io/apimachinery/pkg/apis/meta/v1.(*FieldsV1).UnmarshalJSON</span><br><span class="line">    1.50MB  2.26% 81.88%     1.50MB  2.26%  reflect.mapassign</span><br><span class="line">    1.50MB  2.25% 84.13%     1.50MB  2.25%  reflect.New</span><br><span class="line">    1.50MB  2.25% 86.39%     2.50MB  3.76%  github.com/json-iterator/go.(*Iterator).ReadString</span><br><span class="line">       1MB  1.50% 87.89%        1MB  1.50%  github.com/json-iterator/go.(*Iterator).readStringSlowPath</span><br><span class="line">(pprof)</span><br><span class="line">(pprof) list reconcileHandler</span><br><span class="line">Total: 66.56MB</span><br><span class="line">ROUTINE ======================== sigs.k8s.io/controller-runtime/pkg/internal/controller.(*Controller).reconcileHandler in /workspace/vendor/sigs.k8s.io/controller-runtime/pkg/internal/controller/controller.go</span><br><span class="line">      20MB    40.44MB (flat, cum) 60.76% of Total</span><br><span class="line">         .          .    235:           c.Log.Error(nil, &quot;Queue item was not a Request&quot;, &quot;type&quot;, fmt.Sprintf(&quot;%T&quot;, obj), &quot;value&quot;, obj)</span><br><span class="line">         .          .    236:           // Return true, don&#x27;t take a break</span><br><span class="line">         .          .    237:           return true</span><br><span class="line">         .          .    238:   &#125;</span><br><span class="line">         .          .    239:</span><br><span class="line">      20MB    39.44MB    240:   log := c.Log.WithValues(&quot;name&quot;, req.Name, &quot;namespace&quot;, req.Namespace)</span><br><span class="line">         .          .    241:</span><br><span class="line">         .          .    242:   // RunInformersAndControllers the syncHandler, passing it the namespace/Name string of the</span><br><span class="line">         .          .    243:   // resource to be synced.</span><br><span class="line">         .     1.01MB    244:   if result, err := c.Do.Reconcile(req); err != nil &#123;</span><br><span class="line">         .          .    245:           c.Queue.AddRateLimited(req)</span><br><span class="line">         .          .    246:           log.Error(err, &quot;Reconciler error&quot;)</span><br><span class="line">         .          .    247:           ctrlmetrics.ReconcileErrors.WithLabelValues(c.Name).Inc()</span><br><span class="line">         .          .    248:           ctrlmetrics.ReconcileTotal.WithLabelValues(c.Name, &quot;error&quot;).Inc()</span><br><span class="line">         .          .    249:           return false</span><br><span class="line">(pprof)</span><br><span class="line">(pprof) list .WithValues</span><br><span class="line">Total: 66.56MB</span><br><span class="line">ROUTINE ======================== sigs.k8s.io/controller-runtime/pkg/log.(*DelegatingLogger).WithValues in /workspace/vendor/sigs.k8s.io/controller-runtime/pkg/log/deleg.go</span><br><span class="line">       3MB    19.44MB (flat, cum) 29.20% of Total</span><br><span class="line">         .          .    107:func (l *DelegatingLogger) WithValues(tags ...interface&#123;&#125;) logr.Logger &#123;</span><br><span class="line">         .          .    108:   if l.promise == nil &#123;</span><br><span class="line">         .          .    109:           return l.Logger.WithValues(tags...)</span><br><span class="line">         .          .    110:   &#125;</span><br><span class="line">         .          .    111:</span><br><span class="line">       3MB        3MB    112:   res := &amp;DelegatingLogger&#123;Logger: l.Logger&#125;</span><br><span class="line">         .    16.44MB    113:   promise := l.promise.WithValues(res, tags...)</span><br><span class="line">         .          .    114:   res.promise = promise</span><br><span class="line">         .          .    115:</span><br><span class="line">         .          .    116:   return res</span><br><span class="line">         .          .    117:&#125;</span><br><span class="line">         .          .    118:</span><br><span class="line">ROUTINE ======================== sigs.k8s.io/controller-runtime/pkg/log.(*loggerPromise).WithValues in /workspace/vendor/sigs.k8s.io/controller-runtime/pkg/log/deleg.go</span><br><span class="line">   16.44MB    16.44MB (flat, cum) 24.69% of Total</span><br><span class="line">         .          .     47:   return res</span><br><span class="line">         .          .     48:&#125;</span><br><span class="line">         .          .     49:</span><br><span class="line">         .          .     50:// WithValues provides a new Logger with the tags appended</span><br><span class="line">         .          .     51:func (p *loggerPromise) WithValues(l *DelegatingLogger, tags ...interface&#123;&#125;) *loggerPromise &#123;</span><br><span class="line">      15MB       15MB     52:   res := &amp;loggerPromise&#123;</span><br><span class="line">         .          .     53:           logger:       l,</span><br><span class="line">         .          .     54:           tags:         tags,</span><br><span class="line">         .          .     55:           promisesLock: sync.Mutex&#123;&#125;,</span><br><span class="line">         .          .     56:   &#125;</span><br><span class="line">         .          .     57:</span><br><span class="line">         .          .     58:   p.promisesLock.Lock()</span><br><span class="line">         .          .     59:   defer p.promisesLock.Unlock()</span><br><span class="line">    1.44MB     1.44MB     60:   p.childPromises = append(p.childPromises, res)</span><br><span class="line">         .          .     61:   return res</span><br><span class="line">         .          .     62:&#125;</span><br><span class="line">         .          .     63:</span><br><span class="line">         .          .     64:// Fulfill instantiates the Logger with the provided logger</span><br><span class="line">         .          .     65:func (p *loggerPromise) Fulfill(parentLogger logr.Logger) &#123;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Golang</tag>
        <tag>K8S</tag>
        <tag>K8S Operator</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习记录：spring框架lettuce哨兵接入拓扑更新踩坑记录</title>
    <url>/2024/11/05/20241105_Redis%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9Aspring%E6%A1%86%E6%9E%B6lettuce%E5%93%A8%E5%85%B5%E6%8E%A5%E5%85%A5%E6%8B%93%E6%89%91%E6%9B%B4%E6%96%B0%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<ul>
<li><p>最近使用spring-data-redis接入容器化redis进行自测时，踩到一个坑。</p>
</li>
<li><p>本篇文章简要记录一下排坑过程。</p>
</li>
</ul>
<span id="more"></span>

<h1 id="一、问题背景"><a href="#一、问题背景" class="headerlink" title="一、问题背景"></a>一、问题背景</h1><p>此问题是自测时出现的，整体的流程如下：</p>
<ol>
<li><p>K8S容器化部署3实例哨兵集群 + 1主1从主从集群</p>
</li>
<li><p>业务客户端使用<code>spring-data-redis</code>库以哨兵模式接入，底层使用lettuce，使用容器化部署</p>
</li>
<li><p>使用<code>delete --force</code>删除主实例pod，模拟K8S节点宕机场景</p>
</li>
<li><p>业务客户端出现timeout报错，持续重试</p>
</li>
<li><p>观测哨兵信息，发现已经主从切换完成，哨兵信息中旧从节点已经提升为主</p>
</li>
<li><p>持续观察业务客户端，无法自动恢复，仍持续出现timeout报错；重启业务客户端，业务操作恢复正常</p>
</li>
</ol>
<h1 id="二、问题排查过程"><a href="#二、问题排查过程" class="headerlink" title="二、问题排查过程"></a>二、问题排查过程</h1><p>此前已经看过lettuce的哨兵相关源码，可以确认lettuce原生逻辑，在这种情况下会监听导致提主事件刷新拓扑。</p>
<p>但是这次在spring框架内使用lettuce，却无法更新lettuce拓扑，仍在不断重试访问已经宕机的旧主。</p>
<p>把日志级别调整为debug模式，发现日志中并没有拓扑刷新的日志，说明拓扑并没有刷新。</p>
<p>这种情况我感觉是<code>spring-data-redis</code>库有点什么问题，故先去issue中搜索一下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">issue:  https://github.com/spring-projects/spring-data-redis/issues/1952</span><br></pre></td></tr></table></figure>

<p>经过查询，果然找到一个类似情况的issue，核心信息汇总如下：</p>
<ol>
<li><p>lettuce设计上是异步连接，在模拟K8S节点宕机场景时，<code>Fin</code>&#x2F;<code>RST</code>包无法正常发送，则异步连接短时间内不会自动断开。</p>
</li>
<li><p>spring-data-Redis底层为lettuce时，会保持长连接。除非连接断开，否则拓扑不会主动刷新。</p>
</li>
<li><p>如果希望通过spring-data-Redis使用lettuce时持续追踪拓扑变化，则需要配置<code>ReadFrom</code>。</p>
</li>
</ol>
<p>所以最终可以确认，是lettuce设计上，默认配置就没兼容这种场景。</p>
<p>通过查看<code>spring-data-redis</code>相关源码，发现在配置<code>ReadFrom</code>后，每次执行操作前都会尝试按配置获取最新的主&#x2F;从实例，这样就不会出现异步连接未断开导致拓扑无法刷新的问题了。</p>
<p>随后再次测试，在业务客户端中配置<code>ReadFrom</code>，注入故障后，发现业务操作可以恢复正常，由此问题解决。</p>
<h1 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h1><p>这个问题整体来看有点奇怪，核心是<code>Fin</code>&#x2F;<code>RST</code>包无法正常发送，导致异步连接无法正常关闭刷新拓扑。</p>
<p>但是我感觉<code>spring-data-redis</code>理应处理这种场景，不应该基于连接来触发拓扑刷新，应该有个额外的刷新机制，结果却没有。</p>
<p>仔细看issue里的回复，开发人员认为额外的刷新可能会导致额外资源消耗。。。好吧，可能后续最佳实践里要提一嘴，<code>spring-data-redis</code>使用lettuce哨兵模式接入时，记得配置一下<code>ReadFrom</code>来避免这个问题。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Lettuce</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx学习记录：Nginx代理S3服务</title>
    <url>/2024/12/02/20241202_Nginx%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9ANginx%E4%BB%A3%E7%90%86S3%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<ul>
<li><p>最近有使用Nginx代理对象存储服务的需求，需要出一份配置文件。</p>
</li>
<li><p>本篇文章简要记录一下测试过程中发现的坑吧。</p>
</li>
</ul>
<span id="more"></span>

<h1 id="完整配置文件"><a href="#完整配置文件" class="headerlink" title="完整配置文件"></a>完整配置文件</h1><p>闲话少说，先放出最终的配置文件demo吧。</p>
<p>假设当前信息如下：</p>
<ol>
<li><p>需要代理的S3地址为: <a href="https://real.s3.com/">https://real.s3.com</a></p>
</li>
<li><p>当前Nginx的部署地址为: <a href="http://1.2.3.4:2345/">http://1.2.3.4:2345</a></p>
</li>
</ol>
<p>则最终的配置文件如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">worker_processes auto;</span><br><span class="line">error_log log/nginx/error.log;</span><br><span class="line">pid run/nginx.pid;</span><br><span class="line">worker_rlimit_nofile 65535;</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 512;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    include /etc/nginx/mime.types;</span><br><span class="line">    default_type application/octet-stream;</span><br><span class="line">    log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line">    access_log log/nginx/access.log main;</span><br><span class="line">    server &#123;</span><br><span class="line">        # 监听端口</span><br><span class="line">        listen 2345;</span><br><span class="line">        client_max_body_size 1024M;</span><br><span class="line">        location / &#123;</span><br><span class="line">            # 此处配置S3地址</span><br><span class="line">            proxy_pass https://real.s3.com;</span><br><span class="line">            # 此处配置当前实例地址</span><br><span class="line">            proxy_set_header Host 1.2.3.4:2345;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="坑一-身份校验"><a href="#坑一-身份校验" class="headerlink" title="坑一 身份校验"></a>坑一 身份校验</h1><p>当S3客户端使用AK和SK进行校验时，必须要将转发请求header中<code>Host</code>的值配置为当前Nginx的部署地址，否则会出现身份校验不通过的情况。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    ...</span><br><span class="line">    # 此处配置当前实例地址</span><br><span class="line">    proxy_set_header Host 1.2.3.4:2345;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是因为配置代理后，S3客户端实际会向Nginx发出S3请求，即请求头中的<code>Host</code>会被配置为Nginx的部署地址。</p>
<p>而S3客户端在进行请求的预签名计算时，除了会使用到AK和SK，也会使用请求头中的<code>Host</code>。</p>
<p>后续Nginx进行转发时，若不配置将请求头中的<code>Host</code>替换，则会出现请求头中的<code>Host</code>与预签名不匹配的情况，导致身份校验失败。</p>
<p>下面摘取aws-sdk-go中的一点代码佐证。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// github.com/aws/aws-sdk-go/aws/signer/v4/v4.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ctx *signingCtx)</span></span> buildCanonicalHeaders(r rule, header http.Header) &#123;</span><br><span class="line">	<span class="keyword">var</span> headers []<span class="type">string</span></span><br><span class="line">	headers = <span class="built_in">append</span>(headers, <span class="string">&quot;host&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> header &#123;</span><br><span class="line">		<span class="keyword">if</span> !r.IsValid(k) &#123;</span><br><span class="line">			<span class="keyword">continue</span> <span class="comment">// ignored header</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ctx.SignedHeaderVals == <span class="literal">nil</span> &#123;</span><br><span class="line">			ctx.SignedHeaderVals = <span class="built_in">make</span>(http.Header)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		lowerCaseKey := strings.ToLower(k)</span><br><span class="line">		<span class="keyword">if</span> _, ok := ctx.SignedHeaderVals[lowerCaseKey]; ok &#123;</span><br><span class="line">			<span class="comment">// include additional values</span></span><br><span class="line">			ctx.SignedHeaderVals[lowerCaseKey] = <span class="built_in">append</span>(ctx.SignedHeaderVals[lowerCaseKey], v...)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		headers = <span class="built_in">append</span>(headers, lowerCaseKey)</span><br><span class="line">		ctx.SignedHeaderVals[lowerCaseKey] = v</span><br><span class="line">	&#125;</span><br><span class="line">	sort.Strings(headers)</span><br><span class="line"></span><br><span class="line">	ctx.signedHeaders = strings.Join(headers, <span class="string">&quot;;&quot;</span>)</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> ctx.isPresign &#123;</span><br><span class="line">		ctx.Query.Set(<span class="string">&quot;X-Amz-SignedHeaders&quot;</span>, ctx.signedHeaders)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	headerItems := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="built_in">len</span>(headers))</span><br><span class="line">	<span class="keyword">for</span> i, k := <span class="keyword">range</span> headers &#123;</span><br><span class="line">		<span class="keyword">if</span> k == <span class="string">&quot;host&quot;</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> ctx.Request.Host != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">				headerItems[i] = <span class="string">&quot;host:&quot;</span> + ctx.Request.Host</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				headerItems[i] = <span class="string">&quot;host:&quot;</span> + ctx.Request.URL.Host</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			headerValues := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="built_in">len</span>(ctx.SignedHeaderVals[k]))</span><br><span class="line">			<span class="keyword">for</span> i, v := <span class="keyword">range</span> ctx.SignedHeaderVals[k] &#123;</span><br><span class="line">				headerValues[i] = strings.TrimSpace(v)</span><br><span class="line">			&#125;</span><br><span class="line">			headerItems[i] = k + <span class="string">&quot;:&quot;</span> +</span><br><span class="line">				strings.Join(headerValues, <span class="string">&quot;,&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	stripExcessSpaces(headerItems)</span><br><span class="line">	ctx.canonicalHeaders = strings.Join(headerItems, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="坑二-跨域问题"><a href="#坑二-跨域问题" class="headerlink" title="坑二 跨域问题"></a>坑二 跨域问题</h1><p>如果代理的S3服务本身没有配置跨域配置，那么假如直接通过前端访问代理Nginx地址，就会出现跨域错误。</p>
<p>对于这种情况，可能有些S3服务开跨域比较麻烦，可以考虑直接从Nginx配置层面解决这个问题。</p>
<p>只需要按协议添加相关header，处理<code>OPTIONS</code>请求就可以，示例配置文件如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">worker_processes auto;</span><br><span class="line">error_log log/nginx/error.log;</span><br><span class="line">pid run/nginx.pid;</span><br><span class="line">worker_rlimit_nofile 65535;</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 512;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    include /etc/nginx/mime.types;</span><br><span class="line">    default_type application/octet-stream;</span><br><span class="line">    log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line">    access_log log/nginx/access.log main;</span><br><span class="line">    server &#123;</span><br><span class="line">        # 监听端口</span><br><span class="line">        listen 2345;</span><br><span class="line">        client_max_body_size 1024M;</span><br><span class="line">        location / &#123;</span><br><span class="line">            add_header &#x27;Access-Control-Allow-Origin&#x27; &#x27;*&#x27;;</span><br><span class="line">            add_header &#x27;Access-Control-Allow-Methods&#x27; &#x27;GET, POST, OPTIONS, PUT, POST&#x27;;</span><br><span class="line">            add_header &#x27;Access-Control-Allow-Headers&#x27; &#x27;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization&#x27;;</span><br><span class="line">            if ($request_method = &#x27;OPTIONS&#x27;) &#123;</span><br><span class="line">                return 204;</span><br><span class="line">            &#125;</span><br><span class="line">            # 此处配置S3地址</span><br><span class="line">            proxy_pass https://real.s3.com;</span><br><span class="line">            # 此处配置当前实例地址</span><br><span class="line">            proxy_set_header Host 1.2.3.4:2345;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>S3</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习记录：lettuce哨兵模式接入拓扑刷新源码分析</title>
    <url>/2024/09/22/20240922_Redis%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9Alettuce%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E6%8E%A5%E5%85%A5%E6%8B%93%E6%89%91%E5%88%B7%E6%96%B0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<ul>
<li><p>最近遇到一个问题，用户在用lettuce接入容器化redis时，出现failover后lettuce无法感知导致readonly的问题。</p>
</li>
<li><p>本篇文章简要记录一下排查过程和涉及到的部分源码分析。</p>
</li>
</ul>
<span id="more"></span>

<h1 id="一、问题背景"><a href="#一、问题背景" class="headerlink" title="一、问题背景"></a>一、问题背景</h1><p>用户使用lettuce以哨兵接入，在手动执行<code>sentinel failover</code>命令后，业务客户端出现持续的<code>readonly</code>报错，且无法自动恢复。</p>
<p>经过日志排查可以确认，在<code>sentinel failover</code>命令执行后，redis-operator存在自愈操作，将故障转移过程中的双主变为单主，即对新从节点执行了slaveof操作。</p>
<p>停止redis-operator调谐，再次手动执行<code>sentinel failover</code>命令，业务客户端可以自动感知主从切换，不再出现<code>readonly</code>报错。</p>
<h1 id="二、问题原因"><a href="#二、问题原因" class="headerlink" title="二、问题原因"></a>二、问题原因</h1><p>经过对比停止redis-operator调谐后的日志差异，发现核心在于哨兵的<code>+convert-to-slave</code>消息。在哨兵发出此消息后，lettuce打印拓扑刷新日志，后续连接指向新的master。</p>
<p><strong>问题原因和流程大致也可以确认:</strong></p>
<ol>
<li><p>当用户手动触发故障转移后，redis提升一个slave为master，此时存在两个master。</p>
</li>
<li><p>redis-operator监控到存在两个master，触发自愈流程：将一个master降级为slave并断开此节点的所有连接，最后reset哨兵。</p>
</li>
<li><p>lettuce客户端拓扑无感知，连接被operator断开后，触发重连，但重连地址仍为旧master节点。</p>
</li>
<li><p>此时lettuce客户端执行写操作会报错<code>readonly</code>，且由于拓扑未刷新，导致后续也无法重连至新master节点。</p>
</li>
</ol>
<p><strong>无operator介入的常规流程为:</strong></p>
<ol>
<li><p>当用户手动触发故障转移后，redis提升一个slave为master，此时存在两个master。</p>
</li>
<li><p>operator未干预哨兵故障转移，哨兵正常执行故障转移，主从切换相关事件正常推送。</p>
</li>
<li><p>lettuce客户端订阅到相关事件，刷新拓扑；但存量连接地址合法，不会主动断开连接。</p>
</li>
<li><p>哨兵故障转移结束后，检测到存在多主，触发自愈流程：将一个master降级为slave，断开此节点的所有连接，并推送相关事件。</p>
</li>
<li><p>lettuce客户端连接被哨兵断开后，触发重连，重连地址为新master节点。</p>
</li>
<li><p>此时lettuce客户端正常读写。</p>
</li>
</ol>
<p>由此可以确认是operator介入且未推送事件，导致lettuce无法感知拓扑刷新导致。</p>
<p>这个问题解决主要从两个方向入手：</p>
<ol>
<li><p>调整operator自愈逻辑</p>
</li>
<li><p>客户端捕获异常并适配</p>
</li>
</ol>
<p>经过测试都可以解决这个问题，由此问题最终解决。</p>
<h1 id="三、相关源码分析"><a href="#三、相关源码分析" class="headerlink" title="三、相关源码分析"></a>三、相关源码分析</h1><blockquote>
<p>redis源码版本: 6.2.x<br>  lettuce源码版本: 6.x</p>
</blockquote>
<h2 id="1-哨兵提主逻辑"><a href="#1-哨兵提主逻辑" class="headerlink" title="1. 哨兵提主逻辑"></a>1. 哨兵提主逻辑</h2><p>以下为<code>sentinel.c</code>中的部分源码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sentinelRefreshInstanceInfo</span><span class="params">(sentinelRedisInstance *ri, <span class="type">const</span> <span class="type">char</span> *info)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 哨兵视角检测到节点预期状态为slave, 但是实际状态为master</span></span><br><span class="line">    <span class="keyword">if</span> ((ri-&gt;flags &amp; SRI_SLAVE) &amp;&amp; role == SRI_MASTER) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ri-&gt;flags &amp; SRI_PROMOTED) &amp;&amp;</span><br><span class="line">            (ri-&gt;master-&gt;flags &amp; SRI_FAILOVER_IN_PROGRESS) &amp;&amp;</span><br><span class="line">            (ri-&gt;master-&gt;failover_state ==</span><br><span class="line">                SENTINEL_FAILOVER_STATE_WAIT_PROMOTION))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 故障转移过程中</span></span><br><span class="line">            <span class="comment">// 且此时新master尚未提升完成</span></span><br><span class="line">            <span class="comment">// todo: 提主+更新状态</span></span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 故障转移过程中新master已经稳定 / 非故障转移状态出现多主</span></span><br><span class="line">            <span class="comment">// 实际表现就是存在预期master以外的非预期master</span></span><br><span class="line">            <span class="type">mstime_t</span> wait_time = SENTINEL_PUBLISH_PERIOD*<span class="number">4</span>;</span><br><span class="line">            <span class="keyword">if</span> (!(ri-&gt;flags &amp; SRI_PROMOTED) &amp;&amp;</span><br><span class="line">                 sentinelMasterLooksSane(ri-&gt;master) &amp;&amp;</span><br><span class="line">                 sentinelRedisInstanceNoDownFor(ri,wait_time) &amp;&amp;</span><br><span class="line">                 mstime() - ri-&gt;role_reported_time &gt; wait_time)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 执行slaveof建立复制关系</span></span><br><span class="line">                <span class="type">int</span> retval = sentinelSendSlaveOf(ri,ri-&gt;master-&gt;addr);</span><br><span class="line">                <span class="comment">// 推送+convert-to-slave事件</span></span><br><span class="line">                <span class="keyword">if</span> (retval == C_OK)</span><br><span class="line">                    sentinelEvent(LL_NOTICE,<span class="string">&quot;+convert-to-slave&quot;</span>,ri,<span class="string">&quot;%@&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>哨兵建立复制关系的大致源码如下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sentinelSendSlaveOf</span><span class="params">(sentinelRedisInstance *ri, <span class="type">const</span> sentinelAddr *addr)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 这个函数内发起了一个事务, 主要执行流程如下:</span></span><br><span class="line">    <span class="comment">// 1. 对此实例执行slaveof命令 建立复制关系</span></span><br><span class="line">    <span class="comment">// 2. 重写此实例配置 刷到盘上</span></span><br><span class="line">    <span class="comment">// 3. 杀掉此实例所有normal和pubsub类型的连接</span></span><br><span class="line">    retval = redisAsyncCommand(ri-&gt;link-&gt;cc,</span><br><span class="line">        sentinelDiscardReplyCallback, ri, <span class="string">&quot;%s&quot;</span>,</span><br><span class="line">        sentinelInstanceMapCommand(ri,<span class="string">&quot;MULTI&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (retval == C_ERR) <span class="keyword">return</span> retval;</span><br><span class="line">    ri-&gt;link-&gt;pending_commands++;</span><br><span class="line"></span><br><span class="line">    retval = redisAsyncCommand(ri-&gt;link-&gt;cc,</span><br><span class="line">        sentinelDiscardReplyCallback, ri, <span class="string">&quot;%s %s %s&quot;</span>,</span><br><span class="line">        sentinelInstanceMapCommand(ri,<span class="string">&quot;SLAVEOF&quot;</span>),</span><br><span class="line">        host, portstr);</span><br><span class="line">    <span class="keyword">if</span> (retval == C_ERR) <span class="keyword">return</span> retval;</span><br><span class="line">    ri-&gt;link-&gt;pending_commands++;</span><br><span class="line"></span><br><span class="line">    retval = redisAsyncCommand(ri-&gt;link-&gt;cc,</span><br><span class="line">        sentinelDiscardReplyCallback, ri, <span class="string">&quot;%s REWRITE&quot;</span>,</span><br><span class="line">        sentinelInstanceMapCommand(ri,<span class="string">&quot;CONFIG&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (retval == C_ERR) <span class="keyword">return</span> retval;</span><br><span class="line">    ri-&gt;link-&gt;pending_commands++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> type = <span class="number">0</span>; type &lt; <span class="number">2</span>; type++) &#123;</span><br><span class="line">        retval = redisAsyncCommand(ri-&gt;link-&gt;cc,</span><br><span class="line">            sentinelDiscardReplyCallback, ri, <span class="string">&quot;%s KILL TYPE %s&quot;</span>,</span><br><span class="line">            sentinelInstanceMapCommand(ri,<span class="string">&quot;CLIENT&quot;</span>),</span><br><span class="line">            type == <span class="number">0</span> ? <span class="string">&quot;normal&quot;</span> : <span class="string">&quot;pubsub&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (retval == C_ERR) <span class="keyword">return</span> retval;</span><br><span class="line">        ri-&gt;link-&gt;pending_commands++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    retval = redisAsyncCommand(ri-&gt;link-&gt;cc,</span><br><span class="line">        sentinelDiscardReplyCallback, ri, <span class="string">&quot;%s&quot;</span>,</span><br><span class="line">        sentinelInstanceMapCommand(ri,<span class="string">&quot;EXEC&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (retval == C_ERR) <span class="keyword">return</span> retval;</span><br><span class="line">    ri-&gt;link-&gt;pending_commands++;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以实际上，当哨兵检测到多主时，会把多余的master降级为slave，并杀掉所有的连接。当这一套操作执行成功后，哨兵会推送<code>+convert-to-slave</code>事件。</p>
<h2 id="2-lettuce拓扑刷新逻辑"><a href="#2-lettuce拓扑刷新逻辑" class="headerlink" title="2. lettuce拓扑刷新逻辑"></a>2. lettuce拓扑刷新逻辑</h2><p>从拓扑刷新的地方入手，如下为拓扑刷新的地方，可以看到触发拓扑刷新后，最终会执行<code>setKnownNodes()</code>函数更新拓扑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SentinelConnector.java</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SentinelConnector</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">MasterReplicaConnector</span>&lt;K, V&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> Runnable <span class="title function_">getTopologyRefreshRunnable</span><span class="params">(MasterReplicaTopologyRefresh refresh,</span></span><br><span class="line"><span class="params">            MasterReplicaConnectionProvider&lt;K, V&gt; connectionProvider)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                LOG.debug(<span class="string">&quot;Refreshing topology&quot;</span>);</span><br><span class="line">                refresh.getNodes(redisURI).subscribe(nodes -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                    EventRecorder.getInstance().record(<span class="keyword">new</span> <span class="title class_">MasterReplicaTopologyChangedEvent</span>(redisURI, nodes));</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (nodes.isEmpty()) &#123;</span><br><span class="line">                        LOG.warn(<span class="string">&quot;Topology refresh returned no nodes from &#123;&#125;&quot;</span>, redisURI);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    LOG.debug(<span class="string">&quot;New topology: &#123;&#125;&quot;</span>, nodes);</span><br><span class="line">                    connectionProvider.setKnownNodes(nodes);</span><br><span class="line"></span><br><span class="line">                &#125;, t -&gt; LOG.error(<span class="string">&quot;Error during background refresh&quot;</span>, t));</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                LOG.error(<span class="string">&quot;Error during background refresh&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>setKnownNodes()</code>函数内容如下，主要就是把旧拓扑删除后，把新的拓扑加进去，然后调用<code>closeStaleConnections()</code>函数。</p>
<p><code>closeStaleConnections()</code>函数内部会调用<code>getStaleConnectionKeys()</code>函数获取过期的连接，然后把过期的连接主动close掉，此段代码逻辑较为简单，跳过代码展示。</p>
<p>lettuce判定连接过期的标准为：连接的地址不在当前拓扑内。也就是说lettuce在拓扑刷新后并不会主动断开连接，这个操作得由其他人来做。根据上文中对redis源码的分析，可以发现哨兵在执行完<code>slaveof</code>以后会主动断开连接。此时拓扑刷新lettuce就可以连接到最新的master。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MasterReplicaConnectionProvider.java</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MasterReplicaConnectionProvider</span>&lt;K, V&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setKnownNodes</span><span class="params">(Collection&lt;RedisNodeDescription&gt; knownNodes)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (stateLock) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.knownNodes.clear();</span><br><span class="line">            <span class="built_in">this</span>.knownNodes.addAll(knownNodes);</span><br><span class="line"></span><br><span class="line">            closeStaleConnections();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么拓扑刷新如何触发？可以看到在使用<code>connectAsync()</code>创建异步连接时，会获取runnable函数，即拓扑刷新函数。</p>
<p>这个拓扑刷新函数会通过<code>initializeConnection()</code>函数来绑定到<code>SentinelTopologyRefresh</code>对象上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SentinelConnector.java</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SentinelConnector</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">MasterReplicaConnector</span>&lt;K, V&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> CompletableFuture&lt;StatefulRedisMasterReplicaConnection&lt;K, V&gt;&gt; <span class="title function_">connectAsync</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="type">SentinelTopologyRefresh</span> <span class="variable">sentinelTopologyRefresh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SentinelTopologyRefresh</span>(redisClient,</span><br><span class="line">                redisURI.getSentinelMasterId(), redisURI.getSentinels());</span><br><span class="line"></span><br><span class="line">        <span class="type">MasterReplicaTopologyRefresh</span> <span class="variable">refresh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MasterReplicaTopologyRefresh</span>(redisClient, topologyProvider);</span><br><span class="line">        MasterReplicaConnectionProvider&lt;K, V&gt; connectionProvider = <span class="keyword">new</span> <span class="title class_">MasterReplicaConnectionProvider</span>&lt;&gt;(redisClient, codec,</span><br><span class="line">                redisURI, Collections.emptyMap());</span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> getTopologyRefreshRunnable(refresh, connectionProvider); <span class="comment">// 获取拓扑刷新函数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> refresh.getNodes(redisURI).flatMap(nodes -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nodes.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> Mono.error(<span class="keyword">new</span> <span class="title class_">RedisException</span>(String.format(<span class="string">&quot;Cannot determine topology from %s&quot;</span>, redisURI)));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> initializeConnection(codec, sentinelTopologyRefresh, connectionProvider, runnable, nodes);</span><br><span class="line">        &#125;).onErrorMap(ExecutionException.class, Throwable::getCause).toFuture();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> Mono&lt;StatefulRedisMasterReplicaConnection&lt;K, V&gt;&gt; <span class="title function_">initializeConnection</span><span class="params">(RedisCodec&lt;K, V&gt; codec,</span></span><br><span class="line"><span class="params">            SentinelTopologyRefresh sentinelTopologyRefresh, MasterReplicaConnectionProvider&lt;K, V&gt; connectionProvider,</span></span><br><span class="line"><span class="params">            Runnable runnable, List&lt;RedisNodeDescription&gt; nodes)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        CompletionStage&lt;Void&gt; bind = sentinelTopologyRefresh.bind(runnable); <span class="comment">// 绑定拓扑刷新函数</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看<code>SentinelTopologyRefresh</code>的定义，发现其存在成员<code>topologyRefresh</code>用于触发拓扑刷新。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SentinelTopologyRefresh.java</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SentinelTopologyRefresh</span> <span class="keyword">implements</span> <span class="title class_">AsyncCloseable</span>, Closeable &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PubSubMessageActionScheduler topologyRefresh; </span><br><span class="line">    ...</span><br><span class="line">    SentinelTopologyRefresh(RedisClient redisClient, String masterId, List&lt;RedisURI&gt; sentinels) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="built_in">this</span>.topologyRefresh = <span class="keyword">new</span> <span class="title class_">PubSubMessageActionScheduler</span>(redisClient.getResources().eventExecutorGroup(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">TopologyRefreshMessagePredicate</span>(masterId));</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续深入查找<code>MessagePredicate</code>的实现类<code>TopologyRefreshMessagePredicate</code>，发现内部实现了<code>test()</code>方法用于校验是否需要刷新拓扑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SentinelTopologyRefresh</span> <span class="keyword">implements</span> <span class="title class_">AsyncCloseable</span>, Closeable &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; PROCESSING_CHANNELS = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(</span><br><span class="line">            Arrays.asList(<span class="string">&quot;failover-end&quot;</span>, <span class="string">&quot;failover-end-for-timeout&quot;</span>));</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TopologyRefreshMessagePredicate</span> <span class="keyword">implements</span> <span class="title class_">MessagePredicate</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">private</span> Set&lt;String&gt; TOPOLOGY_CHANGE_CHANNELS = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(</span><br><span class="line">                Arrays.asList(<span class="string">&quot;+slave&quot;</span>, <span class="string">&quot;+sdown&quot;</span>, <span class="string">&quot;-sdown&quot;</span>, <span class="string">&quot;fix-slave-config&quot;</span>, <span class="string">&quot;+convert-to-slave&quot;</span>, <span class="string">&quot;+role-change&quot;</span>));</span><br><span class="line">        ...</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(String channel, String message)</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// trailing spaces after the master name are not bugs</span></span><br><span class="line">            <span class="keyword">if</span> (channel.equals(<span class="string">&quot;+elected-leader&quot;</span>) || channel.equals(<span class="string">&quot;+reset-master&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (message.startsWith(String.format(<span class="string">&quot;master %s &quot;</span>, masterId))) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (TOPOLOGY_CHANGE_CHANNELS.contains(channel)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (message.contains(String.format(<span class="string">&quot;@ %s &quot;</span>, masterId))) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (channel.equals(<span class="string">&quot;+switch-master&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (message.startsWith(String.format(<span class="string">&quot;%s &quot;</span>, masterId))) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> PROCESSING_CHANNELS.contains(channel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此哨兵接入模式的调用链路已经大致完全，lettuce哨兵这边会根据多个哨兵事件来刷新拓扑，但是假如地址仍合法则不会主动断开连接。</p>
<p>当redis哨兵介入提主后会主动kill掉存量连接，则此时lettuce感知到连接断开，会依据此前刷新的拓扑来重新连接，恢复正常。</p>
<p>假如operator介入自愈，则可能会主动reset哨兵，哨兵由此无法正常发送事件，导致lettuce拓扑刷新异常，最终无法连接到正确的节点。</p>
<p>不过lettuce这个逻辑感觉还是很多坑的，比如lettuce不会主动断开连接且为异步连接，则假如连接非正常断开，则lettuce这边可能就无法感知连接断开，导致连接一直异常不会触发重连。不过新版本的好像新增了tcp探活配置来解决这个问题。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>源码阅读</tag>
        <tag>Lettuce</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习记录：jedis哨兵模式接入拓扑刷新源码分析</title>
    <url>/2024/11/16/20241116_Redis%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9Ajedis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E6%8E%A5%E5%85%A5%E6%8B%93%E6%89%91%E5%88%B7%E6%96%B0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<ul>
<li><p>最近在做容器redis宕机自愈优化时遇到一个问题：用户使用jedis接入，若redis进行全量宕机后自愈，jedis可能无法感知主从角色变化导致readonly。</p>
</li>
<li><p>本篇文章简要记录一下排查过程和涉及到的部分源码分析。</p>
</li>
</ul>
<span id="more"></span>

<h1 id="一、问题背景"><a href="#一、问题背景" class="headerlink" title="一、问题背景"></a>一、问题背景</h1><h2 id="1-环境背景"><a href="#1-环境背景" class="headerlink" title="1.环境背景"></a>1.环境背景</h2><p>容器化部署一个哨兵集群与多个主从集群，用户通过哨兵对外暴露的地址与<code>&lt;MasterName&gt;</code>获取主从集群地址进行业务操作。</p>
<p>注：业务端使用jedis的<code>JedisSentinelPool</code>进行接入。</p>
<h2 id="2-模拟故障"><a href="#2-模拟故障" class="headerlink" title="2.模拟故障"></a>2.模拟故障</h2><p>手动删除一个主从集群中的所有主从实例pod，等待operator介入自愈。</p>
<p>operator检测到全量宕机，按顺序执行如下操作：</p>
<ol>
<li><p>拉起进程</p>
</li>
<li><p>进行选主</p>
</li>
<li><p>恢复复制关系</p>
</li>
<li><p>移除并重新添加哨兵监控配置</p>
</li>
</ol>
<p>等待自愈完成后，pod地址已全部变化，故哨兵中<code>&lt;MasterName&gt;</code>对应的主地址也已经变化。</p>
<h2 id="3-业务异常"><a href="#3-业务异常" class="headerlink" title="3.业务异常"></a>3.业务异常</h2><p>全量宕机故障注入后，jedis业务操作出现异常，持续重试且失败。</p>
<p>operator介入自愈完成后，集群状态已恢复正常，但存量的jedis业务客户端并未恢复，扔在重试且失败。</p>
<p>重启jedis业务客户端或新启动业务客户端，均可以正常操作主从集群。</p>
<p>使用lettuce客户端接入模拟此流程，可以正常恢复。</p>
<h1 id="二、相关源码分析"><a href="#二、相关源码分析" class="headerlink" title="二、相关源码分析"></a>二、相关源码分析</h1><blockquote>
<p>redis源码版本: 6.2.x<br>  jedis源码版本: 5.2.0</p>
</blockquote>
<p>这种故障场景，lettuce客户端可以正常自愈，但是jedis客户端不行，说明lettuce没有刷新主从实例拓扑。</p>
<p>之前看过lettuce源码，可以得知lettuce的主从拓扑刷新是通过订阅哨兵事件来实现的；所以首先推测jedis也是类似思路，猜测这次异常是因为jedis没有收到事件导致的。</p>
<h2 id="1-jedis源码"><a href="#1-jedis源码" class="headerlink" title="1. jedis源码"></a>1. jedis源码</h2><p>首先先找下<code>JedisSentinelPool</code>相关的源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/main/java/redis/clients/jedis/JedisSentinelPool.java +333</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">class</span> <span class="title class_">MasterListener</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">while</span> (running.get()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// double check that it is not being shutdown</span></span><br><span class="line">                <span class="keyword">if</span> (!running.get()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">final</span> <span class="type">HostAndPort</span> <span class="variable">hostPort</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HostAndPort</span>(host, port);</span><br><span class="line">                j = <span class="keyword">new</span> <span class="title class_">Jedis</span>(hostPort, sentinelClientConfig);</span><br><span class="line">        </span><br><span class="line">                <span class="comment">// 初始化拓扑</span></span><br><span class="line">                <span class="comment">// code for active refresh</span></span><br><span class="line">                List&lt;String&gt; masterAddr = j.sentinelGetMasterAddrByName(masterName);</span><br><span class="line">                <span class="keyword">if</span> (masterAddr == <span class="literal">null</span> || masterAddr.size() != <span class="number">2</span>) &#123;</span><br><span class="line">                    LOG.warn(<span class="string">&quot;Can not get master addr, master name: &#123;&#125;. Sentinel: &#123;&#125;.&quot;</span>, masterName,</span><br><span class="line">                        hostPort);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    initMaster(toHostAndPort(masterAddr));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 配置拓扑刷新事件</span></span><br><span class="line">                j.subscribe(<span class="keyword">new</span> <span class="title class_">JedisPubSub</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String channel, String message)</span> &#123;</span><br><span class="line">                    LOG.debug(<span class="string">&quot;Sentinel &#123;&#125; published: &#123;&#125;.&quot;</span>, hostPort, message);</span><br><span class="line"></span><br><span class="line">                    String[] switchMasterMsg = message.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (switchMasterMsg.length &gt; <span class="number">3</span>) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (masterName.equals(switchMasterMsg[<span class="number">0</span>])) &#123;</span><br><span class="line">                            <span class="comment">// 刷新拓扑</span></span><br><span class="line">                            initMaster(toHostAndPort(Arrays.asList(switchMasterMsg[<span class="number">3</span>], switchMasterMsg[<span class="number">4</span>])));</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            LOG.debug(</span><br><span class="line">                                <span class="string">&quot;Ignoring message on +switch-master for master name &#123;&#125;, our master name is &#123;&#125;&quot;</span>,</span><br><span class="line">                                switchMasterMsg[<span class="number">0</span>], masterName);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        LOG.error(<span class="string">&quot;Invalid message received on Sentinel &#123;&#125; on channel +switch-master: &#123;&#125;&quot;</span>,</span><br><span class="line">                            hostPort, message);</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="string">&quot;+switch-master&quot;</span>); <span class="comment">// 仅订阅switch-master事件</span></span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (JedisException e) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (running.get()) &#123;</span><br><span class="line">                    LOG.error(<span class="string">&quot;Lost connection to Sentinel at &#123;&#125;:&#123;&#125;. Sleeping 5000ms and retrying.&quot;</span>, host,</span><br><span class="line">                        port, e);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(subscribeRetryWaitTimeMillis);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">                        LOG.error(<span class="string">&quot;Sleep interrupted: &quot;</span>, e1);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    LOG.debug(<span class="string">&quot;Unsubscribing from Sentinel at &#123;&#125;:&#123;&#125;&quot;</span>, host, port);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (j != <span class="literal">null</span>) &#123;</span><br><span class="line">                    j.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出来，jedis这边刷新拓扑仅能通过<code>+switch-master</code>事件触发，没有像lettuce一样订阅多种事件。</p>
<p>而且拓扑刷新的操作也比较简单，就是把哨兵channel的msg拆解后直接更新。</p>
<h2 id="2-redis源码"><a href="#2-redis源码" class="headerlink" title="2. redis源码"></a>2. redis源码</h2><p>然后再看下<code>+switch-master</code>事件相关的源码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sentinel.c</span></span><br><span class="line"><span class="comment">// 按协议解析哨兵间hello消息</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sentinelProcessHelloMessage</span><span class="params">(<span class="type">char</span> *hello, <span class="type">int</span> hello_len)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (numtokens == <span class="number">8</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">/* Update master info if received configuration is newer. */</span></span><br><span class="line">        <span class="keyword">if</span> (si &amp;&amp; master-&gt;config_epoch &lt; master_config_epoch) &#123;</span><br><span class="line">            master-&gt;config_epoch = master_config_epoch;</span><br><span class="line">            <span class="keyword">if</span> (master_port != master-&gt;addr-&gt;port ||</span><br><span class="line">                !sentinelAddrEqualsHostname(master-&gt;addr, token[<span class="number">5</span>]))</span><br><span class="line">            &#123;</span><br><span class="line">                sentinelAddr *old_addr;</span><br><span class="line"></span><br><span class="line">                sentinelEvent(LL_WARNING,<span class="string">&quot;+config-update-from&quot;</span>,si,<span class="string">&quot;%@&quot;</span>);</span><br><span class="line">                sentinelEvent(LL_WARNING,<span class="string">&quot;+switch-master&quot;</span>,</span><br><span class="line">                    master,<span class="string">&quot;%s %s %d %s %d&quot;</span>,</span><br><span class="line">                    master-&gt;name,</span><br><span class="line">                    announceSentinelAddr(master-&gt;addr), master-&gt;addr-&gt;port,</span><br><span class="line">                    token[<span class="number">5</span>], master_port);</span><br><span class="line"></span><br><span class="line">                old_addr = dupSentinelAddr(master-&gt;addr);</span><br><span class="line">                sentinelResetMasterAndChangeAddress(master, token[<span class="number">5</span>], master_port);</span><br><span class="line">                sentinelCallClientReconfScript(master,</span><br><span class="line">                    SENTINEL_OBSERVER,<span class="string">&quot;start&quot;</span>,</span><br><span class="line">                    old_addr,master-&gt;addr);</span><br><span class="line">                releaseSentinelAddr(old_addr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// sentinel.c</span></span><br><span class="line"><span class="comment">// 用于将从实例提升为主</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sentinelFailoverSwitchToPromotedSlave</span><span class="params">(sentinelRedisInstance *master)</span> &#123;</span><br><span class="line">    sentinelRedisInstance *ref = master-&gt;promoted_slave ?</span><br><span class="line">                                 master-&gt;promoted_slave : master;</span><br><span class="line"></span><br><span class="line">    sentinelEvent(LL_WARNING,<span class="string">&quot;+switch-master&quot;</span>,master,<span class="string">&quot;%s %s %d %s %d&quot;</span>,</span><br><span class="line">        master-&gt;name, announceSentinelAddr(master-&gt;addr), master-&gt;addr-&gt;port,</span><br><span class="line">        announceSentinelAddr(ref-&gt;addr), ref-&gt;addr-&gt;port);</span><br><span class="line"></span><br><span class="line">    sentinelResetMasterAndChangeAddress(master,ref-&gt;addr-&gt;hostname,ref-&gt;addr-&gt;port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在redis中，<code>+switch-master</code>事件只会在两种情况下被发出，相关源码如上。</p>
<ol>
<li><p>哨兵配置过期，通过其余哨兵同步配置后，会发出<code>+switch-master</code>事件。</p>
</li>
<li><p>哨兵触发failover，且走到了需要将从实例提升为主的步骤后，会发出<code>+switch-master</code>事件。</p>
</li>
</ol>
<h1 id="三、问题原因分析"><a href="#三、问题原因分析" class="headerlink" title="三、问题原因分析"></a>三、问题原因分析</h1><p>通过上文，可以较为清晰的汇总出如下信息：</p>
<ol>
<li><p>使用jedis作为业务客户端接入哨兵主从，jedis通过<code>+switch-master</code>事件刷新拓扑。</p>
</li>
<li><p>当redis哨兵间不存在过期配置时，redis仅在<code>failover</code>流程中发出<code>+switch-master</code>事件。</p>
</li>
<li><p>全量宕机场景operator介入自愈时，未触发<code>failover</code>流程。</p>
</li>
</ol>
<p>由此问题已经被发现，即jedis使用哨兵接入时，并未考虑到全量宕机恢复这种场景，jedis仅能通过<code>+switch-master</code>事件来感知拓扑变化。</p>
<p>lettuce在这方面显然做的更全面一些，会监听多种哨兵事件来刷新拓扑，所以在operator介入自愈后，可以通过感知其他事件来刷新拓扑。</p>
<h1 id="四、问题解决"><a href="#四、问题解决" class="headerlink" title="四、问题解决"></a>四、问题解决</h1><p>上文已知问题根因为jedis未感知拓扑变化，所以我们手动触发一次<code>failover</code>流程让jedis感知即可。</p>
<p>经过测试，在手动触发<code>failover</code>流程后，jedis业务客户端恢复，可以正常执行业务操作。</p>
<p>从operator视角来看，全量宕机自愈之后，自动触发一次<code>failover</code>流程理论上也能解决这个问题，但是<code>failover</code>流程相对不可控因素太多了，不太稳定。</p>
<p>所以operator这边暂时不进行适配，考虑到这种场景概率还是比较低的，我觉得提供SOP手册即可。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>源码阅读</tag>
        <tag>Jedis</tag>
      </tags>
  </entry>
</search>
