<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>dfs学习记录：模板/思路汇总</title>
    <url>/2020/08/13/20200813_dfs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%80%9D%E8%B7%AF%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p><strong>HB小咸鱼学习记录</strong></p>
<p><strong>因为疫情</strong>，大一在校半年便草草结束了，大二转眼将至。<br>疫情期间在家没事便抽空预习了预习大二要学的数据结构。<br>思来想去还是决定把学习的过程记录下来，方便自己以后查阅或者总结。</p>
<span id="more"></span>

<h1 id="一点看法"><a href="#一点看法" class="headerlink" title="一点看法"></a>一点看法</h1><p>在我看来，计算机的一大优势便是计算速度快。由此，人们在对某些问题的计算方面上，就不用像高斯找到1加到100的特殊技巧那样费力寻找技巧，直接依靠着计算机的计算力从1直接加到100就好。这种不需要技巧的运算方式就是暴力运算。而当你需要对图进行搜索的时候，最基础的就是暴力搜索。<br>就我目前的接触而言，常见的暴力搜索方式便是深度优先遍历与广度优先遍历了。</p>
<h1 id="自我对于“深度优先搜索”的理解"><a href="#自我对于“深度优先搜索”的理解" class="headerlink" title="自我对于“深度优先搜索”的理解"></a>自我对于“深度优先搜索”的理解</h1><p>dfs,字面来看就是以深度为优先的搜索方式。用通俗点来讲就是一条道走到黑。<br>就像我们规定以“前左右”的顺序走迷宫，而在寻找迷宫的出口时就可以看成进行了一次搜索。这样首先便是一直向前走下去。直到前面没有路了，我们就按照“前左右”再向左走，要是左边还走不通就再向右走直到走到死胡同里。当走到死胡同里的时候说明我们走完了一条迷宫的支线，此时我们可以认为自己单刀直入了这条支线的最深处。此时我们还需要找迷宫的出口，于是我们后退到上一个交叉路口的位置，按照“前左右”的顺序寻找一个没有进入过的支线。如果这个路口的支线已经全部走过，则再次后退到上一个交叉路口进行搜索	……直到找到出口。<br>由此看来，如果运气好，我们第一次走便可能直接走到出口；但是运气差的话，可能把整个迷宫走完才能找到出口。</p>
<h1 id="dfs的大致思路"><a href="#dfs的大致思路" class="headerlink" title="dfs的大致思路"></a>dfs的大致思路</h1><p><strong>首先</strong>，如上个片段所说，我们首先需要一个二维数组，来储存迷宫的大致情况，包括可以走的路、障碍物、入口、出口……<br><strong>其次</strong>，我们对于已经走过的分叉路口要进行标记，防止进入已经进入过的路口，就像在走迷宫时你会主动避开走过的路线一样。这个通常用一个与上面地图大小相同的二维数组来储存坐标的状态。例如<strong>false</strong>代表没走过，<strong>true</strong>代表走过。<br><strong>接着</strong>，我们需要对移动的规则进行规定。例如上文的例子规定的“上左右”，我们可以用一个二维数组来储存移动后坐标的变化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> direction[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;; </span><br></pre></td></tr></table></figure>
<p>这个数组里面的四组数据就分别代表“上左右下”，在对坐标变换时进行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x1=x+direction[a][<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span> y1=y+direction[a][<span class="number">1</span>]; </span><br></pre></td></tr></table></figure>
<p>即可实现对坐标的变化。且在变化后将x1,y1的点的状态进行更改，代表你已经来过这里了。<br>而当你到达死路进行后退且前往别的点的时候，记得把刚来过的点的状态进行更改，使下一次也能前往。<br><strong>最后</strong>，我们需要进行判定，从而在找到出口时停止或者返回一些信息。</p>
<h1 id="dfs的大致模板"><a href="#dfs的大致模板" class="headerlink" title="dfs的大致模板"></a>dfs的大致模板</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(当前点位的信息)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(到达中止条件)</span><br><span class="line">	&#123;</span><br><span class="line">		执行一些东西;</span><br><span class="line">		<span class="keyword">return</span>; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">if</span>(当前点位越界或者不符合规定)<span class="comment">//即进行剪枝</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">for</span>(按照搜索的方向进行循环)</span><br><span class="line">	&#123;</span><br><span class="line">		根据当前点位进行修改得到新点位;</span><br><span class="line">		<span class="keyword">if</span>(新点位可以前往)</span><br><span class="line">		&#123;</span><br><span class="line">			执行一些东西;</span><br><span class="line">			把新点位标记;</span><br><span class="line">			<span class="built_in">dfs</span>(新点位的信息);</span><br><span class="line">			取消新点位的标记; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照上面的思路大致可写以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> map[<span class="number">100</span>][<span class="number">100</span>];		<span class="comment">//地图 其中值为0则代表可走 </span></span><br><span class="line"><span class="type">bool</span> b_map[<span class="number">100</span>][<span class="number">100</span>];		<span class="comment">//点状态集	值为false代表没被走过 true代表被走过 </span></span><br><span class="line"><span class="type">int</span> direction[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;; 		<span class="comment">//搜索方向坐标变化集 </span></span><br><span class="line"><span class="type">int</span> X,Y;	<span class="comment">//终点坐标 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> times)</span>		<span class="comment">//传入当前点的x,y坐标以及走的次数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==X&amp;&amp;y==Y)		<span class="comment">//当走到出口时 </span></span><br><span class="line">	&#123;</span><br><span class="line">		std::cout&lt;&lt;times&lt;&lt;<span class="string">&quot;\n&quot;</span>;		<span class="comment">//输出走的步数 </span></span><br><span class="line">		<span class="keyword">return</span>; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">0</span>;a&lt;<span class="number">4</span>;a++)   	 <span class="comment">//对搜索方向进行遍历  </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x1=x+direction[a][<span class="number">0</span>];	 <span class="comment">//x加上当前搜索方向的变化 </span></span><br><span class="line">		<span class="type">int</span> y1=y+direction[a][<span class="number">1</span>]; 	 <span class="comment">//y加上当前搜索方向的变化 </span></span><br><span class="line">		<span class="keyword">if</span>(!map[x1][y1]&amp;&amp;!b_map[x1][y1])	<span class="comment">//判定x1,y1点是否可走 </span></span><br><span class="line">		&#123;</span><br><span class="line">			b_map[x1][y1] = <span class="literal">true</span>;	 <span class="comment">//可走的话就标记以走过 </span></span><br><span class="line">			<span class="built_in">dfs</span>(x1,y1,time<span class="number">+1</span>);		<span class="comment">//递归 传入新点位的坐标 以及走的次数加一 进行下一个坐标点的判定 </span></span><br><span class="line">			b_map[x1][y1] = <span class="literal">false</span>;	  <span class="comment">//取消标记 表示该线路以及搜索完毕 </span></span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="dfs的相关例题"><a href="#dfs的相关例题" class="headerlink" title="dfs的相关例题"></a>dfs的相关例题</h1><p>dfs虽然搜索细致，但是在搜索过程中会进行大量的无意义运算，浪费时间，于是在运算中就要进行“剪枝”，即根据所求信息增加判定要求，从而最大限度的减少递归的调用次数，加快运算时间。</p>
<h2 id="1-蓝桥杯-迷宫"><a href="#1-蓝桥杯-迷宫" class="headerlink" title="1.蓝桥杯 迷宫"></a>1.蓝桥杯 迷宫</h2><p><img src="/images/2020-08-13/1.jpg" alt="蓝桥杯 迷宫"><br><a href="http://oj.ecustacm.cn/problem.php?id=1455">OJ链接</a></p>
<p><strong>思路：</strong> 在这道蓝桥杯的题目里，由于是求最短路径，所以用<strong>bfs</strong>来写比较简单。用<strong>dfs</strong>来写的话由于数据过大，不剪枝或者剪的不够的话稳稳的超时。<br>但是我们可以引入一个与图一样大小的二维数组，该数组用来储存到达该点的最小步数。则如果在递归中，当前步数大于当前点的最小步数，说明到达当前点多走歪路了，则中止递归。<br>在该条件的约束下，该dfs的运算效率得到了极大的提升。</p>
<p><strong>AC代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X 30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Y 50 </span></span><br><span class="line"><span class="type">int</span> a_map[<span class="number">31</span>][<span class="number">51</span>],ans=<span class="number">100000000</span>,zhj=<span class="number">100000000</span>;</span><br><span class="line"><span class="type">bool</span> b_map[<span class="number">31</span>][<span class="number">51</span>];</span><br><span class="line"><span class="type">char</span> fx[<span class="number">10000</span>];</span><br><span class="line"><span class="type">char</span> t_fx[<span class="number">10000</span>];</span><br><span class="line"><span class="type">int</span> z_4[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;; </span><br><span class="line"><span class="type">char</span> z[<span class="number">4</span>] = &#123;<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;L&#x27;</span>,<span class="string">&#x27;R&#x27;</span>,<span class="string">&#x27;U&#x27;</span>&#125;;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">31</span>][<span class="number">51</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> time,<span class="type">int</span> he)</span><span class="comment">//当前点的x,y坐标 走的步数 当前的路程权值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==X&amp;&amp;y==Y)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(time&lt;zhj&amp;&amp;he&lt;ans)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;time;now++)</span><br><span class="line">				fx[now]=t_fx[now];</span><br><span class="line">			zhj=time<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">0</span>;a&lt;<span class="number">4</span>;a++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(he+z[a]&gt;ans)<span class="comment">//条件判定</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="type">int</span> x1=x+z_4[a][<span class="number">0</span>];</span><br><span class="line">		<span class="type">int</span> y1=y+z_4[a][<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(x1&lt;<span class="number">1</span> || y1&lt;<span class="number">1</span> || x1&gt;X || y1&gt;Y)<span class="comment">//条件判定</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(b_map[x1][y1])<span class="comment">//条件判定</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(time<span class="number">+1</span>&gt;dp[x1][y1])<span class="comment">//条件判定</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		dp[x1][y1]=time<span class="number">+1</span>;<span class="comment">//当前点的最小步数更新</span></span><br><span class="line">		b_map[x1][y1]=<span class="literal">true</span>;</span><br><span class="line">		t_fx[time] = z[a];</span><br><span class="line">		<span class="built_in">dfs</span>(x1,y1,time<span class="number">+1</span>,he+z[a]);</span><br><span class="line">		b_map[x1][y1]=<span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(fx,<span class="number">0</span>,<span class="built_in">sizeof</span>(fx));</span><br><span class="line">	<span class="built_in">memset</span>(a_map,<span class="number">0</span>,<span class="built_in">sizeof</span>(a_map));</span><br><span class="line">	<span class="built_in">memset</span>(b_map,<span class="literal">false</span>,<span class="built_in">sizeof</span>(b_map));</span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">999999</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">1</span>;a&lt;=X;a++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> b=<span class="number">1</span>;b&lt;=Y;b++)</span><br><span class="line">		&#123;</span><br><span class="line">			a_map[a][b] = <span class="built_in">getchar</span>()-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">			<span class="keyword">if</span>(a_map[a][b]==<span class="number">1</span>)</span><br><span class="line">				b_map[a][b]=<span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	b_map[<span class="number">1</span>][<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;=zhj;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,fx[now]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/jziwjxjd/article/details/104078653">该思路原地址</a></p>
<h2 id="2-蓝桥杯-全球变暖"><a href="#2-蓝桥杯-全球变暖" class="headerlink" title="2.蓝桥杯 全球变暖"></a>2.蓝桥杯 全球变暖</h2><p><strong>题目</strong><br>你有一张某海域NxN像素的照片，”.”表示海洋、”#”表示陆地，如下所示：<br><img src="/images/2020-08-13/2.jpg" alt="1"></p>
<p>其中”上下左右”四个方向上连在一起的一片陆地组成一座岛屿。例如上图就有2座岛屿。<br>由于全球变暖导致了海面上升，科学家预测未来几十年，岛屿边缘一个像素的范围会被海水淹没。<br>具体来说如果一块陆地像素与海洋相邻(上下左右四个相邻像素中有海洋)，它就会被淹没。<br>例如上图中的海域未来会变成如下样子：<br><img src="/images/2020-08-13/3.jpg" alt="2"></p>
<p>请你计算：依照科学家的预测，照片中有多少岛屿会被完全淹没。</p>
<p><strong>输入</strong><br>第一行包含一个整数N。  (1 &lt;&#x3D; N &lt;&#x3D; 1000)<br>以下N行N列代表一张海域照片。<br>照片保证第1行、第1列、第N行、第N列的像素都是海洋。  </p>
<p><strong>输出</strong><br>一个整数表示答案。</p>
<p><strong>样例输入</strong><br><img src="/images/2020-08-13/4.jpg" alt="3"><br><strong>样例输出</strong><br>1</p>
<p><a href="http://oj.ecustacm.cn/problem.php?id=1365">OJ链接</a></p>
<p><strong>思路</strong>：在接收初始图之后，<strong>首先</strong>搜索查找初始岛屿数，在找到一个岛屿后，对整个岛屿进行标记，防止重复计数。<strong>随后</strong>再次进行搜索，如果有四周均为陆地的坐标，则标记此坐标未被淹没。<strong>最后</strong>查找所有未被淹没的坐标，并将坐标所处的整个岛标记，防止重复计数。初始岛屿数量减去未被淹没岛的数量，即为被淹没的岛的数量。</p>
<p><strong>AC代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> maps[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(maps[x][y]!=<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	maps[x][y]=<span class="string">&#x27;1&#x27;</span>;<span class="comment">//将#标记为1 </span></span><br><span class="line">	<span class="built_in">dfs1</span>(x<span class="number">+1</span>,y);<span class="comment">//把整个岛都进行标记 防止重复计算 </span></span><br><span class="line">	<span class="built_in">dfs1</span>(x<span class="number">-1</span>,y);</span><br><span class="line">	<span class="built_in">dfs1</span>(x,y<span class="number">+1</span>);</span><br><span class="line">	<span class="built_in">dfs1</span>(x,y<span class="number">-1</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(maps[x][y]==<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(maps[x<span class="number">+1</span>][y]==<span class="string">&#x27;1&#x27;</span>&amp;&amp;maps[x<span class="number">-1</span>][y]==<span class="string">&#x27;1&#x27;</span>&amp;&amp;maps[x][y<span class="number">+1</span>]==<span class="string">&#x27;1&#x27;</span>&amp;&amp;maps[x][y<span class="number">-1</span>]==<span class="string">&#x27;1&#x27;</span>)<span class="comment">//四周都是陆地 则标记为2</span></span><br><span class="line">	&#123;	</span><br><span class="line">		maps[x][y]=<span class="string">&#x27;2&#x27;</span>; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">dfs1</span>(x<span class="number">+1</span>,y);<span class="comment">//找4个方向 </span></span><br><span class="line">	<span class="built_in">dfs1</span>(x<span class="number">-1</span>,y);</span><br><span class="line">	<span class="built_in">dfs1</span>(x,y<span class="number">+1</span>);</span><br><span class="line">	<span class="built_in">dfs1</span>(x,y<span class="number">-1</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs3</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(maps[x][y]==<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	maps[x][y]=<span class="string">&#x27;.&#x27;</span>;<span class="comment">//将#标记为 . </span></span><br><span class="line">	<span class="built_in">dfs3</span>(x<span class="number">+1</span>,y);<span class="comment">//把整个岛都进行沉没操作 防止重复计算 </span></span><br><span class="line">	<span class="built_in">dfs3</span>(x<span class="number">-1</span>,y);</span><br><span class="line">	<span class="built_in">dfs3</span>(x,y<span class="number">+1</span>);</span><br><span class="line">	<span class="built_in">dfs3</span>(x,y<span class="number">-1</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,first_num=<span class="number">0</span>,end_num=<span class="number">0</span>;<span class="comment">//层数 初始岛屿数量 末尾岛屿数量 </span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n); </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">1</span>;a&lt;=n;a++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> b=<span class="number">1</span>;b&lt;=n;b++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;maps[a][b]);</span><br><span class="line">				<span class="keyword">if</span>(maps[a][b]==<span class="string">&#x27;.&#x27;</span>||maps[a][b]==<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//先查找有多少个岛屿 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">1</span>;a&lt;=n;a++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> b=<span class="number">1</span>;b&lt;=n;b++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(maps[a][b]==<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">dfs1</span>(a,b);</span><br><span class="line">				first_num++;<span class="comment">//初始岛屿+1 </span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//再对整个岛屿进行变化</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">1</span>;a&lt;=n;a++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> b=<span class="number">1</span>;b&lt;=n;b++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(maps[a][b]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">dfs2</span>(a,b);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//最后查找剩余多少个岛屿 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">1</span>;a&lt;=n;a++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> b=<span class="number">1</span>;b&lt;=n;b++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(maps[a][b]==<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">dfs3</span>(a,b);</span><br><span class="line">				end_num++;<span class="comment">//最终岛屿+1 </span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;first_num-end_num;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="3-leetcode-路径总和"><a href="#3-leetcode-路径总和" class="headerlink" title="3.leetcode 路径总和"></a>3.leetcode 路径总和</h2><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。<br>说明: 叶子节点是指没有子节点的节点。</p>
<p><strong>示例:</strong><br>给定如下二叉树，以及目标和 sum &#x3D; 22，</p>
<pre><code>          5
         / \
        4   8
       /   / \
      11  13  4
     /  \      \
    7    2      1
</code></pre>
<p>返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/path-sum">https://leetcode-cn.com/problems/path-sum</a> <a href="https://leetcode-cn.com/problems/path-sum/">OJ链接</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p><strong>AC代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> sum)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        kg=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">dfs</span>(root,root-&gt;val,sum);</span><br><span class="line">        <span class="keyword">return</span> kg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="type">int</span> now,<span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(now==end&amp;&amp;root-&gt;left==<span class="literal">NULL</span>&amp;&amp;root-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            kg = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span>&amp;&amp;root-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">dfs</span>(root-&gt;left,now+root-&gt;left-&gt;val,end);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right!=<span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">dfs</span>(root-&gt;right,now+root-&gt;right-&gt;val,end);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> kg;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="4-leetcode-路径总和II"><a href="#4-leetcode-路径总和II" class="headerlink" title="4.leetcode 路径总和II"></a>4.leetcode 路径总和II</h2><p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。<br>说明: 叶子节点是指没有子节点的节点。</p>
<p><strong>示例:</strong><br>给定如下二叉树，以及目标和 sum &#x3D; 22，</p>
<pre><code>          5
         / \
        4   8
       /   / \
      11  13  4
     /  \    / \
    7    2  5   1
</code></pre>
<p>返回:</p>
<p>[<br>   [5,4,11,2],<br>   [5,8,4,5]<br>]</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/path-sum-ii">https://leetcode-cn.com/problems/path-sum-ii</a> <a href="https://leetcode-cn.com/problems/path-sum-ii/">OJ链接</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p><strong>AC代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="type">int</span> sum) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            <span class="built_in">dfs</span>(root,sum-root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ps;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;ps;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;temp;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(end==<span class="number">0</span>&amp;&amp;!root-&gt;left&amp;&amp;!root-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt;t=temp;</span><br><span class="line">            ps.<span class="built_in">push_back</span>(t);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left&amp;&amp;!root-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(root-&gt;left-&gt;val);</span><br><span class="line">            <span class="built_in">dfs</span>(root-&gt;left,end-root-&gt;left-&gt;val);</span><br><span class="line">            temp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(root-&gt;right-&gt;val);</span><br><span class="line">            <span class="built_in">dfs</span>(root-&gt;right,end-root-&gt;right-&gt;val);</span><br><span class="line">            temp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p><strong>在使用dfs中，要根据题目数据选择合适的数据类型。</strong><br>比如在题目数据过大时，申请较大的二维数组很容易失败。即使申请成功也会造成极大的内存浪费，循环时也很不方便。<br>这时就可以使用stl里的vector来储存数据，可以很好的提高的数据获取效率。<br><strong>要尽量多的进行筛选，增加效率</strong><br>好多题不止考的是dfs，甚至会考一点dp，所以要多想多做，寻找搜索中的共同点并对症下药。<br><strong>dfs的常用环境</strong><br>找最长路，特殊路等等等等。一般对带权图的搜索都用dfs。<br>在刷蓝桥杯的题的途中发现好多题都可以用dfs进行暴力，但是往往会超时。要想ac还得换题目想让你用的方法。但是往往能过几个检测点，所以不会的题都可以dfs一下混点分哈哈哈哈哈。<br><strong>总之，还是得多刷题，多积累经验。</strong></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>bfs学习记录：模板/思路汇总</title>
    <url>/2020/08/14/20200814_bfs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%80%9D%E8%B7%AF%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p><strong>HB小咸鱼学习记录</strong></p>
<h1 id="一点看法"><a href="#一点看法" class="headerlink" title="一点看法"></a>一点看法</h1><p>蓝桥杯刷了不少的搜索题，但是bfs的题很少，大部分都是dfs的题。<br>但是去年蓝桥杯就考了bfs，所以还是得好好刷题。<br>bfs由于是一个循环进行搜索，所以没法回溯，因而每个点位只能被走一次。这样加快了搜索速度，但是由于每个点只能走一次导致无法列举出所有的可走路径。而这样的好处是避免了绕远路，搜索到结果时一定是最短路。所以大部分的求最短路的题都用bfs.</p>
<span id="more"></span>

<h1 id="自我对于“广度优先搜索”的理解"><a href="#自我对于“广度优先搜索”的理解" class="headerlink" title="自我对于“广度优先搜索”的理解"></a>自我对于“广度优先搜索”的理解</h1><p>bfs,字面来看就是以广度为优先的搜索方式。搜索时以原点向四周扩散。如果说dfs是“搜完一个屋子再搜另一个屋子”，那bfs就是“把每个屋子的柜子搜了再搜每个屋子的桌子……”这样层层深入的搜索。这样可以优先搜索物品可能在的地方，从而减少搜索的时间。<br>就像我们规定以“前左右”的顺序走迷宫，而在寻找迷宫的出口时就可以看成进行了一次搜索。我们首先记录下来第一个路口能前往哪几个路口，随后再按照规定的顺序（前左右）查看这几个路口的又能前往哪几个路口。途中前往过的路口要进行标记，防止重复的查看。直到查看一个路口，它可以前往到终点或者它就是终点，此时搜索结束。我们查看的轮数就是前往该终点的最小步数。而在搜索过程中，我们可以使用适当的数据结构来储存前往终点所经过的路口，这就是最短路径。<br>这样进行搜索的范围大，查找到终点的路径始终是最短路径。但缺点是我们没办法迭代出所有的可前往终点的路径。</p>
<h1 id="bfs的大致思路"><a href="#bfs的大致思路" class="headerlink" title="bfs的大致思路"></a>bfs的大致思路</h1><p><strong>首先</strong>，如上个片段所说，我们首先需要一个二维数组，来对迷宫进行标记，标记出可以走的点和障碍（不可以走的点）。<br><strong>其次</strong>，我们建立一个队列，把起点加入到队列中。<br><strong>接着</strong>，我们建立一个while循环，设定在队列不为空的时候执行循环。<br>循环中，我们首先获取队列的头结点坐标，随后我们需要对移动的规则进行规定。例如上文的例子规定的“上左右”，我们可以用一个二维数组来储存移动后坐标的变化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> direction[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;; </span><br></pre></td></tr></table></figure>
<p>这个数组里面的四组数据就分别代表“上左右下”，在对坐标变换时进行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x1=x+direction[a][<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span> y1=y+direction[a][<span class="number">1</span>]; </span><br></pre></td></tr></table></figure>
<p>即可实现对坐标的变化。我们按照这个顺序，对头结点的周围进行判断，如果可以前往的话，就将变换后的数据点加入队列。然后将新点（x1,y1）的状态进行更改，代表你已经来过这里了。防止重复的搜索。<br><strong>最后</strong>，我们需要设定上一步循环的中止条件，从而在找到出口时停止或者返回一些信息。我们常常在循环中获取头结点后进行判定，如果头结点数据是我们想要搜索到的信息，我们就中止循环。</p>
<h1 id="bfs的大致模板"><a href="#bfs的大致模板" class="headerlink" title="bfs的大致模板"></a>bfs的大致模板</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(传入的数据)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt;q; <span class="comment">//建立一个队列</span></span><br><span class="line">	q.<span class="built_in">push</span>(初始坐标); <span class="comment">//把头结点（初始点）加入队列</span></span><br><span class="line">	<span class="keyword">while</span>(队列不为空) </span><br><span class="line">	&#123;</span><br><span class="line">		top = q.<span class="built_in">front</span>(); <span class="comment">//取出队首元素top</span></span><br><span class="line">		<span class="keyword">if</span>(队首元素top就是你要搜索的目标) </span><br><span class="line">		&#123;</span><br><span class="line">			执行一些操作</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		top.<span class="built_in">pop</span>(); <span class="comment">//将队首元素出队；</span></span><br><span class="line">		<span class="keyword">for</span>(按顺序寻找top的所有子节点)</span><br><span class="line">		&#123;</span><br><span class="line">			把可以前往的子节点入队</span><br><span class="line">			标记入队的子节点，防止下次重复入队</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h1 id="bfs例题"><a href="#bfs例题" class="headerlink" title="bfs例题"></a>bfs例题</h1><h2 id="蓝桥杯-学霸的迷宫"><a href="#蓝桥杯-学霸的迷宫" class="headerlink" title="蓝桥杯 学霸的迷宫"></a>蓝桥杯 学霸的迷宫</h2><p><img src="/images/2020-08-14/1.jpg#pic_center" alt="题干"><br><strong>样例输入</strong><br>Input Sample 1:<br>3 3<br>001<br>100<br>110<br><strong>样例输出</strong><br>Output Sample 1:<br>4<br>RDRD</p>
<p><a href="http://lx.lanqiao.cn/problem.page?gpid=T291"><strong>题目链接</strong></a></p>
<p>这一题算是bfs的经典例题，题目不止让求了最短的步数，还让输出了最短的路径。<br>所以我们在队列结点的数据结构中添加了一个string字符串，用来储存到达某个点的最短路径。<br>在找到终点时，输出最短步数和最短路径即可。<br><strong>ac代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">data</span>	<span class="comment">//队列里的数据结构 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x;	<span class="comment">//坐标x </span></span><br><span class="line">	<span class="type">int</span> y;	<span class="comment">//坐标y </span></span><br><span class="line">	<span class="type">int</span> times;	<span class="comment">//步数 </span></span><br><span class="line">	string road;	<span class="comment">//走过的路径</span></span><br><span class="line">	<span class="built_in">data</span>(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> d,string c)	<span class="comment">//构造函数 </span></span><br><span class="line">	&#123;</span><br><span class="line">		x=a;</span><br><span class="line">		y=b;</span><br><span class="line">		times=d;</span><br><span class="line">		road = c;	</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;;</span><br><span class="line">queue&lt;data&gt;datas;	<span class="comment">//队列用来存放点位数据 </span></span><br><span class="line"><span class="type">bool</span> maps[<span class="number">501</span>][<span class="number">501</span>];	<span class="comment">//存放迷宫地图的点位 false代表可前往 true代表不可前往 </span></span><br><span class="line"><span class="type">char</span> fx[] = &#123;<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;L&#x27;</span>,<span class="string">&#x27;R&#x27;</span>,<span class="string">&#x27;U&#x27;</span>&#125;;	<span class="comment">//方向ascii码从小到大排列 </span></span><br><span class="line"><span class="type">int</span> site[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;	<span class="comment">//下 左 右 上的坐标变化 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span>	<span class="comment">//传参为迷宫的大小 n为宽 m为长 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	datas.<span class="built_in">push</span>(<span class="built_in">data</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="string">&quot;&quot;</span>));	<span class="comment">//把起始点压入队列 </span></span><br><span class="line">	maps[<span class="number">1</span>][<span class="number">1</span>]=<span class="literal">true</span>;	<span class="comment">//标记初始点已走过 </span></span><br><span class="line">	<span class="keyword">while</span>(!datas.<span class="built_in">empty</span>())	<span class="comment">//如果队列不为空 </span></span><br><span class="line">	&#123;</span><br><span class="line">		data now = datas.<span class="built_in">front</span>();	<span class="comment">//声明一个结构体变量 让now变量指向队列的头结点</span></span><br><span class="line">		datas.<span class="built_in">pop</span>();	<span class="comment">//弹出头结点 </span></span><br><span class="line">		<span class="comment">//cout&lt;&lt;now.x&lt;&lt;&quot; &quot;&lt;&lt;now.y&lt;&lt;endl; </span></span><br><span class="line">		<span class="keyword">if</span>(now.x==n&amp;&amp;now.y==m)	<span class="comment">//如果头结点就是要找的点 就搜索结束 </span></span><br><span class="line">		&#123;</span><br><span class="line">			cout&lt;&lt;now.times&lt;&lt;endl&lt;&lt;now.road&lt;&lt;endl;	<span class="comment">//输出走过的路径 和步数 </span></span><br><span class="line">			<span class="keyword">return</span>; </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> temp=<span class="number">0</span>;temp&lt;<span class="number">4</span>;temp++)	<span class="comment">//开始查找该点的四周点位 （因为只有上下左右4个走法 所以循4次 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> x1=now.x+site[temp][<span class="number">0</span>];	<span class="comment">//变换过的x坐标 </span></span><br><span class="line">			<span class="type">int</span> y1=now.y+site[temp][<span class="number">1</span>]; <span class="comment">//变换过的y坐标 </span></span><br><span class="line">			<span class="keyword">if</span>(maps[y1][x1])	<span class="comment">//如果该点已经走过或者有障碍 跳过 </span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(x1&lt;<span class="number">1</span>||y1&lt;<span class="number">1</span>||x1&gt;n||y1&gt;m) 	<span class="comment">//如果坐标超出范围 就跳过此循环</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			datas.<span class="built_in">push</span>(<span class="built_in">data</span>(x1,y1,now.times<span class="number">+1</span>,now.road+fx[temp]));	<span class="comment">//把新点位压入队列 路径加上新选择的fx[temp] </span></span><br><span class="line">			maps[y1][x1] = <span class="literal">true</span>;	<span class="comment">//标记已走过 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(maps,<span class="literal">false</span>,<span class="built_in">sizeof</span>(maps));		<span class="comment">//初始化 </span></span><br><span class="line">	<span class="type">int</span> x,y;	<span class="comment">//接收迷宫大小</span></span><br><span class="line">	<span class="type">char</span> input;	</span><br><span class="line">	cin&gt;&gt;y&gt;&gt;x;</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> y1=<span class="number">1</span>;y1&lt;=y;y1++) 	<span class="comment">//迷宫长 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> x1=<span class="number">1</span>;x1&lt;=x;x1++)	<span class="comment">//迷宫宽 </span></span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;input;</span><br><span class="line">			<span class="keyword">if</span>(input==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">				maps[y1][x1]=<span class="literal">true</span>;	<span class="comment">//如果输入是1就标记不可走</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="built_in">bfs</span>(x,y);	<span class="comment">//bfs 迷宫长宽 与 xy坐标是相反的 所以传反着的坐标 </span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p><strong>在使用bfs中，要根据题目数据选择合适的数据类型。</strong><br>bfs的题中往往不会只让你输出最短路径的长度，一般还会带点别的东西，所以要建立合适的结构来储存数据。<br><strong>bfs的常用环境</strong><br>一般是用来寻找不带权值的图的最短路。问题关键词常为“能否到达”、“最短路径”。<br>目前来看蓝桥杯中对bfs的考察度往往低于dfs，但是蓝桥杯最近几年对bfs的考察也在变多，所以还得好好练。<br><strong>总之，还是得多刷题，多积累经验。</strong></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集学习记录：模板/思路汇总</title>
    <url>/2020/08/19/20200819_%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%80%9D%E8%B7%AF%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p><strong>HB小咸鱼学习记录</strong></p>
<h1 id="自我对于“并查集”的理解"><a href="#自我对于“并查集”的理解" class="headerlink" title="自我对于“并查集”的理解"></a>自我对于“并查集”的理解</h1><p>有时候一些题，是让你判断图中一些数据是否在一个集合中。例如1和3联通，2和3联通，问你1和2是否联通。这其实问的就是1和2是否在一个联通集合里，如果用搜索进行遍历的话，就需要挨个对路径进行尝试，如果数据量大的话，消耗时间就会过多，这时候就可以用并查集来解决问题。</p>
<span id="more"></span>

<h1 id="并查集的大致思路"><a href="#并查集的大致思路" class="headerlink" title="并查集的大致思路"></a>并查集的大致思路</h1><p>并查集的核心操作就是“并”与“查”。<br>“并”指的是将两个数据放到一个集合里，“查”就是查询一个数据在哪个集合里。<br><strong>首先</strong>，我们声明一个father数组，数组的值是指向当前下标元素的父节点。<br><strong>其次</strong>，我们对这个数组进行初始化，使得当前下标的值是他本身。代表他是自己的父节点，即他是根节点，这个情况下可以看作每个元素都是一个单独的集合。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> father[MAX];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1</span>;now&lt;MAX;now++)<span class="comment">//初始化 </span></span><br><span class="line">&#123;</span><br><span class="line">	father[now]=now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>接着</strong>，我们建立“查”操作，查询某一数据属于哪个集合，就是查询他的根节点。<br>因为我们设定了father数组，所以我们不断查找该数据的父节点，即可知道该数据的根节点。<br>我们如果要查询两个数据是否属于一个集合，即可通过“查”操作获取两个数据的根节点，如果两个数据的根节点相同，则说明两个数属于同一个集合。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种写法（递归）</span></span><br><span class="line"><span class="comment">//第一种写法可以用三目运算符缩写为 return father[a]==a ? a : find(father[a]);</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(father[a]==a)</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">find</span>(father[a]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二种写法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = father[a];</span><br><span class="line">	<span class="keyword">while</span>(father[temp]!=temp)</span><br><span class="line">		temp = father[temp];</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>最后</strong>，我们建立“并”操作，可以将两个集合合并。<br>我们首先获取想要合并的数据A和数据B的根节点。如果根节点相同，则说明两个数据本来就属于一个集合，所以不用进行合并处理；如果根节点不同，则说明两个数据不属于同一个集合，此时我们需要进行合并操作。<br>合并操作很简单，让一个数据的根节点指向另一个数据的根节点即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">union_</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp_a=<span class="built_in">find</span>(a);</span><br><span class="line">	<span class="type">int</span> temp_b=<span class="built_in">find</span>(b);</span><br><span class="line">	<span class="keyword">if</span>(temp_a!=temp_b)</span><br><span class="line">	&#123;</span><br><span class="line">		father[temp_a]=temp_b;	</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="一些优化"><a href="#一些优化" class="headerlink" title="一些优化"></a>一些优化</h2><p> <strong>秩优化</strong><br>我们在进行“并”操作时，如果和上面一样，规定无论如何都是数据A往数据B并，那么很有可能大树并小树，导致整个集合的深度增加，最极端的例子是形成了一条链，此时如果find链尾，则会将整个链遍历一遍，时间消耗会大大增加。所以我们在进行“并”操作时，可以获取两个数据所处集合的深度，让深度低的成为深度高的子集。而当深度一样时，则可以看你的喜好进行合并。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> deep[MAX] = &#123;<span class="number">0</span>&#125;;<span class="comment">//深度数组，初始深度都为0，储存各个集合的深度 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">union_</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp_a=<span class="built_in">find</span>(a);</span><br><span class="line">	<span class="type">int</span> temp_b=<span class="built_in">find</span>(b);</span><br><span class="line">	<span class="keyword">if</span>(temp_a!=temp_b)<span class="comment">//两个数据不在同一个集合</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(deep[temp_a]&gt;deep[temp_b])<span class="comment">//a比b深度高 </span></span><br><span class="line">		&#123;</span><br><span class="line">			father[temp_b]=temp_a;<span class="comment">//b成为a的子集 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(deep[temp_a]&lt;deep[temp_b])<span class="comment">//a比b深度低 </span></span><br><span class="line">		&#123;</span><br><span class="line">			father[temp_a]=temp_b;<span class="comment">//a成为b的子集 </span></span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//深度一样 </span></span><br><span class="line">		&#123;</span><br><span class="line">			father[temp_b]=temp_a;<span class="comment">//b成为a的子集 </span></span><br><span class="line">			deep[temp_a]++;<span class="comment">//a的根节点的深度加一 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>路径压缩</strong><br> 在我们进行find查询时，如果我们只在乎某数据的根节点，而不在意他的各个父节点时，我们可以进行路径压缩。让这个数据的父节点直接指向根节点，这样被称作“路径压缩”。在进行路径压缩后，所有的节点都指向根节点，这样集合的深度只有1，在之后进行数据的根节点查询时的复杂度只有O(1),大大提升查询速度。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种写法（递归）</span></span><br><span class="line"><span class="comment">//第一种写法可以用三目运算符缩写为 return father[a]==a ? a : father[a] = find(father[a]);</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(father[a]==a)</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">return</span> father[a] = <span class="built_in">find</span>(father[a]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二种写法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = father[a];</span><br><span class="line">	<span class="keyword">while</span>(father[temp]!=temp)</span><br><span class="line">		temp = father[temp];</span><br><span class="line">    <span class="type">int</span> i=a,j;</span><br><span class="line">    <span class="keyword">while</span>(i!=temp) <span class="comment">//路径压缩</span></span><br><span class="line">    &#123;</span><br><span class="line">         j=father[i]; <span class="comment">// 在改变上级之前用临时变量j记录下他的值</span></span><br><span class="line">         father[i]=temp; <span class="comment">//把上级改为根节点</span></span><br><span class="line">         i=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="并查集的大致模板"><a href="#并查集的大致模板" class="headerlink" title="并查集的大致模板"></a>并查集的大致模板</h1><p>这是秩优化+路径压缩的模板，<br>其余版本看上面的思路模块即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> father[MAX];<span class="comment">//父节点数组</span></span><br><span class="line"><span class="type">int</span> deep[MAX] = &#123;<span class="number">0</span>&#125;;<span class="comment">//深度数组，初始深度都为0，储存各个集合的深度 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span><span class="comment">//初始化 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1</span>;now&lt;MAX;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		father[now]=now;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span><span class="comment">//查询</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(father[a]==a)</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">return</span> father[a] = <span class="built_in">find</span>(father[a]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">union_</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span><span class="comment">//合并</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp_a=<span class="built_in">find</span>(a);</span><br><span class="line">	<span class="type">int</span> temp_b=<span class="built_in">find</span>(b);</span><br><span class="line">	<span class="keyword">if</span>(temp_a!=temp_b)<span class="comment">//两个数据不在同一个集合</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(deep[temp_a]&gt;deep[temp_b])<span class="comment">//a比b深度高 </span></span><br><span class="line">		&#123;</span><br><span class="line">			father[temp_b]=temp_a;<span class="comment">//b成为a的子集 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(deep[temp_a]&lt;deep[temp_b])<span class="comment">//a比b深度低 </span></span><br><span class="line">		&#123;</span><br><span class="line">			father[temp_a]=temp_b;<span class="comment">//a成为b的子集 </span></span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//深度一样 </span></span><br><span class="line">		&#123;</span><br><span class="line">			father[temp_b]=temp_a;<span class="comment">//b成为a的子集 </span></span><br><span class="line">			deep[temp_a]++;<span class="comment">//a的根节点的深度加一 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	........</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="并查集例题"><a href="#并查集例题" class="headerlink" title="并查集例题"></a>并查集例题</h1><h2 id="1-畅通工程"><a href="#1-畅通工程" class="headerlink" title="1.畅通工程"></a>1.畅通工程</h2><p>某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？</p>
<p>Input<br>测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( &lt; 1000 )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。<br>注意:两个城市之间可以有多条道路相通,也就是说<br>3 3<br>1 2<br>1 2<br>2 1<br>这种输入也是合法的<br>当N为0时，输入结束，该用例不被处理。</p>
<p>Output<br>对每个测试用例，在1行里输出最少还需要建设的道路数目。</p>
<p>Sample Input<br>4 2<br>1 3<br>4 3<br>3 3<br>1 2<br>1 3<br>2 3<br>5 2<br>1 2<br>3 5<br>999 0<br>0</p>
<p>Sample Output<br>1<br>0<br>2<br>998</p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1232">题目地址</a></p>
<p>思路：这题在把所有的数据接收后，运用并查集进行集合合并，最后根节点的个数就是集合的个数。而联通n个节点最少需要n-1条边，故根节点的个数减去1就是建设道路的最少值。由于题中只在乎最后根节点的个数，所有使用了路径压缩，提高代码的运算速度。</p>
<p>AC代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> father[<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> father[a]==a ? a : father[a] = <span class="built_in">find</span>(father[a]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compose</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp_a=<span class="built_in">find</span>(a);</span><br><span class="line">	<span class="type">int</span> temp_b=<span class="built_in">find</span>(b);</span><br><span class="line">	<span class="keyword">if</span>(temp_a!=temp_b)</span><br><span class="line">	&#123;</span><br><span class="line">		father[temp_a]=temp_b;	</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a,b,c,d;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a)&amp;&amp;a)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1</span>;now&lt;=a;now++)<span class="comment">//初始化 </span></span><br><span class="line">		&#123;</span><br><span class="line">			father[now]=now;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(b--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;c,&amp;d);</span><br><span class="line">			<span class="built_in">compose</span>(c,d);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1</span>;now&lt;=a;now++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(father[now]==now)</span><br><span class="line">				ans++;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		cout&lt;&lt;ans<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-修改数组"><a href="#2-修改数组" class="headerlink" title="2.修改数组"></a>2.修改数组</h2><p>给定一个长度为N 的数组A &#x3D; [A1, A2,…,AN]，数组中有可能有重复出现的整数。<br>现在小明要按以下方法将其修改为没有重复整数的数组。小明会依次修改A2,A3,…, AN。<br>当修改Ai 时，小明会检查Ai 是否在A1~ Ai-1 中出现过。<br>如果出现过，则小明会给Ai 加上1 ；<br>如果新的Ai 仍在之前出现过，小明会持续给Ai 加1 ，直到Ai 没有在A1~Ai-1中出现过。<br>当AN 也经过上述修改之后，显然A数组中就没有重复的整数了。<br>现在给定初始的A 数组，请你计算出最终的A 数组。</p>
<p>输入<br>第一行包含一个整数N(1&lt;&#x3D;N&lt;&#x3D;100000)<br>第二行包含N个整数A1,A2,…,AN(1&lt;&#x3D;Ai&lt;&#x3D;1000000)</p>
<p>输出<br>输出N个整数，依次是最终的A1,A2,…,AN</p>
<p>样例输入 Copy<br>5<br>2 1 1 3 4</p>
<p>样例输出 Copy<br>2 1 3 4 5</p>
<p><a href="http://oj.ecustacm.cn/problem.php?id=1459">题目地址</a></p>
<p>思路：我们可以把用过的数字放到一个集合里，而让他的父节点指向下一个可以用的数字，具体操作就是**father[a]&#x3D;find(father[a]+1)**。这样我们就会一直对使用过的数字的父节点进行加一操作，直到找到一个没有被使用过的数字。由于这题只需要知道该数字是否被使用过，即是否在“被使用过”这个集合里，所以我们可以使用路径压缩，提高运算效率。</p>
<p>AC代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> father[<span class="number">1000001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(father[a]==<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		father[a]=a;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> father[a]=<span class="built_in">find</span>(father[a]<span class="number">+1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> input,aa;</span><br><span class="line">	cin&gt;&gt;input;</span><br><span class="line">	<span class="built_in">memset</span>(father,<span class="number">-1</span>,<span class="built_in">sizeof</span>(father));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1</span>;now&lt;=input;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;aa;</span><br><span class="line">		aa=<span class="built_in">find</span>(aa);</span><br><span class="line">		cout&lt;&lt;aa&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-敌人"><a href="#3-敌人" class="headerlink" title="3.敌人"></a>3.敌人</h2><p>俗话说得好，敌人的敌人就是朋友。<br>现在有n个人，编号1至n，初始互不相识。接下来有m个操作，操作分为两种：</p>
<p>（1）检查x号和y号是否是朋友，若不是，则变成敌人<br>（2）询问x号的朋友有多少个<br>请你针对每个操作中的询问给出回答。</p>
<p>输入<br>第一行两个正整数n、m，表示人的数量和操作的数量。<br>接下来m行，依次描述输入。每行的第一个整数为1或2表示操作种类。对于操作（1），随后有两个正整数x，y。对于操作（2），随后一个正整数x。</p>
<p>输出<br>输出包含m行，对于操作（1），输入’N’或”Y”，’N’表示x和y之前不是朋友，’Y’表示是朋友。对于操作（2），输出x的朋友数量。</p>
<p>输入示例<br>5 8<br>1 1 2<br>1 1 3<br>1 2 3<br>2 3<br>1 4 5<br>2 3<br>1 1 4<br>2 3</p>
<p>输出示例<br>N<br>N<br>Y<br>1<br>N<br>1<br>N<br>2</p>
<p>思路：这道题相比之前的题，一个不同的特点就是我们无法直接将两个数据放进同一个集合，因为输入的数据要变为“敌人”关系，即不在同一个集合内。那么我们如何能将两个数据放进同一个集合呢？我们可以扩大father数组，使它是原来的两倍大。假如一共有N个数，则1到N代表本身，N+1到2N则代表1到N的敌人。当我们设定两个数是敌人的时候，只需要把第一个数据和第二个数据的敌人放在一个集合，第二个数据和第一个数据的敌人防在一个集合，即可完成合并的操作。因为当和一个数的敌人是朋友时，那和这个数就是敌人。当查询一个数的朋友时，遍历查询与其根节点相同的点的个数，再减去一（它本身），即为朋友的个数。本题由于也是只看根节点，所以可以使用路径压缩。</p>
<p>AC代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> father[<span class="number">600001</span>];<span class="comment">//最大300000个数 数的敌人也有300000个 故一共600000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span><span class="comment">//查询</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> father[a]==a ? a : father[a] = <span class="built_in">find</span>(father[a]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compose</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span><span class="comment">//合并</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp_a=<span class="built_in">find</span>(a);</span><br><span class="line">	<span class="type">int</span> temp_b=<span class="built_in">find</span>(b);</span><br><span class="line">	<span class="keyword">if</span>(temp_a!=temp_b)</span><br><span class="line">	&#123;</span><br><span class="line">		father[temp_a]=temp_b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> input1,input2,a,b,c;</span><br><span class="line">	cin&gt;&gt;input1&gt;&gt;input2;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1</span>;now&lt;=input1*<span class="number">2</span>;now++)<span class="comment">//初始化 </span></span><br><span class="line">	&#123;</span><br><span class="line">		father[now]=now;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;input2;now++)<span class="comment">//接收初始值 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;a;</span><br><span class="line">		<span class="keyword">if</span>(a==<span class="number">1</span>)<span class="comment">//1操作</span></span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;b&gt;&gt;c;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">find</span>(b)==<span class="built_in">find</span>(c))<span class="comment">//是朋友</span></span><br><span class="line">			&#123;</span><br><span class="line">				cout&lt;&lt;<span class="string">&quot;Y&quot;</span>&lt;&lt;endl;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">compose</span>(b,c+input1);<span class="comment">//将输入的第一个数据和第二个数据的敌人放在一个集合里</span></span><br><span class="line">				<span class="built_in">compose</span>(c,b+input1);<span class="comment">//将输入的第二个数据和第一个数据的敌人放在一个集合里</span></span><br><span class="line">				cout&lt;&lt;<span class="string">&quot;N&quot;</span>&lt;&lt;endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="number">2</span>)<span class="comment">//2操作</span></span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;b;</span><br><span class="line">			<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">			<span class="comment">/*for(int now=1;now&lt;=input1*2;now++) </span></span><br><span class="line"><span class="comment">			&#123;</span></span><br><span class="line"><span class="comment">				cout&lt;&lt;father[now]&lt;&lt;&quot; &quot;;</span></span><br><span class="line"><span class="comment">			&#125;*/</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1</span>;now&lt;=input1;now++)<span class="comment">//如果根节点相同则说明在同一集合，是朋友 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">find</span>(b)==<span class="built_in">find</span>(now))</span><br><span class="line">					ans++;</span><br><span class="line">			&#125;</span><br><span class="line">			cout&lt;&lt;ans<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-食物链"><a href="#4-食物链" class="headerlink" title="4.食物链"></a>4.食物链</h2><p>有N只动物分别编号为1，2，……，N。所有动物都属于A，B，C中的一类。已知A能吃掉B，B能吃掉C，C能吃掉A。按顺序给出下面的两种信息共K条：<br>  第一种：x和y属于同一类；<br>  第二种：x吃y。<br>然而这些信息可能会出错，有可能有的信息和之前给出的信息矛盾，也有的信息可能给出的x和y不在1到N的范围内。求在K条信息中有多少条是不正确的。计算过程中，我们将忽视诸如此类的错误信息。</p>
<p>输入<br>第一行两个自然数，两数间用一个空格分隔，分别表示N和K，接下来的K行，每行有三个数，第一个数为0或1，分别对应第一种或第二种，接着的两个数，分别为该条信息的x和y，三个数两两之间用一个空格分隔。</p>
<p>输出<br>一个自然数，表示错误信息的条数。</p>
<p>输入示例<br>100 7<br>0 101 1<br>1 1 2<br>1 2 3<br>1 3 3<br>0 1 3<br>1 3 1<br>0 5 5</p>
<p>输出示例<br>3</p>
<p>思路：与上一题“敌人”相似，这一题也可以通过扩展数组建立多重关系来做。这一题存在同类、吃、被吃这三个关系。所以我们把数组扩到到原来的三倍，1到N代表本身，N+1到2N代表被“本身”吃的，2N+1到3N代表吃“本身”的。当我们建立0操作的“A和B同类”关系时，只需要把三个区域同等合并即可，即A本身和B本身合并为一类，A吃的和B吃的合并为一类，吃A的和吃B的合并为一类，即可说明A和B地位相同。当我们建立1操作的“A吃B”关系时，将B和A吃的划为一类，B吃的和吃A的划为一类，A和吃B的划为一类，即可实现A吃B关系网的建立。<br>而当输入超限、在0操作时判断出A和B是吃或被吃关系、在1操作时判断出A和B是同类或被吃关系时，即为语句错误，答案数量加一。由此结束时输出即可。</p>
<p>AC代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> father[<span class="number">150001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> father[a]==a ? a : father[a] = <span class="built_in">find</span>(father[a]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compose</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp_a=<span class="built_in">find</span>(a);</span><br><span class="line">	<span class="type">int</span> temp_b=<span class="built_in">find</span>(b);</span><br><span class="line">	<span class="keyword">if</span>(temp_a!=temp_b)</span><br><span class="line">	&#123;</span><br><span class="line">		father[temp_a]=temp_b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> input1,input2,a,b,c,ans=<span class="number">0</span>;</span><br><span class="line">	cin&gt;&gt;input1&gt;&gt;input2;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1</span>;now&lt;=input1*<span class="number">3</span>;now++)<span class="comment">//初始化 </span></span><br><span class="line">	&#123;</span><br><span class="line">		father[now]=now;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;input2;now++)<span class="comment">//接收初始值 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;a;</span><br><span class="line">		<span class="keyword">if</span>(a==<span class="number">0</span>)<span class="comment">//输入0 x与y同类 </span></span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;b&gt;&gt;c;</span><br><span class="line">			<span class="keyword">if</span>(b&gt;input1||b&lt;<span class="number">1</span>||c&gt;input1||c&lt;<span class="number">1</span>)<span class="comment">//输入不合法 </span></span><br><span class="line">			&#123;</span><br><span class="line">				ans++;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">find</span>(b)==<span class="built_in">find</span>(c+input1)||<span class="built_in">find</span>(b)==<span class="built_in">find</span>(c<span class="number">+2</span>*input1))<span class="comment">//如果属于吃或者被吃关系 </span></span><br><span class="line">				&#123;</span><br><span class="line">					ans++;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span><span class="comment">//指向平级，代表同类 </span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">compose</span>(b,c); </span><br><span class="line">					<span class="built_in">compose</span>(b+input1,c+input1);</span><br><span class="line">					<span class="built_in">compose</span>(b+input1*<span class="number">2</span>,c+input1*<span class="number">2</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="number">1</span>)<span class="comment">//输入1 x吃y </span></span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;b&gt;&gt;c;</span><br><span class="line">			<span class="keyword">if</span>(b&gt;input1||b&lt;<span class="number">1</span>||c&gt;input1||c&lt;<span class="number">1</span>)<span class="comment">//输入不合法 </span></span><br><span class="line">			&#123;</span><br><span class="line">				ans++;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">find</span>(b)==<span class="built_in">find</span>(c)||<span class="built_in">find</span>(b)==<span class="built_in">find</span>(c+input1))<span class="comment">//属于同一类或者被吃关系 </span></span><br><span class="line">				&#123;</span><br><span class="line">					ans++;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">compose</span>(b+input1,c);<span class="comment">//b吃的 和 c一类 即 b吃c </span></span><br><span class="line">					<span class="built_in">compose</span>(b+input1*<span class="number">2</span>,c+input1);<span class="comment">//吃b的 和 c吃的一类  </span></span><br><span class="line">					<span class="built_in">compose</span>(b,c+input1*<span class="number">2</span>);<span class="comment">//b 和 吃c的一类 </span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;<span class="comment">//结果</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-网络分析"><a href="#5-网络分析" class="headerlink" title="5. 网络分析"></a>5. 网络分析</h2><p>时间限制: 1.0s 内存限制: 256.0MB 本题总分：25 分<br><strong>问题：</strong><br>小明正在做一个网络实验。<br>他设置了 n 台电脑，称为节点，用于收发和存储数据。<br>初始时，所有节点都是独立的，不存在任何连接。<br>小明可以通过网线将两个节点连接起来，连接后两个节点就可以互相了。两个节点如果存在网线连接，称为相邻。<br>小明有时会测试当时的网络，他会在某个节点发送一条信息，信息会到每个相邻的节点，之后这些节点又会转发到自己相邻的节点，直到所有或间接相邻的节点都收到了信息。所有发送和接收的节点都会将信息存储一条信息只存储一次。<br>给出小明连接和测试的过程，请计算出每个节点存储信息的大小。</p>
<p><strong>输入：</strong><br>输入的第一行包含两个整数 n, m，分别表示节点数量和操作数量。节1 至 n 编号。<br>接下来 m 行，每行三个整数，表示一个操作。<br>如果操作为 1 a b，表示将节点 a 和节点 b 通过网线连接起来。当 时，表示连接了一个自环，对网络没有实质影响。<br>如果操作为 2 p t，表示在节点 p 上发送一条大小为 t 的信息。</p>
<p><strong>输出：</strong><br>输出一行，包含 n 个整数，相邻整数之间用一个空格分割，依次表示完上述操作后节点 1 至节点 n 上存储信息的大小。</p>
<p><strong>样例输入：</strong><br>4 8<br>1 1 2<br>2 1 10<br>2 3 5<br>1 4 1<br>2 2 2<br>1 1 2<br>1 2 4<br>2 2 1</p>
<p><strong>样例输出：</strong><br>13 13 5 3</p>
<p><strong>评测用例规模与约定：</strong><br>对于 30% 的评测用例，1 ≤ n ≤ 20，1 ≤ m ≤ 100。<br>对于 50% 的评测用例，1 ≤ n ≤ 100，1 ≤ m ≤ 1000。<br>对于 70% 的评测用例，1 ≤ n ≤ 1000，1 ≤ m ≤ 10000。<br>对于所有评测用例，1 ≤ n ≤ 10000，1 ≤ m ≤ 100000，1 ≤ t ≤ 100。</p>
<p><strong>思路：</strong> 核心思路是并查集。一个数组用来存旧值，一个数组用来存根结点权值，一个数组是并查集的father数组。执行2操作时，查集寻找到操作值的根结点并加权。执行1操作时，若两数在一个集内则不操作；若两数不在一个集内，则对所有节点进行遍历，使他们的旧值数组加上其根节点的权值，随后进行并集操作。记得对权值数组进行清零，防止后面重复计算。</p>
<p><strong>AC代码：</strong> <a href="https://www.acwing.com/problem/content/description/2071/">OJ链接</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> old_[<span class="number">10001</span>],new_[<span class="number">10001</span>],father[<span class="number">10001</span>],n,m;<span class="comment">//存老值 存根节点新值 父节点数组 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> father[a]==a ? a : father[a]=<span class="built_in">find</span>(father[a]);<span class="comment">//路径压缩</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">union_</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp_a=<span class="built_in">find</span>(a),temp_b=<span class="built_in">find</span>(b);</span><br><span class="line">	<span class="keyword">if</span>(temp_a!=temp_b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> now=<span class="number">1</span>;now&lt;=n;now++)</span><br><span class="line">		&#123;</span><br><span class="line">			old_[now]+=new_[<span class="built_in">find</span>(now)];<span class="comment">//旧值数组遍历加上权值</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">memset</span>(new_,<span class="number">0</span>,<span class="built_in">sizeof</span>(new_));<span class="comment">//重置权值数组，防止重复计算</span></span><br><span class="line">		father[temp_a]=temp_b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a,b,c;</span><br><span class="line">	<span class="built_in">memset</span>(new_,<span class="number">0</span>,<span class="built_in">sizeof</span>(new_));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> now=<span class="number">1</span>;now&lt;=<span class="number">10000</span>;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		father[now]=now;<span class="comment">//father数组初始化 </span></span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">while</span>(m--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">		<span class="keyword">if</span>(a==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">union_</span>(b,c);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			new_[<span class="built_in">find</span>(b)]+=c;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> now=<span class="number">1</span>;now&lt;=n;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,old_[now]+new_[<span class="built_in">find</span>(now)]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p><strong>在使用并查集中，要根据题目数据选择合适的优化。</strong><br>一般都得用路径压缩提高效率，但是秩优化用的比较少（我感觉），因为在进行路径压缩后秩优化后的结构就不复存在的，我感觉二者是有点矛盾的。但是两者一起使用相较于只使用路径压缩也会在第一次接收数据时提高一点效率，但是为了敲代码的效率，我还是喜欢只敲路径压缩。<br><strong>使用并查集时，要选择合适的数据结构</strong><br>例如秩优化时的储存深度的数组、例题第三题“敌人”的长数组、以及涉及带权并查集的结构。<br><strong>总之，还是得多刷题，多积累经验。</strong></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2018 蓝桥杯 递增三元组 sort排序</title>
    <url>/2020/08/25/20200825_2018%E8%93%9D%E6%A1%A5%E6%9D%AF%E9%80%92%E5%A2%9E%E4%B8%89%E5%85%83%E7%BB%84sort%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p><strong>这是2018年蓝桥杯C语言省赛B组的第六题</strong></p>
<span id="more"></span>

<p><strong>题目：</strong><br>给定三个整数数组<br>A &#x3D; [A1, A2, … AN],<br>B &#x3D; [B1, B2, … BN],<br>C &#x3D; [C1, C2, … CN]，<br>请你统计有多少个三元组(i, j, k) 满足：</p>
<ol>
<li>1 &lt;&#x3D; i, j, k &lt;&#x3D; N  </li>
<li>Ai &lt; Bj &lt; Ck</li>
</ol>
<p><strong>输入</strong><br>第一行包含一个整数N。<br>第二行包含N个整数A1, A2, … AN。<br>第三行包含N个整数B1, B2, … BN。<br>第四行包含N个整数C1, C2, … CN。<br>1 &lt;&#x3D; N &lt;&#x3D; 100000 0 &lt;&#x3D; Ai, Bi, Ci &lt;&#x3D; 100000 </p>
<p><strong>输出</strong><br>一个整数表示答案</p>
<p><strong>样例输入</strong><br>3<br>1 1 1<br>2 2 2<br>3 3 3</p>
<p><strong>样例输出</strong><br>27</p>
<p><a href="http://oj.ecustacm.cn/problem.php?id=1371">OJ链接</a></p>
<p><strong>思路</strong>：先用sort对三个数组进行排序。随后对B数组进行遍历，用lower_bound函数求出A数组中小于B数组当前元素的数量，用upper_bound函数求出C数组中大于B数组当前元素的数量，两者相乘算出B数组当前元素下可行解的数量，把B数组遍历一遍即可求出总解。<br><strong>PS</strong>：记得用long long，用int的话会爆。</p>
<p><strong>AC代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">100001</span>],b[<span class="number">100001</span>],c[<span class="number">100001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;n;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[now]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;n;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[now]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;n;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;c[now]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">sort</span>(a,a+n);<span class="comment">//排序</span></span><br><span class="line">	<span class="built_in">sort</span>(b,b+n);</span><br><span class="line">	<span class="built_in">sort</span>(c,c+n);</span><br><span class="line">	</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;<span class="comment">//记得用long long</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;n;now++)<span class="comment">//b为中间值 遍历</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">long</span> <span class="type">long</span> s1=<span class="built_in">lower_bound</span>(a,a+n,b[now])-a;<span class="comment">//获取a中小于b【now】的个数</span></span><br><span class="line">		<span class="type">long</span> <span class="type">long</span> s2=n-(<span class="built_in">upper_bound</span>(c,c+n,b[now])-c);<span class="comment">//获取c中大于b【now】的个数</span></span><br><span class="line">		ans+=s1*s2;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构与算法</tag>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title>2018 蓝桥杯 全球变暖(dfs) 深度优先遍历写法</title>
    <url>/2020/08/26/20200826_2018%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%85%A8%E7%90%83%E5%8F%98%E6%9A%96(dfs)%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E5%86%99%E6%B3%95/</url>
    <content><![CDATA[<p><strong>这是2018年蓝桥杯C语言省赛B组的第九题</strong></p>
<span id="more"></span>

<p><strong>题目</strong><br>你有一张某海域NxN像素的照片，”.”表示海洋、”#”表示陆地，如下所示：<br><img src="/images/2020-08-13/2.jpg" alt="1"></p>
<p>其中”上下左右”四个方向上连在一起的一片陆地组成一座岛屿。例如上图就有2座岛屿。<br>由于全球变暖导致了海面上升，科学家预测未来几十年，岛屿边缘一个像素的范围会被海水淹没。<br>具体来说如果一块陆地像素与海洋相邻(上下左右四个相邻像素中有海洋)，它就会被淹没。<br>例如上图中的海域未来会变成如下样子：<br><img src="/images/2020-08-13/3.jpg" alt="1"></p>
<p>请你计算：依照科学家的预测，照片中有多少岛屿会被完全淹没。</p>
<p><strong>输入</strong><br>第一行包含一个整数N。  (1 &lt;&#x3D; N &lt;&#x3D; 1000)<br>以下N行N列代表一张海域照片。<br>照片保证第1行、第1列、第N行、第N列的像素都是海洋。  </p>
<p><strong>输出</strong><br>一个整数表示答案。</p>
<p><strong>样例输入</strong><br><img src="/images/2020-08-13/4.jpg" alt="1"><br><strong>样例输出</strong><br>1</p>
<p><a href="http://oj.ecustacm.cn/problem.php?id=1365">OJ链接</a></p>
<p><strong>思路</strong>：在接收初始图之后，<strong>首先</strong>搜索查找初始岛屿数，在找到一个岛屿后，对整个岛屿进行标记，防止重复计数。<strong>随后</strong>再次进行搜索，如果有四周均为陆地的坐标，则标记此坐标未被淹没。<strong>最后</strong>查找所有未被淹没的坐标，并将坐标所处的整个岛标记，防止重复计数。初始岛屿数量减去未被淹没岛的数量，即为被淹没的岛的数量。</p>
<p><strong>AC代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> maps[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(maps[x][y]!=<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	maps[x][y]=<span class="string">&#x27;1&#x27;</span>;<span class="comment">//将#标记为1 </span></span><br><span class="line">	<span class="built_in">dfs1</span>(x<span class="number">+1</span>,y);<span class="comment">//把整个岛都进行标记 防止重复计算 </span></span><br><span class="line">	<span class="built_in">dfs1</span>(x<span class="number">-1</span>,y);</span><br><span class="line">	<span class="built_in">dfs1</span>(x,y<span class="number">+1</span>);</span><br><span class="line">	<span class="built_in">dfs1</span>(x,y<span class="number">-1</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(maps[x][y]==<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(maps[x<span class="number">+1</span>][y]==<span class="string">&#x27;1&#x27;</span>&amp;&amp;maps[x<span class="number">-1</span>][y]==<span class="string">&#x27;1&#x27;</span>&amp;&amp;maps[x][y<span class="number">+1</span>]==<span class="string">&#x27;1&#x27;</span>&amp;&amp;maps[x][y<span class="number">-1</span>]==<span class="string">&#x27;1&#x27;</span>)<span class="comment">//四周都是陆地 则标记为2</span></span><br><span class="line">	&#123;	</span><br><span class="line">		maps[x][y]=<span class="string">&#x27;2&#x27;</span>; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">dfs1</span>(x<span class="number">+1</span>,y);<span class="comment">//找4个方向 </span></span><br><span class="line">	<span class="built_in">dfs1</span>(x<span class="number">-1</span>,y);</span><br><span class="line">	<span class="built_in">dfs1</span>(x,y<span class="number">+1</span>);</span><br><span class="line">	<span class="built_in">dfs1</span>(x,y<span class="number">-1</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs3</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(maps[x][y]==<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	maps[x][y]=<span class="string">&#x27;.&#x27;</span>;<span class="comment">//将#标记为 . </span></span><br><span class="line">	<span class="built_in">dfs3</span>(x<span class="number">+1</span>,y);<span class="comment">//把整个岛都进行沉没操作 防止重复计算 </span></span><br><span class="line">	<span class="built_in">dfs3</span>(x<span class="number">-1</span>,y);</span><br><span class="line">	<span class="built_in">dfs3</span>(x,y<span class="number">+1</span>);</span><br><span class="line">	<span class="built_in">dfs3</span>(x,y<span class="number">-1</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,first_num=<span class="number">0</span>,end_num=<span class="number">0</span>;<span class="comment">//层数 初始岛屿数量 末尾岛屿数量 </span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n); </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">1</span>;a&lt;=n;a++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> b=<span class="number">1</span>;b&lt;=n;b++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;maps[a][b]);</span><br><span class="line">				<span class="keyword">if</span>(maps[a][b]==<span class="string">&#x27;.&#x27;</span>||maps[a][b]==<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//先查找有多少个岛屿 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">1</span>;a&lt;=n;a++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> b=<span class="number">1</span>;b&lt;=n;b++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(maps[a][b]==<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">dfs1</span>(a,b);</span><br><span class="line">				first_num++;<span class="comment">//初始岛屿+1 </span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//再对整个岛屿进行变化</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">1</span>;a&lt;=n;a++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> b=<span class="number">1</span>;b&lt;=n;b++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(maps[a][b]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">dfs2</span>(a,b);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//最后查找剩余多少个岛屿 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">1</span>;a&lt;=n;a++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> b=<span class="number">1</span>;b&lt;=n;b++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(maps[a][b]==<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">dfs3</span>(a,b);</span><br><span class="line">				end_num++;<span class="comment">//最终岛屿+1 </span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;first_num-end_num;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构与算法</tag>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title>2018 蓝桥杯 日志统计 尺取法</title>
    <url>/2020/08/27/20200827_2018%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%97%A5%E5%BF%97%E7%BB%9F%E8%AE%A1%E5%B0%BA%E5%8F%96%E6%B3%95/</url>
    <content><![CDATA[<p><strong>这是2018年蓝桥杯C语言省赛B组的第八题</strong></p>
<span id="more"></span>

<p><strong>题目描述</strong><br>小明维护着一个程序员论坛。现在他收集了一份”点赞”日志，日志共有N行。<br>其中每一行的格式是：ts id。表示在ts时刻编号id的帖子收到一个”赞”。<br>现在小明想统计有哪些帖子曾经是”热帖”。<br>如果一个帖子曾在任意一个长度为D的时间段内收到不少于K个赞，小明就认为这个帖子曾是”热帖”。<br>具体来说，如果存在某个时刻T满足该帖在[T, T+D)这段时间内(注意是左闭右开区间)收到不少于K个赞，该帖就曾是”热帖”。<br>给定日志，请你帮助小明统计出所有曾是”热帖”的帖子编号。  </p>
<p><strong>输入</strong><br>第一行包含三个整数N、D和K。<br>以下N行每行一条日志，包含两个整数ts和id。<br>1 &lt;&#x3D; K &lt;&#x3D; N &lt;&#x3D; 100000 0 &lt;&#x3D; ts &lt;&#x3D; 100000 0 &lt;&#x3D; id &lt;&#x3D; 100000  </p>
<p><strong>输出</strong><br>按从小到大的顺序输出热帖id。每个id一行。</p>
<p><strong>样例输入</strong><br>7 10 2<br>0 1<br>0 10<br>10 10<br>10 1<br>9 1<br>100 3<br>100 3 </p>
<p><strong>样例输出</strong><br>1<br>3</p>
<p><a href="http://oj.ecustacm.cn/problem.php?id=1373">OJ链接</a></p>
<p><strong>思路</strong>：我的思路是一个二维数组储存每个id的点赞时间，即maps[id][]&#x3D;ts。然后根据maps数组对每个id运用尺取法进行条件判定，如果符合要求就是答案。<br>为了减少对数组的搜索，我引入了一个set用来储存出现过的id号，然后对出现过的id号关联的数组进行查询即可。</p>
<p><strong>尺取法：</strong> 我认为就是在一个连续的集合里，设定一个子集的首位位置和末尾位置，然后不断的推进首尾位置，寻找符合条件的子集。因为这题要计算相差的时间，所以数据必须是有序的，所以下面的代码中我使用了sort对maps数组进行排序。</p>
<p><strong>AC代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;maps[<span class="number">100001</span>]; <span class="comment">//二维数组储存每个节点的被点赞的时间 maps[x][0]就是x号帖子第一次被点赞的时间 </span></span><br><span class="line">set&lt;<span class="type">int</span>&gt;alls; <span class="comment">//储存出现的帖子编号  与maps配合 避免不必要的查询 直接maps[alls][]就行 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,d,k,ts,id;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;n,&amp;d,&amp;k);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(n--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;ts,&amp;id);</span><br><span class="line">		alls.<span class="built_in">insert</span>(id); <span class="comment">//储存出现的id号 </span></span><br><span class="line">		maps[id].<span class="built_in">push_back</span>(ts);	<span class="comment">//将点赞时间储存至maps[id][] </span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(set&lt;<span class="type">int</span>&gt;::iterator iter=alls.<span class="built_in">begin</span>();iter!=alls.<span class="built_in">end</span>();iter++) <span class="comment">//对整个maps[alls][]数组进行排序 方便后面的时间统计 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">sort</span>(maps[*iter].<span class="built_in">begin</span>(),maps[*iter].<span class="built_in">end</span>()); <span class="comment">//对有数据的数组进行排序 即 maps[alls][]</span></span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(set&lt;<span class="type">int</span>&gt;::iterator iter=alls.<span class="built_in">begin</span>();iter!=alls.<span class="built_in">end</span>();iter++) <span class="comment">//对有数据的maps数组进行查找  </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> all=<span class="number">0</span>,first=<span class="number">0</span>,end=<span class="number">0</span>; <span class="comment">//点赞数量 第一个赞的位置 最后一个赞的位置 </span></span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>) <span class="comment">//尺取法 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(all&lt;k&amp;&amp;end&lt;maps[*iter].<span class="built_in">size</span>()) <span class="comment">//点赞数小于要求 &amp;&amp; 数组里的数据还没有统计完 </span></span><br><span class="line">			&#123;</span><br><span class="line">				all++; </span><br><span class="line">				end++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(all&lt;k) <span class="comment">//统计完了 赞也不够 </span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">if</span>(maps[*iter][end<span class="number">-1</span>]-maps[*iter][first]&lt;d) <span class="comment">//赞够 并且 第一个赞和末尾赞的时间相隔符合要求 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*iter); <span class="comment">//由于set有序 所以直接输出即可 </span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			all--;</span><br><span class="line">			first++; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构与算法</tag>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title>2017 蓝桥杯 日期问题</title>
    <url>/2020/08/28/20200828_2017%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%97%A5%E6%9C%9F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><strong>这是2017年蓝桥杯C语言省赛B组的第七题</strong></p>
<span id="more"></span>

<p><strong>题目描述</strong><br>小明正在整理一批历史文献。这些历史文献中出现了很多日期。<br>小明知道这些日期都在1960年1月1日至2059年12月31日。<br>令小明头疼的是，这些日期采用的格式非常不统一，有采用年&#x2F;月&#x2F;日的，有采用月&#x2F;日&#x2F;年的，还有采用日&#x2F;月&#x2F;年的。<br>更加麻烦的是，年份也都省略了前两位，使得文献上的一个日期，存在很多可能的日期与其对应。<br>比如02&#x2F;03&#x2F;04，可能是2002年03月04日、2004年02月03日或2004年03月02日。<br>给出一个文献上的日期，你能帮助小明判断有哪些可能的日期对其对应吗？</p>
<p><strong>输入</strong><br>一个日期，格式是”AA&#x2F;BB&#x2F;CC”。  (0 &lt;&#x3D; A, B, C &lt;&#x3D; 9)  </p>
<p><strong>输出</strong><br>输出若干个不相同的日期，每个日期一行，格式是”yyyy-MM-dd”。<br>多个日期按从早到晚排列。</p>
<p><strong>样例输入</strong><br>02&#x2F;03&#x2F;04</p>
<p><strong>样例输出</strong><br>2002-03-04<br>2004-02-03<br>2004-03-02</p>
<p><a href="http://oj.ecustacm.cn/problem.php?id=1328">OJ链接</a></p>
<p><strong>思路：</strong> </p>
<ul>
<li>本来刚看见这道题，我还觉得很简单。。。但是一写发现情况很复杂，需要判定的东西很多，果然好歹也是偏后面的题，不会太简单。</li>
<li>我的思路就是主函数进行接收数据，然后在主函数里数据排序后，利用一个judge函数进行判定日期是否合法，如果合法就输出。</li>
<li>judge函数判定主要为：<strong>月是否合理</strong>、根据月份判断<strong>日是否合理</strong>（首先要判断是不是30&#x2F;31天的月，如果是2月则要判定是不是闰年，随后看日期是否超限）。</li>
<li>随后需要注意的是，<strong>相同日期只用输出一次</strong>，所以在主函数里我们需要判定judge函数的传参是否相同，如果相同就说明是相同日期，输出一次即可。</li>
</ul>
<p><strong>AC代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">judge</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span><span class="comment">//判断是否合理 合理即输出 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(b&lt;<span class="number">1</span>||b&gt;<span class="number">12</span>)<span class="comment">//月超标 pass</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(c&lt;<span class="number">1</span>||c&gt;<span class="number">31</span>)<span class="comment">//日超标 pass </span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>((b==<span class="number">1</span>||b==<span class="number">3</span>||b==<span class="number">5</span>||b==<span class="number">7</span>||b==<span class="number">8</span>||b==<span class="number">10</span>||b==<span class="number">12</span>)&amp;&amp;c&gt;<span class="number">31</span>)<span class="comment">//如果是 1 3 5 7 8 10 12月 并且日期大于31 pass </span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>((b==<span class="number">4</span>||b==<span class="number">6</span>||b==<span class="number">9</span>||b==<span class="number">11</span>)&amp;&amp;c&gt;<span class="number">30</span>)<span class="comment">//如果是 4 6 9 11 月 并且日期大于30 pass </span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(b==<span class="number">2</span>)<span class="comment">//如果是2月就判断是不是闰年 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(a%<span class="number">400</span>==<span class="number">0</span>||(a%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;a%<span class="number">100</span>!=<span class="number">0</span>))<span class="comment">//是闰年</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(c&gt;<span class="number">29</span>)<span class="comment">//大于29天 pass </span></span><br><span class="line">				<span class="keyword">return</span>; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(c&gt;<span class="number">28</span>)<span class="comment">//大于28天 pass</span></span><br><span class="line">				<span class="keyword">return</span>; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d-%02d-%02d\n&quot;</span>,a,b,c);<span class="comment">//成功输出 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a,b,c,a1,c1;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d/%d/%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">	a1=a;</span><br><span class="line">	c1=c;</span><br><span class="line">	<span class="keyword">if</span>(a&lt;=<span class="number">59</span>)<span class="comment">//加100方便比较 </span></span><br><span class="line">		a1+=<span class="number">100</span>;</span><br><span class="line">	<span class="keyword">if</span>(c&lt;=<span class="number">59</span>)</span><br><span class="line">		c1+=<span class="number">100</span>;	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	三种情况 </span></span><br><span class="line"><span class="comment">	 a  b  c</span></span><br><span class="line"><span class="comment">	年 月 日 （1） </span></span><br><span class="line"><span class="comment">	月 日 年 （2) </span></span><br><span class="line"><span class="comment">	日 月 年  (3)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">if</span>(a1&lt;c1)<span class="comment">//a小于c的话  先输出（1） 再（2）（3） </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">judge</span>(<span class="number">1900</span>+a1,b,c);<span class="comment">//判断是否合理 合理即输出 </span></span><br><span class="line">		<span class="type">int</span> max_temp = <span class="built_in">max</span>(a,b);<span class="comment">//取b,c最大值和最小值 </span></span><br><span class="line">		<span class="type">int</span> min_temp = <span class="built_in">min</span>(a,b);</span><br><span class="line">		<span class="built_in">judge</span>(<span class="number">1900</span>+c1,min_temp,max_temp);<span class="comment">//按从小到大 输出（2）（3） </span></span><br><span class="line">		<span class="keyword">if</span>(max_temp!=min_temp)<span class="comment">//防止重复输出 </span></span><br><span class="line">			<span class="built_in">judge</span>(<span class="number">1900</span>+c1,max_temp,min_temp); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(a1==c1)<span class="comment">//只有一个年份 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(a==b)<span class="comment">//三数相等就只输出一次 </span></span><br><span class="line">			<span class="built_in">judge</span>(<span class="number">1900</span>+a1,b,c);</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//否则按顺序输出 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> max_temp = <span class="built_in">max</span>(a,b);<span class="comment">//取b,c最大值和最小值 </span></span><br><span class="line">			<span class="type">int</span> min_temp = <span class="built_in">min</span>(a,b);</span><br><span class="line">			<span class="built_in">judge</span>(<span class="number">1900</span>+a1,min_temp,max_temp);</span><br><span class="line">			<span class="built_in">judge</span>(<span class="number">1900</span>+c1,max_temp,min_temp); </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span><span class="comment">//先输出（2）（3）再（1） </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> max_temp = <span class="built_in">max</span>(a,b);<span class="comment">//取b,c最大值和最小值 </span></span><br><span class="line">		<span class="type">int</span> min_temp = <span class="built_in">min</span>(a,b);</span><br><span class="line">		<span class="built_in">judge</span>(<span class="number">1900</span>+c1,min_temp,max_temp);<span class="comment">//按从小到大 输出（2）（3） </span></span><br><span class="line">		<span class="keyword">if</span>(max_temp!=min_temp)<span class="comment">//防止重复输出</span></span><br><span class="line">			<span class="built_in">judge</span>(<span class="number">1900</span>+c1,max_temp,min_temp); </span><br><span class="line">		<span class="built_in">judge</span>(<span class="number">1900</span>+a1,b,c);<span class="comment">//判断是否合理 合理即输出 （1） </span></span><br><span class="line">	&#125; 	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构与算法</tag>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title>2016 蓝桥杯 剪邮票 dfs</title>
    <url>/2020/08/31/20200831_2016%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%89%AA%E9%82%AE%E7%A5%A8dfs/</url>
    <content><![CDATA[<p><strong>这是2016年蓝桥杯C语言省赛B组的第七题</strong></p>
<span id="more"></span>

<p><strong>题目：</strong><br>如下图, 有12张连在一起的12生肖的邮票。现在你要从中剪下5张来，要求必须是连着的。（仅仅连接一个角不算相连）<br><img src="/images/2020-08-31/1.jpg#pic_center" alt="图1"></p>
<p>比如，下面两张图中，粉红色所示部分就是合格的剪取。<br><img src="/images/2020-08-31/2.jpg#pic_center" alt="图2"></p>
<p>请你计算，一共有多少种不同的剪取方法。</p>
<p><strong>输出：</strong><br>请填写表示方案数目的整数。</p>
<p><a href="http://oj.ecustacm.cn/problem.php?id=1286">OJ链接</a></p>
<p><strong>思路：</strong> </p>
<ul>
<li>首先，我们将数组储存为<br>1   2   3   4<br>6  7   8   9<br>11 12 13 14<br>这样如果两数相减绝对值是5则是上下相邻关系，绝对值是1则是左右相邻关系。 </li>
<li> <img src="/images/2020-08-31/3.jpg#pic_center" alt="图3"><br> 通过对上图的观察我们可以发现，如果满足题意，则各邮票的相连邮票数量之和一定大于等于8，且每个邮票都有相连邮票。（上面两个图的相连数量之和都为8，如果剪12567的话相连数量就是9）按照这个规律我们就可以用双重循环来搜索答案了。</li>
<li>前面用5层循环来组合出所有可能，防止重复。</li>
</ul>
<p><strong>AC代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> temp[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>&#125;;</span><br><span class="line"><span class="type">int</span> shuzu[<span class="number">5</span>]; </span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1  2  3  4</span></span><br><span class="line"><span class="comment">6  7  8  9</span></span><br><span class="line"><span class="comment">11 12 13 14</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">judge</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;<span class="number">5</span>;now++)<span class="comment">//取前五个 看是否都相连 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> flag=<span class="number">0</span>;<span class="comment">//先假设不相连 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> now1=<span class="number">0</span>;now1&lt;<span class="number">5</span>;now1++)<span class="comment">//挨个判断 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(now==now1)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">abs</span>(shuzu[now1]-shuzu[now])==<span class="number">5</span>||<span class="built_in">abs</span>(shuzu[now1]-shuzu[now])==<span class="number">1</span>)<span class="comment">//上下相连 绝对值为5 或者 左右相连 绝对值为1 </span></span><br><span class="line">			&#123;</span><br><span class="line">				flag+=<span class="number">1</span>;<span class="comment">//相连点位+1 </span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag==<span class="number">0</span>)<span class="comment">//如果是孤立点 没有相连点位 就直接返回false  </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		count+=flag;<span class="comment">//加上连接数 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(count&lt;<span class="number">8</span>)<span class="comment">//如果连接数小于8 则说明5个点位没有相互相邻 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//printf(&quot;%d %d %d %d %d\n&quot;,shuzu[0],shuzu[1],shuzu[2],shuzu[3],shuzu[4]);</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">0</span>;a&lt;<span class="number">12</span>;a++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> b=a<span class="number">+1</span>;b&lt;<span class="number">12</span>;b++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> c=b<span class="number">+1</span>;c&lt;<span class="number">12</span>;c++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> d=c<span class="number">+1</span>;d&lt;<span class="number">12</span>;d++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">for</span>(<span class="type">int</span> e=d<span class="number">+1</span>;e&lt;<span class="number">12</span>;e++)</span><br><span class="line">					&#123;</span><br><span class="line">						shuzu[<span class="number">0</span>]=temp[a],shuzu[<span class="number">1</span>]=temp[b],shuzu[<span class="number">2</span>]=temp[c],shuzu[<span class="number">3</span>]=temp[d],shuzu[<span class="number">4</span>]=temp[e];</span><br><span class="line">						<span class="keyword">if</span>(<span class="built_in">judge</span>())</span><br><span class="line">						&#123;</span><br><span class="line">							ans++;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;	</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构与算法</tag>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title>c/c++算法 基础题 练手汇总</title>
    <url>/2020/09/02/20200902_c++%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E9%A2%98%E7%BB%83%E6%89%8B%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p><strong>因为是基础题所以都不算难，个人把碰见过的感觉比较好的练手基础题在这里做个汇总，方便查阅。</strong></p>
<span id="more"></span>

<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><ul>
<li>一般都是数据量比较小的简单题，难点在于对数据的判断处理。用循环直接对数据区间枚举随后进行判断即可。如果数据量较大，就优化判断条件或者找共性减少运算时间。</li>
</ul>
<h2 id="1-安全区"><a href="#1-安全区" class="headerlink" title="1.安全区"></a>1.安全区</h2><p><strong>题目描述</strong><br>在一个n<em>n的网格图上有m个探测器，第i个探测器位于(xi,yi)位置，探测半径为ri。<br>求出n</em>n个点中有多少个是安全的点，即未被探测的点。</p>
<p><strong>输入</strong><br>第一行为两个整数n,m(1&lt;&#x3D;n&lt;&#x3D;100,1&lt;&#x3D;m&lt;&#x3D;n*n)<br>接下来m行每行3个整数表示xi,yi,ri（1&lt;&#x3D;xi,yi,ri&lt;&#x3D;n）</p>
<p><strong>输出</strong><br>输出一个整数表示答案</p>
<p><strong>样例输入</strong><br>5 2<br>3 3 1<br>4 2 1</p>
<p><strong>样例输出</strong><br>17</p>
<p><a href="http://oj.ecustacm.cn/problem.php?id=1078">OJ链接</a></p>
<p><strong>思路：</strong> 重点是半径判断，我是用<strong>sqrt((x-x1) * (x-x1) + (y-y1) * (y-y1)) &gt; r</strong> 来判断是否在检测半径内，同时用二维数组来储存是否能被探测到。</p>
<p><strong>AC代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> mymap[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> r,<span class="type">int</span> n)</span><span class="comment">//中心点 x y 探测半径 r 地图总长 n</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> a=x-r;a&lt;=x+r;a++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(a&lt;<span class="number">1</span>||a&gt;n)<span class="comment">//x超界</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> b=y-r;b&lt;=y+r;b++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(b&lt;<span class="number">1</span>||b&gt;n)<span class="comment">//y超界</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">sqrt</span>((x-a)*(x-a)+(y-b)*(y-b))&gt;r)<span class="comment">//不在半径内</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="comment">//printf(&quot;%lf %d\n&quot;,sqrt((x-a)*(x-a)+(y-b)*(y-b)),r);</span></span><br><span class="line">			<span class="keyword">if</span>(!mymap[a][b])</span><br><span class="line">				mymap[a][b]=<span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(mymap,<span class="literal">false</span>,<span class="built_in">sizeof</span>(mymap));</span><br><span class="line">	<span class="type">int</span> n,m,xi,yi,ri,ans=<span class="number">0</span>;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="comment">/*for(int a=1;a&lt;=n;a++)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		for(int b=1;b&lt;=n;b++)</span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">			printf(&quot;%d &quot;,mymap[a][b]);</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		printf(&quot;\n&quot;);</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> temp=<span class="number">0</span>;temp&lt;m;temp++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;xi&gt;&gt;yi&gt;&gt;ri;</span><br><span class="line">		<span class="built_in">func</span>(xi,yi,ri,n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">1</span>;a&lt;=n;a++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> b=<span class="number">1</span>;b&lt;=n;b++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//printf(&quot;%d &quot;,mymap[a][b]);</span></span><br><span class="line">			<span class="keyword">if</span>(mymap[a][b]==<span class="literal">false</span>)</span><br><span class="line">				ans++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//printf(&quot;\n&quot;);</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="2-统计方形"><a href="#2-统计方形" class="headerlink" title="2.统计方形"></a>2.统计方形</h2><p><strong>题目描述</strong><br>有一个n*m方格的棋盘，求其方格包含多少正方形、长方形（此处长方形不包含正方形）</p>
<p><strong>输入</strong><br>输入存在多组测试数据。每组测试数据输入两个整数n,m，数字不超过5000</p>
<p><strong>输出</strong><br>对于每组数据输出一行包含两个整数，分别表示正方形数目和长方形数目</p>
<p><strong>样例输入</strong><br>2 3</p>
<p><strong>样例输出</strong><br>8 10</p>
<p><strong>思路：</strong> 就是两层循环，代表当前图形的长和宽，长宽一样就是正方形，不一样就是长方形。然后求出这一行能有多少个这种图形(1+(m-b))，再求这一列有多少种这种图形(1+(n-a))，两者相乘就是这个图里有多少种这种图形。然后加到总数里，等循环跑完就是答案。</p>
<p><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,m;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> ans1=<span class="number">0</span>,ans2=<span class="number">0</span>;<span class="comment">//ans1=正方形 ans2=长方形 </span></span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">1</span>;a&lt;=n;a++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> b=<span class="number">1</span>;b&lt;=m;b++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a==b)</span><br><span class="line">			&#123;</span><br><span class="line">				ans1+=(<span class="number">1</span>+(n-a))*(<span class="number">1</span>+(m-a));	</span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				ans2+=(<span class="number">1</span>+(n-a))*(<span class="number">1</span>+(m-b));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ans2;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>但是这样复杂度会比较高，可能会超时，所以有第二种求法。先求出总的矩形个数，再用一层循环求出正方形个数，总的减去正方形的就是长方形的。</li>
</ul>
<p><strong>AC代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*对于一个n*m的棋盘，共有矩形 (m+m-1+m-2+...+1)*(n+n-1+n-2+...+1)</span></span><br><span class="line"><span class="comment">    即[m*(m+1)/2]*[n*(n+1)/2]个，这一步可知用前一个式子循环道加，也可版用后一个式子直接算；</span></span><br><span class="line"><span class="comment">    共有正方形（假设m&gt;n) m*n+(m-1)*(n-1)+...+(m-n+1)*1 个，这步用循环做就行；</span></span><br><span class="line"><span class="comment">    长方形就用 矩形权数 减去 正方形数 就行了。*/</span></span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m)!=EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">long</span> <span class="type">long</span> sum1=<span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="built_in">min</span>(n,m);i++)</span><br><span class="line">	    &#123;</span><br><span class="line">	        sum1+=(n-i<span class="number">+1</span>)*(m-i<span class="number">+1</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,sum1);</span><br><span class="line">	    <span class="type">long</span> <span class="type">long</span> sum2=<span class="number">1LL</span>*n*(n<span class="number">+1</span>)/<span class="number">2</span>*<span class="number">1LL</span>*m*(m<span class="number">+1</span>)/<span class="number">2</span>;<span class="comment">//1</span></span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,sum2-sum1);</span><br><span class="line">	&#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-连续自然数和（尺取法）"><a href="#3-连续自然数和（尺取法）" class="headerlink" title="3.连续自然数和（尺取法）"></a>3.连续自然数和（尺取法）</h2><p><strong>题目</strong><br>对于给定自然数N，求出存在多少个连续自然数段，长度至少为2，使得这些连续的自然数段之和为N。</p>
<p><strong>输入</strong><br>输入有若干行，每行一个正整数n。(1&lt;&#x3D;n&lt;&#x3D;2000000)</p>
<p><strong>输出</strong><br>对于每组测试数据输出第一个数字表示答案</p>
<p><strong>样例输入</strong><br>9<br>10000</p>
<p><strong>样例输出</strong><br>2<br>4</p>
<p><strong>思路：</strong> 可以用for循环暴力循环出来，但是我下面是用的尺取法，来减少复杂度。</p>
<p><strong>AC代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> ans=<span class="number">0</span>,temp=<span class="number">0</span>,f=<span class="number">1</span>,e=<span class="number">1</span>;<span class="comment">//答案个数 中间值 头 尾</span></span><br><span class="line">		<span class="keyword">while</span>(n!=<span class="number">0</span>)<span class="comment">//尺取</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(temp&lt;n&amp;&amp;e&lt;n)</span><br><span class="line">			&#123;</span><br><span class="line">				temp+=e;</span><br><span class="line">				e++; </span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(temp&lt;n)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(temp==n&amp;&amp;e-f&gt;=<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				ans++;</span><br><span class="line">			&#125;</span><br><span class="line">			temp-=f;</span><br><span class="line">			f++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="4-蓝桥杯-数字分组"><a href="#4-蓝桥杯-数字分组" class="headerlink" title="4.蓝桥杯 数字分组"></a>4.蓝桥杯 数字分组</h2><p><strong>问题描述</strong><br>　　输入任意10个浮点数，根据它们的聚集程度划分为3组，输出每一组的平均值。<br>　　提供老师上课讲的一种思路：将10个数字进行在数轴上排序，然后计算每两个点间的距离，在所有的距离中选取两个最大距离处断开，这样就把10个数字分为了3组。<br>　　本题难度较大，如果深入讨论会比较复杂，大家可以只考虑如下面样例所示的分组情况非常简单的情况，只要简单情况能够成功计算，本题就能得分。<br>　　另外，本题内容有些超前，推荐大家自学一下数组那一章中第一节一维数组，然后使用一维数组来做。排序算法可以参考trustie平台上传的冒泡排序法参考资料。</p>
<p><strong>输入格式</strong><br>　　十个待输入的浮点数，使用空格隔开</p>
<p><strong>输出格式</strong><br>　　三组数的平均数，每输出一个需要换行</p>
<p><strong>样例输入</strong><br>一个满足题目要求的输入范例。<br>例1：<br>50.4 51.3 52.3 9.5 10.4 11.6 19.1 20.8 21.9 49.6<br>例2：<br>8.6 7.4 3.5 17.9 19.1 18.5 37.6 40.4 38.5 40.0</p>
<p><strong>样例输出</strong><br>与上面的样例输入对应的输出。<br>例1：<br>10.5<br>20.6<br>50.9<br>例2:<br>6.5<br>18.5<br>39.125</p>
<p><strong>思路：</strong> 直接循环枚举检测间隔即可。</p>
<p><strong>AC代码：</strong> <a href="http://lx.lanqiao.cn/problem.page?gpid=T774">OJ链接</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> shuzu[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">double</span> max1=<span class="number">0</span>,max2=<span class="number">0</span>,m1,m2;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">0</span>;a&lt;<span class="number">10</span>;a++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;shuzu[a]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(shuzu,shuzu<span class="number">+10</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">0</span>;a&lt;<span class="number">9</span>;a++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">double</span> temp=shuzu[a<span class="number">+1</span>]-shuzu[a];</span><br><span class="line">		<span class="keyword">if</span>(temp&gt;max1)</span><br><span class="line">		&#123;</span><br><span class="line">			max2=max1;</span><br><span class="line">			m2=m1;</span><br><span class="line">			max1=temp;</span><br><span class="line">			m1=a;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(temp&gt;max2)</span><br><span class="line">		&#123;</span><br><span class="line">			max2=temp;</span><br><span class="line">			m2=a;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">double</span> temp=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">0</span>;a&lt;=<span class="built_in">min</span>(m1,m2);a++)</span><br><span class="line">	&#123;</span><br><span class="line">		temp+=shuzu[a];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%g\n&quot;</span>,temp/(<span class="built_in">min</span>(m1,m2)<span class="number">+1</span>));</span><br><span class="line">	temp=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> a=<span class="built_in">min</span>(m1,m2)<span class="number">+1</span>;a&lt;=<span class="built_in">max</span>(m1,m2);a++)</span><br><span class="line">	&#123;</span><br><span class="line">		temp+=shuzu[a];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%g\n&quot;</span>,temp/(<span class="built_in">max</span>(m1,m2)-<span class="built_in">min</span>(m1,m2)));</span><br><span class="line">	temp=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> a=<span class="built_in">max</span>(m1,m2)<span class="number">+1</span>;a&lt;=<span class="number">9</span>;a++)</span><br><span class="line">	&#123;</span><br><span class="line">		temp+=shuzu[a];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%g\n&quot;</span>,temp/(<span class="number">9</span>-<span class="built_in">max</span>(m1,m2)));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 蓝桥杯 C/C++实现 7月C组省赛</title>
    <url>/2020/09/03/20200903_2020%E8%93%9D%E6%A1%A5%E6%9D%AFC-C++%E5%AE%9E%E7%8E%B07%E6%9C%88C%E7%BB%84%E7%9C%81%E8%B5%9B/</url>
    <content><![CDATA[<p><strong>2020蓝桥杯 C&#x2F;C++ 7月C组省赛原题 &amp; 题解</strong></p>
<span id="more"></span>

<h1 id="试题-A-指数计算"><a href="#试题-A-指数计算" class="headerlink" title="试题 A: 指数计算"></a>试题 A: 指数计算</h1><p>本题总分：5 分<br><strong>问题：</strong><br>请计算：7 ^ 2020 mod 1921，其中 A mod B 表示 A 除以 B 的余数。</p>
<p><strong>思路：</strong> 快速幂。</p>
<p><strong>答案：</strong> <strong>480</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">ksm</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(b==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> a*<span class="built_in">ksm</span>(a,b<span class="number">-1</span>,c)%c;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">long</span> <span class="type">long</span> ans=<span class="built_in">ksm</span>(a,b/<span class="number">2</span>,c)%c;</span><br><span class="line">		<span class="keyword">return</span> ans*ans%c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,<span class="built_in">ksm</span>(<span class="number">7</span>,<span class="number">2020</span>,<span class="number">1921</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="试题-B-解密"><a href="#试题-B-解密" class="headerlink" title="试题 B: 解密"></a>试题 B: 解密</h1><p>本题总分：5 分<br><strong>问题:</strong><br>小明设计了一种文章加密的方法：对于每个字母 c，将它变成某个另外的字符 Tc。下表给出了字符变换的规则：<br><img src="/images/2020-09-03/1.jpg#pic_center" alt="rt"><br>例如，将字符串 YeRi 加密可得字符串 EaFn。小明有一个随机的字符串，加密后为<strong>EaFnjISplhFviDhwFbEjRjfIBBkRyY</strong>(由 30 个大小写英文字母组成，不包含换行符），请问原字符串是多少？<br>（如果你把以上字符串和表格复制到文本文件中，请务必检查复制的内容是否与文档中的一致。在试题目录下有一个文件 str.txt，第一行为上面的字符串，后面 52 行依次为表格中的内容。）</p>
<p><strong>思路：</strong> 因为我没有文本形式的这个对照表。。。所以用的最笨的方法。</p>
<p><strong>答案：</strong> <strong>YeRikGSunlRzgDlvRwYkXkrGWWhXaA</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string a=<span class="string">&quot;EaFnjISplhFviDhwFbEjRjfIBBkRyY&quot;</span>;</span><br><span class="line">	<span class="comment">//cin&gt;&gt;a;     //EaFnjISplhFviDhwFbEjRjfIBBkRyY</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;a.<span class="built_in">size</span>();now++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">switch</span>(a[now])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;e&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;w&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;f&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;d&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;y&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;r&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;o&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;l&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;g&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;j&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;k&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;k&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;h&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;n&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;c&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;i&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;p&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;u&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;q&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;m&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;x&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;s&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;j&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;q&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;z&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;v&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;b&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;y&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;a&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;z&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;t&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;E&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;W&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;F&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;D&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;Y&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;F&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;R&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;G&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;O&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;H&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;L&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;G&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;J&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;K&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;K&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;H&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;N&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;C&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;N&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;I&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;O&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;P&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;P&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;U&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;Q&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;M&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;R&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;X&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;S&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;J&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;U&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;Q&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;Z&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;W&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;V&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;B&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;Y&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;A&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;Z&#x27;</span>:cout&lt;&lt;<span class="string">&#x27;T&#x27;</span>;<span class="keyword">break</span>;		</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="试题-C-跑步训练"><a href="#试题-C-跑步训练" class="headerlink" title="试题 C: 跑步训练"></a>试题 C: 跑步训练</h1><p>本题总分：10 分<br><strong>问题：</strong><br>小明要做一个跑步训练。<br>初始时，小明充满体力，体力值计为 10000。如果小明跑步，每分钟损耗600 的体力。如果小明休息，每分钟增加 300 的体力。体力的损耗和增加都是均匀变化的。<br>小明打算跑一分钟、休息一分钟、再跑一分钟、再休息一分钟……如此循环。如果某个时刻小明的体力到达 0，他就停止锻炼。<br>请问小明在多久后停止锻炼。为了使答案为整数，请以秒为单位输出答案。<br>答案中只填写数，不填写单位。</p>
<p><strong>思路：</strong> 简单循环即可。</p>
<p><strong>答案：</strong> <strong>3880</strong> </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> first=<span class="number">10000</span>,ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(first)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(first&gt;=<span class="number">600</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			first-=<span class="number">600</span>;</span><br><span class="line">			ans+=<span class="number">60</span>;</span><br><span class="line">			first+=<span class="number">300</span>;</span><br><span class="line">			ans+=<span class="number">60</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			ans+=first/<span class="number">10</span>;</span><br><span class="line">			first=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="试题-D-合并检测"><a href="#试题-D-合并检测" class="headerlink" title="试题 D: 合并检测"></a>试题 D: 合并检测</h1><p>本题总分：10 分<br><strong>问题：</strong><br>新冠疫情由新冠病毒引起，最近在 A 国蔓延，为了尽快控制疫情，A 国准 备给大量民众进病毒核酸检测。<br>然而，用于检测的试剂盒紧缺。 为了解决这一困难，科学家想了一个办法：合并检测。即将从多个人（k 个）采集的标本放到同一个试剂盒中进行检测。如果结果为阴性，则说明这 k 个人都是阴性，用一个试剂盒完成了 k 个人的检测。如果结果为阳性，则说明 至少有一个人为阳性，需要将这 k 个人的样本全部重新独立检测（从理论上看， 如果检测前 k−1 个人都是阴性可以推断出第 k 个人是阳性，但是在实际操作中 不会利用此推断，而是将 k 个人独立检测），加上最开始的合并检测，一共使用 了 k + 1 个试剂盒完成了 k 个人的检测。<br> A 国估计被测的民众的感染率大概是 **1%**，呈均匀分布。请问 k 取多少能 最节省试剂盒？</p>
<p><strong>思路：</strong> 假设有一共检测m个人，则第一批检测需要m&#x2F;k个试剂盒（向上取整）。由于感染率为1%，且均匀分布，则有0.01 * m个试剂盒会有阳性反应。这时进行第二批挨个检测，检测盒数量即为0.01 * m * k个。<br>则总需求盒子数即为<strong>m&#x2F;k+0.01 * m * k</strong>个（m&#x2F;k向上取整）。</p>
<p><strong>答案：</strong> 10</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> min_=<span class="number">999</span>,min_k=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> m=<span class="number">100</span>;<span class="comment">//假设初始人有100 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">100</span>;k++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> need=m/k<span class="number">+0.01</span>*m*k;</span><br><span class="line">		<span class="keyword">if</span>(m%k!=<span class="number">0</span>)</span><br><span class="line">			need++;</span><br><span class="line">		<span class="keyword">if</span>(need&lt;min_)</span><br><span class="line">		&#123;</span><br><span class="line">			min_=need;</span><br><span class="line">			min_k=k;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;min_k;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="试题-E-REPEAT-程序"><a href="#试题-E-REPEAT-程序" class="headerlink" title="试题 E: REPEAT 程序"></a>试题 E: REPEAT 程序</h1><p>本题总分：15 分<br><strong>问题：</strong><br>附件 prog.txt 中是一个用某种语言写的程序。<br><a href="https://wwa.lanzous.com/i6APvex4r3g">prog.txt 附件下载地址</a><br>其中 REPEAT k 表示一个次数为 k 的循环。循环控制的范围由缩进表达，从次行开始连续的缩进比该行多的（前面的空白更长的）为循环包含的内容。<br>例如如下片段：<br><img src="/images/2020-09-03/2.jpg#pic_center" alt="rt"></p>
<p>A &#x3D; A + 4 所在的行到 A &#x3D; A + 8 所在的行都在第一行的循环两次中。<br>REPEAT 6: 所在的行到 A &#x3D; A + 7 所在的行都在 REPEAT 5: 循环中。<br>A &#x3D; A + 5 实际总共的循环次数是 2 × 5 × 6 &#x3D; 60 次。<br>请问该程序执行完毕之后，A 的值是多少？</p>
<p><strong>思路：</strong> 可以建立一个栈来存放循环的信息，一个变量times存放当前行数被执行的次数。通过对文本的观察我们发现，可以通过每一行前面的空格数量来判断当前行数的“等级”，4个空格代表一个等级。如果当前行等级比上一层循环的等级低则说明退出了上一层循环，对栈和times进行改变即可。随后我们发现整个文本里面，所有数字都为单位数，所以我们直接用循环找到一个数字即可提取出该行的有效数字。</p>
<p><strong>答案：</strong> 241830</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string string_;</span><br><span class="line">	stack&lt;<span class="type">int</span>&gt;stack_; </span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;prog.txt&quot;</span>, <span class="string">&quot;rb&quot;</span>, stdin);</span><br><span class="line">	<span class="built_in">getline</span>(cin, string_);<span class="comment">//读第一行 A=0 </span></span><br><span class="line">	<span class="type">int</span> A=<span class="number">0</span>,times=<span class="number">1</span>,old_counts=<span class="number">0</span>;<span class="comment">//A=0,当前倍数，老的层数 </span></span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">getline</span>(cin, string_))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> counts=<span class="number">0</span>;<span class="comment">//当前的层数，</span></span><br><span class="line">		<span class="keyword">for</span>(counts=<span class="number">0</span>;counts&lt;string_.<span class="built_in">size</span>();counts++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//记录空格数 4个空格是一层 </span></span><br><span class="line">			<span class="keyword">if</span>(string_[counts]!=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		counts/=<span class="number">4</span>;<span class="comment">//这句话的层数 </span></span><br><span class="line">		<span class="keyword">while</span>(counts&lt;old_counts)<span class="comment">//新层数低 则退出一层循环 pop </span></span><br><span class="line">		&#123;</span><br><span class="line">			times/=stack_.<span class="built_in">top</span>();</span><br><span class="line">			stack_.<span class="built_in">pop</span>();</span><br><span class="line">			old_counts--; </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">if</span>(string_[counts*<span class="number">4</span>]==<span class="string">&#x27;R&#x27;</span>)<span class="comment">//R开头就是新增循环</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> now=counts*<span class="number">4</span>;now&lt;string_.<span class="built_in">size</span>();now++)<span class="comment">//找到数字 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(string_[now]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;string_[now]&lt;=<span class="string">&#x27;9&#x27;</span>)<span class="comment">//如果是数字 </span></span><br><span class="line">				&#123;</span><br><span class="line">					stack_.<span class="built_in">push</span>(string_[now]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">					times*=string_[now]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">					old_counts++;</span><br><span class="line">					<span class="keyword">break</span>; </span><br><span class="line">				&#125; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span><span class="comment">//否则就是执行计算操作 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> now=counts*<span class="number">4</span>;now&lt;string_.<span class="built_in">size</span>();now++)<span class="comment">//找到数字 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(string_[now]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;string_[now]&lt;=<span class="string">&#x27;9&#x27;</span>)<span class="comment">//如果是数字 </span></span><br><span class="line">				&#123;</span><br><span class="line">					A+=(string_[now]-<span class="string">&#x27;0&#x27;</span>)*times;</span><br><span class="line">					<span class="keyword">break</span>; </span><br><span class="line">				&#125; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;A; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="试题-F-分类计数"><a href="#试题-F-分类计数" class="headerlink" title="试题 F: 分类计数"></a>试题 F: 分类计数</h1><p>时间限制: 1.0s 内存限制: 512.0MB 本题总分：15 分<br><strong>问题：</strong><br>输入一个字符串，请输出这个字符串包含多少个大写字母，多少个小写字母，多少个数字。</p>
<p><strong>输入：</strong><br>输入一行包含一个字符串。</p>
<p><strong>输出：</strong><br>输出三行，每行一个整数，分别表示大写字母、小写字母和数字的个数。</p>
<p><strong>样例输入：</strong><br>1+a&#x3D;Aab</p>
<p><strong>样例输出：</strong><br>1<br>3<br>1</p>
<p><strong>思路：</strong> 简单循环。</p>
<p><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string string_;</span><br><span class="line">	<span class="built_in">getline</span>(cin,string_);</span><br><span class="line">	<span class="type">int</span> ans_1=<span class="number">0</span>,ans_2=<span class="number">0</span>,ans_3=<span class="number">0</span>;<span class="comment">//大写，小写，数字</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> now=<span class="number">0</span>;now&lt;string_.<span class="built_in">size</span>();now++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(string_[now]&lt;=<span class="string">&#x27;Z&#x27;</span>&amp;&amp;string_[now]&gt;=<span class="string">&#x27;A&#x27;</span>) </span><br><span class="line">		&#123;</span><br><span class="line">			ans_1++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(string_[now]&lt;=<span class="string">&#x27;z&#x27;</span>&amp;&amp;string_[now]&gt;=<span class="string">&#x27;a&#x27;</span>) </span><br><span class="line">		&#123;</span><br><span class="line">			ans_2++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(string_[now]&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;string_[now]&gt;=<span class="string">&#x27;0&#x27;</span>) </span><br><span class="line">		&#123;</span><br><span class="line">			ans_3++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n%d\n%d\n&quot;</span>,ans_1,ans_2,ans_3);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="试题-G-整除序列"><a href="#试题-G-整除序列" class="headerlink" title="试题 G: 整除序列"></a>试题 G: 整除序列</h1><p>时间限制: 1.0s 内存限制: 512.0MB 本题总分：20 分<br><strong>问题：</strong><br>有一个序列，序列的第一个数是 n，后面的每个数是前一个数整除 2，请输出这个序列中值为正数的项。</p>
<p><strong>输入：</strong><br>输入一行包含一个整数 n。</p>
<p><strong>输出：</strong><br>输出一行，包含多个整数，相邻的整数之间用一个空格分隔，表示答案。</p>
<p><strong>样例输入：</strong><br>20</p>
<p><strong>样例输出：</strong><br>20 10 5 2 1</p>
<p><strong>评测用例规模与约定：</strong><br>对于 80% 的评测用例，1 ≤ n ≤ 10的9次方。<br>对于所有评测用例，1 ≤ n ≤ 10的18次方。</p>
<p><strong>思路：</strong> 简单循环即可。</p>
<p><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">while</span>(n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,n);</span><br><span class="line">		n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="试题-H-走方格"><a href="#试题-H-走方格" class="headerlink" title="试题 H: 走方格"></a>试题 H: 走方格</h1><p>时间限制: 1.0s 内存限制: 512.0MB 本题总分：20 分<br><strong>问题：</strong><br>在平面上有一些二维的点阵。这些点的编号就像二维数组的编号一样，从上到下依次为第 1 至第 n 行，从左到右依次为第 1 至第 m 列，每一个点可以用行号和列号来表示。现在有个人站在第 1 行第 1 列，要走到第 n 行第 m 列。只能向右或者向下走。<br><strong>注意</strong>，如果行号和列数都是偶数，不能走入这一格中。问有多少种方案。</p>
<p><strong>输入：</strong><br>输入一行包含两个整数 n, m。</p>
<p><strong>输出：</strong><br>输出一个整数，表示答案。</p>
<p><strong>样例输入1：</strong><br>3 4</p>
<p><strong>样例输出1：</strong><br>2</p>
<p><strong>样例输入2：</strong><br>6 6</p>
<p><strong>样例输出2：</strong><br>0</p>
<p><strong>评测用例规模与约定：</strong><br>对于所有评测用例，1 ≤ n ≤ 30, 1 ≤ m ≤ 30。</p>
<p><strong>思路：</strong> dfs暴力搜索的话，当n&#x3D;29，m&#x3D;30的时候应该会超时。我们可以用dp把结果都记录下来然后直接输出。记得行号列号都是偶数的时候跳过，因为不能走入这种方格。</p>
<p><strong>代码：</strong></p>
<ul>
<li>dfs写法<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fx[<span class="number">2</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;,ans=<span class="number">0</span>;<span class="comment">//右/下 答案 </span></span><br><span class="line"><span class="type">int</span> n,m,a1,b1;<span class="comment">//n,m </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a==n&amp;&amp;b==m)</span><br><span class="line">	&#123;</span><br><span class="line">		ans++;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;<span class="number">2</span>;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		a1=a+fx[now][<span class="number">0</span>];</span><br><span class="line">		b1=b+fx[now][<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(a1&gt;n||b1&gt;m) </span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(!(a1&amp;<span class="number">1</span>)&amp;&amp;!(b1&amp;<span class="number">1</span>)) </span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(a1,b1); </span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">if</span>(!(n&amp;<span class="number">1</span>)&amp;&amp;!(m&amp;<span class="number">1</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
<li>dp写法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> dp[<span class="number">31</span>][<span class="number">31</span>];<span class="comment">//dp</span></span><br><span class="line">	<span class="type">int</span> n,m;<span class="comment">//n,m </span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">	dp[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1</span>;now&lt;=<span class="number">30</span>;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> now1=<span class="number">1</span>;now1&lt;=<span class="number">30</span>;now1++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!(now&amp;<span class="number">1</span>)&amp;&amp;!(now1&amp;<span class="number">1</span>))<span class="comment">//都是偶数就跳过 </span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(now<span class="number">-1</span>&gt;=<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[now][now1]+=dp[now<span class="number">-1</span>][now1];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(now1<span class="number">-1</span>&gt;=<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[now][now1]+=dp[now][now1<span class="number">-1</span>];</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*for(int now=1;now&lt;=30;now++)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		for(int now1=1;now1&lt;=30;now1++)</span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">			printf(&quot;%d &quot;,dp[now][now1]);</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		printf(&quot;\n&quot;);</span></span><br><span class="line"><span class="comment">	&#125;*/</span> </span><br><span class="line">	cout&lt;&lt;dp[n][m];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h1 id="试题-I-字符串编码"><a href="#试题-I-字符串编码" class="headerlink" title="试题 I: 字符串编码"></a>试题 I: 字符串编码</h1><p>时间限制: 1.0s 内存限制: 512.0MB 本题总分：25 分<br><strong>问题：</strong><br>小明发明了一种给由全大写字母组成的字符串编码的方法。对于每一个大写字母，小明将它转换成它在 26 个英文字母中序号，即 A → 1, B → 2, … Z →26。<br>这样一个字符串就能被转化成一个数字序列：<br>比如 ABCXYZ → 123242526。<br>现在给定一个转换后的数字序列，小明想还原出原本的字符串。当然这样的还原有可能存在多个符合条件的字符串。小明希望找出其中字典序最大的字符串。</p>
<p><strong>输入：</strong><br>一个数字序列。</p>
<p><strong>输出：</strong><br>一个只包含大写字母的字符串，代表答案</p>
<p><strong>样例输入：</strong><br>123242526</p>
<p><strong>样例输出：</strong><br>LCXYZ</p>
<p><strong>评测用例规模与约定</strong><br>对于 20% 的评测用例，输入的长度不超过 20。<br>对于所有评测用例，输入的长度不超过 200000。</p>
<p><strong>思路：</strong> 多条件判定，连着两个数和大于26的单个输出，后数第两个值为0的单个输出……大概要点好像就这么多，欢迎补充。</p>
<p><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string string_;</span><br><span class="line">	<span class="built_in">getline</span>(cin,string_);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;string_.<span class="built_in">size</span>();)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(string_[now]==<span class="string">&#x27;1&#x27;</span>)<span class="comment">//开头为1 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(now<span class="number">+2</span>&lt;string_.<span class="built_in">size</span>())<span class="comment">//后两位有数 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(string_[now<span class="number">+2</span>]!=<span class="string">&#x27;0&#x27;</span>)<span class="comment">//后第两位不是0 </span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,(string_[now]-<span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span>+string_[now<span class="number">+1</span>]-<span class="string">&#x27;0&#x27;</span>+<span class="string">&#x27;A&#x27;</span><span class="number">-1</span>);</span><br><span class="line">					now+=<span class="number">2</span>;<span class="comment">//后移两位 </span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,string_[now]-<span class="string">&#x27;0&#x27;</span>+<span class="string">&#x27;A&#x27;</span><span class="number">-1</span>);</span><br><span class="line">					now++;<span class="comment">//后移一位 </span></span><br><span class="line">				&#125; </span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(now<span class="number">+1</span>&lt;string_.<span class="built_in">size</span>())<span class="comment">//后一位有数 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,(string_[now]-<span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span>+string_[now<span class="number">+1</span>]-<span class="string">&#x27;0&#x27;</span>+<span class="string">&#x27;A&#x27;</span><span class="number">-1</span>);</span><br><span class="line">				now+=<span class="number">2</span>;<span class="comment">//后移两位 </span></span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">else</span><span class="comment">//最后一位直接输出 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,string_[now]-<span class="string">&#x27;0&#x27;</span>+<span class="string">&#x27;A&#x27;</span><span class="number">-1</span>);</span><br><span class="line">				now++;<span class="comment">//后移一位 </span></span><br><span class="line">			&#125; </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(string_[now]==<span class="string">&#x27;2&#x27;</span>)<span class="comment">//开头为2 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(now<span class="number">+2</span>&lt;string_.<span class="built_in">size</span>())<span class="comment">//后两位有数 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(string_[now<span class="number">+2</span>]!=<span class="string">&#x27;0&#x27;</span>)<span class="comment">//后第两位不是0 </span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(string_[now<span class="number">+1</span>]&lt;=<span class="string">&#x27;6&#x27;</span>)<span class="comment">//小于26 </span></span><br><span class="line">					&#123;</span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,(string_[now]-<span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span>+string_[now<span class="number">+1</span>]-<span class="string">&#x27;0&#x27;</span>+<span class="string">&#x27;A&#x27;</span><span class="number">-1</span>);</span><br><span class="line">						now+=<span class="number">2</span>;<span class="comment">//后移两位 </span></span><br><span class="line">					&#125; </span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">					&#123;</span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,string_[now]-<span class="string">&#x27;0&#x27;</span>+<span class="string">&#x27;A&#x27;</span><span class="number">-1</span>);</span><br><span class="line">						now++;<span class="comment">//后移一位 </span></span><br><span class="line">					&#125; </span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,string_[now]-<span class="string">&#x27;0&#x27;</span>+<span class="string">&#x27;A&#x27;</span><span class="number">-1</span>);</span><br><span class="line">					now++;<span class="comment">//后移一位 </span></span><br><span class="line">				&#125; </span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(now<span class="number">+1</span>&lt;string_.<span class="built_in">size</span>())<span class="comment">//后一位有数 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(string_[now<span class="number">+1</span>]&lt;=<span class="string">&#x27;6&#x27;</span>)<span class="comment">//小于26 </span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,(string_[now]-<span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span>+string_[now<span class="number">+1</span>]-<span class="string">&#x27;0&#x27;</span>+<span class="string">&#x27;A&#x27;</span><span class="number">-1</span>);</span><br><span class="line">					now+=<span class="number">2</span>;<span class="comment">//后移两位 </span></span><br><span class="line">				&#125; </span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,string_[now]-<span class="string">&#x27;0&#x27;</span>+<span class="string">&#x27;A&#x27;</span><span class="number">-1</span>);</span><br><span class="line">					now++;<span class="comment">//后移一位 </span></span><br><span class="line">				&#125; </span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">else</span><span class="comment">//最后一位直接输出 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,string_[now]-<span class="string">&#x27;0&#x27;</span>+<span class="string">&#x27;A&#x27;</span><span class="number">-1</span>);</span><br><span class="line">				now++;<span class="comment">//后移一位 </span></span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//其余直接输出 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,string_[now]-<span class="string">&#x27;0&#x27;</span>+<span class="string">&#x27;A&#x27;</span><span class="number">-1</span>);</span><br><span class="line">			now++;<span class="comment">//后移一位 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="试题-J-整数小拼接"><a href="#试题-J-整数小拼接" class="headerlink" title="试题 J: 整数小拼接"></a>试题 J: 整数小拼接</h1><p>时间限制: 1.0s 内存限制: 512.0MB 本题总分：25 分<br><strong>问题：</strong><br>给定义个长度为 n 的数组 A1, A2, · · · , An。你可以从中选出两个数 Ai 和 Aj (i不等于 j)，然后将 Ai 和 Aj 一前一后拼成一个新的整数。例如 12 和 345 可以拼成 12345 或 34512 。注意交换 Ai 和 Aj 的顺序总是被视为 2 种拼法，即便是 Ai &#x3D; Aj 时。请你计算有多少种拼法满足拼出的整数小于等于 K。</p>
<p><strong>输入：</strong><br>第一行包含 2 个整数 n 和 K。<br>第二行包含 n 个整数 A1, A2, · · · , An。</p>
<p><strong>输出：</strong><br>一个整数代表答案。</p>
<p><strong>样例输入：</strong><br>4 33<br>1 2 3 4</p>
<p><strong>样例输出：</strong><br>8</p>
<p><strong>评测用例规模与约定：</strong><br>对于 30% 的评测用例，1 ≤ N ≤ 1000, 1 ≤ K ≤ 10的8次方, 1 ≤ Ai ≤ 10的四次方。<br>对于所有评测用例，1 ≤ N ≤ 100000，1 ≤ K ≤ 10的十次方，1 ≤ Ai ≤ 10的九次方。</p>
<p><strong>思路：</strong> 暴力求解应该只能过30%样例。我的思路是在第一次接收数组的时候，直接再次按位数存到二维数组里。在接下来的判断中，两个数的位数相加小于K的位数的话，就是合法值。两个数的位数相加等于K的时候再相加准确计算，由于数据最大为十的十次方，所以用long long存。<br>这样的思路应该能比直接暴力快不少，评测点应该能多过几个，但是能不能AC我也不清楚，毕竟现在也没样例数据。如果大佬们有好的思路，麻烦指导下谢谢。</p>
<p><strong>代码：</strong> </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> array[<span class="number">100001</span>];<span class="comment">//存数据 </span></span><br><span class="line">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;mymap[<span class="number">10</span>];<span class="comment">//存上面数组的每个数的位数 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> n,k,ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;n;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;array[now]);	</span><br><span class="line">		mymap[(<span class="type">int</span>)<span class="built_in">log10</span>(array[now])<span class="number">+1</span>].<span class="built_in">push_back</span>(array[now]);<span class="comment">//按位数存进mymap里</span></span><br><span class="line">	&#125; </span><br><span class="line">	<span class="type">int</span> k_count=(<span class="type">int</span>)<span class="built_in">log10</span>(k)<span class="number">+1</span>,temp,temp1;<span class="comment">//k的位数 中间值（后面用） </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1</span>;now&lt;k_count<span class="number">-1</span>;now++)<span class="comment">//两个数位数相加小于k的位数 说明肯定小于k 直接交叉相乘 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> now1=<span class="number">1</span>;now1+now&lt;k_count;now1++)</span><br><span class="line">		&#123;</span><br><span class="line">			ans+=mymap[now].<span class="built_in">size</span>()*mymap[now1].<span class="built_in">size</span>();</span><br><span class="line">			<span class="keyword">if</span>(now==now1)<span class="comment">//如果位数相同 则有重复计算 </span></span><br><span class="line">			&#123;</span><br><span class="line">				ans-=mymap[now].<span class="built_in">size</span>();<span class="comment">//减去一部分 </span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">sort</span>(array,array+n);<span class="comment">//先排个序 一会循环到位数大于等于k的位数的时候 直接break; </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;n;now++)<span class="comment">//两个数位数相加等于k的情况 挨个判断 </span></span><br><span class="line">	&#123;</span><br><span class="line">		temp=(<span class="type">int</span>)<span class="built_in">log10</span>(array[now])<span class="number">+1</span>;</span><br><span class="line">		<span class="keyword">if</span>(temp&gt;=k_count)</span><br><span class="line">			<span class="keyword">break</span>; </span><br><span class="line">		temp1=mymap[k_count-temp].<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> now1=<span class="number">0</span>;now1&lt;temp1;now1++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//cout&lt;&lt;array[now]*pow(10,k_count-temp)+mymap[k_count-temp][now1]&lt;&lt;&quot; &quot;&lt;&lt;k&lt;&lt;endl;</span></span><br><span class="line">			<span class="keyword">if</span>(array[now]*<span class="built_in">pow</span>(<span class="number">10</span>,k_count-temp)+mymap[k_count-temp][now1]&lt;=k)<span class="comment">//两数相加小于等于k </span></span><br><span class="line">			&#123;</span><br><span class="line">				ans++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">if</span>(temp==k_count-temp&amp;&amp;array[now]*<span class="built_in">pow</span>(<span class="number">10</span>,k_count-temp)+array[now]&lt;=k)<span class="comment">//重复计数 减一个 </span></span><br><span class="line">		&#123;</span><br><span class="line">			ans--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构与算法</tag>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 蓝桥杯 C/C++实现 7月B组省赛</title>
    <url>/2020/09/06/20200906_2020%E8%93%9D%E6%A1%A5%E6%9D%AFC-C++%E5%AE%9E%E7%8E%B07%E6%9C%88B%E7%BB%84%E7%9C%81%E8%B5%9B/</url>
    <content><![CDATA[<p><strong>2020蓝桥杯 C&#x2F;C++ 7月B组省赛原题 &amp; 题解</strong></p>
<span id="more"></span>

<p>@<a href="%E9%A2%98%E7%9B%AE%E5%88%97%E8%A1%A8">TOC</a></p>
<h1 id="试题-A-跑步训练"><a href="#试题-A-跑步训练" class="headerlink" title="试题 A: 跑步训练"></a>试题 A: 跑步训练</h1><p>本题总分：5 分<br><strong>问题：</strong><br>小明要做一个跑步训练。<br>初始时，小明充满体力，体力值计为 10000。如果小明跑步，每分钟损耗600 的体力。如果小明休息，每分钟增加 300 的体力。体力的损耗和增加都是均匀变化的。<br>小明打算跑一分钟、休息一分钟、再跑一分钟、再休息一分钟……如此循环。如果某个时刻小明的体力到达 0，他就停止锻炼。<br>请问小明在多久后停止锻炼。为了使答案为整数，请以<strong>秒</strong>为单位输出答案。<br>答案中只填写数，不填写单位。</p>
<p><strong>思路：</strong> 简单循环即可。</p>
<p><strong>答案：</strong> <strong>3880</strong> </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> first=<span class="number">10000</span>,ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(first)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(first&gt;=<span class="number">600</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			first-=<span class="number">600</span>;</span><br><span class="line">			ans+=<span class="number">60</span>;</span><br><span class="line">			first+=<span class="number">300</span>;</span><br><span class="line">			ans+=<span class="number">60</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			ans+=first/<span class="number">10</span>;</span><br><span class="line">			first=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="试题-B-纪念日"><a href="#试题-B-纪念日" class="headerlink" title="试题 B: 纪念日"></a>试题 B: 纪念日</h1><p>本题总分：5 分<br><strong>问题：</strong><br>2020 年 7 月 1 日是中国某党成立 99 周年纪念日。<br>中国某党成立于 1921 年 7 月 23 日。<br>请问从 1921 年 7 月 23 日中午 12 时到 2020 年 7 月 1 日中午 12 时一共含多少分钟？</p>
<p><strong>思路：</strong> 先算多少天，再算多少时，再算多少分钟。</p>
<p><strong>答案：</strong> <strong>52038720</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1922</span>;now&lt;<span class="number">2020</span>;now++)<span class="comment">//1922到2019年共有多少天 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(now%<span class="number">100</span>!=<span class="number">0</span>&amp;&amp;now%<span class="number">4</span>==<span class="number">0</span>||now%<span class="number">400</span>==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			ans+=<span class="number">366</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			ans+=<span class="number">365</span>;	</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	ans=ans<span class="number">+31</span><span class="number">+29</span><span class="number">+31</span><span class="number">+30</span><span class="number">+31</span><span class="number">+30</span>;<span class="comment">//2020年1到6月有多少天 </span></span><br><span class="line">	ans=ans<span class="number">+31</span><span class="number">+30</span><span class="number">+31</span><span class="number">+30</span><span class="number">+31</span>;<span class="comment">//1921年8月到12月有多少天</span></span><br><span class="line">	ans+=<span class="number">9</span>;<span class="comment">//加上多余那几天</span></span><br><span class="line">	ans*=<span class="number">24</span>;<span class="comment">//换算成时 </span></span><br><span class="line">	ans*=<span class="number">60</span>;<span class="comment">//换算成分 </span></span><br><span class="line">	cout&lt;&lt;ans; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="试题-C-合并检测"><a href="#试题-C-合并检测" class="headerlink" title="试题 C: 合并检测"></a>试题 C: 合并检测</h1><p>本题总分：10 分<br><strong>问题：</strong><br>新冠疫情由新冠病毒引起，最近在 A 国蔓延，为了尽快控制疫情，A 国准 备给大量民众进病毒核酸检测。<br>然而，用于检测的试剂盒紧缺。 为了解决这一困难，科学家想了一个办法：合并检测。即将从多个人（k 个）采集的标本放到同一个试剂盒中进行检测。如果结果为阴性，则说明这 k 个人都是阴性，用一个试剂盒完成了 k 个人的检测。如果结果为阳性，则说明 至少有一个人为阳性，需要将这 k 个人的样本全部重新独立检测（从理论上看， 如果检测前 k−1 个人都是阴性可以推断出第 k 个人是阳性，但是在实际操作中 不会利用此推断，而是将 k 个人独立检测），加上最开始的合并检测，一共使用 了 k + 1 个试剂盒完成了 k 个人的检测。<br> A 国估计被测的民众的感染率大概是 **1%**，呈均匀分布。请问 k 取多少能 最节省试剂盒？</p>
<p><strong>思路：</strong> 假设有一共检测m个人，则第一批检测需要m&#x2F;k个试剂盒（向上取整）。由于感染率为1%，且均匀分布，则有0.01 * m个试剂盒会有阳性反应。这时进行第二批挨个检测，检测盒数量即为0.01 * m * k个。<br>则总需求盒子数即为<strong>m&#x2F;k+0.01 * m * k</strong>个（m&#x2F;k向上取整）。</p>
<p><strong>答案：</strong> 10</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> min_=<span class="number">999</span>,min_k=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> m=<span class="number">100</span>;<span class="comment">//假设初始人有100 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">100</span>;k++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> need=m/k<span class="number">+0.01</span>*m*k;</span><br><span class="line">		<span class="keyword">if</span>(m%k!=<span class="number">0</span>)</span><br><span class="line">			need++;</span><br><span class="line">		<span class="keyword">if</span>(need&lt;min_)</span><br><span class="line">		&#123;</span><br><span class="line">			min_=need;</span><br><span class="line">			min_k=k;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;min_k;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="试题-D-REPEAT-程序"><a href="#试题-D-REPEAT-程序" class="headerlink" title="试题 D: REPEAT 程序"></a>试题 D: REPEAT 程序</h1><p>本题总分：15 分<br><strong>问题：</strong><br>附件 prog.txt 中是一个用某种语言写的程序。<br><a href="https://wwa.lanzous.com/i6APvex4r3g">prog.txt 附件下载地址</a><br>其中 REPEAT k 表示一个次数为 k 的循环。循环控制的范围由缩进表达，从次行开始连续的缩进比该行多的（前面的空白更长的）为循环包含的内容。<br>例如如下片段：<br><img src="/images/2020-09-06/1.jpg#pic_center" alt="rt"></p>
<p>A &#x3D; A + 4 所在的行到 A &#x3D; A + 8 所在的行都在第一行的循环两次中。<br>REPEAT 6: 所在的行到 A &#x3D; A + 7 所在的行都在 REPEAT 5: 循环中。<br>A &#x3D; A + 5 实际总共的循环次数是 2 × 5 × 6 &#x3D; 60 次。<br>请问该程序执行完毕之后，A 的值是多少？</p>
<p><strong>思路：</strong> 可以建立一个栈来存放循环的信息，一个变量times存放当前行数被执行的次数。通过对文本的观察我们发现，可以通过每一行前面的空格数量来判断当前行数的“等级”，4个空格代表一个等级。如果当前行等级比上一层循环的等级低则说明退出了上一层循环，对栈和times进行改变即可。随后我们发现整个文本里面，所有数字都为单位数，所以我们直接用循环找到一个数字即可提取出该行的有效数字。</p>
<p><strong>答案：</strong> <strong>241830</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string string_;</span><br><span class="line">	stack&lt;<span class="type">int</span>&gt;stack_; </span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;prog.txt&quot;</span>, <span class="string">&quot;rb&quot;</span>, stdin);</span><br><span class="line">	<span class="built_in">getline</span>(cin, string_);<span class="comment">//读第一行 A=0 </span></span><br><span class="line">	<span class="type">int</span> A=<span class="number">0</span>,times=<span class="number">1</span>,old_counts=<span class="number">0</span>;<span class="comment">//A=0,当前倍数，老的层数 </span></span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">getline</span>(cin, string_))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> counts=<span class="number">0</span>;<span class="comment">//当前的层数，</span></span><br><span class="line">		<span class="keyword">for</span>(counts=<span class="number">0</span>;counts&lt;string_.<span class="built_in">size</span>();counts++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//记录空格数 4个空格是一层 </span></span><br><span class="line">			<span class="keyword">if</span>(string_[counts]!=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		counts/=<span class="number">4</span>;<span class="comment">//这句话的层数 </span></span><br><span class="line">		<span class="keyword">while</span>(counts&lt;old_counts)<span class="comment">//新层数低 则退出一层循环 pop </span></span><br><span class="line">		&#123;</span><br><span class="line">			times/=stack_.<span class="built_in">top</span>();</span><br><span class="line">			stack_.<span class="built_in">pop</span>();</span><br><span class="line">			old_counts--; </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">if</span>(string_[counts*<span class="number">4</span>]==<span class="string">&#x27;R&#x27;</span>)<span class="comment">//R开头就是新增循环</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> now=counts*<span class="number">4</span>;now&lt;string_.<span class="built_in">size</span>();now++)<span class="comment">//找到数字 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(string_[now]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;string_[now]&lt;=<span class="string">&#x27;9&#x27;</span>)<span class="comment">//如果是数字 </span></span><br><span class="line">				&#123;</span><br><span class="line">					stack_.<span class="built_in">push</span>(string_[now]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">					times*=string_[now]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">					old_counts++;</span><br><span class="line">					<span class="keyword">break</span>; </span><br><span class="line">				&#125; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span><span class="comment">//否则就是执行计算操作 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> now=counts*<span class="number">4</span>;now&lt;string_.<span class="built_in">size</span>();now++)<span class="comment">//找到数字 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(string_[now]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;string_[now]&lt;=<span class="string">&#x27;9&#x27;</span>)<span class="comment">//如果是数字 </span></span><br><span class="line">				&#123;</span><br><span class="line">					A+=(string_[now]-<span class="string">&#x27;0&#x27;</span>)*times;</span><br><span class="line">					<span class="keyword">break</span>; </span><br><span class="line">				&#125; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;A; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="试题-E-矩阵"><a href="#试题-E-矩阵" class="headerlink" title="试题 E: 矩阵"></a>试题 E: 矩阵</h1><p>本题总分：15 分<br><strong>问题：</strong><br>把 1 ∼ 2020 放在 2 × 1010 的矩阵里。要求同一行中右边的比左边大，列中下边的比上边的大。一共有多少种方案？<br>答案很大，你只需要给出方案数除以 2020 的余数即可。</p>
<p><strong>思路：</strong> 动态规划。</p>
<p><strong>答案：</strong> <strong>1340</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[<span class="number">1020</span>][<span class="number">1020</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;                                   <span class="comment">// 两行一个数字都不放，也是一种方案</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1010</span>; i ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">1010</span>; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i - <span class="number">1</span> &gt;= j)                         <span class="comment">// 转移前的状态也要合法，即第一行的数量不小于第二行的数量</span></span><br><span class="line">            	f[i][j] += f[i - <span class="number">1</span>][j] % <span class="number">2020</span>;</span><br><span class="line">            <span class="keyword">if</span>(j)</span><br><span class="line">            	f[i][j] += f[i][j - <span class="number">1</span>] % <span class="number">2020</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    cout &lt;&lt; f[<span class="number">1010</span>][<span class="number">1010</span>] &lt;&lt; endl;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>以下五题均能通过<a href="https://www.acwing.com/problem/">AcWing</a>的数据测试</li>
</ul>
<h1 id="试题-F-整除序列"><a href="#试题-F-整除序列" class="headerlink" title="试题 F: 整除序列"></a>试题 F: 整除序列</h1><p>时间限制: 1.0s 内存限制: 256.0MB 本题总分：15<br><strong>问题：</strong><br>有一个序列，序列的第一个数是 n，后面的每个数是前一个数整除 2，出这个序列中值为正数的项。</p>
<p><strong>输入:</strong><br>输入一行包含一个整数 n。</p>
<p><strong>输出：</strong><br>输出一行，包含多个整数，相邻的整数之间用一个空格分隔，表示答案。</p>
<p><strong>样例输入：</strong><br>20</p>
<p><strong>样例输出：</strong><br>20 10 5 2 1</p>
<p><strong>评测用例规模与约定：</strong><br>对于 80% 的评测用例，1 ≤ n ≤ 10的9次方。<br>对于所有评测用例，1 ≤ n ≤ 10的18次方。</p>
<p><strong>思路：</strong> 直接循环除就好。</p>
<p><strong>AC代码：</strong> <a href="https://www.acwing.com/problem/content/2067/">OJ链接</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> n=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">while</span>(n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,n);</span><br><span class="line">		n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="试题-G-解码"><a href="#试题-G-解码" class="headerlink" title="试题 G: 解码"></a>试题 G: 解码</h1><p>时间限制: 1.0s 内存限制: 256.0MB 本题总分：20 分<br><strong>问题：</strong><br>小明有一串很长的英文字母，可能包含大写和小写。<br>在这串字母中，有很多连续的是重复的。小明想了一个办法将这串字达得更短：将连续的几个相同字母写成字母 + 出现次数的形式。<br>例如，连续的 5 个 a，即 aaaaa，小明可以简写成 a5（也可能简写aa3a 等）。对于这个例子：HHHellllloo，小明可以简写成 H3el5o2。为了方便表达，小明不会将连续的超过 9 个相同的字符写成简写的形式。<br>现在给出简写后的字符串，请帮助小明还原成原来的串。</p>
<p><strong>输入：</strong><br>输入一行包含一个字符串。</p>
<p><strong>输出：</strong><br>输出一个字符串，表示还原后的串。</p>
<p><strong>样例输入：</strong><br>H3el5o2</p>
<p><strong>样例输出：</strong><br>HHHellllloo</p>
<p><strong>评测用例规模与约定：</strong><br>对于所有评测用例，字符串由大小写英文字母和数字组成，长度不100。<br>请注意原来的串长度可能超过 100。</p>
<p><strong>思路：</strong> 对字符串进行循环判断即可。</p>
<p><strong>AC代码：</strong> <a href="https://www.acwing.com/problem/content/description/2068/">OJ链接</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string string_;</span><br><span class="line">	<span class="type">char</span> old_letter;<span class="comment">//老字母 </span></span><br><span class="line">	<span class="built_in">getline</span>(cin,string_);</span><br><span class="line">	old_letter=string_[<span class="number">0</span>];<span class="comment">//指向第一个字母 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1</span>;now&lt;string_.<span class="built_in">size</span>();now++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(string_[now]&gt;=<span class="string">&#x27;1&#x27;</span>&amp;&amp;string_[now]&lt;=<span class="string">&#x27;9&#x27;</span>)<span class="comment">//数字就循环输出</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> temp=<span class="number">0</span>;temp&lt;string_[now]-<span class="string">&#x27;0&#x27;</span><span class="number">-1</span>;temp++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,old_letter);</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//否则输出一次 换新字</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,old_letter);</span><br><span class="line">			old_letter=string_[now];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,old_letter);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="试题-H-走方格"><a href="#试题-H-走方格" class="headerlink" title="试题 H: 走方格"></a>试题 H: 走方格</h1><p>时间限制: 1.0s 内存限制: 256.0MB 本题总分：20 分<br><strong>问题：</strong><br>在平面上有一些二维的点阵。这些点的编号就像二维数组的编号一样，从上到下依次为第 1 至第 n 行，从左到右依次为第 1 至第 m 列，每一个点可以用行号和列号来表示。现在有个人站在第 1 行第 1 列，要走到第 n 行第 m 列。只能向右或者向下走。<br><strong>注意</strong>，如果行号和列数都是偶数，不能走入这一格中。问有多少种方案。</p>
<p><strong>输入：</strong><br>输入一行包含两个整数 n, m。</p>
<p><strong>输出：</strong><br>输出一个整数，表示答案。</p>
<p><strong>样例输入1：</strong><br>3 4</p>
<p><strong>样例输出1：</strong><br>2</p>
<p><strong>样例输入2：</strong><br>6 6</p>
<p><strong>样例输出2：</strong><br>0</p>
<p><strong>评测用例规模与约定：</strong><br>对于所有评测用例，1 ≤ n ≤ 30, 1 ≤ m ≤ 30。</p>
<p><strong>思路：</strong> dfs暴力搜索的话，当n&#x3D;29，m&#x3D;30的时候会超时。我们可以用dp把结果都记录下来然后直接输出。记得行号列号都是偶数的时候跳过，因为不能走入这种方格。</p>
<p><strong>AC代码：</strong> <a href="https://www.acwing.com/problem/content/submission/2069/">OJ链接</a></p>
<ul>
<li>1.dfs写法（超时）<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fx[<span class="number">2</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;,ans=<span class="number">0</span>;<span class="comment">//右/下 答案 </span></span><br><span class="line"><span class="type">int</span> n,m,a1,b1;<span class="comment">//n,m </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a==n&amp;&amp;b==m)</span><br><span class="line">	&#123;</span><br><span class="line">		ans++;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;<span class="number">2</span>;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		a1=a+fx[now][<span class="number">0</span>];</span><br><span class="line">		b1=b+fx[now][<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(a1&gt;n||b1&gt;m) </span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(!(a1&amp;<span class="number">1</span>)&amp;&amp;!(b1&amp;<span class="number">1</span>)) </span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(a1,b1); </span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">if</span>(!(n&amp;<span class="number">1</span>)&amp;&amp;!(m&amp;<span class="number">1</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
<li>2.dp写法（可AC）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> dp[<span class="number">31</span>][<span class="number">31</span>];<span class="comment">//dp</span></span><br><span class="line">	<span class="type">int</span> n,m;<span class="comment">//n,m </span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">	dp[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1</span>;now&lt;=<span class="number">30</span>;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> now1=<span class="number">1</span>;now1&lt;=<span class="number">30</span>;now1++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!(now&amp;<span class="number">1</span>)&amp;&amp;!(now1&amp;<span class="number">1</span>))<span class="comment">//都是偶数就跳过 </span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(now<span class="number">-1</span>&gt;=<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[now][now1]+=dp[now<span class="number">-1</span>][now1];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(now1<span class="number">-1</span>&gt;=<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[now][now1]+=dp[now][now1<span class="number">-1</span>];</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*for(int now=1;now&lt;=30;now++)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		for(int now1=1;now1&lt;=30;now1++)</span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">			printf(&quot;%d &quot;,dp[now][now1]);</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		printf(&quot;\n&quot;);</span></span><br><span class="line"><span class="comment">	&#125;*/</span> </span><br><span class="line">	cout&lt;&lt;dp[n][m];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="试题-I-整数拼接"><a href="#试题-I-整数拼接" class="headerlink" title="试题 I: 整数拼接"></a>试题 I: 整数拼接</h1><p>时间限制: 1.0s 内存限制: 256.0MB 本题总分：25 分<br><strong>问题：</strong><br>给定义个长度为 n 的数组 A1, A2, · · · , An。你可以从中选出两个数 Ai (i 不等于 j)，然后将 Ai 和 Aj 一前一后拼成一个新的整数。例如 12 和 以拼成 12345 或 34512。注意交换 Ai 和 Aj 的顺序总是被视为 2 种拼法，是 Ai &#x3D; Aj 时。<br>请你计算有多少种拼法满足拼出的整数是 K 的倍数。</p>
<p><strong>输入：</strong><br>第一行包含 2 个整数 n 和 K。<br>第二行包含 n 个整数 A1, A2, · · · , An。</p>
<p><strong>输出：</strong><br>一个整数代表答案。</p>
<p><strong>样例输入：</strong><br>4 2<br>1 2 3 4</p>
<p><strong>样例输出：</strong><br>6</p>
<p><strong>评测用例规模与约定：</strong><br>对于 30% 的评测用例，1 ≤ n ≤ 1000, 1 ≤ K ≤ 20, 1 ≤ Ai ≤ 10的四次方。<br>对于所有评测用例，1 ≤ n ≤ 10的五次方，1 ≤ K ≤ 10的五次方，1 ≤ Ai ≤ 10的九次方。</p>
<p><strong>思路：</strong> 直接暴力肯定超时。我们可以先进行一次操作，对所有数字进行遍历。求出对于每个数，后数为多少时满足题目要求。因为所有数都小于等于十的九次方，即最多为10位数，所以我们只需要求每个数在后数为1位数到10位数时对后数的余数要求即可。然后再遍历一次判定满足要求的后数，总答案加上对该后数的需求即可。数据接收数组选择long long，防止运算中数据超限。答案也选择long long，防止储存不下。</p>
<p>具体思路如下：</p>
<ul>
<li>整式为 <strong>（数一*10^数二的位数^+数二）%k &#x3D;&#x3D; 0</strong> 即<strong>数一数二</strong>满足要求</li>
<li>我们遍历整个数组，按 <strong>（k - 数一*10^1-10^%k）%k</strong> 求出<strong>数一</strong>在1-10次方的情况下对后数余数的要求。这次遍历统计的是<strong>数一对于数二的需求</strong>。</li>
<li>用一个二维数组 <strong>mymap[位数][余数需求]</strong> 来储存对于 <strong>特定数二</strong> 的需求数量。</li>
<li>再次遍历整个数组，对数组元素的位数与余数进行计算，如果位数与余数满足需求，总答案则加上上一步中统计的需求数量。这次遍历是为了寻找<strong>数二</strong>。</li>
<li>在遍历中，我们需要进行去重判定。如果一个数跟自己组合也满足条件，说明上面多加了一次，总答案减去1。</li>
</ul>
<p><strong>AC代码：</strong> <a href="https://www.acwing.com/problem/content/2070/">OJ链接</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> myarray[<span class="number">100001</span>];<span class="comment">//存数 </span></span><br><span class="line"><span class="type">int</span> mymap[<span class="number">11</span>][<span class="number">100001</span>];<span class="comment">//存不同幂情况下对余数的需求 mymap[幂][需求]=数量 </span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;<span class="comment">//答案 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k)</span><span class="comment">//将各个位数可组合数的需求进行统计 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;n;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> temp=<span class="number">1</span>;temp&lt;=<span class="number">10</span>;temp++)</span><br><span class="line">		&#123;</span><br><span class="line">			</span><br><span class="line">			<span class="type">int</span> times=(<span class="type">long</span> <span class="type">long</span>)<span class="built_in">pow</span>(<span class="number">10</span>,temp)%k;</span><br><span class="line">			mymap[temp][(k-myarray[now]*times%k)%k]++;<span class="comment">//在temp次幂的情况下  对后数余数为 k-array[now]*times%k 的需求加一 </span></span><br><span class="line">			<span class="comment">//即后数为temp位数 并且余数为 k-array[now]*times%k 即可成功组合 </span></span><br><span class="line">			<span class="comment">//因为 array[now]*times%k 可能等于0 所以k减它可能等于k 所以需要总体%k一下 </span></span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k)</span><span class="comment">//遍历所有数 答案加上需求数 顺便去重 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;n;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> times=(<span class="type">int</span>)<span class="built_in">log10</span>(myarray[now])<span class="number">+1</span>;<span class="comment">//当前数位数 </span></span><br><span class="line">		ans+=mymap[times][myarray[now]%k];<span class="comment">//加上所有可以组合的 </span></span><br><span class="line">		<span class="keyword">if</span>((myarray[now]*(<span class="type">int</span>)<span class="built_in">pow</span>(<span class="number">10</span>,times)%k+myarray[now]%k)%k==<span class="number">0</span>)<span class="comment">//去重  </span></span><br><span class="line">		&#123;</span><br><span class="line">			ans--;<span class="comment">//如果一个数跟自己组合也满足条件 说明上面多加了一次 减去它 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>       </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,k; </span><br><span class="line">    <span class="built_in">memset</span>(mymap,<span class="number">0</span>,<span class="built_in">sizeof</span>(mymap));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;n;now++)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;myarray[now]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">func1</span>(n,k);</span><br><span class="line">	<span class="built_in">func2</span>(n,k);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="试题-J-网络分析"><a href="#试题-J-网络分析" class="headerlink" title="试题 J: 网络分析"></a>试题 J: 网络分析</h1><p>时间限制: 1.0s 内存限制: 256.0MB 本题总分：25 分<br><strong>问题：</strong><br>小明正在做一个网络实验。<br>他设置了 n 台电脑，称为节点，用于收发和存储数据。<br>初始时，所有节点都是独立的，不存在任何连接。<br>小明可以通过网线将两个节点连接起来，连接后两个节点就可以互相了。两个节点如果存在网线连接，称为相邻。<br>小明有时会测试当时的网络，他会在某个节点发送一条信息，信息会到每个相邻的节点，之后这些节点又会转发到自己相邻的节点，直到所有或间接相邻的节点都收到了信息。所有发送和接收的节点都会将信息存储一条信息只存储一次。<br>给出小明连接和测试的过程，请计算出每个节点存储信息的大小。</p>
<p><strong>输入：</strong><br>输入的第一行包含两个整数 n, m，分别表示节点数量和操作数量。节1 至 n 编号。<br>接下来 m 行，每行三个整数，表示一个操作。<br>如果操作为 1 a b，表示将节点 a 和节点 b 通过网线连接起来。当 时，表示连接了一个自环，对网络没有实质影响。<br>如果操作为 2 p t，表示在节点 p 上发送一条大小为 t 的信息。</p>
<p><strong>输出：</strong><br>输出一行，包含 n 个整数，相邻整数之间用一个空格分割，依次表示完上述操作后节点 1 至节点 n 上存储信息的大小。</p>
<p><strong>样例输入：</strong><br>4 8<br>1 1 2<br>2 1 10<br>2 3 5<br>1 4 1<br>2 2 2<br>1 1 2<br>1 2 4<br>2 2 1</p>
<p><strong>样例输出：</strong><br>13 13 5 3</p>
<p><strong>评测用例规模与约定：</strong><br>对于 30% 的评测用例，1 ≤ n ≤ 20，1 ≤ m ≤ 100。<br>对于 50% 的评测用例，1 ≤ n ≤ 100，1 ≤ m ≤ 1000。<br>对于 70% 的评测用例，1 ≤ n ≤ 1000，1 ≤ m ≤ 10000。<br>对于所有评测用例，1 ≤ n ≤ 10000，1 ≤ m ≤ 100000，1 ≤ t ≤ 100。</p>
<p><strong>思路：</strong> 核心思路是并查集。一个数组用来存旧值，一个数组用来存根结点权值，一个数组是并查集的father数组。执行2操作时，查集寻找到操作值的根结点并加权。执行1操作时，若两数在一个集内则不操作；若两数不在一个集内，则对所有节点进行遍历，使他们的旧值数组加上其根节点的权值，随后进行并集操作。记得对权值数组进行清零，防止后面重复计算。</p>
<p><strong>AC代码：</strong> <a href="https://www.acwing.com/problem/content/description/2071/">OJ链接</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> old_[<span class="number">10001</span>],new_[<span class="number">10001</span>],father[<span class="number">10001</span>],n,m;<span class="comment">//存老值 存根节点新值 父节点数组 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> father[a]==a ? a : father[a]=<span class="built_in">find</span>(father[a]);<span class="comment">//路径压缩</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">union_</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp_a=<span class="built_in">find</span>(a),temp_b=<span class="built_in">find</span>(b);</span><br><span class="line">	<span class="keyword">if</span>(temp_a!=temp_b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> now=<span class="number">1</span>;now&lt;=n;now++)</span><br><span class="line">		&#123;</span><br><span class="line">			old_[now]+=new_[<span class="built_in">find</span>(now)];<span class="comment">//旧值数组遍历加上权值</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">memset</span>(new_,<span class="number">0</span>,<span class="built_in">sizeof</span>(new_));<span class="comment">//重置权值数组，防止重复计算</span></span><br><span class="line">		father[temp_a]=temp_b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a,b,c;</span><br><span class="line">	<span class="built_in">memset</span>(new_,<span class="number">0</span>,<span class="built_in">sizeof</span>(new_));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> now=<span class="number">1</span>;now&lt;=<span class="number">10000</span>;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		father[now]=now;<span class="comment">//father数组初始化 </span></span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">while</span>(m--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">		<span class="keyword">if</span>(a==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">union_</span>(b,c);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			new_[<span class="built_in">find</span>(b)]+=c;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> now=<span class="number">1</span>;now&lt;=n;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,old_[now]+new_[<span class="built_in">find</span>(now)]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构与算法</tag>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 第十一届 蓝桥杯 整数拼接</title>
    <url>/2020/09/07/20200907_2020%E7%AC%AC%E5%8D%81%E4%B8%80%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%95%B4%E6%95%B0%E6%8B%BC%E6%8E%A5/</url>
    <content><![CDATA[<p><strong>此题为2020年第十一届蓝桥杯省赛第一场B组第九题</strong></p>
<span id="more"></span>

<p>时间限制: 1.0s 内存限制: 256.0MB 本题总分：25 分<br><strong>问题：</strong><br>给定义个长度为 n 的数组 A1, A2, · · · , An。你可以从中选出两个数 Ai (i 不等于 j)，然后将 Ai 和 Aj 一前一后拼成一个新的整数。例如 12 和 以拼成 12345 或 34512。注意交换 Ai 和 Aj 的顺序总是被视为 2 种拼法，是 Ai &#x3D; Aj 时。<br>请你计算有多少种拼法满足拼出的整数是 K 的倍数。</p>
<p><strong>输入：</strong><br>第一行包含 2 个整数 n 和 K。<br>第二行包含 n 个整数 A1, A2, · · · , An。</p>
<p><strong>输出：</strong><br>一个整数代表答案。</p>
<p><strong>样例输入：</strong><br>4 2<br>1 2 3 4</p>
<p><strong>样例输出：</strong><br>6</p>
<p><strong>评测用例规模与约定：</strong><br>对于 30% 的评测用例，1 ≤ n ≤ 1000, 1 ≤ K ≤ 20, 1 ≤ Ai ≤ 10的四次方。<br>对于所有评测用例，1 ≤ n ≤ 10的五次方，1 ≤ K ≤ 10的五次方，1 ≤ Ai ≤ 10的九次方。</p>
<p><strong>思路：</strong> 直接暴力肯定超时。我们可以先进行一次操作，对所有数字进行遍历。求出对于每个数，后数为多少时满足题目要求。因为所有数都小于等于十的九次方，即最多为10位数，所以我们只需要求每个数在后数为1位数到10位数时对后数的余数要求即可。然后再遍历一次判定满足要求的后数，总答案加上对该后数的需求即可。数据接收数组选择long long，防止运算中数据超限。答案也选择long long，防止储存不下。</p>
<p>具体思路如下：</p>
<ul>
<li>整式为 <strong>（数一*10^数二的位数^+数二）%k &#x3D;&#x3D; 0</strong> 即<strong>数一数二</strong>满足要求</li>
<li>我们遍历整个数组，按 <strong>（k - 数一*10^1-10^%k）%k</strong> 求出<strong>数一</strong>在1-10次方的情况下对后数余数的要求。这次遍历统计的是<strong>数一对于数二的需求</strong>。</li>
<li>用一个二维数组 <strong>mymap[位数][余数需求]</strong> 来储存对于 <strong>特定数二</strong> 的需求数量。</li>
<li>再次遍历整个数组，对数组元素的位数与余数进行计算，如果位数与余数满足需求，总答案则加上上一步中统计的需求数量。这次遍历是为了寻找<strong>数二</strong>。</li>
<li>在遍历中，我们需要进行去重判定。如果一个数跟自己组合也满足条件，说明上面多加了一次，总答案减去1。</li>
</ul>
<p><strong>AC代码：</strong> <a href="https://www.acwing.com/problem/content/2070/">OJ链接</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> myarray[<span class="number">100001</span>];<span class="comment">//存数 </span></span><br><span class="line"><span class="type">int</span> mymap[<span class="number">11</span>][<span class="number">100001</span>];<span class="comment">//存不同幂情况下对余数的需求 mymap[幂][需求]=数量 </span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;<span class="comment">//答案 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k)</span><span class="comment">//将各个位数可组合数的需求进行统计 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;n;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> temp=<span class="number">1</span>;temp&lt;=<span class="number">10</span>;temp++)</span><br><span class="line">		&#123;</span><br><span class="line">			</span><br><span class="line">			<span class="type">int</span> times=(<span class="type">long</span> <span class="type">long</span>)<span class="built_in">pow</span>(<span class="number">10</span>,temp)%k;</span><br><span class="line">			mymap[temp][(k-myarray[now]*times%k)%k]++;<span class="comment">//在temp次幂的情况下  对后数余数为 k-array[now]*times%k 的需求加一 </span></span><br><span class="line">			<span class="comment">//即后数为temp位数 并且余数为 k-array[now]*times%k 即可成功组合 </span></span><br><span class="line">			<span class="comment">//因为 array[now]*times%k 可能等于0 所以k减它可能等于k 所以需要总体%k一下 </span></span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k)</span><span class="comment">//遍历所有数 答案加上需求数 顺便去重 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;n;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> times=(<span class="type">int</span>)<span class="built_in">log10</span>(myarray[now])<span class="number">+1</span>;<span class="comment">//当前数位数 </span></span><br><span class="line">		ans+=mymap[times][myarray[now]%k];<span class="comment">//加上所有可以组合的 </span></span><br><span class="line">		<span class="keyword">if</span>((myarray[now]*(<span class="type">int</span>)<span class="built_in">pow</span>(<span class="number">10</span>,times)%k+myarray[now]%k)%k==<span class="number">0</span>)<span class="comment">//去重  </span></span><br><span class="line">		&#123;</span><br><span class="line">			ans--;<span class="comment">//如果一个数跟自己组合也满足条件 说明上面多加了一次 减去它 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>       </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,k; </span><br><span class="line">    <span class="built_in">memset</span>(mymap,<span class="number">0</span>,<span class="built_in">sizeof</span>(mymap));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;n;now++)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;myarray[now]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">func1</span>(n,k);</span><br><span class="line">	<span class="built_in">func2</span>(n,k);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构与算法</tag>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言读取csv文件数据并分组</title>
    <url>/2020/09/11/20200911_C%E8%AF%AD%E8%A8%80%E8%AF%BB%E5%8F%96csv%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%88%86%E7%BB%84/</url>
    <content><![CDATA[<p><strong>核心就是.csv文件各组数据之间用‘,’逗号来分割，我们使用C语言的strtok函数对.csv文件的每一行数据进行分割即可。</strong></p>
<span id="more"></span>

<p><strong>代码如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cut</span><span class="params">(<span class="type">char</span> *line,<span class="type">int</span> num)</span><span class="comment">//读入这一行的数据 / 数据的组数-1（逗号的个数） </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> *temp;</span><br><span class="line">    temp=<span class="built_in">strtok</span>(line,<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(temp)</span><br><span class="line">	&#123;</span><br><span class="line">   		<span class="built_in">printf</span>(<span class="string">&quot;第1组数据：%6s\t&quot;</span>,temp);<span class="comment">//第一组数据 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;num<span class="number">-1</span>;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		temp = <span class="built_in">strtok</span>(<span class="literal">NULL</span>,<span class="string">&quot;,&quot;</span>);</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">&quot;第%d组数据：%6s\t&quot;</span>,now<span class="number">+2</span>,temp);<span class="comment">//中间的数据 </span></span><br><span class="line">  	&#125;</span><br><span class="line">  	temp = <span class="built_in">strtok</span>(<span class="literal">NULL</span>,<span class="string">&quot;,&quot;</span>);</span><br><span class="line">  	temp[<span class="built_in">strlen</span>(temp)<span class="number">-1</span>]=<span class="string">&#x27;\0&#x27;</span>;<span class="comment">//把fgets读取的回车去掉 </span></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">&quot;第%d组数据：%6s\n&quot;</span>,num<span class="number">+1</span>, temp);<span class="comment">//最后一组数据 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*if(argc!=3)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        return 0;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    </span><br><span class="line">    FILE *file = <span class="built_in">fopen</span>(<span class="string">&quot;minute.csv&quot;</span>,<span class="string">&quot;r&quot;</span>);<span class="comment">//读文件 </span></span><br><span class="line">    <span class="keyword">if</span>(!file)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;file error&quot;</span>);</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">char</span> line[<span class="number">1024</span>];</span><br><span class="line">	<span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fgets</span>(line,<span class="number">1024</span>,file);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;line[now]!=<span class="string">&#x27;\n&#x27;</span>;now++)<span class="comment">//通过统计分割的逗号 来统计数据的组数 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(line[now]==<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			num++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;一共有%d组数据\n&quot;</span>,num<span class="number">+1</span>);<span class="comment">//有num个逗号 就是有num+1组数据 </span></span><br><span class="line">	<span class="built_in">cut</span>(line,num);<span class="comment">//分割输出第一行 </span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">fgets</span>(line,<span class="number">1024</span>,file)!=<span class="literal">NULL</span>)<span class="comment">//对之后行进行分割 </span></span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">cut</span>(line,num);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言实现大整数加减 数组实现</title>
    <url>/2020/10/13/20201013_C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p><strong>C语言通过数组实现大整数加减法</strong></p>
<span id="more"></span>

<h1 id="思路导图"><a href="#思路导图" class="headerlink" title="思路导图"></a>思路导图</h1><p><img src="/images/2020-10-13/1.jpg#pic_center" alt="在这里插入图片描述"><br><img src="/images/2020-10-13/2.jpg#pic_center" alt="在这里插入图片描述"><br><img src="/images/2020-10-13/3.jpg#pic_center" alt="在这里插入图片描述"><br><img src="/images/2020-10-13/4.jpg#pic_center" alt="在这里插入图片描述"><br><img src="/images/2020-10-13/5.jpg#pic_center" alt="在这里插入图片描述"><br><img src="/images/2020-10-13/6.jpg#pic_center" alt="在这里插入图片描述"><br><img src="/images/2020-10-13/7.jpg#pic_center" alt="在这里插入图片描述"><br><img src="/images/2020-10-13/8.jpg#pic_center" alt="在这里插入图片描述"><br><img src="/images/2020-10-13/9.jpg#pic_center" alt="在这里插入图片描述"><br><img src="/images/2020-10-13/10.jpg#pic_center" alt="在这里插入图片描述"><br><img src="/images/2020-10-13/11.jpg#pic_center" alt="在这里插入图片描述"><br><img src="/images/2020-10-13/12.jpg#pic_center" alt="在这里插入图片描述"><br><img src="/images/2020-10-13/13.jpg#pic_center" alt="在这里插入图片描述"></p>
<h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span>* count_1,<span class="type">int</span> *count_2,<span class="type">int</span> *ans,<span class="type">int</span> max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;max;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		ans[now]+=count_1[now]+count_2[now];<span class="comment">//这一位的值加上第一个数组的该位值 再加上第二个数组的该位值 </span></span><br><span class="line">		<span class="keyword">if</span>(ans[now]&gt;=<span class="number">10</span>)<span class="comment">//大于10就进位 </span></span><br><span class="line">		&#123;</span><br><span class="line">			ans[now<span class="number">+1</span>]+=<span class="number">1</span>;<span class="comment">//进一位</span></span><br><span class="line">			ans[now]%=<span class="number">10</span>;<span class="comment">//留下个位 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sub</span><span class="params">(<span class="type">int</span>* count_1,<span class="type">int</span> *count_2,<span class="type">int</span> *ans,<span class="type">int</span> max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;max;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		ans[now]+=count_1[now]-count_2[now];<span class="comment">//这一位的值等于第一个数组的该位值 减去第二个数组的该位值 </span></span><br><span class="line">		<span class="keyword">if</span>(ans[now]&lt;<span class="number">0</span>)<span class="comment">//如果该位数字小于0 </span></span><br><span class="line">		&#123;</span><br><span class="line">			ans[now]+=<span class="number">10</span>;<span class="comment">//借一位 加10 </span></span><br><span class="line">			ans[now<span class="number">+1</span>]--;<span class="comment">//前一位-1; </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> *ans,<span class="type">int</span> max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">bool</span> kg=<span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=max<span class="number">-1</span>;now&gt;=<span class="number">0</span>;now--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(ans[now]!=<span class="number">0</span>||kg==<span class="literal">true</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans[now]);	</span><br><span class="line">			kg=<span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> string0[<span class="number">1000</span>],*front,*after,sign;<span class="comment">//输入的字符串 切割后的第一个字符串front 第二个字符串after 符号 </span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,string0);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(string0[now]==<span class="string">&#x27;+&#x27;</span>)<span class="comment">//找到加号 </span></span><br><span class="line">		&#123;</span><br><span class="line">			sign=<span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">			front=<span class="built_in">strtok_r</span>(string0,<span class="string">&quot;+&quot;</span>,&amp;after);<span class="comment">//切割 </span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(string0[now]==<span class="string">&#x27;-&#x27;</span>)<span class="comment">//找到减号 </span></span><br><span class="line">		&#123;</span><br><span class="line">			sign=<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">			front=<span class="built_in">strtok_r</span>(string0,<span class="string">&quot;-&quot;</span>,&amp;after);<span class="comment">//切割 </span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> n=<span class="built_in">strlen</span>(front),m=<span class="built_in">strlen</span>(after);<span class="comment">//两个数的位数 用于下一行的最大位数的选择 </span></span><br><span class="line">	<span class="type">int</span> max;<span class="comment">//最大位数 不超过两个数最大位数+1 </span></span><br><span class="line">	<span class="keyword">if</span>(n&gt;m)<span class="comment">//n比m大 </span></span><br><span class="line">	&#123;</span><br><span class="line">		max=n<span class="number">+1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		max=m<span class="number">+1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> count_1[max], count_2[max], ans[max];<span class="comment">//第一个数的数组 第二个数的数组 答案 </span></span><br><span class="line">	<span class="built_in">memset</span>(count_1,<span class="number">0</span>,<span class="built_in">sizeof</span>(count_1));</span><br><span class="line">	<span class="built_in">memset</span>(count_2,<span class="number">0</span>,<span class="built_in">sizeof</span>(count_2));</span><br><span class="line">	<span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="built_in">sizeof</span>(ans));<span class="comment">//每一位都初始化为0  </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;n;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		count_1[now]=front[n-now<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;m;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		count_2[now]=after[m-now<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot; = &quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(sign==<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">add</span>(count_1,count_2,ans,max);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(n&gt;m)<span class="comment">// 1 比 2 长 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">sub</span>(count_1,count_2,ans,max);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(n==m)<span class="comment">//一样长 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">bool</span> state=<span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> a=max<span class="number">-1</span>;a&gt;=<span class="number">0</span>&amp;&amp;state==<span class="literal">false</span>;a--)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(count_1[a]&gt;count_2[a])</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">sub</span>(count_1,count_2,ans,max);</span><br><span class="line">					state=<span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(count_1[a]&lt;count_2[a])</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">					<span class="built_in">sub</span>(count_2,count_1,ans,max);</span><br><span class="line">					state=<span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(state==<span class="literal">false</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//1 比 2 短 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">			<span class="built_in">sub</span>(count_2,count_1,ans,max);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> 	<span class="built_in">print</span>(ans,max);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划学习记录：题型/思路汇总</title>
    <url>/2020/11/05/20201105_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E9%A2%98%E5%9E%8B%E6%80%9D%E8%B7%AF%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p><strong>动态规划学习记录</strong></p>
<p>记录了常见的一维与二维动态规划题目 &amp; 题解。</p>
<span id="more"></span>
<h1 id="一维数组动态规划"><a href="#一维数组动态规划" class="headerlink" title="一维数组动态规划"></a>一维数组动态规划</h1><ul>
<li>一般来说这类题数据都是一维的。例如只受价格影响，如果像01背包问题那样的受价格和大小两个数据影响，就是二维的动态规划。一维动态规划的状态转移方程一般都是平级移动，受之前状态的影响，相对较简单。</li>
</ul>
<h2 id="1-爬楼梯"><a href="#1-爬楼梯" class="headerlink" title="1.爬楼梯"></a>1.爬楼梯</h2><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？<br>注意：给定 n 是一个正整数。</p>
<p><strong>示例 1：</strong><br>输入： 2<br>输出： 2<br>解释： 有两种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶</li>
<li>2 阶</li>
</ol>
<p><strong>示例 2：</strong><br>输入： 3<br>输出： 3<br>解释： 有三种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶 + 1 阶</li>
<li>1 阶 + 2 阶</li>
<li>2 阶 + 1 阶</li>
</ol>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/climbing-stairs">https://leetcode-cn.com/problems/climbing-stairs</a> <a href="https://leetcode-cn.com/problems/climbing-stairs/">OJ链接</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p><strong>思路：</strong><br>思路很简单，因为一次只能跳一格或者两格，所以当前阶数可前往的方法数等于前两阶的方法数之和。</p>
<p><strong>状态转移方程为：</strong><br><strong>dp[now] &#x3D; dp[now-1] + dp[now-2];</strong></p>
<p><strong>AC代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> *dp = <span class="keyword">new</span> <span class="type">int</span>[n<span class="number">+10</span>],t;</span><br><span class="line">		dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">		dp[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">3</span>;now&lt;=n;now++)</span><br><span class="line">		&#123;</span><br><span class="line">			dp[now] = dp[now<span class="number">-1</span>]+dp[now<span class="number">-2</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		t = dp[n];</span><br><span class="line">		<span class="keyword">delete</span>[] dp;</span><br><span class="line">		<span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	Solution s;</span><br><span class="line">	cout&lt;&lt;s.<span class="built_in">climbStairs</span>(n);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-数硬币"><a href="#2-数硬币" class="headerlink" title="2.数硬币"></a>2.数硬币</h2><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。<br>你可以认为每种硬币的数量是无限的。</p>
<p><strong>示例 1：</strong><br>输入：coins &#x3D; [1, 2, 5], amount &#x3D; 11<br>输出：3<br>解释：11 &#x3D; 5 + 5 + 1</p>
<p><strong>示例 2：</strong><br>输入：coins &#x3D; [2], amount &#x3D; 3<br>输出：-1</p>
<p><strong>示例 3：</strong><br>输入：coins &#x3D; [1], amount &#x3D; 0<br>输出：0</p>
<p><strong>示例 4：</strong><br>输入：coins &#x3D; [1], amount &#x3D; 1<br>输出：1</p>
<p><strong>示例 5：</strong><br>输入：coins &#x3D; [1], amount &#x3D; 2<br>输出：2</p>
<p><strong>提示：</strong><br>1 &lt;&#x3D; coins.length &lt;&#x3D; 12<br>1 &lt;&#x3D; coins[i] &lt;&#x3D; 231 - 1<br>0 &lt;&#x3D; amount &lt;&#x3D; 104</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/coin-change">https://leetcode-cn.com/problems/coin-change</a> <a href="https://leetcode-cn.com/problems/coin-change/">OJ链接</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p><strong>思路：</strong> </p>
<p>当前金额的最小需要硬币数，等于当前金额分别减去硬币面额的所需最小硬币数的最小值加一。例如求2,5,7面额硬币凑27块钱所需的最少硬币，就得求20块钱、22块钱、25块钱的最少硬币(27-7 27-5 27-2)，找到其中的最小值加一就是27块钱所需的最小硬币数。而20块钱，22块钱，25块钱的最少硬币数就按这个倒推，最终可以求出所有金额所需的最小硬币数。</p>
<p><strong>状态转移方程为：</strong><br>dp[x] &#x3D; x金额的所需最少硬币数;<br><strong>dp[now] &#x3D; min( (now-coin[0])+1, (now-coin[1])+1, …… (now-coin[end])+1 );</strong><br><strong>最终结果为: dp[amount];</strong></p>
<p><strong>AC代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> *z,vector&lt;<span class="type">int</span>&gt;&amp; coins,<span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> temp=<span class="number">9999999</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;coins.<span class="built_in">size</span>();now++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(d-coins[now]&gt;=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                temp=<span class="built_in">min</span>(temp,z[d-coins[now]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp<span class="number">+1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> *count=<span class="keyword">new</span> <span class="type">int</span>[amount<span class="number">+1</span>];</span><br><span class="line">	</span><br><span class="line">        count[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1</span>;now&lt;amount<span class="number">+1</span>;now++)</span><br><span class="line">        &#123;</span><br><span class="line">            count[now]=<span class="built_in">func</span>(count,coins,now);</span><br><span class="line">            <span class="comment">//printf(&quot;%d\n&quot;,count[now]);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count[amount]==<span class="number">10000000</span> ? <span class="number">-1</span> : count[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="3-最大子序和"><a href="#3-最大子序和" class="headerlink" title="3.最大子序和"></a>3.最大子序和</h2><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>示例:</strong><br>输入: [-2,1,-3,4,-1,2,1,-5,4]<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximum-subarray">https://leetcode-cn.com/problems/maximum-subarray</a> <a href="https://leetcode-cn.com/problems/maximum-subarray/">OJ链接</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p><strong>思路：</strong><br>加一个max变量，储存最大值，dp数组储存当前连续的最大值。</p>
<p><strong>状态转移方程为：</strong><br><strong>dp[now] &#x3D; max(nums[now],dp[now-1]+nums[now];</strong> </p>
<p><strong>AC代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> *dp = <span class="keyword">new</span> <span class="type">int</span>[nums.<span class="built_in">size</span>()<span class="number">+1</span>],max_=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        max_=dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1</span>;now&lt;nums.<span class="built_in">size</span>();now++)</span><br><span class="line">        &#123;</span><br><span class="line">        	</span><br><span class="line">            dp[now]=<span class="built_in">max</span>(nums[now],dp[now<span class="number">-1</span>]+nums[now]);</span><br><span class="line">            max_=<span class="built_in">max</span>(max_,dp[now]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a[] = &#123;<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>&#125;;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;<span class="built_in">n</span>(a,a<span class="number">+9</span>);</span><br><span class="line">	Solution s;</span><br><span class="line">	cout&lt;&lt;s.<span class="built_in">maxSubArray</span>(n);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-区域和检索-数组不可变"><a href="#4-区域和检索-数组不可变" class="headerlink" title="4.区域和检索 - 数组不可变"></a>4.区域和检索 - 数组不可变</h2><p>给定一个整数数组  nums，求出数组从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点。<br>实现 NumArray 类：<br>NumArray(int[] nums) 使用数组 nums 初始化对象<br>int sumRange(int i, int j) 返回数组 nums 从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点（也就是 sum(nums[i], nums[i + 1], … , nums[j])）</p>
<p><strong>示例：</strong></p>
<ul>
<li>输入：<br>[“NumArray”, “sumRange”, “sumRange”, “sumRange”]<br>[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]</li>
<li>输出：<br>[null, 1, -1, -3]</li>
</ul>
<p><strong>解释：</strong><br>NumArray numArray &#x3D; new NumArray([-2, 0, 3, -5, 2, -1]);<br>numArray.sumRange(0, 2); &#x2F;&#x2F; return 1 ((-2) + 0 + 3)<br>numArray.sumRange(2, 5); &#x2F;&#x2F; return -1 (3 + (-5) + 2 + (-1))<br>numArray.sumRange(0, 5); &#x2F;&#x2F; return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))</p>
<p><strong>提示：</strong><br>0 &lt;&#x3D; nums.length &lt;&#x3D; 104<br>-105 &lt;&#x3D; nums[i] &lt;&#x3D; 105<br>0 &lt;&#x3D; i &lt;&#x3D; j &lt; nums.length<br>最多调用 104 次 sumRange 方法</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/range-sum-query-immutable">https://leetcode-cn.com/problems/range-sum-query-immutable</a> <a href="https://leetcode-cn.com/problems/range-sum-query-immutable/">OJ链接</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p><strong>思路：</strong><br>用dp数组记录前x个数的和，求i ~ j区间的值的和即为dp[j+1] - dp[i];</p>
<p><strong>状态转移方程：</strong><br>dp[now]代表前now个数字的和；<br><strong>dp[now] &#x3D; dp[now-1] + nums[now-1];</strong></p>
<p><strong>AC代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) </span><br><span class="line">    &#123;</span><br><span class="line">        dp.<span class="built_in">resize</span>(nums.<span class="built_in">size</span>()<span class="number">+10</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=dp[i<span class="number">-1</span>]+nums[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRange</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dp[j<span class="number">+1</span>]-dp[i];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; dp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="5-整数拆分"><a href="#5-整数拆分" class="headerlink" title="5.整数拆分"></a>5.整数拆分</h2><p>定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p>
<p><strong>示例 1:</strong><br>输入: 2<br>输出: 1<br>解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1。</p>
<p><strong>示例 2:</strong><br>输入: 10<br>输出: 36<br>解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36。<br>说明: 你可以假设 n 不小于 2 且不大于 58。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/integer-break">https://leetcode-cn.com/problems/integer-break</a>  <a href="https://leetcode-cn.com/problems/integer-break/">OJ地址</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p><strong>思路：</strong> 遍历所有可能的分割结果。</p>
<p><strong>状态转移方程为：</strong><br>dp[x] &#x3D; 整数为x时的最大组合乘积;<br>初始dp[1]&#x3D;1;即1的整数最大乘积是1;<br><strong>dp[x] &#x3D; max( max( dp[x-1] * 1, (x-1) * 1 ), max( dp[x-2] * 2, (x-2) * 2 ), max( dp[x-3] * 3, (x-3) * 3 ), …… max( dp[1] * (x-1), 1 * (x-1)  );</strong><br><strong>最终结果为: dp[n];</strong></p>
<p><strong>AC代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> *count = <span class="keyword">new</span> <span class="type">int</span>[n<span class="number">+1</span>],temp=<span class="number">0</span>; </span><br><span class="line">		count[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">2</span>;now&lt;n<span class="number">+1</span>;now++)</span><br><span class="line">		&#123;</span><br><span class="line">			temp=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> t1=<span class="number">1</span>;t1&lt;now;t1++)</span><br><span class="line">			&#123;</span><br><span class="line">				temp=<span class="built_in">max</span>(temp,count[now-t1]*t1);</span><br><span class="line">				temp=<span class="built_in">max</span>(temp,(now-t1)*t1);</span><br><span class="line">			&#125;</span><br><span class="line">			count[now]=temp;</span><br><span class="line">			<span class="comment">//cout&lt;&lt;count[now]&lt;&lt;endl;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> count[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	</span><br><span class="line">	Solution s;</span><br><span class="line">	cout&lt;&lt;s.<span class="built_in">integerBreak</span>(n);</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="6-打家劫舍"><a href="#6-打家劫舍" class="headerlink" title="6.打家劫舍"></a>6.打家劫舍</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<p><strong>示例 1：</strong><br>输入：[1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。<br>     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</p>
<p><strong>示例 2：</strong><br>输入：[2,7,9,3,1]<br>输出：12<br>解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。<br>     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</p>
<p><strong>提示：</strong><br>0 &lt;&#x3D; nums.length &lt;&#x3D; 100<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 400</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/house-robber">https://leetcode-cn.com/problems/house-robber</a> <a href="https://leetcode-cn.com/problems/house-robber/">OJ链接</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p><strong>思路：</strong> 可简单看出最大值是在不偷前一个屋子加上偷当前屋子和不偷当前屋子和偷前一个屋子之间做选择。</p>
<p><strong>状态转移方程为：</strong><br>dp[x] &#x3D; 偷到x号房子时的最大可偷最大价值;<br>初始dp[0]&#x3D;0,dp[1]&#x3D;nums[0];<br>即不偷的时候价值为0，只偷一个屋子时价值最大为第一个屋子;<br><strong>dp[x] &#x3D; max( dp[x-2]+nums[x], dp[x-1] );</strong><br><strong>最终结果为: dp[nums.size()];</strong></p>
<p><strong>AC代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> *dp = <span class="keyword">new</span> <span class="type">int</span>[nums.<span class="built_in">size</span>()<span class="number">+1</span>];</span><br><span class="line">		<span class="keyword">if</span>(nums.<span class="built_in">size</span>()&gt;=<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			dp[<span class="number">0</span>]=<span class="number">0</span>,dp[<span class="number">1</span>]=nums[<span class="number">0</span>];</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">2</span>;now&lt;=nums.<span class="built_in">size</span>();now++)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[now] = <span class="built_in">max</span>(dp[now<span class="number">-2</span>]+nums[now<span class="number">-1</span>],dp[now<span class="number">-1</span>]);</span><br><span class="line">				<span class="comment">//cout&lt;&lt;dp[now]&lt;&lt;endl;</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> dp[nums.<span class="built_in">size</span>()];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;n; </span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t)!=EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		n.<span class="built_in">push_back</span>(t);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	Solution s;</span><br><span class="line">	cout&lt;&lt;s.<span class="built_in">rob</span>(n);</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="7-打家劫舍II"><a href="#7-打家劫舍II" class="headerlink" title="7.打家劫舍II"></a>7.打家劫舍II</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下 ，能够偷窃到的最高金额。</p>
<p><strong>示例 1：</strong><br>输入：nums &#x3D; [2,3,2]<br>输出：3<br>解释：你不能先偷窃 1 号房屋（金额 &#x3D; 2），然后偷窃 3 号房屋（金额 &#x3D; 2）, 因为他们是相邻的。</p>
<p><strong>示例 2：</strong><br>输入：nums &#x3D; [1,2,3,1]<br>输出：4<br>解释：你可以先偷窃 1 号房屋（金额 &#x3D; 1），然后偷窃 3 号房屋（金额 &#x3D; 3）。<br>偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</p>
<p><strong>示例 3：</strong><br>输入：nums &#x3D; [0]<br>输出：0</p>
<p><strong>提示：</strong><br>1 &lt;&#x3D; nums.length &lt;&#x3D; 100<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 1000</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/house-robber-ii">https://leetcode-cn.com/problems/house-robber-ii</a> <a href="https://leetcode-cn.com/problems/house-robber-ii/">OJ链接</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p><strong>思路：</strong> 在上一题的基础上，增加了环的概念。大致就是有首不能有尾，有尾不能有首。我们可以先求{1，n-1}这个区间的最大值，再求{2，n}这个区间的最大值，然后取这两个值中的最大值，即为本题答案。</p>
<p><strong>AC代码：</strong> </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> *dp = <span class="keyword">new</span> <span class="type">int</span>[nums.<span class="built_in">size</span>()<span class="number">+1</span>];</span><br><span class="line">		<span class="type">int</span> *dp2 = <span class="keyword">new</span> <span class="type">int</span>[nums.<span class="built_in">size</span>()<span class="number">+1</span>];</span><br><span class="line">		<span class="keyword">if</span>(nums.<span class="built_in">size</span>()&gt;=<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			dp[<span class="number">0</span>]=<span class="number">0</span>,dp[<span class="number">1</span>]=nums[<span class="number">0</span>];<span class="comment">// 0 ~ n-1</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">2</span>;now&lt;=nums.<span class="built_in">size</span>()<span class="number">-1</span>;now++)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[now] = <span class="built_in">max</span>(dp[now<span class="number">-2</span>]+nums[now<span class="number">-1</span>],dp[now<span class="number">-1</span>]);</span><br><span class="line">				<span class="comment">//cout&lt;&lt;dp[now]&lt;&lt;endl;</span></span><br><span class="line">			&#125;</span><br><span class="line">			dp2[<span class="number">0</span>]=<span class="number">0</span>,dp2[<span class="number">1</span>]=<span class="number">0</span>;<span class="comment">// 1 ~ n</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">2</span>;now&lt;=nums.<span class="built_in">size</span>();now++)</span><br><span class="line">			&#123;</span><br><span class="line">				dp2[now] = <span class="built_in">max</span>(dp2[now<span class="number">-2</span>]+nums[now<span class="number">-1</span>],dp2[now<span class="number">-1</span>]);</span><br><span class="line">				<span class="comment">//cout&lt;&lt;dp[now]&lt;&lt;endl;</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(nums.<span class="built_in">size</span>()&gt;<span class="number">1</span>)</span><br><span class="line">				dp[nums.<span class="built_in">size</span>()]=<span class="built_in">max</span>(dp[nums.<span class="built_in">size</span>()<span class="number">-1</span>],dp2[nums.<span class="built_in">size</span>()]);</span><br><span class="line">			<span class="keyword">return</span> dp[nums.<span class="built_in">size</span>()];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;n; </span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t)!=EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		n.<span class="built_in">push_back</span>(t);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	Solution s;</span><br><span class="line">	cout&lt;&lt;s.<span class="built_in">rob</span>(n);</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="8-解码方法"><a href="#8-解码方法" class="headerlink" title="8.解码方法"></a>8.解码方法</h2><p>一条包含字母 A-Z 的消息通过以下方式进行了编码：<br>‘A’ -&gt; 1<br>‘B’ -&gt; 2<br>…<br>‘Z’ -&gt; 26<br>给定一个只包含数字的非空字符串，请计算解码方法的总数。<br>题目数据保证答案肯定是一个 32 位的整数。</p>
<p><strong>示例 1：</strong><br>输入：”12”<br>输出：2<br>解释：它可以解码为 “AB”（1 2）或者 “L”（12）。</p>
<p><strong>示例 2：</strong><br>输入：”226”<br>输出：3<br>解释：它可以解码为 “BZ” (2 26), “VF” (22 6), 或者 “BBF” (2 2 6) 。</p>
<p><strong>示例 3：</strong><br>输入：s &#x3D; “0”<br>输出：0</p>
<p><strong>示例 4：</strong><br>输入：s &#x3D; “1”<br>输出：1</p>
<p><strong>示例 5：</strong><br>输入：s &#x3D; “2”<br>输出：1</p>
<p><strong>提示：</strong><br>1 &lt;&#x3D; s.length &lt;&#x3D; 100<br>s 只包含数字，并且可以包含前导零。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/decode-ways">https://leetcode-cn.com/problems/decode-ways</a> <a href="https://leetcode-cn.com/problems/decode-ways/">OJ链接</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p><strong>AC代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numDecodings</span><span class="params">(string s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> *dp = <span class="keyword">new</span> <span class="type">int</span>[s.<span class="built_in">size</span>()<span class="number">+1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        s[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span> ? dp[<span class="number">1</span>]=<span class="number">0</span> : dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">2</span>;now&lt;=s.<span class="built_in">size</span>();now++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(s[now<span class="number">-1</span>]!=<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        	&#123;</span><br><span class="line">        		<span class="keyword">if</span>(s[now<span class="number">-2</span>]==<span class="string">&#x27;1&#x27;</span>||(s[now<span class="number">-2</span>]==<span class="string">&#x27;2&#x27;</span>&amp;&amp;s[now<span class="number">-1</span>]&lt;=<span class="string">&#x27;6&#x27;</span>))</span><br><span class="line">        		&#123;</span><br><span class="line">        			dp[now]=dp[now<span class="number">-1</span>]+dp[now<span class="number">-2</span>];</span><br><span class="line">        			</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					dp[now]=dp[now<span class="number">-1</span>];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(s[now<span class="number">-2</span>]==<span class="string">&#x27;2&#x27;</span>||s[now<span class="number">-2</span>]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					dp[now]=dp[now<span class="number">-2</span>];</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dp[s.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="9-乘积最大字数组"><a href="#9-乘积最大字数组" class="headerlink" title="9.乘积最大字数组"></a>9.乘积最大字数组</h2><p>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<p><strong>示例 1:</strong><br>输入: [2,3,-2,4]<br>输出: 6<br>解释: 子数组 [2,3] 有最大乘积 6。</p>
<p><strong>示例 2:</strong><br>输入: [-2,0,-1]<br>输出: 0<br>解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximum-product-subarray">https://leetcode-cn.com/problems/maximum-product-subarray</a> <a href="https://leetcode-cn.com/problems/maximum-product-subarray/">OJ链接</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p><strong>AC代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> dp_max[nums.<span class="built_in">size</span>()<span class="number">+10</span>],dp_min[nums.<span class="built_in">size</span>()<span class="number">+10</span>];</span><br><span class="line">        dp_max[<span class="number">1</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        dp_min[<span class="number">1</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">2</span>;now&lt;=nums.<span class="built_in">size</span>();now++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp_max[now] = <span class="built_in">max</span>(dp_min[now<span class="number">-1</span>]*nums[now<span class="number">-1</span>], dp_max[now<span class="number">-1</span>]*nums[now<span class="number">-1</span>]);</span><br><span class="line">            dp_max[now] = <span class="built_in">max</span>(dp_max[now], nums[now<span class="number">-1</span>]);</span><br><span class="line">            dp_min[now] = <span class="built_in">min</span>(dp_max[now<span class="number">-1</span>]*nums[now<span class="number">-1</span>], dp_min[now<span class="number">-1</span>]*nums[now<span class="number">-1</span>]);</span><br><span class="line">            dp_min[now] = <span class="built_in">min</span>(dp_min[now], nums[now<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> max_ = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1</span>;now&lt;=nums.<span class="built_in">size</span>();now++)</span><br><span class="line">        &#123;</span><br><span class="line">            max_ = <span class="built_in">max</span>(max_,dp_max[now]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="10-完全平方数"><a href="#10-完全平方数" class="headerlink" title="10.完全平方数"></a>10.完全平方数</h2><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p>
<p><strong>示例 1:</strong><br>输入: n &#x3D; 12<br>输出: 3<br>解释: 12 &#x3D; 4 + 4 + 4.</p>
<p><strong>示例 2:</strong><br>输入: n &#x3D; 13<br>输出: 2<br>解释: 13 &#x3D; 4 + 9.</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/perfect-squares">https://leetcode-cn.com/problems/perfect-squares</a> <a href="https://leetcode-cn.com/problems/perfect-squares/">OJ链接</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p><strong>AC代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> dp[n<span class="number">+1</span>],t=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">9999</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1</span>;now&lt;=n;now++)</span><br><span class="line">        &#123;</span><br><span class="line">            t=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(t*t&lt;=now)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[now] = <span class="built_in">min</span>(dp[now],dp[now-t*t]<span class="number">+1</span>);</span><br><span class="line">                t++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="二维数组动态规划"><a href="#二维数组动态规划" class="headerlink" title="二维数组动态规划"></a>二维数组动态规划</h1><ul>
<li>这类的dp题有两个影响结果的数值，例如01背包问题里的价值和大小、空间问题里的x,y坐标等等都是二维的数据。这种题建立dp数组的时候，就需要构建二维的dp数组，并且状态转移方程的变化情况也更加多样，相对较难一点。</li>
</ul>
<h2 id="1-不同路径"><a href="#1-不同路径" class="headerlink" title="1.不同路径"></a>1.不同路径</h2><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。<br>问总共有多少条不同的路径？</p>
<p><img src="/images/2020-11-05/1.jpg#pic_center" alt="图1"></p>
<p>例如，上图是一个7 x 3 的网格。有多少可能的路径？</p>
<p><strong>示例 1:</strong></p>
<ul>
<li>输入: m &#x3D; 3, n &#x3D; 2</li>
<li>输出: 3<br><strong>解释:</strong><br>从左上角开始，总共有 3 条路径可以到达右下角。</li>
</ul>
<ol>
<li>向右 -&gt; 向右 -&gt; 向下</li>
<li>向右 -&gt; 向下 -&gt; 向右</li>
<li>向下 -&gt; 向右 -&gt; 向右</li>
</ol>
<p><strong>示例 2:</strong></p>
<ul>
<li>输入: m &#x3D; 7, n &#x3D; 3</li>
<li>输出: 28</li>
</ul>
<p><strong>提示：</strong><br>1 &lt;&#x3D; m, n &lt;&#x3D; 100<br>题目数据保证答案小于等于 2 * 10 ^ 9</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/unique-paths">https://leetcode-cn.com/problems/unique-paths</a> <a href="https://leetcode-cn.com/problems/unique-paths/">OJ链接</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p><strong>思路：</strong> dp构建表格，dp[x][y]代表在x,y坐标时的可前往路程数。由于方格只能向下或者向右走，所以前往某一格的方案数，就是前往上一格和左一格的方案数之和。</p>
<p><strong>状态转移方程：</strong><br><strong>dp[x][y] &#x3D; dp[x-1][y]+dp[x][y-1];</strong><br><strong>最终结果为: dp[X][Y];</strong></p>
<p><strong>AC代码：</strong> <a href="https://www.acwing.com/problem/content/submission/2069/">OJ链接</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="type">int</span> dp[<span class="number">101</span>][<span class="number">101</span>];   </span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1</span>;now&lt;=m;now++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> now1=<span class="number">1</span>;now1&lt;=n;now1++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(now<span class="number">-1</span>&gt;=<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[now][now1]+=dp[now<span class="number">-1</span>][now1];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(now1<span class="number">-1</span>&gt;=<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[now][now1]+=dp[now][now1<span class="number">-1</span>];</span><br><span class="line">                &#125;	</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Solution s;</span><br><span class="line">	cout&lt;&lt;s.<span class="built_in">uniquePaths</span>(<span class="number">7</span>,<span class="number">3</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-不同路径II"><a href="#2-不同路径II" class="headerlink" title="2.不同路径II"></a>2.不同路径II</h2><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。<br>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？<br><img src="/images/2020-11-05/2.jpg#pic_center" alt="图2"></p>
<p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p>
<p><strong>示例 1：</strong></p>
<ul>
<li>输入：obstacleGrid &#x3D; [[0,0,0],[0,1,0],[0,0,0]]</li>
<li>输出：2<br><strong>解释：</strong><br>3x3 网格的正中间有一个障碍物。<br>从左上角到右下角一共有 2 条不同的路径：</li>
</ul>
<ol>
<li>向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</li>
<li>向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</li>
</ol>
<p><strong>示例 2：</strong></p>
<ul>
<li>输入：obstacleGrid &#x3D; [[0,1],[0,0]]</li>
<li>输出：1</li>
</ul>
<p><strong>提示：</strong><br>m &#x3D;&#x3D; obstacleGrid.length<br> n &#x3D;&#x3D; obstacleGrid[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 100<br>obstacleGrid[i][j] 为 0 或 1</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/unique-paths-ii">https://leetcode-cn.com/problems/unique-paths-ii</a> <a href="https://leetcode-cn.com/problems/unique-paths-ii/">OJ链接</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p><strong>思路：</strong><br>在上一题的基础上，增加一个判断即可，当遍历到障碍格时，直接跳过不计数即可。令障碍格的可到达方法为0。</p>
<p><strong>状态转移方程：</strong><br><strong>dp[x][y] &#x3D; dp[x-1][y]+dp[x][y-1];</strong><br><strong>最终结果为: dp[X][Y];</strong></p>
<p><strong>AC代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; obstacleGrid)</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="type">int</span> dp[<span class="number">101</span>][<span class="number">101</span>];   </span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1</span>;now&lt;=obstacleGrid.<span class="built_in">size</span>();now++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> now1=<span class="number">1</span>;now1&lt;=obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>();now1++)</span><br><span class="line">            &#123;</span><br><span class="line">            	<span class="keyword">if</span>(obstacleGrid[now<span class="number">-1</span>][now1<span class="number">-1</span>]==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                	<span class="keyword">if</span>(now<span class="number">-1</span>&gt;=<span class="number">1</span>)</span><br><span class="line">	                &#123;</span><br><span class="line">	                    dp[now][now1]+=dp[now<span class="number">-1</span>][now1];</span><br><span class="line">	                &#125;</span><br><span class="line">	                <span class="keyword">if</span>(now1<span class="number">-1</span>&gt;=<span class="number">1</span>)</span><br><span class="line">	                &#123;</span><br><span class="line">	                    dp[now][now1]+=dp[now][now1<span class="number">-1</span>];</span><br><span class="line">	                &#125;	</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					dp[now][now1]=<span class="number">0</span>;	</span><br><span class="line">				&#125;	</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[obstacleGrid.<span class="built_in">size</span>()][obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="3-最小路径和"><a href="#3-最小路径和" class="headerlink" title="3.最小路径和"></a>3.最小路径和</h2><p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。<br>说明：每次只能向下或者向右移动一步。</p>
<p><strong>示例 1：</strong></p>
<ul>
<li>输入：grid &#x3D; [[1,3,1],[1,5,1],[4,2,1]]</li>
<li>输出：7<br><strong>解释：</strong> 因为路径 1→3→1→1→1 的总和最小。</li>
</ul>
<p><strong>示例 2：</strong></p>
<ul>
<li>输入：grid &#x3D; [[1,2,3],[4,5,6]]</li>
<li>输出：12</li>
</ul>
<p><strong>提示：</strong><br>m &#x3D;&#x3D; grid.length<br>n &#x3D;&#x3D; grid[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 200<br>0 &lt;&#x3D; grid[i][j] &lt;&#x3D; 100</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/minimum-path-sum">https://leetcode-cn.com/problems/minimum-path-sum</a> <a href="https://leetcode-cn.com/problems/minimum-path-sum/solution/">OJ链接</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p><strong>思路：</strong><br>由于只能向下或者向右移动，所以前往一个格子的最小路径，就是其上一个格子和左一个格子的较小路径和加上这个格子的权值。</p>
<p><strong>状态转移方程：</strong><br><strong>dp[x][y] &#x3D; min(dp[x-1][y], dp[x][y-1]) + grid[x][y];</strong></p>
<p><strong>AC代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> dp[<span class="number">201</span>][<span class="number">201</span>];   </span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;grid.<span class="built_in">size</span>();now++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> now1=<span class="number">0</span>;now1&lt;grid[now].<span class="built_in">size</span>();now1++)</span><br><span class="line">            &#123;</span><br><span class="line">            	<span class="keyword">if</span>(now!=<span class="number">0</span>&amp;&amp;now1!=<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[now][now1] = <span class="built_in">min</span>(dp[now<span class="number">-1</span>][now1],dp[now][now1<span class="number">-1</span>]) + grid[now][now1];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(now==<span class="number">0</span>&amp;&amp;now1!=<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[now][now1] = dp[now][now1<span class="number">-1</span>] + grid[now][now1];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(now!=<span class="number">0</span>&amp;&amp;now1==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[now][now1] = dp[now<span class="number">-1</span>][now1] + grid[now][now1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[grid.<span class="built_in">size</span>()<span class="number">-1</span>][grid[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="4-三角形最小路径和"><a href="#4-三角形最小路径和" class="headerlink" title="4.三角形最小路径和"></a>4.三角形最小路径和</h2><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。<br>相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。</p>
<p>例如，给定三角形：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">     [<span class="number">2</span>],</span><br><span class="line">    [<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">   [<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>],</span><br><span class="line">  [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">3</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 &#x3D; 11）。</p>
<p><strong>说明：</strong><br>如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/triangle">https://leetcode-cn.com/problems/triangle</a> <a href="https://leetcode-cn.com/problems/triangle/">OJ链接</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p><strong>思路：</strong><br>建立二维数组，储存到达每一个坐标的最小路径值。最后遍历最后一行的最小值，即为最终答案。</p>
<p><strong>状态转移方程：</strong><br>对于行首元素：<br><strong>dp[x][0] &#x3D; dp[x-1][0] + triangle[x][0];</strong><br>对于行尾元素：<br><strong>dp[x][x] &#x3D; dp[x-1][x-1] + triangle[x][x];</strong><br>对于行中元素：<br><strong>dp[x][y] &#x3D; min(dp[x-1][y-1], dp[x-1][y]) + triangle[x][y];</strong></p>
<p><strong>AC代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumTotal</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; triangle)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> dp[triangle.<span class="built_in">size</span>()][triangle.<span class="built_in">size</span>()];</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1</span>;now&lt;triangle.<span class="built_in">size</span>();now++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[now][<span class="number">0</span>]=dp[now<span class="number">-1</span>][<span class="number">0</span>]+triangle[now][<span class="number">0</span>];</span><br><span class="line">            dp[now][now]=dp[now<span class="number">-1</span>][now<span class="number">-1</span>]+triangle[now][now];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=now<span class="number">-1</span>;t++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[now][t] = <span class="built_in">min</span>(dp[now<span class="number">-1</span>][t<span class="number">-1</span>],dp[now<span class="number">-1</span>][t]) + triangle[now][t]; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> min_=INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;triangle.<span class="built_in">size</span>();now++)</span><br><span class="line">        &#123;</span><br><span class="line">            min_=<span class="built_in">min</span>(dp[triangle.<span class="built_in">size</span>()<span class="number">-1</span>][now],min_);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="5-最大正方形"><a href="#5-最大正方形" class="headerlink" title="5.最大正方形"></a>5.最大正方形</h2><p>在一个由 ‘0’ 和 ‘1’ 组成的二维矩阵内，找到只包含 ‘1’ 的最大正方形，并返回其面积。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">matrix = [[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>],</span><br><span class="line">          [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>],</span><br><span class="line">          [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>],</span><br><span class="line">          [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>]]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximal-square">https://leetcode-cn.com/problems/maximal-square</a> <a href="https://leetcode-cn.com/problems/maximal-square/">OJ链接</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p><strong>AC代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximalSquare</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; matrix)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> dp[matrix.<span class="built_in">size</span>()<span class="number">+1</span>][matrix[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">+1</span>];</span><br><span class="line">        <span class="type">int</span> max_=<span class="number">0</span>,temp;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;=matrix.<span class="built_in">size</span>();x++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">1</span>;y&lt;=matrix[<span class="number">0</span>].<span class="built_in">size</span>();y++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[x<span class="number">-1</span>][y<span class="number">-1</span>]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp = <span class="built_in">min</span>(dp[x<span class="number">-1</span>][y<span class="number">-1</span>],dp[x<span class="number">-1</span>][y]);</span><br><span class="line">                    temp = <span class="built_in">min</span>(temp,dp[x][y<span class="number">-1</span>]);</span><br><span class="line">                    dp[x][y] = temp<span class="number">+1</span>;</span><br><span class="line">                    max_ = <span class="built_in">max</span>(max_,dp[x][y]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[x][y] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_*max_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2019 蓝桥杯 C/C++实现 B组国赛</title>
    <url>/2020/11/12/20201112_2019%E8%93%9D%E6%A1%A5%E6%9D%AFC-C++%E5%AE%9E%E7%8E%B0B%E7%BB%84%E5%9B%BD%E8%B5%9B/</url>
    <content><![CDATA[<p><strong>2019 蓝桥杯 C&#x2F;C++实现 B组国赛 题目 &amp; 题解</strong></p>
<span id="more"></span>

<h1 id="A：平方序列"><a href="#A：平方序列" class="headerlink" title="A：平方序列"></a>A：平方序列</h1><p>请找到两个正整数X和Y满足下列条件：<br>1、2019&lt;X&lt;Y<br>2、2019^2^、X^2^、Y^2^构成等差数列<br>满足条件的X和Y可能有多种情况，请给出X+Y的值，并且令X+Y尽可能的小。</p>
<p><strong>思路：</strong> 两层暴力循环。</p>
<p><strong>答案：</strong> 7020</p>
<p><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> t=<span class="number">2019</span>*<span class="number">2019</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">2020</span>;x&lt;<span class="number">10000</span>;x++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> y=x<span class="number">+1</span>;y&lt;<span class="number">10000</span>;y++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl;</span></span><br><span class="line">			<span class="keyword">if</span>(y*y-x*x==x*x-t)</span><br><span class="line">			&#123;</span><br><span class="line">				cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;y&lt;&lt;endl;</span><br><span class="line">				cout&lt;&lt;x+y;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B：质数拆分"><a href="#B：质数拆分" class="headerlink" title="B：质数拆分"></a>B：质数拆分</h1><p>2019可以被分解成若干个两两不同的素数，请问不同的分解方案有多少种？<br>注意：分解方案不考虑顺序，如2+2017&#x3D;2019和2017+2&#x3D;2019属于同一种方案。</p>
<p><strong>思路：</strong> 动态规划。dp[a][b]表示数字a拆成若干份，最大值为b的方法数。<br>可知，状态转移方程为</p>
<ul>
<li>dp[a][b] &#x3D; (dp[a-b][2]+dp[a-b][3]+dp[a-b][5]+…+dp[a-b][b下的最大素数]);</li>
</ul>
<p>用双层循环对a和b进行遍历，其中b均为素数，最后对dp[2019]进行统计即可。</p>
<p><strong>答案：</strong> 55965365465060</p>
<p><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">2020</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;ps;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dp[M][M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shai</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">bool</span> kg=<span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">2</span>;now&lt;M;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		kg=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">2</span>;t&lt;=<span class="built_in">sqrt</span>(now);t++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(now%t==<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				kg=<span class="literal">false</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(kg==<span class="literal">true</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			ps.<span class="built_in">push_back</span>(now);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">shai</span>();</span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;ps.<span class="built_in">size</span>();now++)</span><br><span class="line">	&#123;</span><br><span class="line">		dp[ps[now]][ps[now]] = <span class="number">1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">2</span>;now&lt;M;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> count=<span class="number">0</span>;ps[count]&lt;now;count++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;count&amp;&amp;ps[t]&lt;=now-ps[count];t++)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[now][ps[count]] += dp[now-ps[count]][ps[t]];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;ps.<span class="built_in">size</span>();now++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,dp[M<span class="number">-1</span>][ps[now]]);</span><br><span class="line">		ans+=dp[M<span class="number">-1</span>][ps[now]];	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n最终答案：%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C：拼接"><a href="#C：拼接" class="headerlink" title="C：拼接"></a>C：拼接</h1><p>小明要把一根木头切成两段，然后拼接成一个直角。</p>
<p>如下图所示，他把中间部分分成了 n × n 的小正方形，他标记了每个小正方形属于左边还是右边。<br><img src="/images/2020-11-12/1.jpg#pic_center" alt="1"></p>
<p>然后沿两边的分界线将木头切断，将右边旋转向上后拼接在一起。<br>要求每个小正方形都正好属于左边或右边，而且同一边的必须是连通的。<br>在拼接时，拼接的部位必须保持在原来大正方形里面。<br>请问，对于 7 × 7 的小正方形，有多少种合法的划分小正方形的方式。</p>
<h1 id="D：求值"><a href="#D：求值" class="headerlink" title="D：求值"></a>D：求值</h1><p>有一个7X7的方格。方格左上角顶点坐标为(0,0)，右下角坐标为(7,7)。<br>求满足下列条件的路径条数：<br>1、起点和终点都是(0,0)<br>2、路径不自交<br>3、路径长度不大于12<br>4、对于每一个顶点，有上下左右四个方向可以走，但是不能越界。<br>例如，图中路线，左上角顶点（0，0），路线长度为10<br><img src="/images/2020-11-12/2.jpg#pic_center" alt="图1"><br><strong>思路：</strong> dfs暴力搜索，为了防止路径重复，即(0,0) &gt; (0,1) &gt; (0,0)，(0,0) &gt; (1,0) &gt; (0,0)，我把初始点(0,0)进行标记，在坐标即将改变时进行判定。</p>
<p><strong>答案：</strong> 206</p>
<p><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> m[<span class="number">8</span>][<span class="number">8</span>];</span><br><span class="line"><span class="type">int</span> fx[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> nnn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(nnn&gt;=<span class="number">12</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;<span class="number">4</span>;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> tx = x + fx[now][<span class="number">0</span>];</span><br><span class="line">		<span class="type">int</span> ty = y + fx[now][<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(tx&lt;<span class="number">0</span>||ty&lt;<span class="number">0</span>||tx&gt;<span class="number">7</span>||ty&gt;<span class="number">7</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(tx==<span class="number">0</span>&amp;&amp;ty==<span class="number">0</span>&amp;&amp;nnn!=<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			ans++;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(m[tx][ty]==<span class="literal">true</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		m[tx][ty]=<span class="literal">true</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(tx,ty,nnn<span class="number">+1</span>);</span><br><span class="line">		m[tx][ty]=<span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(m,<span class="literal">false</span>,<span class="built_in">sizeof</span>(m));</span><br><span class="line">	m[<span class="number">0</span>][<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="E：路径计数"><a href="#E：路径计数" class="headerlink" title="E：路径计数"></a>E：路径计数</h1><p>有1个约数的最小数为1（1），有两个约数的最小数为2（1，2）……<br>有n个约数的最小数为Sn<br>S1&#x3D;1 （1）<br>S2&#x3D;2 （1 2）<br>S3&#x3D;4 （1 2 4）<br>S4&#x3D;6 （1 2 3 6）<br>求S100</p>
<p><strong>思路：</strong> 两层暴力循环。</p>
<p><strong>答案：</strong> 45360</p>
<p><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">100</span>;;now++)</span><br><span class="line">	&#123;</span><br><span class="line">		ans=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">2</span>;t&lt;=now;t++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(now%t==<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				ans++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(ans==<span class="number">100</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout&lt;&lt;now;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="F：最优包含"><a href="#F：最优包含" class="headerlink" title="F：最优包含"></a>F：最优包含</h1><p>我们称一个字符串 S 包含字符串 T 是指 T 是 S 的一个子序列，即可以从字符串 S 中抽出若干个字符，它们按原来的顺序组合成一个新的字符串与 T 完全一样。</p>
<p>给定两个字符串 S 和 T，请问最少修改 S 中的多少个字符，能使 S 包含 T？</p>
<p><strong>输入格式：</strong><br>输入两行，每行一个字符串。<br>第一行的字符串为 S，第二行的字符串为 T。<br>两个字符串均非空而且只包含大写英文字母。</p>
<p><strong>输出格式：</strong><br>输出一个整数，表示答案。</p>
<p><strong>数据范围：</strong><br>1≤|T|≤|S|≤1000</p>
<p><strong>输入样例：</strong><br>ABCDEABCD<br>XAABZ</p>
<p><strong>输出样例：</strong><br>3</p>
<p><a href="https://www.acwing.com/problem/content/2555/">OJ链接</a></p>
<p><strong>AC代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">	string s1,s2;</span><br><span class="line">	cin&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;=s<span class="number">2.</span><span class="built_in">size</span>();x++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> y=x;y&lt;=s<span class="number">1.</span><span class="built_in">size</span>();y++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(s1[y<span class="number">-1</span>]!=s2[x<span class="number">-1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(y&gt;x)</span><br><span class="line">					dp[x][y] = <span class="built_in">min</span>(dp[x<span class="number">-1</span>][y<span class="number">-1</span>]<span class="number">+1</span>,dp[x][y<span class="number">-1</span>]);</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					dp[x][y] = dp[x<span class="number">-1</span>][y<span class="number">-1</span>]<span class="number">+1</span>; </span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				dp[x][y] = dp[x<span class="number">-1</span>][y<span class="number">-1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;dp[s<span class="number">2.</span><span class="built_in">size</span>()][s<span class="number">1.</span><span class="built_in">size</span>()];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="G：排列数"><a href="#G：排列数" class="headerlink" title="G：排列数"></a>G：排列数</h1><p>在一个排列中，一个折点是指排列中的一个元素，它同时小于两边的元素，或者同时大于两边的元素。<br>对于一个 1 ∼ n 的排列，如果可以将这个排列中包含 t 个折点，则它称为一个 t + 1 单调序列。<br>例如，排列 (1, 4, 2, 3) 是一个 3 单调序列，其中 4 和 2 都是折点。</p>
<p>给定 n 和 k，请问 1 ∼ n 的所有排列中有多少个 k 单调队列？</p>
<p><strong>输入格式：</strong><br>输入一行包含两个整数 n, k。</p>
<p><strong>输出格式：</strong><br>输出一个整数，表示答案。答案可能很大，你可需要输出满足条件的排列数量除以 123456 的余数即可。</p>
<p><strong>样例输入：</strong><br>4 2</p>
<p><strong>样例输出：</strong><br>12</p>
<p><strong>数据范围：</strong><br>对于 20% 的评测用例，1 ≤ k ≤ n ≤ 10；<br>对于 40% 的评测用例，1 ≤ k ≤ n ≤ 20；<br>对于 60% 的评测用例，1 ≤ k ≤ n ≤ 100；<br>对于所有评测用例，1 ≤ k ≤ n ≤ 500。</p>
<h1 id="H：解谜游戏"><a href="#H：解谜游戏" class="headerlink" title="H：解谜游戏"></a>H：解谜游戏</h1><p><img src="/images/2020-11-12/3.jpg#pic_center" alt="2"></p>
<p>小明正在玩一款解谜游戏，谜题由 24 根塑料棒组成，</p>
<p>其中黄色塑料棒 4 根，红色 8 根，绿色 12 根 (后面用 Y 表示黄色、R 表示红色、G 表示绿色)。</p>
<p>初始时这些塑料棒排成三圈，如上图所示，外圈 12 根，中圈 8 根，内圈 4 根。</p>
<p>小明可以进行三种操作：</p>
<p>将三圈塑料棒都顺时针旋转一个单位。<br>例如当前外圈从 0 点位置开始，顺时针依次是 YRYGRYGRGGGG，中圈是 RGRGGRRY，内圈是 GGGR。<br>那么顺时针旋转一次之后，外圈、中圈、内圈依次变为：GYRYGRYGRGGG、YRGRGGRR 和 RGGG。<br>将三圈塑料棒都逆时针旋转一个单位。<br>例如当前外圈从 0 点位置开始，顺时针依次是 YRYGRYGRGGGG，中圈是 RGRGGRRY，内圈是 GGGR。<br>那么逆时针旋转一次之后，外圈、中圈、内圈依次变为：RYGRYGRGGGGY、GRGGRRYR 和 GGRG<br>将三圈 0 点位置的塑料棒做一个轮换。<br>具体来说：外圈 0 点塑料棒移动到内圈 0 点，内圈 0 点移动到中圈 0 点，中圈 0 点移动到外圈 0 点。<br>例如当前外圈从 0 点位置开始顺时针依次是 YRYGRYGRGGGG，中圈是RGRGGRRY，内圈是 GGGR。<br>那么轮换一次之后，外圈、中圈、内圈依次变为：RRYGRYGRGGGG、GGRGGRRY 和 YGGR。<br>小明的目标是把所有绿色移动到外圈、所有红色移动中圈、所有黄色移动到内圈。给定初始状态，请你判断小明是否可以达成目标？</p>
<p><strong>输入格式：</strong><br>第一行包含一个整数 T，代表询问的组数。(1 ≤ T ≤ 100)。<br>每组询问包含 3 行：<br>第一行包含 12 个大写字母，代表外圈从 0 点位置开始顺时针每个塑料棒的颜色。<br>第二行包含 8 个大写字母，代表中圈从 0 点位置开始顺时针每个塑料棒的颜色。<br>第三行包含 4 个大写字母，代表内圈从 0 点位置开始顺时针每个塑料棒的颜色。</p>
<p><strong>输出格式：</strong><br>对于每组询问，输出一行 YES 或者 NO，代表小明是否可以达成目标。</p>
<p><strong>样例输入：</strong><br>2<br>GYGGGGGGGGGG<br>RGRRRRRR<br>YRYY<br>YGGGRRRRGGGY<br>YGGGRRRR<br>YGGG</p>
<p><strong>样例输出：</strong><br>YES<br>NO</p>
<h1 id="I：第八大奇迹"><a href="#I：第八大奇迹" class="headerlink" title="I：第八大奇迹"></a>I：第八大奇迹</h1><p>在一条 R 河流域，繁衍着一个古老的名族 Z，他们世代沿河而居，也在河边发展出了璀璨的文明。</p>
<p>Z 族在 R 河沿岸修建了很多建筑，最近，他们热衷攀比起来，他们总是在比谁的建筑建得最奇特。</p>
<p>幸好 Z 族人对奇特的理解都差不多，他们很快给每栋建筑都打了分，这样评选谁最奇特就轻而易举了。</p>
<p>于是，根据分值，大家很快评出了最奇特的建筑，称为大奇迹。</p>
<p>后来他们又陆续评选了第二奇特、第二奇特、……、第七奇特的建筑，依次称为第二大奇迹、第三大奇迹、……、第七大奇迹。</p>
<p>最近，他们开始评选第八奇特的建筑，准备命名为第八大奇迹，在评选中，他们遇到了一些问题。</p>
<p>首先，Z 族一直在发展，有的建筑被拆除又建了新的建筑，新建筑的奇特值和原建筑不一样，这使得评选不那么容易了。</p>
<p>其次，Z 族的每个人所生活的范围可能不一样，他们见过的建筑并不是所有的建筑，他们坚持他们自己所看到的第八奇特的建筑就是第八大奇迹。</p>
<p>Z 族首领最近很头疼这个问题，他害怕因为意见不一致导致 Z 族发生分歧。他找到你，他想先了解一下，民众自己认为的奇迹是怎样的。</p>
<p>现在告诉在 R 河周边的建筑的变化情况，以及在变化过程中一些人的生活范围，请编程求出每个人认为的第八大奇迹的奇特值是多少。</p>
<p><strong>输入格式：</strong><br>输入的第一行包含两个整数 L, N，分别表示河流的长度和要你处理的信息的数量。开始时河流沿岸没有建筑，或者说所有的奇特值为 0。<br>接下来 N 行，每行一条你要处理的信息。<br>如果信息为 C p x，表示流域中第 p 个位置 (1 ≤ p ≤ L) 建立了一个建筑，其奇特值为 x。如果这个位置原来有建筑，原来的建筑会被拆除。<br>如果信息为 Q a b，表示有个人生活的范围是河流的第 a 到 b 个位置（包含 a 和 b，a ≤ b），这时你要算出这个区间的第八大奇迹的奇特值，并输出。如果找不到第八大奇迹，输出 0。</p>
<p><strong>输出格式：</strong><br>对于每个为 Q 的信息，你需要输出一个整数，表示区间中第八大奇迹的奇特值。</p>
<p><strong>样例输入：</strong><br>10 15<br>C 1 10<br>C 2 20<br>C 3 30<br>C 4 40<br>C 5 50<br>C 6 60<br>C 7 70<br>C 8 80<br>C 9 90<br>C 10 100<br>Q 1 2<br>Q 1 10<br>Q 1 8<br>C 10 1<br>Q 1 10</p>
<p><strong>样例输出：</strong><br>0<br>30<br>10<br>20</p>
<p><strong>数据范围：</strong><br>对于 20% 的评测用例，1 ≤ L ≤ 1000, 1 ≤ N ≤ 1000。<br>对于 40% 的评测用例，1 ≤ L ≤ 10000, 1 ≤ N ≤ 10000。<br>对于 100% 的评测用例，1 ≤ L ≤ 100000，1 ≤ N ≤ 100000。<br>所有奇特值为不超过 10^9^ 的非负整数。</p>
<h1 id="J：燃烧权杖"><a href="#J：燃烧权杖" class="headerlink" title="J：燃烧权杖"></a>J：燃烧权杖</h1><p>小 C 最近迷上了一款游戏。现在，在游戏中，小 C 有一个英雄，生命值为 x；敌人也有一个英雄，生命值为 y。</p>
<p>除此以外，还有 k 个士兵，生命值分别为a1 、a2 、……、ak，现在小 C 打算使用一个叫做“燃烧权杖”的技能。</p>
<p>“燃烧权杖”会每次等概率随机选择一个活着的角色（英雄或士兵），扣减其 10 点生命值，</p>
<p>然后如果该角色的生命值小于或等于 0，则该角色死亡，不会再被“燃烧权杖”选中。</p>
<p>“燃烧权杖”会重复做上述操作，直至任意一名英雄死亡。</p>
<p>小 C 想知道使用“燃烧权杖”后敌方英雄死亡（即，小 C 的英雄存活）的概率。</p>
<p>为了避免精度误差，你只需要输出答案模一个质数 p 的结果，具体见输出格式。</p>
<p><strong>输入格式：</strong><br>输入包含多组数据。<br>输入第一行包含一个正整数 T，表示数据组数。<br>接下来 T 组，每组数据第一行包含四个非负整数 x, y, p, k，分别表示小C的英雄的生命值、敌方英雄的生命值，模数和士兵个数。<br>第二行包含 k 个正整数 a1 、a2 、……、ak ，分别表示每个士兵的生命值。</p>
<p><strong>输出格式：</strong><br>对于每组数据，输出一行一个非负整数，表示答案模质数 p 的余数。可以证明，答案一定为有理数。<br>设答案为 a &#x2F; b（a 和 b 为互质的正整数），你输出的数为 x，则你需要保证 a 与 bx 模 p 同余；<br>也即，x &#x3D; (a·b−1 ) mod p，其中 b−1 表示 b 模 p 的逆元， mod 为取模运算。</p>
<p><strong>样例输入：</strong><br>6<br>1 10 101 0<br>100 1 101 0<br>50 30 4903 2<br>1 1<br>987 654 233 1<br>321<br>1000000000 999999999 233 3<br>1 2 3<br>1000000000 999999999 3 3<br>1 2 3</p>
<p><strong>样例输出：</strong><br>51<br>37<br>1035<br>118<br>117<br>2</p>
<p><strong>样例说明：</strong><br>对于第一组数据，所求概率即为“燃烧权杖”第一次就扣减敌方英雄 10 点生命值的概率，即 1&#x2F;2。2 × 51 模 101 余 1。<br>对于第二组数据，答案为 1023&#x2F;1024，1024 × 37 与 1023 模 101 同余。<br>对于第三组数据，答案为 99&#x2F;128。</p>
<p><strong>数据范围：</strong><br>对于 10% 的评测用例，x, y, a1 ,··· , ak ≤ 10。<br>对于 20% 的评测用例，x, y, a1,··· , ak ≤ 100。<br>对于 50% 的评测用例，x, y, a1 ,··· , ak ≤ 1000。<br>另有 10% 的评测用例，p &#x3D; 3。<br>另有 20% 的评测用例，p ≤ 100。<br>对于全部评测用例，1 ≤ x, y, a1 ,··· , ak ≤ 10^9^ ，3 ≤ p ≤ 10000 且 p 为质数，0 ≤ k ≤ 10。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构与算法</tag>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title>使用g++创建动态库和静态库及其相关探索</title>
    <url>/2020/12/07/20201207_%E4%BD%BF%E7%94%A8g++%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81%E5%BA%93%E5%92%8C%E9%9D%99%E6%80%81%E5%BA%93%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E6%8E%A2%E7%B4%A2/</url>
    <content><![CDATA[<p><strong>使用g++创建动态库和静态库及其相关探索</strong></p>
<span id="more"></span>

<h2 id="0-前期准备"><a href="#0-前期准备" class="headerlink" title="0.前期准备"></a>0.前期准备</h2><ul>
<li><p><strong>首先我们建立头文件 “hello.h”</strong></p>
</li>
<li><p>内容如图：<img src="/images/2020-12-07/1.jpg#pic_center" alt="hello.h"></p>
</li>
<li><p><strong>随后我们建立源文件 “hello.cpp”</strong></p>
</li>
<li><p>内容如图：<img src="/images/2020-12-07/2.png#pic_center" alt="hello.cpp"></p>
</li>
<li><p><strong>最后我们建立源文件 “main.cpp”</strong></p>
</li>
<li><p>内容如图：<img src="/images/2020-12-07/3.png#pic_center" alt="main.cpp"></p>
</li>
<li><p><strong>我们使用 g++ -c 编译出.o文件。<br>无论是动态库还是静态库，都得由.o文件创建，所以我们先编译出.o文件。</strong></p>
</li>
<li><p>结果如图：可以看到有 hello.o 文件<img src="/images/2020-12-07/4.png#pic_center" alt="图1"></p>
</li>
</ul>
<h2 id="1-静态库创建及链接"><a href="#1-静态库创建及链接" class="headerlink" title="1.静态库创建及链接"></a>1.静态库创建及链接</h2><ul>
<li><strong>使用 ar crv 命令创立静态库。</strong></li>
<li>结果如图：建立出了静态库文件 libmyhello.a ，静态库文件后缀为.a 。<img src="/images/2020-12-07/5.png#pic_center" alt="图2"></li>
<li><strong>使用 g++ 命令链接静态库</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">g++ main.cpp libmyhello.a -o main</span><br></pre></td></tr></table></figure>

<ul>
<li>结果如图：生成了可执行文件main，且可以正常运行。<img src="/images/2020-12-07/6.png#pic_center" alt="图3"></li>
<li><strong>删除静态库libmyhello.a，程序仍能运行，说明链接成功。</strong></li>
<li>结果如图：<br><img src="/images/2020-12-07/7.png#pic_center" alt="图4"></li>
</ul>
<h2 id="2-动态库创建及链接"><a href="#2-动态库创建及链接" class="headerlink" title="2.动态库创建及链接"></a>2.动态库创建及链接</h2><ul>
<li><strong>使用 -shared -fPCI 命令创立动态库。</strong></li>
<li>结果如图：建立出了动态库文件 libtest.so ，动态库文件后缀为.so 。<br><img src="/images/2020-12-07/8.png#pic_center" alt="图1"></li>
<li><strong>使用 g++ 命令链接动态库</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">g++ main.cpp -L. -ltest -o main</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">-L代表so库目录，“-L.” 是当前目录， -I代表引用文件目录。main即为可执行文件</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>结果如图： 生成可执行文件main<br> <img src="/images/2020-12-07/9.png#pic_center" alt="图2"></li>
<li><strong>运行程序</strong></li>
<li>直接运行会报错：缺少文件。我们将动态库移动到&#x2F;usr&#x2F;lib 中即可</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mv libtest.so /usr/lib</span><br></pre></td></tr></table></figure>
<ul>
<li>随后即可正常运行（如果移动后仍不能运行，请看下文）<img src="/images/2020-12-07/2.png#pic_center" alt="图3"></li>
</ul>
<h2 id="3-相关问题"><a href="#3-相关问题" class="headerlink" title="3.相关问题"></a>3.相关问题</h2><h3 id="移动动态库后仍不能运行"><a href="#移动动态库后仍不能运行" class="headerlink" title="移动动态库后仍不能运行"></a>移动动态库后仍不能运行</h3><p>1.首先进入 &#x2F;etc&#x2F;ld.so.conf 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/ld.so.conf</span><br></pre></td></tr></table></figure>
<p>2.修改内容为如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include /etc/ld.so.conf.d/*.conf</span><br></pre></td></tr></table></figure>
<p>3.进入目录，创建任意*.conf文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /etc/ld.so.conf.d</span><br><span class="line">vim mylib.conf</span><br></pre></td></tr></table></figure>
<p>4.在其中添加so的路径即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/lib</span><br></pre></td></tr></table></figure>
<p>5.执行命令使其生效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure>
<p>随后程序即可正常运行</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习记录：基于C++的快速学习</title>
    <url>/2021/01/08/20210108_Java%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E5%9F%BA%E4%BA%8EC++%E7%9A%84%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><strong>HB小咸鱼学习记录</strong></p>
<ul>
<li>初中的时候曾经学过一点java，算是程序的敲门砖，但是没想到上了大学最先深入学习的是C语言和C++。21年初这个寒假决定在家系统学习Java和网络编程，发个帖子记录过程，方便今后查看。</li>
</ul>
<span id="more"></span>

<h1 id="【前期准备】"><a href="#【前期准备】" class="headerlink" title="【前期准备】"></a>【前期准备】</h1><ul>
<li>Java JDK版本选择的是： <strong>“1.8.0_181”</strong></li>
<li>编译器我选择的是： <strong>Eclipse</strong></li>
<li>具体环境搭建方法由网络上查询得知，不多说了。</li>
<li>学习地址：（B站永远滴神）<br>[video(video-zPI8bhtB-1610116863147)(type-bilibili)(url-<a href="https://player.bilibili.com/player.html?aid=797299458)(image-https://ss.csdn.net/p?http://i2.hdslb.com/bfs/archive/73b9c56133cf2defc06255ca50a219156917272e.png)(title-%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98Java%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A-%E3%80%90%E5%9F%BA%E7%A1%80+%E9%AB%98%E7%BA%A7%E3%80%91-%E9%99%84%E5%85%A8%E5%A5%97%E8%B5%84%E6%96%99(IDEA%E7%89%88))%5D">https://player.bilibili.com/player.html?aid=797299458)(image-https://ss.csdn.net/p?http://i2.hdslb.com/bfs/archive/73b9c56133cf2defc06255ca50a219156917272e.png)(title-黑马程序员Java语言入门到精通-【基础+高级】-附全套资料(IDEA版))]</a></li>
</ul>
<h1 id="【笔记一】-1-基本语法"><a href="#【笔记一】-1-基本语法" class="headerlink" title="【笔记一】 1- 基本语法"></a>【笔记一】 1- 基本语法</h1><ol>
<li>C++里的include头文件和Java里的import包机制相似。</li>
<li>C++和Java代码执行的起点都是main函数。</li>
<li>变量关键字与C++基本一致。<strong>值得一提的是，由于Java里没有指针，所以Java中的字符串由字符串变量String储存。使用方法与C++&#x2F;STL里的string大同小异，记得Java里的String首字母要大写。</strong></li>
<li><strong>Java中申请数组时，分为动态分配和静态分配。动态分配为new申请内存后不设置各初始值，静态分配为new申请内存后直接设置各初始值。</strong><br> <code>int[] array1 = new int[3];//动态分配  int[] array2 = new int[]&#123;1,2,3&#125;;//静态分配</code></li>
<li><strong>Java中的数组和字符串都自带类似C++&#x2F;STL里的方法，例如length()就是获取长度。</strong></li>
<li>变量类型强制转换和C++一致都可以使用(int)double这样的格式进行转换。</li>
<li>字符类型与C++一致也是用的ASCII码。</li>
<li>if&#x2F;else条件判定语句与C++一致。</li>
<li>switch关键字的使用方法与C++一致。</li>
<li>for循环、while循环、do…while循环的使用方法与C++一致。</li>
<li>break和continue的使用方法与C++一致。</li>
<li><strong>Java中类的思路与C++中基本一致。注意Java类中的公&#x2F;私有标识符不用加 ‘:’ 。</strong></li>
<li>Java中类和方法的声明&#x2F;使用方法与C++基本一致。</li>
<li>对于只使用一次的对象，可以使用匿名对象，直接new就行。</li>
<li><strong>final</strong>关键字代表最终的，不可改变的。</li>
<li><strong>外部类名称.内部类名称 对象名 &#x3D; new 外部类名称().new 内部类名称();</strong> 直接声明内部类。</li>
<li>现在的编译器支持自动装箱和自动拆箱。</li>
<li>包装类除了<strong>int–Integer</strong>，<strong>char–Character</strong>，其余都是首字母大写。</li>
<li><strong>泛型省去了类型转换的麻烦，更加安全，但是只能储存一种数据。</strong></li>
<li><strong>native</strong>关键字，代表该方法调用的是本地操作系统的方法。</li>
<li>当方法的参数类型已经确定，但是参数个数不确定时，可以使用可变参数。<br><strong>修饰符 返回值类型 方法名(数据类型…变量名){}</strong> 底层为一个数组。</li>
</ol>
<h1 id="【笔记二】-115-118P-Scanner接收类"><a href="#【笔记二】-115-118P-Scanner接收类" class="headerlink" title="【笔记二】 115-118P  Scanner接收类"></a>【笔记二】 115-118P  Scanner接收类</h1><ol>
<li>Java接收输入的方式为调用Scanner类。需要导包：import java.util.Scanner;</li>
<li>接收数据的方法为:<br>字符串-<strong>Scanner.next()&#x2F;Scanner.nextLine();</strong><br>其余类型-<strong>Scanner.next类型();</strong>  如：int-Scanner.nextInt(); double-Scanner.nextDouble();</li>
</ol>
<h1 id="【笔记三】-121-124P-Random随机数类"><a href="#【笔记三】-121-124P-Random随机数类" class="headerlink" title="【笔记三】 121-124P  Random随机数类"></a>【笔记三】 121-124P  Random随机数类</h1><ol>
<li>Java生成随机数的方式为调用Random类。需要导包：import java.util.Random;</li>
<li>Random类生成随机数的方法和Scanner的方法类似，如<strong>Random.nextInt(100);</strong> 范围左闭右开，即[0,100)，0~99。</li>
</ol>
<h1 id="【笔记四】-133-142P-String字符串类"><a href="#【笔记四】-133-142P-String字符串类" class="headerlink" title="【笔记四】 133-142P  String字符串类"></a>【笔记四】 133-142P  String字符串类</h1><ol>
<li>不需要导包。</li>
<li>字符串比较方法：<strong>str1.equals(str2);</strong> 相同返回true。**.equalsIgnoreCase()** 忽略大小写。</li>
<li>字符串长度：<strong>str1.length();</strong> 返回字符串长度。</li>
<li>拼接字符串：<strong>str3 &#x3D; str1.concat(str2);</strong> 返回值为新的字符串地址。</li>
<li>获取字符串指定位置字符：<strong>char ch &#x3D; str1.charAt(1);</strong> 返回值为一个char。 </li>
<li>查找子串在主串中第一次出现的位置：<strong>int a &#x3D; str1.indexOf(“abc”);</strong> 返回值为第一次出现的索引位置。没有的话返回-1。</li>
<li>字符串截取方法：<br><strong>str2 &#x3D; str1.substring(5);</strong>&#x2F;&#x2F;从第5号截取到末尾<br><strong>str2 &#x3D; str1.substring(4,7);</strong>&#x2F;&#x2F;从4号截取到6号，左闭右开[4,7)</li>
<li>字符串转为char数组：<strong>char[] chars &#x3D; “hello”.toCharArray();</strong></li>
<li>字符串转为byte数组：<strong>byte[] bytes &#x3D; “hello”.getBytes();</strong></li>
<li>替换字符串内指定内容：<strong>String str1 &#x3D; “how do you do?”.replace(“o”,”*”);</strong>&#x2F;&#x2F;h*w d* y*u d*?</li>
<li>分割字符串：<strong>String[] array1 &#x3D; “aaa.bbb.ccc”.split(“\\.”);</strong>&#x2F;&#x2F;切成aaa,bbb,ccc三个字符串</li>
</ol>
<h1 id="【笔记五】-143-147P-static静态关键字"><a href="#【笔记五】-143-147P-static静态关键字" class="headerlink" title="【笔记五】 143-147P  static静态关键字"></a>【笔记五】 143-147P  static静态关键字</h1><ol>
<li><strong>当使用static进行修饰后，被修饰的方法&#x2F;变量不再属于对象，而是属于类。</strong></li>
<li>由于不再属于对象，所以带static的方法&#x2F;变量可以<strong>直接被调用</strong>。<br>静态方法：类名称.静态方法();<br>静态变量：类名称.静态变量;</li>
<li>静态不能直接访问非静态，例如静态方法访问非静态变量。</li>
<li>静态方法里也不能用this。</li>
<li><strong>对于静态变量初始化，我们可以使用静态代码块。静态代码块只在类第一次被声明时，执行一次。</strong></li>
<li>静态内容总是优先于非静态。</li>
</ol>
<h1 id="【笔记六】-148-149P-Arrays数组工具类"><a href="#【笔记六】-148-149P-Arrays数组工具类" class="headerlink" title="【笔记六】 148-149P  Arrays数组工具类"></a>【笔记六】 148-149P  Arrays数组工具类</h1><ol>
<li>需要导包：import java.util.Arrays;</li>
<li>将数组变为字符串：<strong>Arrays.toString();</strong><br>int[] a1 &#x3D; {10,20,30};<br>String s1 &#x3D; Arrays.toString(a1);&#x2F;&#x2F;[10, 20, 30]</li>
<li>数组排序：<strong>Arrays.sort();</strong><br>int[] a1 &#x3D; {20,10,30};<br>Arrays.sort(a1);&#x2F;&#x2F;10,20,30 默认为升序</li>
</ol>
<h1 id="【笔记七】-150-151P-Math数学工具类"><a href="#【笔记七】-150-151P-Math数学工具类" class="headerlink" title="【笔记七】 150-151P  Math数学工具类"></a>【笔记七】 150-151P  Math数学工具类</h1><ol>
<li>不需要导包。</li>
<li>取绝对值：<strong>Math.abs();</strong> 与C++一致，但是浮点数类型也是abs()，不是fabs()。</li>
<li>取平方根：<strong>Math.sqrt();</strong> 与C++一致。</li>
<li>求n次方：<strong>Math.pow(a,b);</strong> 求a的b次方，与C++一致。</li>
<li>比大小：<strong>Math.max(a,b) &#x2F; Math.min(a,b);</strong> a和b比大小，与C++一致。</li>
<li>向上取整：<strong>Math.ceil();</strong></li>
<li>向下取整：<strong>Math.floor();</strong></li>
<li>四舍五入：<strong>Math.round();</strong></li>
<li>Math包里还有常见的数学值，比如<strong>Math.PI</strong>是圆周率，<strong>Math.E</strong>是e值。</li>
</ol>
<h1 id="【笔记八】-171-184P-接口相关"><a href="#【笔记八】-171-184P-接口相关" class="headerlink" title="【笔记八】  171-184P  接口相关"></a>【笔记八】  171-184P  接口相关</h1><ol>
<li>接口<strong>没有</strong>静态代码块和构造方法。</li>
<li>一个类的父类只有一个，但是一个类可以同时实现<strong>多个</strong>接口。<br>当父类的方法与接口的默认方法冲突，<strong>优先父类</strong>。<br>当实现多个接口时存在<strong>默认方法冲突</strong>，需要对默认方法进行重写。<br>当实现多个接口时存在<strong>抽象方法冲突</strong>，只需要覆盖重写一次即可。</li>
<li>使用接口首先要定义接口类。<br><strong>定义接口类</strong>的格式如：<strong>public interface 接口名称 { 接口内容 }</strong></li>
<li>使用接口需要创建接口实现类对接口进行实现。<br><strong>接口实现类</strong>的格式如：<strong>public class 实现类名称 implements 接口名称 { … }</strong></li>
<li>接口中定义的变量均为常量。<br><strong>常量</strong>格式如：<strong>public static final 数据类型 常量名称 &#x3D; 数值;</strong> 前方三个关键词可省略。</li>
<li>接口中均为抽象方法，且实现类必须覆盖重写接口所有的抽象方法，除非实现类也是抽象类。(必须覆盖)<br><strong>抽象方法</strong>格式如：<strong>public abstract 返回值类型 方法名称(参数列表);</strong></li>
<li>Java8后，接口中可以定义默认方法。(可覆盖可不覆盖)<br><strong>默认方法</strong>格式如：<strong>public default 返回值类型 方法名称(参数列表) { 方法体 }</strong></li>
<li>Java8后，接口中可以定义静态方法。<br><strong>静态方法</strong>格式如：<strong>public static 返回值类型 方法名称(参数列表) { 方法体 }</strong></li>
<li>Java9后，接口中可以定义私有方法。(我的Java版本是1.8.0也就是Java8，所以不支持)<br><strong>普通私有方法</strong>格式如：<strong>private 返回值类型 方法名称(参数列表) { 方法体 }</strong><br><strong>静态私有方法</strong>格式如：<strong>private static 返回值类型 方法名称(参数列表) { 方法体 }</strong></li>
</ol>
<h1 id="【笔记九】-185-194P-继承与多态相关"><a href="#【笔记九】-185-194P-继承与多态相关" class="headerlink" title="【笔记九】  185-194P  继承与多态相关"></a>【笔记九】  185-194P  继承与多态相关</h1><ol>
<li><strong>C++继承用冒号，Java继承用关键字extends。</strong></li>
<li>@Override检测是否重写，总体来说，Java的类继承与C++的类继承很相似。</li>
<li><strong>Java不支持多重继承，所以有super关键字，用来找父类。</strong></li>
<li><strong>abstract为抽象关键字。抽象类&#x2F;抽象方法。</strong></li>
<li>访问成员变量的规则：<br>通过<strong>对象名称</strong>访问：看声明对象时对象的类型(等号左边)，没有就向上找。<br>通过<strong>成员方法</strong>访问：看方法属于谁，就优先用谁的成员变量，没有就向上找。</li>
<li>实现多态性：父类引用指向子类对象。<br>多态格式：<br><strong>父类名称 对象名 &#x3D; new 子类名称();<br>接口名称 对象名 &#x3D; new 实现类名称();</strong></li>
<li>根据第6条和第7条可知，多态中成员方法优先用子类的成员方法；通过对象名称访问成员变量，优先用父类的成员变量。</li>
<li><strong>“编译看左，运行看右”，即编译前把对象看为父类类型(左边)，运行时成员变量看左边，成员方法看右边。</strong></li>
<li>个人感觉，多态的存在使代码更加有逻辑性。</li>
<li><strong>向上转型</strong>：右侧new一个子类对象，把它当父类来看待。 (无法调用子类特有方法)</li>
<li><strong>向下转型</strong>：将父类对象，<strong>还原</strong>成为本来的子类对象。<br>格式：子类名称 对象名 &#x3D; (子类名称)父类对象；（有点像强制类型转换）</li>
<li><strong>对象 instanceof 类名称</strong> ：如果对象属于该类，则返回true。使用这个即可根据对象类型，来进行向下转型，使用子类特有方法。</li>
</ol>
<h1 id="【笔记十】-215-218P-Object-Objects根类"><a href="#【笔记十】-215-218P-Object-Objects根类" class="headerlink" title="【笔记十】  215-218P  Object&#x2F;Objects根类"></a>【笔记十】  215-218P  Object&#x2F;Objects根类</h1><ol>
<li>不需要导包。</li>
<li>**Object.toString()**：转换为字符串，默认转换对象的地址值，需重写。</li>
<li>**Object.equals(对象)**：比较对象是否相等，默认比较对象的地址值，需重写。</li>
<li>**Objects.equals(对象1,对象2)**：第二条的equals方法存在空指针异常可能，Objects的equals方法更加完善。</li>
</ol>
<h1 id="【笔记十一】-219-225P-日期时间类"><a href="#【笔记十一】-219-225P-日期时间类" class="headerlink" title="【笔记十一】  219-225P  日期时间类"></a>【笔记十一】  219-225P  日期时间类</h1><ul>
<li>Date类</li>
</ul>
<ol>
<li>需要导包：import java.util.Date;</li>
<li>Date类的空参构造函数为获取当前日期。</li>
<li>Date类的带参构造函数为传入一个long类型的毫秒值，根据毫秒值计算日期。0L为1970年1月1日0点。(中国是东八区加8个小时)</li>
<li>**Date.getTime()**：将日期转换为毫秒值，返回值为long类型。</li>
</ol>
<ul>
<li>DateFormat类</li>
</ul>
<ol start="5">
<li>需要导包：import java.text.DateFormat;</li>
<li>DateFomat类是一个抽象类，无法直接创建对象，可以使用其子类<strong>SimpleDateFormat(String pattern)</strong> </li>
<li>SimpleDateFormat类需要导包：import java.text.SimpleDateFormat;</li>
<li><strong>SimpleDateFormat s1 &#x3D; new SimpleDateFormat(“yyyy年MM月dd日 HH时mm分ss秒”);</strong> 构造函数传参按这个格式即可，字母不能变，其余可变。</li>
<li><strong>String str1 &#x3D; s1.format(Date对象);</strong> 将一个Date对象转换为SimpleDateFormat对象中指定格式的字符串。</li>
<li><strong>Date date &#x3D; s1.parse(“2020年01月04日 20时00分00秒”);</strong> 按照SimpleDateFormat对象的格式，转换为一个Date格式对象。</li>
</ol>
<ul>
<li>Calendar类</li>
</ul>
<ol start="11">
<li>需要导包：import java.util.Calendar; </li>
<li>Calendar类为抽象类，无法直接创建对象。</li>
<li><strong>Calendar c1 &#x3D; Calendar.getInstance();</strong> 使用多态方法，获取一个Calendar的子类。等号右边方法为获取Calendar的子类。</li>
<li>**Calendar.get(字段)**：返回日历指定字段的数值。例：c1.get(Calendar.YEAR);</li>
<li>**Calendar.set(字段,值)**：设置日历指定字段的数值。例：c1.set(Calendar.YEAR, 2020);</li>
<li>**Calendar.add(字段,值)**：使指定字段增加给定值，可以为负数。例：c1.add(Calendar.YEAR, -2);</li>
<li>**Calendar.getTime()**：将Calendar类转为Date类。例：Date date &#x3D; c1.getTime();</li>
</ol>
<h1 id="【笔记十二】-226-226P-System系统类"><a href="#【笔记十二】-226-226P-System系统类" class="headerlink" title="【笔记十二】 226-226P  System系统类"></a>【笔记十二】 226-226P  System系统类</h1><ol>
<li>不需要导包。 </li>
<li><strong>System.currentTimeMillis()：</strong> 返回以毫秒为单位的当前时间，可以用来计算程序的运行时间。</li>
<li><strong>System.arraycopy(参数1,参数2,参数3,参数4,参数5)：</strong> 将数组中指定的数据copy到另一个数组。<br><strong>参数1 &#x2F; 参数3</strong>：源数组 <strong>&#x2F;</strong> 目标数组。<br><strong>参数2 &#x2F; 参数4</strong>：源数组中的起始位置 <strong>&#x2F;</strong> 目标数组中的起始位置。<br><strong>参数5</strong>：要复制的数组元素的数量。</li>
</ol>
<h1 id="【笔记十三】-227-229P-StringBuilder字符串缓冲区类"><a href="#【笔记十三】-227-229P-StringBuilder字符串缓冲区类" class="headerlink" title="【笔记十三】  227-229P  StringBuilder字符串缓冲区类"></a>【笔记十三】  227-229P  StringBuilder字符串缓冲区类</h1><ol>
<li>不需要导包。</li>
<li><strong>字符串缓冲区，可以提高字符串的操作效率。</strong></li>
<li>String底层为final修饰的数组，而StringBuilder底层是没有被final修饰的数组，可以改变长度。</li>
<li><strong>StringBuilder()：</strong> 无参构造函数，默认建议一个空字符串。</li>
<li><strong>StringBuilder(String str)：</strong> 带参构造函数，建立一个内容为str的字符串。</li>
<li><strong>append(参数)：</strong> 向对象里添加指定参数内容。返回值为”this”，故不用接收返回值。</li>
<li><strong>toString()：</strong> 将一个StringBuilder对象转为String对象，返回一个String对象，需要接收。</li>
</ol>
<h1 id="【笔记十四】-234-281P-容器及其相关"><a href="#【笔记十四】-234-281P-容器及其相关" class="headerlink" title="【笔记十四】  234-281P  容器及其相关*"></a>【笔记十四】  234-281P  容器及其相关*</h1><p> &emsp;<strong>详情请看我的另一篇文章</strong>：<a href="https://blog.csdn.net/qq_45698148/article/details/112799775">链接点我</a><br> &emsp;<strong>其中介绍了Java容器及其相关内容。</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java容器及其相关学习记录</title>
    <url>/2021/01/19/20210119_Java%E5%AE%B9%E5%99%A8%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p><strong>本文主要记录Java容器相关的内容。</strong><br><strong>更多详细Java学习记录，请看我的另一篇文章：</strong><a href="https://zgg2001.github.io/2021/01/08/20210108_Java%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E5%9F%BA%E4%BA%8EC++%E7%9A%84%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0/#more">链接点我</a></p>
<span id="more"></span>

<h1 id="1-容器关系图"><a href="#1-容器关系图" class="headerlink" title="1.容器关系图"></a>1.容器关系图</h1><p>如图所示：<br><img src="/images/2021-01-19/1.jpg" alt="Java容器关系图"></p>
<h1 id="2-Iterator迭代器"><a href="#2-Iterator迭代器" class="headerlink" title="2.Iterator迭代器"></a>2.Iterator迭代器</h1><p>主要用于遍历Collection中的元素。由于Java没有指针，所以迭代器的使用相比C++更复杂一点。</p>
<h2 id="2-1-常用方法"><a href="#2-1-常用方法" class="headerlink" title="2.1 常用方法"></a>2.1 常用方法</h2><ul>
<li><strong>import java.util.Iterator;</strong></li>
<li><strong>public E next()</strong> ：返回迭代的下一个元素。</li>
<li><strong>public boolean hasNext()</strong> ：如果仍有元素可以迭代，返回true。</li>
<li><strong>public void remove()：</strong> 删除当前指针所指向的元素，一般和next方法一起用，这时候的作用就是删除next方法返回的元素。</li>
</ul>
<h2 id="2-2-使用实例"><a href="#2-2-使用实例" class="headerlink" title="2.2 使用实例"></a>2.2 使用实例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		Collection&lt;Integer&gt; t1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		t1.add(<span class="number">1</span>);</span><br><span class="line">		t1.add(<span class="number">2</span>);</span><br><span class="line">		t1.add(<span class="number">3</span>);</span><br><span class="line">		t1.add(<span class="number">4</span>);</span><br><span class="line">		t1.add(<span class="number">5</span>);</span><br><span class="line">		<span class="comment">//while循环遍历</span></span><br><span class="line">		Iterator&lt;Integer&gt; iter1 = t1.iterator();</span><br><span class="line">		<span class="keyword">while</span>(iter1.hasNext())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> iter1.next();</span><br><span class="line">			System.out.println(temp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//for循环遍历</span></span><br><span class="line">		<span class="keyword">for</span>(Iterator&lt;Integer&gt; iter2 = t1.iterator();iter2.hasNext();)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> iter2.next();</span><br><span class="line">			System.out.println(temp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-增强for循环"><a href="#2-3-增强for循环" class="headerlink" title="2.3 增强for循环"></a>2.3 增强for循环</h2><p>增强for循环，用来遍历集合和数组。<br>是JDK1.5之后出现的新特性，底层使用的也是迭代器，但是简化了使用方法。(不用导Iterator包)</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(集合/数组的数据类型 变量名 : 集合名/数组名)</span><br><span class="line">&#123;</span><br><span class="line">	System.out.println(变量名);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		Collection&lt;Integer&gt; t1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		t1.add(<span class="number">1</span>);</span><br><span class="line">		t1.add(<span class="number">2</span>);</span><br><span class="line">		t1.add(<span class="number">3</span>);</span><br><span class="line">		t1.add(<span class="number">4</span>);</span><br><span class="line">		t1.add(<span class="number">5</span>);</span><br><span class="line">		<span class="comment">//增强for循环</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i : t1)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-Collection（单列集合）"><a href="#3-Collection（单列集合）" class="headerlink" title="3.Collection（单列集合）"></a>3.Collection（单列集合）</h1><p>Collection是所有单列集合的父接口，其中定义了单列集合(List和Set)通用的一些方法，<strong>这些方法可以用于操作所有的单列集合</strong>。</p>
<ul>
<li><strong>import java.util.Collection;</strong></li>
<li><strong>public boolean add(E e)</strong> ：把给定的对象添加到当前集合中。</li>
<li><strong>public void clear()</strong> ：清空集合中的所有元素。</li>
<li><strong>public boolean remove(E e)</strong> ：把给定的对象在当前集合中删除。</li>
<li><strong>public boolean contains(E e)</strong> ：判断当前集合中是否包含给定的对象。</li>
<li><strong>public boolean isEmpty()</strong> ：判断当前集合是否为空。</li>
<li><strong>public int size()</strong> ：返回集合中元素的个数。</li>
<li><strong>public Object[] toarray()</strong> ：把集合中的元素，储存到数组中。</li>
<li><strong>public Iterator iterator()</strong> ： 获取集合所依赖的迭代器对象。</li>
</ul>
<h2 id="3-1-List（列表）"><a href="#3-1-List（列表）" class="headerlink" title="3.1 List（列表）"></a>3.1 List（列表）</h2><p>List接口为有序的集合，并且存在索引，**包含了一些带索引的方法(特有)**。List接口中允许存储重复的元素。</p>
<ul>
<li><strong>import java.util.List;</strong></li>
<li><strong>public void add(int index, E element)</strong> ：将指定的元素，添加到该集合指定的位置上。</li>
<li><strong>public E get(int index)</strong> ：返回集合中指定位置的元素。</li>
<li><strong>public E remove(int index)</strong> ：移除列表中指定的元素，返回的为被移除的元素。</li>
<li><strong>public E set(int index, E element)</strong> ：用指定的元素替换集合中指定位置的元素，返回值为更新前的元素。</li>
</ul>
<h3 id="3-1-1-ArrayList"><a href="#3-1-1-ArrayList" class="headerlink" title="3.1.1 ArrayList"></a>3.1.1 ArrayList</h3><p>ArrayList储存结构为<strong>数组</strong>结构，通过List接口实现大小可变的数组。<strong>元素增删慢，查找快。</strong><br>ArrayList的实现是多线程的，也就是<strong>实现不是同步的</strong>，效率高，但是存在线程安全问题。</p>
<ul>
<li><strong>import java.util.ArrayList;</strong></li>
</ul>
<h3 id="3-1-2-LinkedList"><a href="#3-1-2-LinkedList" class="headerlink" title="3.1.2 LinkedList"></a>3.1.2 LinkedList</h3><p>LinkedList储存结构为<strong>链表</strong>结构，通过List接口实现双向链表。<strong>元素增删快，查找慢。</strong><br>LinkedList提供了大量首尾操作的<strong>特有</strong>方法，跟C++的STL<strong>队列</strong>方法思路都差不多。</p>
<ul>
<li><strong>import java.util.LinkedList;</strong></li>
<li><strong>public void addFirst(E e)</strong> ：将指定元素添加到列表的开头。</li>
<li><strong>public void addLast(E e)</strong> ：将指定元素添加到列表的结尾。</li>
<li><strong>public E getFirst()</strong> ：返回此列表的第一个元素。</li>
<li><strong>public E getLast()</strong> ：返回此列表的最后一个元素。</li>
<li><strong>public E removeFirst()</strong> ：移除并返回列表的第一个元素。</li>
<li><strong>public E removeLast()</strong> ：移除并返回列表的最后一个元素。</li>
<li><strong>public E pop()</strong> ：从此列表的堆栈处弹出一个元素。<strong>此处等效于removeFirst();</strong></li>
<li><strong>public void push(E e)</strong> ：将元素推入列表的堆栈。<strong>此处等效于addFirst();</strong></li>
<li><strong>public boolean isEmpty()</strong> ：如果列表不包含元素，返回true。</li>
</ul>
<h3 id="3-1-3-Vector"><a href="#3-1-3-Vector" class="headerlink" title="3.1.3 Vector"></a>3.1.3 Vector</h3><p>Vector储存结构为<strong>数组</strong>结构，通过List接口实现大小可变的数组。<strong>元素增删慢，查找快。</strong><br>Vector的实现是单线程的，即<strong>实现是同步的</strong>，所以效率比ArrayList要低，但是不存在线程安全问题。</p>
<ul>
<li><strong>import java.util.Vector;</strong></li>
</ul>
<h2 id="3-2-Set（集合）"><a href="#3-2-Set（集合）" class="headerlink" title="3.2 Set（集合）"></a>3.2 Set（集合）</h2><p>Set接口与Collection接口中的方法基本一致，没有对Collection进行功能上的扩充，但是比Collection接口更加严格。<br><strong>Set接口中元素无序，且都会以某种规则保证存入的元素不出现重复。也不能通过普通的for循环进行遍历。</strong> (参考C++中的set即可)</p>
<ul>
<li><strong>import java.util.Set;</strong></li>
</ul>
<h3 id="3-2-1-HashSet"><a href="#3-2-1-HashSet" class="headerlink" title="3.2.1 HashSet"></a>3.2.1 HashSet</h3><p>底层为一个哈希表(数组加红黑树)，查询的速度非常快。且为一个<strong>无序</strong>的集合，存储和取出元素的顺序不一定一样。<br>在进行数据add存储时，首先使用hashCode()方法获取哈希值进行比较，如果无重复则直接填入。如果存在哈希冲突，则使用equals()方法进行判重，如果不存在重复则填入。</p>
<ul>
<li><strong>import java.util.HashSet;</strong></li>
<li><strong>在HashSet存储自定义类型元素时，需重写对象的hashCode方法和equals方法，建立自己的比较方式，从而保证集合中对象唯一。</strong></li>
</ul>
<h3 id="3-2-2-LinkedHashSet"><a href="#3-2-2-LinkedHashSet" class="headerlink" title="3.2.2 LinkedHashSet"></a>3.2.2 LinkedHashSet</h3><p>底层为一个哈希表+链表，多的这条链表用来记录元素的存储顺序，保证元素<strong>有序</strong>，即存储和取出元素的顺序一样。</p>
<ul>
<li><strong>import java.util.LinkedHashSet;</strong></li>
</ul>
<h1 id="4-Map（双列集合-图）"><a href="#4-Map（双列集合-图）" class="headerlink" title="4.Map（双列集合&#x2F;图）"></a>4.Map（双列集合&#x2F;图）</h1><p>Map为双列集合，一个元素里有两个值(key和value)。key不可重复，value可重复。</p>
<ul>
<li><strong>import java.util.Map;</strong></li>
<li><strong>public V put(K key, V value)</strong> ：把指定的键与指定的值添加到Map集合中。</li>
<li><strong>public V remove(Object key)</strong> ：把指定的键 所对应的键值对元素  在Map集合中删除，返回被删除元素的值。</li>
<li><strong>public V get(Object key)</strong> ：根据指定的键，在Map集合中获取对应的值。</li>
<li><strong>boolean containsKey(Object key)</strong> ：判断集合中是否包含指定的键。</li>
<li><strong>public Set&lt;K&gt; keySet()</strong> ：获取Map集合中所有的键，存储到Set集合中。</li>
<li><strong>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</strong> ：获取到Map集合中所有的 键值对 对象的集合(Set集合)。</li>
</ul>
<p><strong>实例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		Integer temp;</span><br><span class="line">		Map&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">		<span class="comment">//put添加元素 如果key不重复返回值为null;如果key重复,替换value,返回值是老value</span></span><br><span class="line">		temp = map.put(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>);<span class="comment">//temp = null</span></span><br><span class="line">		temp = map.put(<span class="string">&quot;张三&quot;</span>, <span class="number">19</span>);<span class="comment">//temp = 18</span></span><br><span class="line">		System.out.println(temp);</span><br><span class="line">		<span class="comment">//remove删除元素 key存在,返回value值;key不存在,返回null</span></span><br><span class="line">		map.put(<span class="string">&quot;李四&quot;</span>, <span class="number">20</span>);</span><br><span class="line">		temp = map.remove(<span class="string">&quot;李四&quot;</span>);<span class="comment">//temp = 20</span></span><br><span class="line">		temp = map.remove(<span class="string">&quot;王五&quot;</span>);<span class="comment">//temp = null</span></span><br><span class="line">		System.out.println(temp);</span><br><span class="line">		<span class="comment">//get获取元素 key存在,返回value值;key不存在,返回null</span></span><br><span class="line">		temp = map.get(<span class="string">&quot;张三&quot;</span>);<span class="comment">//temp = 19</span></span><br><span class="line">		temp = map.get(<span class="string">&quot;赵六&quot;</span>);<span class="comment">//temp = null</span></span><br><span class="line">		System.out.println(temp);</span><br><span class="line">		<span class="comment">//containsKey通过key判断集合中是否包含指定元素 存在返回true</span></span><br><span class="line">		<span class="type">boolean</span> <span class="variable">bool</span> <span class="operator">=</span> map.containsKey(<span class="string">&quot;张三&quot;</span>);<span class="comment">//true</span></span><br><span class="line">		bool = map.containsKey(<span class="string">&quot;赵六&quot;</span>);<span class="comment">//false</span></span><br><span class="line">		System.out.println(bool);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//keySet 获取一个set,其中储存了map的所有key值</span></span><br><span class="line">		Set&lt;String&gt; set = map.keySet();</span><br><span class="line">		<span class="keyword">for</span>(String i : set)<span class="comment">//随后就可以根据set使用增强for或者迭代器进行遍历</span></span><br><span class="line">		&#123;</span><br><span class="line">			temp = map.get(i);</span><br><span class="line">			System.out.println(i+<span class="string">&quot; &quot;</span>+temp);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//entrySet 返回一个set,其中储存了map中的所有Entry对象</span></span><br><span class="line">		Set&lt;Map.Entry&lt;String,Integer&gt;&gt; set1 = map.entrySet();</span><br><span class="line">		<span class="keyword">for</span>(Map.Entry&lt;String,Integer&gt; i : set1)<span class="comment">//遍历set集合,获取每一个Entry对象</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//通过Entry对象中的方法获取key和value</span></span><br><span class="line">			<span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> i.getKey();</span><br><span class="line">			<span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> i.getValue();</span><br><span class="line">			System.out.println(key+<span class="string">&quot; &quot;</span>+value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="4-1-HashMap"><a href="#4-1-HashMap" class="headerlink" title="4.1 HashMap"></a>4.1 HashMap</h2><p>底层为哈希表(数组+链表&#x2F;红黑树)，查询速度很快。且为一个<strong>无序</strong>的集合，存储和取出元素的顺序不一定一样。</p>
<ul>
<li><strong>import java.util.HashMap;</strong></li>
<li><strong>在HashMap存储自定义类型元素时，需重写key元素的hashCode方法和equals方法，从而保证key唯一。</strong></li>
</ul>
<h2 id="4-2-LinkedHashMap"><a href="#4-2-LinkedHashMap" class="headerlink" title="4.2 LinkedHashMap"></a>4.2 LinkedHashMap</h2><p>底层为哈希表+链表，多的这条链表用来记录元素的存储顺序，保证元素<strong>有序</strong>，即存储和取出元素的顺序一样。</p>
<ul>
<li><strong>import java.util.LinkedHashMap;</strong></li>
</ul>
<h2 id="4-3-Hashtable"><a href="#4-3-Hashtable" class="headerlink" title="4.3 Hashtable"></a>4.3 Hashtable</h2><p>底层为哈希表，与HashMap基本一致。其与HashMap的关系，类似Vector与ArrayList的关系。</p>
<p><strong>区别：</strong></p>
<ol>
<li>HashMap键值<strong>可以为null</strong>，但是Hashtable的键值都不能为空。</li>
<li>Hashtable为单线程，线程安全但是速度慢。</li>
</ol>
<ul>
<li><strong>import java.util.Hashtable;</strong></li>
</ul>
<h1 id="5-Collections集合工具类"><a href="#5-Collections集合工具类" class="headerlink" title="5.Collections集合工具类"></a>5.Collections集合工具类</h1><ul>
<li><strong>import java.util.Collections;</strong></li>
<li><strong>public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T…elements)</strong> ：往集合中添加一些元素。</li>
<li><strong>public static void shuffle(List&lt;?&gt; list)</strong> ：打乱集合顺序。</li>
<li><strong>public static &lt;T&gt; void sort(List&lt;T&gt; list)</strong> ：将集合中元素按照默认规则排序。(默认为升序)</li>
<li><strong>public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; )</strong> ：将集合中元素按照指定规则排序。</li>
</ul>
<p><strong>实例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		ArrayList&lt;Integer&gt; t1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		<span class="comment">//addAll 添加1，2，3，4，5</span></span><br><span class="line">		Collections.addAll(t1,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">		<span class="comment">//shuffle 打乱顺序 每次执行顺序都不一样</span></span><br><span class="line">		Collections.shuffle(t1);</span><br><span class="line">		<span class="comment">//sort默认排序 默认为升序</span></span><br><span class="line">		Collections.sort(t1);</span><br><span class="line">		<span class="comment">//sort自定义排序 降序</span></span><br><span class="line">		Collections.sort(t1,<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;()</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="meta">@Override</span><span class="comment">//重写compare方法</span></span><br><span class="line">			<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1,Integer o2)</span>/</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//后减前为降序 前减后为升序</span></span><br><span class="line">				<span class="keyword">return</span> o2-o1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="comment">//增强for循环</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i : t1)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(i);<span class="comment">//5 4 3 2 1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>C++网络编程学习：建立基础TCP服务端/客户端</title>
    <url>/2021/01/21/20210121_C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%BB%BA%E7%AB%8B%E5%9F%BA%E7%A1%80TCP%E6%9C%8D%E5%8A%A1%E7%AB%AF-%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
    <content><![CDATA[<ul>
<li>使用的语言为C&#x2F;C++</li>
<li>源码支持的平台为：Windows</li>
</ul>
<h1 id="一、建立简易TCP服务端"><a href="#一、建立简易TCP服务端" class="headerlink" title="一、建立简易TCP服务端"></a>一、建立简易TCP服务端</h1><h2 id="1-建立服务端大致流程"><a href="#1-建立服务端大致流程" class="headerlink" title="1.建立服务端大致流程"></a>1.建立服务端大致流程</h2><ol>
<li>建立一个套接字 <strong>（socket）</strong></li>
<li>绑定客户端连接的端口 <strong>（bind）</strong></li>
<li>监听网络端口 <strong>（listen）</strong></li>
<li>等待接受客户端连接 <strong>（accept）</strong></li>
<li>接收客户端发送的数据 <strong>（recv）</strong></li>
<li>向客户端发送数据 <strong>（send）</strong></li>
<li>关闭套接字 <strong>（closesocket）</strong></li>
</ol>
<span id="more"></span>

<h2 id="2-代码实现以及详细注释"><a href="#2-代码实现以及详细注释" class="headerlink" title="2.代码实现以及详细注释"></a>2.代码实现以及详细注释</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN<span class="comment">//消除下面两个头文件存在的冲突</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;winSock2.h&gt;</span><span class="comment">//此头文件应在windows.h头文件的上面，否则会有冲突</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//链接此动态链接库 windows特有 </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//启动windows socket 2,x环境 windows特有 </span></span><br><span class="line">	WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>);<span class="comment">//WinSock库版本号 </span></span><br><span class="line">	WSADATA dat;<span class="comment">//网络结构体 储存WSAStartup函数调用后返回的Socket数据 </span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span> != <span class="built_in">WSAStartup</span>(ver,&amp;dat))<span class="comment">//正确初始化后返回0 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//建立一个socket </span></span><br><span class="line">	SOCKET _mysocket = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,IPPROTO_TCP);<span class="comment">//IPV4 数据流类型 TCP类型 </span></span><br><span class="line">	<span class="keyword">if</span>(INVALID_SOCKET == _mysocket)<span class="comment">//建立失败 </span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">	<span class="comment">//绑定网络端口和IP地址 </span></span><br><span class="line">	sockaddr_in _myaddr = &#123;&#125;;<span class="comment">//建立sockaddr结构体  sockaddr_in结构体方便填写 但是下面要进行类型转换 </span></span><br><span class="line">	_myaddr.sin_family = AF_INET;<span class="comment">//IPV4</span></span><br><span class="line">	_myaddr.sin_port = <span class="built_in">htons</span>(<span class="number">8888</span>);<span class="comment">//端口 host to net unsigned short</span></span><br><span class="line">	_myaddr.sin_addr.S_un.S_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);<span class="comment">//网络地址 INADDR_ANY监听所有网卡的端口 </span></span><br><span class="line">	<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">bind</span>(_mysocket,(sockaddr*)&amp;_myaddr,<span class="built_in">sizeof</span>(sockaddr_in)))<span class="comment">//socket (强制转换)sockaddr结构体 结构体大小 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;绑定不成功&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;&quot;绑定成功&quot;&lt;&lt;endl; </span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//监听网络端口</span></span><br><span class="line">	<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">listen</span>(_mysocket,<span class="number">5</span>))<span class="comment">//套接字 最大多少人连接 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;监听失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;&quot;监听成功&quot;&lt;&lt;endl; </span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//等待接收客户端连接</span></span><br><span class="line">	sockaddr_in _clientAddr = &#123;&#125;;<span class="comment">//新建sockadd结构体接收客户端数据 </span></span><br><span class="line">	<span class="type">int</span> _addr_len = <span class="built_in">sizeof</span>(sockaddr_in);<span class="comment">//获取sockadd结构体长度 </span></span><br><span class="line">	SOCKET _temp_socket = INVALID_SOCKET;<span class="comment">//声明客户端套接字 </span></span><br><span class="line">	<span class="type">char</span> _buf[<span class="number">256</span>] = &#123;&#125;;<span class="comment">//接收客户端发送的消息 </span></span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		_temp_socket = <span class="built_in">accept</span>(_mysocket,(sockaddr*)&amp;_clientAddr,&amp;_addr_len);<span class="comment">//自身套接字 客户端结构体 结构体大小 </span></span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET == _temp_socket)<span class="comment">//接收失败 </span></span><br><span class="line">		&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;接收到无效客户端Socket&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;新客户端加入&quot;</span>&lt;&lt;endl; </span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;IP地址为：%s \n&quot;</span>, <span class="built_in">inet_ntoa</span>(_clientAddr.sin_addr));  </span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//接收客户端发送的数据 </span></span><br><span class="line">		<span class="type">char</span> _buf[<span class="number">256</span>] = &#123;&#125;;</span><br><span class="line">		<span class="type">int</span> _buf_len = <span class="built_in">recv</span>(_temp_socket,_buf,<span class="number">256</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(_buf_len&gt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,_buf);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//向客户端发送数据</span></span><br><span class="line">		<span class="type">char</span> _msg[] = <span class="string">&quot;HelloWorld&quot;</span>;</span><br><span class="line">		<span class="built_in">send</span>(_temp_socket,_msg,<span class="built_in">strlen</span>(_msg)<span class="number">+1</span>,<span class="number">0</span>);<span class="comment">//客户端套接字 数据 数据长短 flag </span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//关闭客户端socket</span></span><br><span class="line">		<span class="built_in">closesocket</span>(_temp_socket); </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//关闭socket </span></span><br><span class="line">	<span class="built_in">closesocket</span>(_mysocket); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//清除windows socket 环境 </span></span><br><span class="line">	<span class="built_in">WSACleanup</span>(); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="二、建立简易TCP客户端"><a href="#二、建立简易TCP客户端" class="headerlink" title="二、建立简易TCP客户端"></a>二、建立简易TCP客户端</h1><h2 id="1-建立客户端大致流程"><a href="#1-建立客户端大致流程" class="headerlink" title="1.建立客户端大致流程"></a>1.建立客户端大致流程</h2><ol>
<li>建立一个套接字 <strong>（socket）</strong></li>
<li>连接服务器 <strong>（connect）</strong></li>
<li>向客户端发送数据 <strong>（send）</strong></li>
<li>接收客户端发送的数据 <strong>（recv）</strong></li>
<li>关闭套接字 <strong>（closesocket）</strong></li>
</ol>
<h2 id="2-代码实现以及详细注释-1"><a href="#2-代码实现以及详细注释-1" class="headerlink" title="2.代码实现以及详细注释"></a>2.代码实现以及详细注释</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;winSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//链接此动态链接库 windows特有 </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//启动windows socket 2,x环境 windows特有 </span></span><br><span class="line">	WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>);<span class="comment">//WinSock库版本号 </span></span><br><span class="line">	WSADATA dat;<span class="comment">//网络结构体 储存WSAStartup函数调用后返回的Socket数据 </span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span> != <span class="built_in">WSAStartup</span>(ver,&amp;dat))<span class="comment">//正确初始化后返回0 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//建立一个socket </span></span><br><span class="line">	SOCKET _mysocket = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);<span class="comment">//IPV4 数据流类型 类型可以不用写 </span></span><br><span class="line">	<span class="keyword">if</span>(INVALID_SOCKET == _mysocket)<span class="comment">//建立失败 </span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//连接服务器</span></span><br><span class="line">    sockaddr_in _sin = &#123;&#125;;<span class="comment">//sockaddr结构体 </span></span><br><span class="line">    _sin.sin_family = AF_INET;<span class="comment">//IPV4</span></span><br><span class="line">    _sin.sin_port = <span class="built_in">htons</span>(<span class="number">8888</span>);<span class="comment">//想要连接的端口号 </span></span><br><span class="line">	_sin.sin_addr.S_un.S_addr =  <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);<span class="comment">//想要连接的IP </span></span><br><span class="line">	<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">connect</span>(_mysocket,(sockaddr*)&amp;_sin,<span class="built_in">sizeof</span>(sockaddr_in)))</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;连接失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">		<span class="built_in">closesocket</span>(_mysocket);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;连接成功&quot;</span>&lt;&lt;endl; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//向客户端发送数据</span></span><br><span class="line">	<span class="type">char</span> _msg[] = <span class="string">&quot;HelloServer&quot;</span>;</span><br><span class="line">	<span class="built_in">send</span>(_mysocket,_msg,<span class="built_in">strlen</span>(_msg)<span class="number">+1</span>,<span class="number">0</span>);<span class="comment">//客户端套接字 数据 数据长短 flag </span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//接收服务器信息 </span></span><br><span class="line">	<span class="type">char</span> _buf[<span class="number">256</span>] = &#123;&#125;;</span><br><span class="line">	<span class="type">int</span> _buf_len = <span class="built_in">recv</span>(_mysocket,_buf,<span class="number">256</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(_buf_len&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,_buf);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//关闭socket</span></span><br><span class="line">	<span class="built_in">closesocket</span>(_mysocket); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//清除windows socket 环境 </span></span><br><span class="line">	<span class="built_in">WSACleanup</span>(); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>


<h1 id="三、建立可持续处理请求的网络程序"><a href="#三、建立可持续处理请求的网络程序" class="headerlink" title="三、建立可持续处理请求的网络程序"></a>三、建立可持续处理请求的网络程序</h1><h2 id="1-思路"><a href="#1-思路" class="headerlink" title="1.思路"></a>1.思路</h2><p>&emsp;&emsp;在进行socket连接后，即服务端进行<strong>accept</strong>操作、客户端进行<strong>connect</strong>操作后，使用循环，在此循环中进行<strong>send&#x2F;recv</strong>操作传输数据，即可实现持续处理请求。</p>
<h2 id="2-代码实现以及详细注释-2"><a href="#2-代码实现以及详细注释-2" class="headerlink" title="2.代码实现以及详细注释"></a>2.代码实现以及详细注释</h2><h3 id="2-1-服务端代码"><a href="#2-1-服务端代码" class="headerlink" title="2.1 服务端代码"></a>2.1 服务端代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;winSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//链接此动态链接库 windows特有 </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//启动windows socket 2,x环境 windows特有 </span></span><br><span class="line">	WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>);<span class="comment">//WinSock库版本号 </span></span><br><span class="line">	WSADATA dat;<span class="comment">//网络结构体 储存WSAStartup函数调用后返回的Socket数据 </span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span> != <span class="built_in">WSAStartup</span>(ver,&amp;dat))<span class="comment">//正确初始化后返回0 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//建立一个socket </span></span><br><span class="line">	SOCKET _mysocket = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,IPPROTO_TCP);<span class="comment">//IPV4 数据流类型 TCP类型 </span></span><br><span class="line">	<span class="keyword">if</span>(INVALID_SOCKET == _mysocket)<span class="comment">//建立失败 </span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">	<span class="comment">//绑定网络端口和IP地址 </span></span><br><span class="line">	sockaddr_in _myaddr = &#123;&#125;;<span class="comment">//建立sockaddr结构体  sockaddr_in结构体方便填写 但是下面要进行类型转换 </span></span><br><span class="line">	_myaddr.sin_family = AF_INET;<span class="comment">//IPV4</span></span><br><span class="line">	_myaddr.sin_port = <span class="built_in">htons</span>(<span class="number">8888</span>);<span class="comment">//端口 host to net unsigned short</span></span><br><span class="line">	_myaddr.sin_addr.S_un.S_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);<span class="comment">//网络地址 INADDR_ANY监听所有网卡的端口 </span></span><br><span class="line">	<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">bind</span>(_mysocket,(sockaddr*)&amp;_myaddr,<span class="built_in">sizeof</span>(sockaddr_in)))<span class="comment">//socket (强制转换)sockaddr结构体 结构体大小 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;绑定不成功&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;&quot;绑定成功&quot;&lt;&lt;endl; </span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//监听网络端口</span></span><br><span class="line">	<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">listen</span>(_mysocket,<span class="number">5</span>))<span class="comment">//套接字 最大多少人连接 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;监听失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;&quot;监听成功&quot;&lt;&lt;endl; </span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//等待接收客户端连接</span></span><br><span class="line">	sockaddr_in _clientAddr = &#123;&#125;;<span class="comment">//新建sockadd结构体接收客户端数据 </span></span><br><span class="line">	<span class="type">int</span> _addr_len = <span class="built_in">sizeof</span>(sockaddr_in);<span class="comment">//获取sockadd结构体长度 </span></span><br><span class="line">	SOCKET _temp_socket = INVALID_SOCKET;<span class="comment">//声明客户端套接字 </span></span><br><span class="line">	<span class="type">char</span> _buf[<span class="number">256</span>] = &#123;&#125;;<span class="comment">//接收客户端发送的消息 </span></span><br><span class="line">	</span><br><span class="line">	_temp_socket = <span class="built_in">accept</span>(_mysocket,(sockaddr*)&amp;_clientAddr,&amp;_addr_len);<span class="comment">//自身套接字 客户端结构体 结构体大小 </span></span><br><span class="line">	<span class="keyword">if</span>(INVALID_SOCKET == _temp_socket)<span class="comment">//接收失败 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;接收到无效客户端Socket&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;新客户端加入&quot;</span>&lt;&lt;endl; </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;IP地址为：%s \n&quot;</span>, <span class="built_in">inet_ntoa</span>(_clientAddr.sin_addr));  </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)<span class="comment">//循环</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//接收客户端发送的数据 </span></span><br><span class="line">		<span class="type">int</span> _buf_len = <span class="built_in">recv</span>(_temp_socket,_buf,<span class="number">256</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(_buf_len&lt;=<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;客户端已退出\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(_buf,<span class="string">&quot;getname&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//向客户端发送数据</span></span><br><span class="line">			<span class="type">char</span> _msg[] = <span class="string">&quot;My name is Mr.Zhao&quot;</span>;</span><br><span class="line">			<span class="built_in">send</span>(_temp_socket,_msg,<span class="built_in">strlen</span>(_msg)<span class="number">+1</span>,<span class="number">0</span>);<span class="comment">//客户端套接字 数据 数据长短 flag </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(_buf,<span class="string">&quot;getage&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//向客户端发送数据</span></span><br><span class="line">			<span class="type">char</span> _msg[] = <span class="string">&quot;My age is 19&quot;</span>;</span><br><span class="line">			<span class="built_in">send</span>(_temp_socket,_msg,<span class="built_in">strlen</span>(_msg)<span class="number">+1</span>,<span class="number">0</span>);<span class="comment">//客户端套接字 数据 数据长短 flag </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//向客户端发送数据</span></span><br><span class="line">			<span class="type">char</span> _msg[] = <span class="string">&quot;???&quot;</span>;</span><br><span class="line">			<span class="built_in">send</span>(_temp_socket,_msg,<span class="built_in">strlen</span>(_msg)<span class="number">+1</span>,<span class="number">0</span>);<span class="comment">//客户端套接字 数据 数据长短 flag </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭客户端socket</span></span><br><span class="line">	<span class="built_in">closesocket</span>(_temp_socket);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭socket </span></span><br><span class="line">	<span class="built_in">closesocket</span>(_mysocket); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//清除windows socket 环境 </span></span><br><span class="line">	<span class="built_in">WSACleanup</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;任务结束，程序已退出&quot;</span>); </span><br><span class="line">	 </span><br><span class="line">	<span class="built_in">getchar</span>(); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="2-2-客户端代码"><a href="#2-2-客户端代码" class="headerlink" title="2.2 客户端代码"></a>2.2 客户端代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;winSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//链接此动态链接库 windows特有 </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//启动windows socket 2,x环境 windows特有 </span></span><br><span class="line">	WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>);<span class="comment">//WinSock库版本号 </span></span><br><span class="line">	WSADATA dat;<span class="comment">//网络结构体 储存WSAStartup函数调用后返回的Socket数据 </span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span> != <span class="built_in">WSAStartup</span>(ver,&amp;dat))<span class="comment">//正确初始化后返回0 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//建立一个socket </span></span><br><span class="line">	SOCKET _mysocket = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);<span class="comment">//IPV4 数据流类型 类型可以不用写 </span></span><br><span class="line">	<span class="keyword">if</span>(INVALID_SOCKET == _mysocket)<span class="comment">//建立失败 </span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//连接服务器</span></span><br><span class="line">    sockaddr_in _sin = &#123;&#125;;<span class="comment">//sockaddr结构体 </span></span><br><span class="line">    _sin.sin_family = AF_INET;<span class="comment">//IPV4</span></span><br><span class="line">    _sin.sin_port = <span class="built_in">htons</span>(<span class="number">8888</span>);<span class="comment">//想要连接的端口号 </span></span><br><span class="line">	_sin.sin_addr.S_un.S_addr =  <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);<span class="comment">//想要连接的IP </span></span><br><span class="line">	<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">connect</span>(_mysocket,(sockaddr*)&amp;_sin,<span class="built_in">sizeof</span>(sockaddr_in)))</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;连接失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">		<span class="built_in">closesocket</span>(_mysocket);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;连接成功&quot;</span>&lt;&lt;endl; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)<span class="comment">//循环</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//输入请求 </span></span><br><span class="line">		<span class="type">char</span> _msg[<span class="number">256</span>] = &#123;&#125;;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,_msg);</span><br><span class="line">		<span class="comment">//处理请求 </span></span><br><span class="line">		<span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(_msg,<span class="string">&quot;exit&quot;</span>))<span class="comment">//退出</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//向客户端发送数据</span></span><br><span class="line">			<span class="built_in">send</span>(_mysocket,_msg,<span class="built_in">strlen</span>(_msg)<span class="number">+1</span>,<span class="number">0</span>);<span class="comment">//客户端套接字 数据 数据长短 flag</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//接收服务器信息 </span></span><br><span class="line">		<span class="type">char</span> _buf[<span class="number">256</span>] = &#123;&#125;;</span><br><span class="line">		<span class="type">int</span> _buf_len = <span class="built_in">recv</span>(_mysocket,_buf,<span class="number">256</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(_buf_len&gt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,_buf);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭socket</span></span><br><span class="line">	<span class="built_in">closesocket</span>(_mysocket); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//清除windows socket 环境 </span></span><br><span class="line">	<span class="built_in">WSACleanup</span>(); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++网络编程学习：网络数据报文的收发</title>
    <url>/2021/01/22/20210122_C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%96%87%E7%9A%84%E6%94%B6%E5%8F%91/</url>
    <content><![CDATA[<ul>
<li>使用的语言为C&#x2F;C++</li>
<li>源码支持的平台为：Windows</li>
</ul>
<h1 id="一、网络数据报文的格式定义"><a href="#一、网络数据报文的格式定义" class="headerlink" title="一、网络数据报文的格式定义"></a>一、网络数据报文的格式定义</h1><ul>
<li>报文有两个部分，<strong>包头</strong>和<strong>包体</strong>，是网络消息的基本单元。</li>
<li><strong>包头：</strong> 描述本次消息包的大小，描述包体数据的作用。</li>
<li><strong>包体：</strong> 其中包含了需要传输的数据。</li>
</ul>
<span id="more"></span>

<p>&emsp;&emsp;根据此数据结构，我们可以根据包头的内容，来灵活的对包体的数据进行处理。</p>
<h1 id="二、将包头与包体数据分开收发"><a href="#二、将包头与包体数据分开收发" class="headerlink" title="二、将包头与包体数据分开收发"></a>二、将包头与包体数据分开收发</h1><h2 id="1-概括"><a href="#1-概括" class="headerlink" title="1.概括"></a>1.概括</h2><p>&emsp;&emsp;通过上文对网络数据报文的定义，我们可以很轻易的想到：</p>
<ol>
<li>发送端进行两次<strong>send</strong>操作，第一次<strong>send</strong>发送包头，第二次<strong>send</strong>发送包体，即可实现网络数据报文的发送。</li>
<li>接收端进行两次<strong>recv</strong>操作，第一次<strong>recv</strong>接收包头，第二次<strong>recv</strong>接收包体并根据包头的内容进行数据处理，即可实现网络数据报文的接收。</li>
</ol>
<p>&emsp;&emsp;按以上操作，即可实现网络数据报文的收发。</p>
<h2 id="2-代码及其详细注释"><a href="#2-代码及其详细注释" class="headerlink" title="2.代码及其详细注释"></a>2.代码及其详细注释</h2><h3 id="2-1-服务端代码"><a href="#2-1-服务端代码" class="headerlink" title="2.1 服务端代码"></a>2.1 服务端代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;winSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//链接此动态链接库 windows特有 </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//枚举类型记录命令 </span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">cmd</span> </span><br><span class="line">&#123;</span><br><span class="line">	CMD_LOGIN,<span class="comment">//登录 </span></span><br><span class="line">	CMD_LOGOUT,<span class="comment">//登出 </span></span><br><span class="line">	CMD_ERROR<span class="comment">//错误 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义数据包头 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DateHeader</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">short</span> cmd;<span class="comment">//命令</span></span><br><span class="line">	<span class="type">short</span> date_length;<span class="comment">//数据的长短	</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包体1 登录 传输账号与密码</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Login</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">	<span class="type">char</span> PassWord[<span class="number">32</span>];<span class="comment">//密码 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包体2 登录结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoginResult</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包体3 登出 传输用户名 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Logout</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包体4 登出结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LogoutResult</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//启动windows socket 2,x环境 windows特有 </span></span><br><span class="line">	WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>);<span class="comment">//WinSock库版本号 </span></span><br><span class="line">	WSADATA dat;<span class="comment">//网络结构体 储存WSAStartup函数调用后返回的Socket数据 </span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span> != <span class="built_in">WSAStartup</span>(ver,&amp;dat))<span class="comment">//正确初始化后返回0 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//建立一个socket </span></span><br><span class="line">	SOCKET _mysocket = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,IPPROTO_TCP);<span class="comment">//IPV4 数据流类型 TCP类型 </span></span><br><span class="line">	<span class="keyword">if</span>(INVALID_SOCKET == _mysocket)<span class="comment">//建立失败 </span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">	<span class="comment">//绑定网络端口和IP地址 </span></span><br><span class="line">	sockaddr_in _myaddr = &#123;&#125;;<span class="comment">//建立sockaddr结构体  sockaddr_in结构体方便填写 但是下面要进行类型转换 </span></span><br><span class="line">	_myaddr.sin_family = AF_INET;<span class="comment">//IPV4</span></span><br><span class="line">	_myaddr.sin_port = <span class="built_in">htons</span>(<span class="number">8888</span>);<span class="comment">//端口 host to net unsigned short</span></span><br><span class="line">	_myaddr.sin_addr.S_un.S_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);<span class="comment">//网络地址 INADDR_ANY监听所有网卡的端口 </span></span><br><span class="line">	<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">bind</span>(_mysocket,(sockaddr*)&amp;_myaddr,<span class="built_in">sizeof</span>(sockaddr_in)))<span class="comment">//socket (强制转换)sockaddr结构体 结构体大小 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;绑定不成功&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;&quot;绑定成功&quot;&lt;&lt;endl; </span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//监听网络端口</span></span><br><span class="line">	<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">listen</span>(_mysocket,<span class="number">5</span>))<span class="comment">//套接字 最大多少人连接 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;监听失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;&quot;监听成功&quot;&lt;&lt;endl; </span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//等待接收客户端连接</span></span><br><span class="line">	sockaddr_in _clientAddr = &#123;&#125;;<span class="comment">//新建sockadd结构体接收客户端数据 </span></span><br><span class="line">	<span class="type">int</span> _addr_len = <span class="built_in">sizeof</span>(sockaddr_in);<span class="comment">//获取sockadd结构体长度 </span></span><br><span class="line">	SOCKET _temp_socket = INVALID_SOCKET;<span class="comment">//声明客户端套接字 </span></span><br><span class="line">	</span><br><span class="line">	_temp_socket = <span class="built_in">accept</span>(_mysocket,(sockaddr*)&amp;_clientAddr,&amp;_addr_len);<span class="comment">//自身套接字 客户端结构体 结构体大小 </span></span><br><span class="line">	<span class="keyword">if</span>(INVALID_SOCKET == _temp_socket)<span class="comment">//接收失败 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;接收到无效客户端Socket&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;新客户端加入&quot;</span>&lt;&lt;endl; </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;IP地址为：%s \n&quot;</span>, <span class="built_in">inet_ntoa</span>(_clientAddr.sin_addr));  </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//接收客户端发送的数据 </span></span><br><span class="line">		DateHeader _head = &#123;&#125;; </span><br><span class="line">		<span class="type">int</span> _buf_len = <span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_head,<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(_buf_len&lt;=<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;客户端已退出\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;接收到包头，命令：%d，数据长度：%d\n&quot;</span>,_head.cmd,_head.date_length);</span><br><span class="line">		<span class="keyword">switch</span>(_head.cmd)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> CMD_LOGIN:<span class="comment">//登录 接收登录包体 </span></span><br><span class="line">			&#123;</span><br><span class="line">				Login _login = &#123;&#125;;</span><br><span class="line">				<span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_login,<span class="built_in">sizeof</span>(Login),<span class="number">0</span>);</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				进行判断操作 </span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%s已登录\n&quot;</span>,_login.UserName); </span><br><span class="line">				<span class="built_in">send</span>(_temp_socket,(<span class="type">char</span>*)&amp;_head,<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);<span class="comment">//发包头 </span></span><br><span class="line">				LoginResult _result = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">				<span class="built_in">send</span>(_temp_socket,(<span class="type">char</span>*)&amp;_result,<span class="built_in">sizeof</span>(LoginResult),<span class="number">0</span>);<span class="comment">//发包体 </span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> CMD_LOGOUT:<span class="comment">//登出 接收登出包体 </span></span><br><span class="line">			&#123;</span><br><span class="line">				Logout _logout = &#123;&#125;;</span><br><span class="line">				<span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_logout,<span class="built_in">sizeof</span>(Logout),<span class="number">0</span>);</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				进行判断操作 </span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%s已登出\n&quot;</span>,_logout.UserName); </span><br><span class="line">				<span class="built_in">send</span>(_temp_socket,(<span class="type">char</span>*)&amp;_head,<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);<span class="comment">//发包头 </span></span><br><span class="line">				LogoutResult _result = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">				<span class="built_in">send</span>(_temp_socket,(<span class="type">char</span>*)&amp;_result,<span class="built_in">sizeof</span>(LogoutResult),<span class="number">0</span>);<span class="comment">//发包体</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:<span class="comment">//错误 </span></span><br><span class="line">			&#123;</span><br><span class="line">				_head.cmd = CMD_ERROR; </span><br><span class="line">				_head.date_length = <span class="number">0</span>; </span><br><span class="line">				<span class="built_in">send</span>(_temp_socket,(<span class="type">char</span>*)&amp;_head,<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);<span class="comment">//发包头 </span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭客户端socket</span></span><br><span class="line">	<span class="built_in">closesocket</span>(_temp_socket);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭socket </span></span><br><span class="line">	<span class="built_in">closesocket</span>(_mysocket); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//清除windows socket 环境 </span></span><br><span class="line">	<span class="built_in">WSACleanup</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;任务结束，程序已退出&quot;</span>); </span><br><span class="line">	 </span><br><span class="line">	<span class="built_in">getchar</span>(); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="2-2-客户端代码"><a href="#2-2-客户端代码" class="headerlink" title="2.2 客户端代码"></a>2.2 客户端代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;winSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//链接此动态链接库 windows特有 </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//枚举类型记录命令 </span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">cmd</span> </span><br><span class="line">&#123;</span><br><span class="line">	CMD_LOGIN,<span class="comment">//登录 </span></span><br><span class="line">	CMD_LOGOUT,<span class="comment">//登出 </span></span><br><span class="line">	CMD_ERROR<span class="comment">//错误 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义数据包头 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DateHeader</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">short</span> cmd;<span class="comment">//命令</span></span><br><span class="line">	<span class="type">short</span> date_length;<span class="comment">//数据的长短	</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包体1 登录 传输账号与密码</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Login</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">	<span class="type">char</span> PassWord[<span class="number">32</span>];<span class="comment">//密码 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包体2 登录结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoginResult</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包体3 登出 传输用户名 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Logout</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包体4 登出结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LogoutResult</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//启动windows socket 2,x环境 windows特有 </span></span><br><span class="line">	WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>);<span class="comment">//WinSock库版本号 </span></span><br><span class="line">	WSADATA dat;<span class="comment">//网络结构体 储存WSAStartup函数调用后返回的Socket数据 </span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span> != <span class="built_in">WSAStartup</span>(ver,&amp;dat))<span class="comment">//正确初始化后返回0 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//建立一个socket </span></span><br><span class="line">	SOCKET _mysocket = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);<span class="comment">//IPV4 数据流类型 类型可以不用写 </span></span><br><span class="line">	<span class="keyword">if</span>(INVALID_SOCKET == _mysocket)<span class="comment">//建立失败 </span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//连接服务器</span></span><br><span class="line">    sockaddr_in _sin = &#123;&#125;;<span class="comment">//sockaddr结构体 </span></span><br><span class="line">    _sin.sin_family = AF_INET;<span class="comment">//IPV4</span></span><br><span class="line">    _sin.sin_port = <span class="built_in">htons</span>(<span class="number">8888</span>);<span class="comment">//想要连接的端口号 </span></span><br><span class="line">	_sin.sin_addr.S_un.S_addr =  <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);<span class="comment">//想要连接的IP </span></span><br><span class="line">	<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">connect</span>(_mysocket,(sockaddr*)&amp;_sin,<span class="built_in">sizeof</span>(sockaddr_in)))</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;连接失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">		<span class="built_in">closesocket</span>(_mysocket);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;连接成功&quot;</span>&lt;&lt;endl; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//输入请求 </span></span><br><span class="line">		<span class="type">char</span> _msg[<span class="number">256</span>] = &#123;&#125;;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,_msg);</span><br><span class="line">		<span class="comment">//处理请求 </span></span><br><span class="line">		<span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(_msg,<span class="string">&quot;exit&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(_msg,<span class="string">&quot;login&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//发送 </span></span><br><span class="line">			Login _login = &#123;<span class="string">&quot;河边小咸鱼&quot;</span>,<span class="string">&quot;123456&quot;</span>&#125;;</span><br><span class="line">			DateHeader _head = &#123;CMD_LOGIN,<span class="built_in">sizeof</span>(_login)&#125;;</span><br><span class="line">			<span class="built_in">send</span>(_mysocket,(<span class="type">const</span> <span class="type">char</span>*)&amp;_head,<span class="built_in">sizeof</span>(_head),<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">send</span>(_mysocket,(<span class="type">const</span> <span class="type">char</span>*)&amp;_login,<span class="built_in">sizeof</span>(_login),<span class="number">0</span>);</span><br><span class="line">			<span class="comment">//接收 </span></span><br><span class="line">			DateHeader _head2 = &#123;&#125;; </span><br><span class="line">			LoginResult _result= &#123;&#125;; </span><br><span class="line">			<span class="built_in">recv</span>(_mysocket,(<span class="type">char</span>*)&amp;_head2,<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">recv</span>(_mysocket,(<span class="type">char</span>*)&amp;_result,<span class="built_in">sizeof</span>(LoginResult),<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;result:%d\n&quot;</span>,_result.Result);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(_msg,<span class="string">&quot;logout&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//发送 </span></span><br><span class="line">			Logout _logout = &#123;<span class="string">&quot;河边小咸鱼&quot;</span>&#125;;</span><br><span class="line">			DateHeader _head = &#123;CMD_LOGOUT,<span class="built_in">sizeof</span>(_logout)&#125;;</span><br><span class="line">			<span class="built_in">send</span>(_mysocket,(<span class="type">const</span> <span class="type">char</span>*)&amp;_head,<span class="built_in">sizeof</span>(_head),<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">send</span>(_mysocket,(<span class="type">const</span> <span class="type">char</span>*)&amp;_logout,<span class="built_in">sizeof</span>(_logout),<span class="number">0</span>);</span><br><span class="line">			<span class="comment">//接收 </span></span><br><span class="line">			DateHeader _head2 = &#123;&#125;; </span><br><span class="line">			LogoutResult _result= &#123;&#125;; </span><br><span class="line">			<span class="built_in">recv</span>(_mysocket,(<span class="type">char</span>*)&amp;_head2,<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">recv</span>(_mysocket,(<span class="type">char</span>*)&amp;_result,<span class="built_in">sizeof</span>(LogoutResult),<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;result:%d\n&quot;</span>,_result.Result);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;不存在的命令\n&quot;</span>);</span><br><span class="line">		&#125; 	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭socket</span></span><br><span class="line">	<span class="built_in">closesocket</span>(_mysocket); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//清除windows socket 环境 </span></span><br><span class="line">	<span class="built_in">WSACleanup</span>(); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>


<h1 id="三、将分开收发报文数据改为一次收发"><a href="#三、将分开收发报文数据改为一次收发" class="headerlink" title="三、将分开收发报文数据改为一次收发"></a>三、将分开收发报文数据改为一次收发</h1><h2 id="1-思路"><a href="#1-思路" class="headerlink" title="1.思路"></a>1.思路</h2><p>&emsp;&emsp;由上文，我们可以知道，可以通过两次send和两次recv进行报文的收发，但是其中操作较为麻烦，需要多次声明DateHeader包头结构体，不仅消耗时间资源，也容易出错。<br>&emsp;&emsp;因此，我们可以尝试将分开收发改为一次收发。大致思路为完善报文的结构体，使<strong>包体继承包头结构体</strong>，或者使<strong>包体结构体中包含一个包头结构体</strong>。由此完善报文的结构体，只进行一次send操作，即可发送所有报文数据。<br>&emsp;&emsp;在进行数据接收时，我们先接收包头大小的数据，随后根据包头的内容，来确定接下来接收数据的大小，即接收 总数据大小 减去 包头数据大小 的数据。而在接下来使用recv接收剩下数据时，要使用指针偏移，跳过结构体包头的接收(因为接收过了)，直接接收到包体数据位置上。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">因为包头已经接收过了 所以进行指针偏移：&amp;_login+sizeof(DateHeader)</span></span><br><span class="line"><span class="comment">接收数据长短为：sizeof(Login)-sizeof(DateHeader) 减去包头的大小</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_login+<span class="built_in">sizeof</span>(DateHeader),<span class="built_in">sizeof</span>(Login)-<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br></pre></td></tr></table></figure>


<h2 id="2-代码及其详细注释-1"><a href="#2-代码及其详细注释-1" class="headerlink" title="2.代码及其详细注释"></a>2.代码及其详细注释</h2><h3 id="2-1-服务端代码-1"><a href="#2-1-服务端代码-1" class="headerlink" title="2.1 服务端代码"></a>2.1 服务端代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;winSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//链接此动态链接库 windows特有 </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//枚举类型记录命令 </span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">cmd</span> </span><br><span class="line">&#123;</span><br><span class="line">	CMD_LOGIN,<span class="comment">//登录 </span></span><br><span class="line">	CMD_LOGINRESULT,<span class="comment">//登录结果 </span></span><br><span class="line">	CMD_LOGOUT,<span class="comment">//登出 </span></span><br><span class="line">	CMD_LOGOUTRESULT,<span class="comment">//登出结果 </span></span><br><span class="line">	CMD_ERROR<span class="comment">//错误 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义数据包头 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DateHeader</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">short</span> cmd;<span class="comment">//命令</span></span><br><span class="line">	<span class="type">short</span> date_length;<span class="comment">//数据的长短	</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包1 登录 传输账号与密码</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Login</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Login</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGIN;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Login); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">	<span class="type">char</span> PassWord[<span class="number">32</span>];<span class="comment">//密码 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包2 登录结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoginResult</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LoginResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGINRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LoginResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包3 登出 传输用户名 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Logout</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Logout</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Logout); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包4 登出结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LogoutResult</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LogoutResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUTRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LogoutResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//启动windows socket 2,x环境 windows特有 </span></span><br><span class="line">	WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>);<span class="comment">//WinSock库版本号 </span></span><br><span class="line">	WSADATA dat;<span class="comment">//网络结构体 储存WSAStartup函数调用后返回的Socket数据 </span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span> != <span class="built_in">WSAStartup</span>(ver,&amp;dat))<span class="comment">//正确初始化后返回0 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//建立一个socket </span></span><br><span class="line">	SOCKET _mysocket = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,IPPROTO_TCP);<span class="comment">//IPV4 数据流类型 TCP类型 </span></span><br><span class="line">	<span class="keyword">if</span>(INVALID_SOCKET == _mysocket)<span class="comment">//建立失败 </span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">	<span class="comment">//绑定网络端口和IP地址 </span></span><br><span class="line">	sockaddr_in _myaddr = &#123;&#125;;<span class="comment">//建立sockaddr结构体  sockaddr_in结构体方便填写 但是下面要进行类型转换 </span></span><br><span class="line">	_myaddr.sin_family = AF_INET;<span class="comment">//IPV4</span></span><br><span class="line">	_myaddr.sin_port = <span class="built_in">htons</span>(<span class="number">8888</span>);<span class="comment">//端口 host to net unsigned short</span></span><br><span class="line">	_myaddr.sin_addr.S_un.S_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);<span class="comment">//网络地址 INADDR_ANY监听所有网卡的端口 </span></span><br><span class="line">	<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">bind</span>(_mysocket,(sockaddr*)&amp;_myaddr,<span class="built_in">sizeof</span>(sockaddr_in)))<span class="comment">//socket (强制转换)sockaddr结构体 结构体大小 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;绑定不成功&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;&quot;绑定成功&quot;&lt;&lt;endl; </span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//监听网络端口</span></span><br><span class="line">	<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">listen</span>(_mysocket,<span class="number">5</span>))<span class="comment">//套接字 最大多少人连接 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;监听失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;&quot;监听成功&quot;&lt;&lt;endl; </span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//等待接收客户端连接</span></span><br><span class="line">	sockaddr_in _clientAddr = &#123;&#125;;<span class="comment">//新建sockadd结构体接收客户端数据 </span></span><br><span class="line">	<span class="type">int</span> _addr_len = <span class="built_in">sizeof</span>(sockaddr_in);<span class="comment">//获取sockadd结构体长度 </span></span><br><span class="line">	SOCKET _temp_socket = INVALID_SOCKET;<span class="comment">//声明客户端套接字 </span></span><br><span class="line">	</span><br><span class="line">	_temp_socket = <span class="built_in">accept</span>(_mysocket,(sockaddr*)&amp;_clientAddr,&amp;_addr_len);<span class="comment">//自身套接字 客户端结构体 结构体大小 </span></span><br><span class="line">	<span class="keyword">if</span>(INVALID_SOCKET == _temp_socket)<span class="comment">//接收失败 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;接收到无效客户端Socket&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;新客户端加入&quot;</span>&lt;&lt;endl; </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;IP地址为：%s \n&quot;</span>, <span class="built_in">inet_ntoa</span>(_clientAddr.sin_addr));  </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//接收客户端发送的数据 </span></span><br><span class="line">		DateHeader _head = &#123;&#125;; </span><br><span class="line">		<span class="type">int</span> _buf_len = <span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_head,<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(_buf_len&lt;=<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;客户端已退出\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;接收到包头，命令：%d，数据长度：%d\n&quot;</span>,_head.cmd,_head.date_length);</span><br><span class="line">		<span class="keyword">switch</span>(_head.cmd)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> CMD_LOGIN:<span class="comment">//登录 接收登录包体 </span></span><br><span class="line">			&#123;</span><br><span class="line">				Login _login;</span><br><span class="line">				<span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_login+<span class="built_in">sizeof</span>(DateHeader),<span class="built_in">sizeof</span>(Login)-<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				进行判断操作 </span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%s已登录\n密码：%s\n&quot;</span>,_login.UserName,_login.PassWord); </span><br><span class="line">				LoginResult _result;</span><br><span class="line">				_result.Result = <span class="number">1</span>;</span><br><span class="line">				<span class="built_in">send</span>(_temp_socket,(<span class="type">char</span>*)&amp;_result,<span class="built_in">sizeof</span>(LoginResult),<span class="number">0</span>);<span class="comment">//发包体 </span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> CMD_LOGOUT:<span class="comment">//登出 接收登出包体 </span></span><br><span class="line">			&#123;</span><br><span class="line">				Logout _logout;</span><br><span class="line">				<span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_logout+<span class="built_in">sizeof</span>(DateHeader),<span class="built_in">sizeof</span>(Logout)-<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				进行判断操作 </span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%s已登出\n&quot;</span>,_logout.UserName); </span><br><span class="line">				LogoutResult _result;</span><br><span class="line">				_result.Result = <span class="number">1</span>;</span><br><span class="line">				<span class="built_in">send</span>(_temp_socket,(<span class="type">char</span>*)&amp;_result,<span class="built_in">sizeof</span>(LogoutResult),<span class="number">0</span>);<span class="comment">//发包体</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:<span class="comment">//错误 </span></span><br><span class="line">			&#123;</span><br><span class="line">				_head.cmd = CMD_ERROR; </span><br><span class="line">				_head.date_length = <span class="number">0</span>; </span><br><span class="line">				<span class="built_in">send</span>(_temp_socket,(<span class="type">char</span>*)&amp;_head,<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);<span class="comment">//发包头 </span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭客户端socket</span></span><br><span class="line">	<span class="built_in">closesocket</span>(_temp_socket);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭socket </span></span><br><span class="line">	<span class="built_in">closesocket</span>(_mysocket); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//清除windows socket 环境 </span></span><br><span class="line">	<span class="built_in">WSACleanup</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;任务结束，程序已退出&quot;</span>); </span><br><span class="line">	 </span><br><span class="line">	<span class="built_in">getchar</span>(); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-2-客户端代码-1"><a href="#2-2-客户端代码-1" class="headerlink" title="2.2 客户端代码"></a>2.2 客户端代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;winSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//链接此动态链接库 windows特有 </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//枚举类型记录命令 </span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">cmd</span> </span><br><span class="line">&#123;</span><br><span class="line">	CMD_LOGIN,<span class="comment">//登录 </span></span><br><span class="line">	CMD_LOGINRESULT,<span class="comment">//登录结果 </span></span><br><span class="line">	CMD_LOGOUT,<span class="comment">//登出 </span></span><br><span class="line">	CMD_LOGOUTRESULT,<span class="comment">//登出结果 </span></span><br><span class="line">	CMD_ERROR<span class="comment">//错误 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义数据包头 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DateHeader</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">short</span> cmd;<span class="comment">//命令</span></span><br><span class="line">	<span class="type">short</span> date_length;<span class="comment">//数据的长短	</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包1 登录 传输账号与密码</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Login</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Login</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGIN;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Login); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">	<span class="type">char</span> PassWord[<span class="number">32</span>];<span class="comment">//密码 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包2 登录结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoginResult</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LoginResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGINRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LoginResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包3 登出 传输用户名 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Logout</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Logout</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Logout); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包4 登出结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LogoutResult</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LogoutResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUTRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LogoutResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//启动windows socket 2,x环境 windows特有 </span></span><br><span class="line">	WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>);<span class="comment">//WinSock库版本号 </span></span><br><span class="line">	WSADATA dat;<span class="comment">//网络结构体 储存WSAStartup函数调用后返回的Socket数据 </span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span> != <span class="built_in">WSAStartup</span>(ver,&amp;dat))<span class="comment">//正确初始化后返回0 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//建立一个socket </span></span><br><span class="line">	SOCKET _mysocket = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);<span class="comment">//IPV4 数据流类型 类型可以不用写 </span></span><br><span class="line">	<span class="keyword">if</span>(INVALID_SOCKET == _mysocket)<span class="comment">//建立失败 </span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//连接服务器</span></span><br><span class="line">    sockaddr_in _sin = &#123;&#125;;<span class="comment">//sockaddr结构体 </span></span><br><span class="line">    _sin.sin_family = AF_INET;<span class="comment">//IPV4</span></span><br><span class="line">    _sin.sin_port = <span class="built_in">htons</span>(<span class="number">8888</span>);<span class="comment">//想要连接的端口号 </span></span><br><span class="line">	_sin.sin_addr.S_un.S_addr =  <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);<span class="comment">//想要连接的IP </span></span><br><span class="line">	<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">connect</span>(_mysocket,(sockaddr*)&amp;_sin,<span class="built_in">sizeof</span>(sockaddr_in)))</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;连接失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">		<span class="built_in">closesocket</span>(_mysocket);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;连接成功&quot;</span>&lt;&lt;endl; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//输入请求 </span></span><br><span class="line">		<span class="type">char</span> _msg[<span class="number">256</span>] = &#123;&#125;;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,_msg);</span><br><span class="line">		<span class="comment">//处理请求 </span></span><br><span class="line">		<span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(_msg,<span class="string">&quot;exit&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(_msg,<span class="string">&quot;login&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//发送 </span></span><br><span class="line">			Login _login;</span><br><span class="line">			<span class="built_in">strcpy</span>(_login.UserName,<span class="string">&quot;河边小咸鱼&quot;</span>);</span><br><span class="line">			<span class="built_in">strcpy</span>(_login.PassWord,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">			<span class="built_in">send</span>(_mysocket,(<span class="type">const</span> <span class="type">char</span>*)&amp;_login,<span class="built_in">sizeof</span>(_login),<span class="number">0</span>);</span><br><span class="line">			<span class="comment">//接收 </span></span><br><span class="line">			LoginResult _result; </span><br><span class="line">			<span class="built_in">recv</span>(_mysocket,(<span class="type">char</span>*)&amp;_result,<span class="built_in">sizeof</span>(LoginResult),<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;result:%d\n&quot;</span>,_result.Result);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(_msg,<span class="string">&quot;logout&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//发送 </span></span><br><span class="line">			Logout _logout;</span><br><span class="line">			<span class="built_in">strcpy</span>(_logout.UserName,<span class="string">&quot;河边小咸鱼&quot;</span>);</span><br><span class="line">			<span class="built_in">send</span>(_mysocket,(<span class="type">const</span> <span class="type">char</span>*)&amp;_logout,<span class="built_in">sizeof</span>(_logout),<span class="number">0</span>);</span><br><span class="line">			<span class="comment">//接收 </span></span><br><span class="line">			LogoutResult _result; </span><br><span class="line">			<span class="built_in">recv</span>(_mysocket,(<span class="type">char</span>*)&amp;_result,<span class="built_in">sizeof</span>(LogoutResult),<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;result:%d\n&quot;</span>,_result.Result);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;不存在的命令\n&quot;</span>);</span><br><span class="line">		&#125; 	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭socket</span></span><br><span class="line">	<span class="built_in">closesocket</span>(_mysocket); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//清除windows socket 环境 </span></span><br><span class="line">	<span class="built_in">WSACleanup</span>(); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>


<h1 id="网络编程学习记录"><a href="#网络编程学习记录" class="headerlink" title="网络编程学习记录"></a>网络编程学习记录</h1><ul>
<li>使用的语言为C&#x2F;C++</li>
<li>源码支持的平台为：Windows</li>
</ul>
<p>笔记一：建立基础TCP服务端&#x2F;客户端 &emsp;<a href="https://blog.csdn.net/qq_45698148/article/details/112967657">点我跳转</a><br>笔记二：网络数据报文的收发 &emsp;<a href="https://blog.csdn.net/qq_45698148/article/details/112981662">点我跳转</a><br>笔记三：升级为select网络模型 &emsp;<a href="&emsp;https://blog.csdn.net/qq_45698148/article/details/113061122">点我跳转</a><br>笔记四：跨平台支持Windows、Linux系统 &emsp;<a href="https://blog.csdn.net/qq_45698148/article/details/113095420">点我跳转</a><br>笔记五：源码的封装 &emsp;<a href="https://blog.csdn.net/qq_45698148/article/details/113191673">点我跳转</a><br>笔记六：缓冲区溢出与粘包分包 &emsp;<a href="https://blog.csdn.net/qq_45698148/article/details/113307959">点我跳转</a><br>笔记七：服务端多线程分离业务处理高负载 &emsp;<a href="https://blog.csdn.net/qq_45698148/article/details/113704768">点我跳转</a><br>笔记八：对socket select网络模型的优化 &emsp;<a href="https://blog.csdn.net/qq_45698148/article/details/113895569">点我跳转</a><br>笔记九：消息接收与发送分离 &emsp;<a href="https://blog.csdn.net/qq_45698148/article/details/113899184">点我跳转</a><br>笔记十：项目化 (加入内存池静态库 &#x2F; 报文动态库) &emsp;<a href="https://blog.csdn.net/qq_45698148/article/details/116137196">更多笔记请点我</a></p>
<p>@<a href="%E7%AC%94%E8%AE%B0%E4%BA%8C">TOC</a></p>
<h1 id="一、网络数据报文的格式定义-1"><a href="#一、网络数据报文的格式定义-1" class="headerlink" title="一、网络数据报文的格式定义"></a>一、网络数据报文的格式定义</h1><ul>
<li>报文有两个部分，<strong>包头</strong>和<strong>包体</strong>，是网络消息的基本单元。</li>
<li><strong>包头：</strong> 描述本次消息包的大小，描述包体数据的作用。</li>
<li><strong>包体：</strong> 其中包含了需要传输的数据。</li>
</ul>
<p>&emsp;&emsp;根据此数据结构，我们可以根据包头的内容，来灵活的对包体的数据进行处理。</p>
<h1 id="二、将包头与包体数据分开收发-1"><a href="#二、将包头与包体数据分开收发-1" class="headerlink" title="二、将包头与包体数据分开收发"></a>二、将包头与包体数据分开收发</h1><h2 id="1-概括-1"><a href="#1-概括-1" class="headerlink" title="1.概括"></a>1.概括</h2><p>&emsp;&emsp;通过上文对网络数据报文的定义，我们可以很轻易的想到：</p>
<ol>
<li>发送端进行两次<strong>send</strong>操作，第一次<strong>send</strong>发送包头，第二次<strong>send</strong>发送包体，即可实现网络数据报文的发送。</li>
<li>接收端进行两次<strong>recv</strong>操作，第一次<strong>recv</strong>接收包头，第二次<strong>recv</strong>接收包体并根据包头的内容进行数据处理，即可实现网络数据报文的接收。</li>
</ol>
<p>&emsp;&emsp;按以上操作，即可实现网络数据报文的收发。</p>
<h2 id="2-代码及其详细注释-2"><a href="#2-代码及其详细注释-2" class="headerlink" title="2.代码及其详细注释"></a>2.代码及其详细注释</h2><h3 id="2-1-服务端代码-2"><a href="#2-1-服务端代码-2" class="headerlink" title="2.1 服务端代码"></a>2.1 服务端代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;winSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//链接此动态链接库 windows特有 </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//枚举类型记录命令 </span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">cmd</span> </span><br><span class="line">&#123;</span><br><span class="line">	CMD_LOGIN,<span class="comment">//登录 </span></span><br><span class="line">	CMD_LOGOUT,<span class="comment">//登出 </span></span><br><span class="line">	CMD_ERROR<span class="comment">//错误 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义数据包头 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DateHeader</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">short</span> cmd;<span class="comment">//命令</span></span><br><span class="line">	<span class="type">short</span> date_length;<span class="comment">//数据的长短	</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包体1 登录 传输账号与密码</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Login</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">	<span class="type">char</span> PassWord[<span class="number">32</span>];<span class="comment">//密码 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包体2 登录结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoginResult</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包体3 登出 传输用户名 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Logout</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包体4 登出结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LogoutResult</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//启动windows socket 2,x环境 windows特有 </span></span><br><span class="line">	WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>);<span class="comment">//WinSock库版本号 </span></span><br><span class="line">	WSADATA dat;<span class="comment">//网络结构体 储存WSAStartup函数调用后返回的Socket数据 </span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span> != <span class="built_in">WSAStartup</span>(ver,&amp;dat))<span class="comment">//正确初始化后返回0 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//建立一个socket </span></span><br><span class="line">	SOCKET _mysocket = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,IPPROTO_TCP);<span class="comment">//IPV4 数据流类型 TCP类型 </span></span><br><span class="line">	<span class="keyword">if</span>(INVALID_SOCKET == _mysocket)<span class="comment">//建立失败 </span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">	<span class="comment">//绑定网络端口和IP地址 </span></span><br><span class="line">	sockaddr_in _myaddr = &#123;&#125;;<span class="comment">//建立sockaddr结构体  sockaddr_in结构体方便填写 但是下面要进行类型转换 </span></span><br><span class="line">	_myaddr.sin_family = AF_INET;<span class="comment">//IPV4</span></span><br><span class="line">	_myaddr.sin_port = <span class="built_in">htons</span>(<span class="number">8888</span>);<span class="comment">//端口 host to net unsigned short</span></span><br><span class="line">	_myaddr.sin_addr.S_un.S_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);<span class="comment">//网络地址 INADDR_ANY监听所有网卡的端口 </span></span><br><span class="line">	<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">bind</span>(_mysocket,(sockaddr*)&amp;_myaddr,<span class="built_in">sizeof</span>(sockaddr_in)))<span class="comment">//socket (强制转换)sockaddr结构体 结构体大小 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;绑定不成功&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;&quot;绑定成功&quot;&lt;&lt;endl; </span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//监听网络端口</span></span><br><span class="line">	<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">listen</span>(_mysocket,<span class="number">5</span>))<span class="comment">//套接字 最大多少人连接 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;监听失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;&quot;监听成功&quot;&lt;&lt;endl; </span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//等待接收客户端连接</span></span><br><span class="line">	sockaddr_in _clientAddr = &#123;&#125;;<span class="comment">//新建sockadd结构体接收客户端数据 </span></span><br><span class="line">	<span class="type">int</span> _addr_len = <span class="built_in">sizeof</span>(sockaddr_in);<span class="comment">//获取sockadd结构体长度 </span></span><br><span class="line">	SOCKET _temp_socket = INVALID_SOCKET;<span class="comment">//声明客户端套接字 </span></span><br><span class="line">	</span><br><span class="line">	_temp_socket = <span class="built_in">accept</span>(_mysocket,(sockaddr*)&amp;_clientAddr,&amp;_addr_len);<span class="comment">//自身套接字 客户端结构体 结构体大小 </span></span><br><span class="line">	<span class="keyword">if</span>(INVALID_SOCKET == _temp_socket)<span class="comment">//接收失败 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;接收到无效客户端Socket&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;新客户端加入&quot;</span>&lt;&lt;endl; </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;IP地址为：%s \n&quot;</span>, <span class="built_in">inet_ntoa</span>(_clientAddr.sin_addr));  </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//接收客户端发送的数据 </span></span><br><span class="line">		DateHeader _head = &#123;&#125;; </span><br><span class="line">		<span class="type">int</span> _buf_len = <span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_head,<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(_buf_len&lt;=<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;客户端已退出\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;接收到包头，命令：%d，数据长度：%d\n&quot;</span>,_head.cmd,_head.date_length);</span><br><span class="line">		<span class="keyword">switch</span>(_head.cmd)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> CMD_LOGIN:<span class="comment">//登录 接收登录包体 </span></span><br><span class="line">			&#123;</span><br><span class="line">				Login _login = &#123;&#125;;</span><br><span class="line">				<span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_login,<span class="built_in">sizeof</span>(Login),<span class="number">0</span>);</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				进行判断操作 </span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%s已登录\n&quot;</span>,_login.UserName); </span><br><span class="line">				<span class="built_in">send</span>(_temp_socket,(<span class="type">char</span>*)&amp;_head,<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);<span class="comment">//发包头 </span></span><br><span class="line">				LoginResult _result = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">				<span class="built_in">send</span>(_temp_socket,(<span class="type">char</span>*)&amp;_result,<span class="built_in">sizeof</span>(LoginResult),<span class="number">0</span>);<span class="comment">//发包体 </span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> CMD_LOGOUT:<span class="comment">//登出 接收登出包体 </span></span><br><span class="line">			&#123;</span><br><span class="line">				Logout _logout = &#123;&#125;;</span><br><span class="line">				<span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_logout,<span class="built_in">sizeof</span>(Logout),<span class="number">0</span>);</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				进行判断操作 </span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%s已登出\n&quot;</span>,_logout.UserName); </span><br><span class="line">				<span class="built_in">send</span>(_temp_socket,(<span class="type">char</span>*)&amp;_head,<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);<span class="comment">//发包头 </span></span><br><span class="line">				LogoutResult _result = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">				<span class="built_in">send</span>(_temp_socket,(<span class="type">char</span>*)&amp;_result,<span class="built_in">sizeof</span>(LogoutResult),<span class="number">0</span>);<span class="comment">//发包体</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:<span class="comment">//错误 </span></span><br><span class="line">			&#123;</span><br><span class="line">				_head.cmd = CMD_ERROR; </span><br><span class="line">				_head.date_length = <span class="number">0</span>; </span><br><span class="line">				<span class="built_in">send</span>(_temp_socket,(<span class="type">char</span>*)&amp;_head,<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);<span class="comment">//发包头 </span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭客户端socket</span></span><br><span class="line">	<span class="built_in">closesocket</span>(_temp_socket);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭socket </span></span><br><span class="line">	<span class="built_in">closesocket</span>(_mysocket); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//清除windows socket 环境 </span></span><br><span class="line">	<span class="built_in">WSACleanup</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;任务结束，程序已退出&quot;</span>); </span><br><span class="line">	 </span><br><span class="line">	<span class="built_in">getchar</span>(); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="2-2-客户端代码-2"><a href="#2-2-客户端代码-2" class="headerlink" title="2.2 客户端代码"></a>2.2 客户端代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;winSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//链接此动态链接库 windows特有 </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//枚举类型记录命令 </span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">cmd</span> </span><br><span class="line">&#123;</span><br><span class="line">	CMD_LOGIN,<span class="comment">//登录 </span></span><br><span class="line">	CMD_LOGOUT,<span class="comment">//登出 </span></span><br><span class="line">	CMD_ERROR<span class="comment">//错误 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义数据包头 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DateHeader</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">short</span> cmd;<span class="comment">//命令</span></span><br><span class="line">	<span class="type">short</span> date_length;<span class="comment">//数据的长短	</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包体1 登录 传输账号与密码</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Login</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">	<span class="type">char</span> PassWord[<span class="number">32</span>];<span class="comment">//密码 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包体2 登录结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoginResult</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包体3 登出 传输用户名 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Logout</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包体4 登出结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LogoutResult</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//启动windows socket 2,x环境 windows特有 </span></span><br><span class="line">	WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>);<span class="comment">//WinSock库版本号 </span></span><br><span class="line">	WSADATA dat;<span class="comment">//网络结构体 储存WSAStartup函数调用后返回的Socket数据 </span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span> != <span class="built_in">WSAStartup</span>(ver,&amp;dat))<span class="comment">//正确初始化后返回0 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//建立一个socket </span></span><br><span class="line">	SOCKET _mysocket = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);<span class="comment">//IPV4 数据流类型 类型可以不用写 </span></span><br><span class="line">	<span class="keyword">if</span>(INVALID_SOCKET == _mysocket)<span class="comment">//建立失败 </span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//连接服务器</span></span><br><span class="line">    sockaddr_in _sin = &#123;&#125;;<span class="comment">//sockaddr结构体 </span></span><br><span class="line">    _sin.sin_family = AF_INET;<span class="comment">//IPV4</span></span><br><span class="line">    _sin.sin_port = <span class="built_in">htons</span>(<span class="number">8888</span>);<span class="comment">//想要连接的端口号 </span></span><br><span class="line">	_sin.sin_addr.S_un.S_addr =  <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);<span class="comment">//想要连接的IP </span></span><br><span class="line">	<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">connect</span>(_mysocket,(sockaddr*)&amp;_sin,<span class="built_in">sizeof</span>(sockaddr_in)))</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;连接失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">		<span class="built_in">closesocket</span>(_mysocket);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;连接成功&quot;</span>&lt;&lt;endl; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//输入请求 </span></span><br><span class="line">		<span class="type">char</span> _msg[<span class="number">256</span>] = &#123;&#125;;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,_msg);</span><br><span class="line">		<span class="comment">//处理请求 </span></span><br><span class="line">		<span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(_msg,<span class="string">&quot;exit&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(_msg,<span class="string">&quot;login&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//发送 </span></span><br><span class="line">			Login _login = &#123;<span class="string">&quot;河边小咸鱼&quot;</span>,<span class="string">&quot;123456&quot;</span>&#125;;</span><br><span class="line">			DateHeader _head = &#123;CMD_LOGIN,<span class="built_in">sizeof</span>(_login)&#125;;</span><br><span class="line">			<span class="built_in">send</span>(_mysocket,(<span class="type">const</span> <span class="type">char</span>*)&amp;_head,<span class="built_in">sizeof</span>(_head),<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">send</span>(_mysocket,(<span class="type">const</span> <span class="type">char</span>*)&amp;_login,<span class="built_in">sizeof</span>(_login),<span class="number">0</span>);</span><br><span class="line">			<span class="comment">//接收 </span></span><br><span class="line">			DateHeader _head2 = &#123;&#125;; </span><br><span class="line">			LoginResult _result= &#123;&#125;; </span><br><span class="line">			<span class="built_in">recv</span>(_mysocket,(<span class="type">char</span>*)&amp;_head2,<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">recv</span>(_mysocket,(<span class="type">char</span>*)&amp;_result,<span class="built_in">sizeof</span>(LoginResult),<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;result:%d\n&quot;</span>,_result.Result);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(_msg,<span class="string">&quot;logout&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//发送 </span></span><br><span class="line">			Logout _logout = &#123;<span class="string">&quot;河边小咸鱼&quot;</span>&#125;;</span><br><span class="line">			DateHeader _head = &#123;CMD_LOGOUT,<span class="built_in">sizeof</span>(_logout)&#125;;</span><br><span class="line">			<span class="built_in">send</span>(_mysocket,(<span class="type">const</span> <span class="type">char</span>*)&amp;_head,<span class="built_in">sizeof</span>(_head),<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">send</span>(_mysocket,(<span class="type">const</span> <span class="type">char</span>*)&amp;_logout,<span class="built_in">sizeof</span>(_logout),<span class="number">0</span>);</span><br><span class="line">			<span class="comment">//接收 </span></span><br><span class="line">			DateHeader _head2 = &#123;&#125;; </span><br><span class="line">			LogoutResult _result= &#123;&#125;; </span><br><span class="line">			<span class="built_in">recv</span>(_mysocket,(<span class="type">char</span>*)&amp;_head2,<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">recv</span>(_mysocket,(<span class="type">char</span>*)&amp;_result,<span class="built_in">sizeof</span>(LogoutResult),<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;result:%d\n&quot;</span>,_result.Result);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;不存在的命令\n&quot;</span>);</span><br><span class="line">		&#125; 	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭socket</span></span><br><span class="line">	<span class="built_in">closesocket</span>(_mysocket); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//清除windows socket 环境 </span></span><br><span class="line">	<span class="built_in">WSACleanup</span>(); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>


<h1 id="三、将分开收发报文数据改为一次收发-1"><a href="#三、将分开收发报文数据改为一次收发-1" class="headerlink" title="三、将分开收发报文数据改为一次收发"></a>三、将分开收发报文数据改为一次收发</h1><h2 id="1-思路-1"><a href="#1-思路-1" class="headerlink" title="1.思路"></a>1.思路</h2><p>&emsp;&emsp;由上文，我们可以知道，可以通过两次send和两次recv进行报文的收发，但是其中操作较为麻烦，需要多次声明DateHeader包头结构体，不仅消耗时间资源，也容易出错。<br>&emsp;&emsp;因此，我们可以尝试将分开收发改为一次收发。大致思路为完善报文的结构体，使<strong>包体继承包头结构体</strong>，或者使<strong>包体结构体中包含一个包头结构体</strong>。由此完善报文的结构体，只进行一次send操作，即可发送所有报文数据。<br>&emsp;&emsp;在进行数据接收时，我们先接收包头大小的数据，随后根据包头的内容，来确定接下来接收数据的大小，即接收 总数据大小 减去 包头数据大小 的数据。而在接下来使用recv接收剩下数据时，要使用指针偏移，跳过结构体包头的接收(因为接收过了)，直接接收到包体数据位置上。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">因为包头已经接收过了 所以进行指针偏移：&amp;_login+sizeof(DateHeader)</span></span><br><span class="line"><span class="comment">接收数据长短为：sizeof(Login)-sizeof(DateHeader) 减去包头的大小</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_login+<span class="built_in">sizeof</span>(DateHeader),<span class="built_in">sizeof</span>(Login)-<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br></pre></td></tr></table></figure>


<h2 id="2-代码及其详细注释-3"><a href="#2-代码及其详细注释-3" class="headerlink" title="2.代码及其详细注释"></a>2.代码及其详细注释</h2><h3 id="2-1-服务端代码-3"><a href="#2-1-服务端代码-3" class="headerlink" title="2.1 服务端代码"></a>2.1 服务端代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;winSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//链接此动态链接库 windows特有 </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//枚举类型记录命令 </span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">cmd</span> </span><br><span class="line">&#123;</span><br><span class="line">	CMD_LOGIN,<span class="comment">//登录 </span></span><br><span class="line">	CMD_LOGINRESULT,<span class="comment">//登录结果 </span></span><br><span class="line">	CMD_LOGOUT,<span class="comment">//登出 </span></span><br><span class="line">	CMD_LOGOUTRESULT,<span class="comment">//登出结果 </span></span><br><span class="line">	CMD_ERROR<span class="comment">//错误 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义数据包头 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DateHeader</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">short</span> cmd;<span class="comment">//命令</span></span><br><span class="line">	<span class="type">short</span> date_length;<span class="comment">//数据的长短	</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包1 登录 传输账号与密码</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Login</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Login</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGIN;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Login); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">	<span class="type">char</span> PassWord[<span class="number">32</span>];<span class="comment">//密码 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包2 登录结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoginResult</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LoginResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGINRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LoginResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包3 登出 传输用户名 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Logout</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Logout</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Logout); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包4 登出结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LogoutResult</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LogoutResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUTRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LogoutResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//启动windows socket 2,x环境 windows特有 </span></span><br><span class="line">	WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>);<span class="comment">//WinSock库版本号 </span></span><br><span class="line">	WSADATA dat;<span class="comment">//网络结构体 储存WSAStartup函数调用后返回的Socket数据 </span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span> != <span class="built_in">WSAStartup</span>(ver,&amp;dat))<span class="comment">//正确初始化后返回0 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//建立一个socket </span></span><br><span class="line">	SOCKET _mysocket = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,IPPROTO_TCP);<span class="comment">//IPV4 数据流类型 TCP类型 </span></span><br><span class="line">	<span class="keyword">if</span>(INVALID_SOCKET == _mysocket)<span class="comment">//建立失败 </span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">	<span class="comment">//绑定网络端口和IP地址 </span></span><br><span class="line">	sockaddr_in _myaddr = &#123;&#125;;<span class="comment">//建立sockaddr结构体  sockaddr_in结构体方便填写 但是下面要进行类型转换 </span></span><br><span class="line">	_myaddr.sin_family = AF_INET;<span class="comment">//IPV4</span></span><br><span class="line">	_myaddr.sin_port = <span class="built_in">htons</span>(<span class="number">8888</span>);<span class="comment">//端口 host to net unsigned short</span></span><br><span class="line">	_myaddr.sin_addr.S_un.S_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);<span class="comment">//网络地址 INADDR_ANY监听所有网卡的端口 </span></span><br><span class="line">	<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">bind</span>(_mysocket,(sockaddr*)&amp;_myaddr,<span class="built_in">sizeof</span>(sockaddr_in)))<span class="comment">//socket (强制转换)sockaddr结构体 结构体大小 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;绑定不成功&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;&quot;绑定成功&quot;&lt;&lt;endl; </span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//监听网络端口</span></span><br><span class="line">	<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">listen</span>(_mysocket,<span class="number">5</span>))<span class="comment">//套接字 最大多少人连接 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;监听失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;&quot;监听成功&quot;&lt;&lt;endl; </span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//等待接收客户端连接</span></span><br><span class="line">	sockaddr_in _clientAddr = &#123;&#125;;<span class="comment">//新建sockadd结构体接收客户端数据 </span></span><br><span class="line">	<span class="type">int</span> _addr_len = <span class="built_in">sizeof</span>(sockaddr_in);<span class="comment">//获取sockadd结构体长度 </span></span><br><span class="line">	SOCKET _temp_socket = INVALID_SOCKET;<span class="comment">//声明客户端套接字 </span></span><br><span class="line">	</span><br><span class="line">	_temp_socket = <span class="built_in">accept</span>(_mysocket,(sockaddr*)&amp;_clientAddr,&amp;_addr_len);<span class="comment">//自身套接字 客户端结构体 结构体大小 </span></span><br><span class="line">	<span class="keyword">if</span>(INVALID_SOCKET == _temp_socket)<span class="comment">//接收失败 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;接收到无效客户端Socket&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;新客户端加入&quot;</span>&lt;&lt;endl; </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;IP地址为：%s \n&quot;</span>, <span class="built_in">inet_ntoa</span>(_clientAddr.sin_addr));  </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//接收客户端发送的数据 </span></span><br><span class="line">		DateHeader _head = &#123;&#125;; </span><br><span class="line">		<span class="type">int</span> _buf_len = <span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_head,<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(_buf_len&lt;=<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;客户端已退出\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;接收到包头，命令：%d，数据长度：%d\n&quot;</span>,_head.cmd,_head.date_length);</span><br><span class="line">		<span class="keyword">switch</span>(_head.cmd)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> CMD_LOGIN:<span class="comment">//登录 接收登录包体 </span></span><br><span class="line">			&#123;</span><br><span class="line">				Login _login;</span><br><span class="line">				<span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_login+<span class="built_in">sizeof</span>(DateHeader),<span class="built_in">sizeof</span>(Login)-<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				进行判断操作 </span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%s已登录\n密码：%s\n&quot;</span>,_login.UserName,_login.PassWord); </span><br><span class="line">				LoginResult _result;</span><br><span class="line">				_result.Result = <span class="number">1</span>;</span><br><span class="line">				<span class="built_in">send</span>(_temp_socket,(<span class="type">char</span>*)&amp;_result,<span class="built_in">sizeof</span>(LoginResult),<span class="number">0</span>);<span class="comment">//发包体 </span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> CMD_LOGOUT:<span class="comment">//登出 接收登出包体 </span></span><br><span class="line">			&#123;</span><br><span class="line">				Logout _logout;</span><br><span class="line">				<span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_logout+<span class="built_in">sizeof</span>(DateHeader),<span class="built_in">sizeof</span>(Logout)-<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				进行判断操作 </span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%s已登出\n&quot;</span>,_logout.UserName); </span><br><span class="line">				LogoutResult _result;</span><br><span class="line">				_result.Result = <span class="number">1</span>;</span><br><span class="line">				<span class="built_in">send</span>(_temp_socket,(<span class="type">char</span>*)&amp;_result,<span class="built_in">sizeof</span>(LogoutResult),<span class="number">0</span>);<span class="comment">//发包体</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:<span class="comment">//错误 </span></span><br><span class="line">			&#123;</span><br><span class="line">				_head.cmd = CMD_ERROR; </span><br><span class="line">				_head.date_length = <span class="number">0</span>; </span><br><span class="line">				<span class="built_in">send</span>(_temp_socket,(<span class="type">char</span>*)&amp;_head,<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);<span class="comment">//发包头 </span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭客户端socket</span></span><br><span class="line">	<span class="built_in">closesocket</span>(_temp_socket);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭socket </span></span><br><span class="line">	<span class="built_in">closesocket</span>(_mysocket); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//清除windows socket 环境 </span></span><br><span class="line">	<span class="built_in">WSACleanup</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;任务结束，程序已退出&quot;</span>); </span><br><span class="line">	 </span><br><span class="line">	<span class="built_in">getchar</span>(); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-2-客户端代码-3"><a href="#2-2-客户端代码-3" class="headerlink" title="2.2 客户端代码"></a>2.2 客户端代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;winSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//链接此动态链接库 windows特有 </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//枚举类型记录命令 </span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">cmd</span> </span><br><span class="line">&#123;</span><br><span class="line">	CMD_LOGIN,<span class="comment">//登录 </span></span><br><span class="line">	CMD_LOGINRESULT,<span class="comment">//登录结果 </span></span><br><span class="line">	CMD_LOGOUT,<span class="comment">//登出 </span></span><br><span class="line">	CMD_LOGOUTRESULT,<span class="comment">//登出结果 </span></span><br><span class="line">	CMD_ERROR<span class="comment">//错误 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义数据包头 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DateHeader</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">short</span> cmd;<span class="comment">//命令</span></span><br><span class="line">	<span class="type">short</span> date_length;<span class="comment">//数据的长短	</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包1 登录 传输账号与密码</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Login</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Login</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGIN;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Login); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">	<span class="type">char</span> PassWord[<span class="number">32</span>];<span class="comment">//密码 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包2 登录结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoginResult</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LoginResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGINRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LoginResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包3 登出 传输用户名 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Logout</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Logout</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Logout); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包4 登出结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LogoutResult</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LogoutResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUTRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LogoutResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//启动windows socket 2,x环境 windows特有 </span></span><br><span class="line">	WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>);<span class="comment">//WinSock库版本号 </span></span><br><span class="line">	WSADATA dat;<span class="comment">//网络结构体 储存WSAStartup函数调用后返回的Socket数据 </span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span> != <span class="built_in">WSAStartup</span>(ver,&amp;dat))<span class="comment">//正确初始化后返回0 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//建立一个socket </span></span><br><span class="line">	SOCKET _mysocket = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);<span class="comment">//IPV4 数据流类型 类型可以不用写 </span></span><br><span class="line">	<span class="keyword">if</span>(INVALID_SOCKET == _mysocket)<span class="comment">//建立失败 </span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//连接服务器</span></span><br><span class="line">    sockaddr_in _sin = &#123;&#125;;<span class="comment">//sockaddr结构体 </span></span><br><span class="line">    _sin.sin_family = AF_INET;<span class="comment">//IPV4</span></span><br><span class="line">    _sin.sin_port = <span class="built_in">htons</span>(<span class="number">8888</span>);<span class="comment">//想要连接的端口号 </span></span><br><span class="line">	_sin.sin_addr.S_un.S_addr =  <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);<span class="comment">//想要连接的IP </span></span><br><span class="line">	<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">connect</span>(_mysocket,(sockaddr*)&amp;_sin,<span class="built_in">sizeof</span>(sockaddr_in)))</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;连接失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">		<span class="built_in">closesocket</span>(_mysocket);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;连接成功&quot;</span>&lt;&lt;endl; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//输入请求 </span></span><br><span class="line">		<span class="type">char</span> _msg[<span class="number">256</span>] = &#123;&#125;;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,_msg);</span><br><span class="line">		<span class="comment">//处理请求 </span></span><br><span class="line">		<span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(_msg,<span class="string">&quot;exit&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(_msg,<span class="string">&quot;login&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//发送 </span></span><br><span class="line">			Login _login;</span><br><span class="line">			<span class="built_in">strcpy</span>(_login.UserName,<span class="string">&quot;河边小咸鱼&quot;</span>);</span><br><span class="line">			<span class="built_in">strcpy</span>(_login.PassWord,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">			<span class="built_in">send</span>(_mysocket,(<span class="type">const</span> <span class="type">char</span>*)&amp;_login,<span class="built_in">sizeof</span>(_login),<span class="number">0</span>);</span><br><span class="line">			<span class="comment">//接收 </span></span><br><span class="line">			LoginResult _result; </span><br><span class="line">			<span class="built_in">recv</span>(_mysocket,(<span class="type">char</span>*)&amp;_result,<span class="built_in">sizeof</span>(LoginResult),<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;result:%d\n&quot;</span>,_result.Result);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(_msg,<span class="string">&quot;logout&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//发送 </span></span><br><span class="line">			Logout _logout;</span><br><span class="line">			<span class="built_in">strcpy</span>(_logout.UserName,<span class="string">&quot;河边小咸鱼&quot;</span>);</span><br><span class="line">			<span class="built_in">send</span>(_mysocket,(<span class="type">const</span> <span class="type">char</span>*)&amp;_logout,<span class="built_in">sizeof</span>(_logout),<span class="number">0</span>);</span><br><span class="line">			<span class="comment">//接收 </span></span><br><span class="line">			LogoutResult _result; </span><br><span class="line">			<span class="built_in">recv</span>(_mysocket,(<span class="type">char</span>*)&amp;_result,<span class="built_in">sizeof</span>(LogoutResult),<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;result:%d\n&quot;</span>,_result.Result);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;不存在的命令\n&quot;</span>);</span><br><span class="line">		&#125; 	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭socket</span></span><br><span class="line">	<span class="built_in">closesocket</span>(_mysocket); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//清除windows socket 环境 </span></span><br><span class="line">	<span class="built_in">WSACleanup</span>(); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++网络编程学习：升级为select网络模型</title>
    <url>/2021/01/23/20210123_C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%8D%87%E7%BA%A7%E4%B8%BAselect%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<ul>
<li>使用的语言为C&#x2F;C++</li>
<li>源码支持的平台为：Windows</li>
</ul>
<h1 id="一、为何要使用select网络模型？"><a href="#一、为何要使用select网络模型？" class="headerlink" title="一、为何要使用select网络模型？"></a>一、为何要使用select网络模型？</h1><p>&emsp;&emsp;通过前面的学习，已经实现了简单的网络报文收发。但是可以很明显的看出其中的缺点，那就是整个程序的运行是<strong>阻塞模式</strong>的。即服务端在与一个客户端进行socket连接时，只要连接不中断，那么就无法接收新的客户端的消息。而客户端在未输入命令时，是阻塞状态，也无法接收服务端发来的消息。<br>&emsp;&emsp;在之前碰到这个问题时，我的想法是通过多线程来解决程序运行中的阻塞问题，但是在最近的学习中，我了解到可以使用select网络模型来方便快捷的解决小型网络程序运行中的阻塞问题。<strong>（I&#x2F;O多路复用模型相关内容）</strong></p>
<span id="more"></span>

<h1 id="二、select系统及其相关"><a href="#二、select系统及其相关" class="headerlink" title="二、select系统及其相关"></a>二、select系统及其相关</h1><p>select函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">WINSOCK_API_LINKAGE <span class="type">int</span> WSAAPI <span class="title">select</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">int</span> nfds,<span class="comment">//是指待监听集合里的范围 即待监听数量最大值+1</span></span></span></span><br><span class="line"><span class="params"><span class="function">	fd_set *readfds,<span class="comment">//待监听的可读文件集合 </span></span></span></span><br><span class="line"><span class="params"><span class="function">	fd_set *writefds,<span class="comment">//待监听的可写文件集合  </span></span></span></span><br><span class="line"><span class="params"><span class="function">	fd_set *exceptfds,<span class="comment">//待监听的异常文件集合  </span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">const</span> PTIMEVAL timeout)</span></span>;<span class="comment">//超时设置 传入NULL为阻塞模式 传入timeval结构体为非阻塞模式</span></span><br><span class="line"></span><br><span class="line">返回值为满足条件的待监听socket数量和，如果出错返回<span class="number">-1</span>，如果超时返回<span class="number">0</span>。</span><br></pre></td></tr></table></figure>

<p>通过上面select函数的参数可以发现存在两个特殊的结构体 <strong>fd_set</strong> 和 <strong>timeval</strong>，其相关内容如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">fd_set</span><span class="comment">//可以存放多个socket </span></span><br><span class="line">&#123;</span><br><span class="line">	u_int	fd_count;<span class="comment">//记录放了多少个socket</span></span><br><span class="line">	SOCKET	fd_array[FD_SETSIZE];<span class="comment">//socket数组</span></span><br><span class="line">&#125; fd_set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timeval</span><span class="comment">//时间结构体 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">long</span> tv_sec;<span class="comment">//秒</span></span><br><span class="line">	<span class="type">long</span> tv_usec;<span class="comment">//毫秒</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来为select的相关函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>;<span class="comment">//将fd加入set集合</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *set)</span></span>;<span class="comment">//使set集合清零 不包含任何socket</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>;<span class="comment">//将fd从set集合中清除</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>;<span class="comment">//测试fd是否在集合中 0是不在 1是在</span></span><br></pre></td></tr></table></figure>

<h2 id="★-select相关使用总结与心得"><a href="#★-select相关使用总结与心得" class="headerlink" title="★ select相关使用总结与心得"></a>★ select相关使用总结与心得</h2><p>&emsp;&emsp;在一开始的select使用中，我以为向select函数中传入fd_set地址，select会把待处理事件的socket放在set集合中，但是发现并不是这样。<br>&emsp;&emsp;经过网络上资料的查询以及我个人的测试，可以发现，用户首先需要把一份socket数组传入到此set中，select函数的作用是移除该set中没有待处理事件的socket，则剩下的socket都存在待处理事件(未决I&#x2F;O操作)。这个过程可以说是一种“选择”的过程，select函数“选择”出需要操作的socket，这或许就是select(选择)的意思吧。<br>&emsp;&emsp;在接下来的源码中，对于需要存储所有已连接socket的服务端，我使用动态数组vector进行socket的储存。在进行select筛选前，先把vector中的socket导入到set中，随后set中筛选剩下的即为有待处理事件的socket。<br>&emsp;&emsp;如果服务端自己的socket提示有待处理事件，则说明有新的客户端尝试进行连接，此时进行accept操作即可。<br>&emsp;&emsp;对于客户端的多线程问题，需要注意使用detach()方法使主线程与新线程分类，否则可能会出现主线程先结束的情况，导致程序出错。<br>&emsp;&emsp;在线程中，我们可以引入一个bool变量，用来记录客户端是否仍在连接中，当输入exit命令退出客户端时，通过此bool变量使主线程停止，跳出循环。</p>
<h1 id="三、升级为select网络模型的思路"><a href="#三、升级为select网络模型的思路" class="headerlink" title="三、升级为select网络模型的思路"></a>三、升级为select网络模型的思路</h1><h2 id="1-服务端升级（select）"><a href="#1-服务端升级（select）" class="headerlink" title="1.服务端升级（select）"></a>1.服务端升级（select）</h2><p>在之前，我们的思路是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>建立socket</span><br><span class="line"><span class="number">2.</span>绑定端口IP</span><br><span class="line"><span class="number">3.</span>监听端口</span><br><span class="line"><span class="number">4.</span>与客户端连接</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="number">5.</span>接收数据</span><br><span class="line">	<span class="number">6.</span>发送数据</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">7.</span>关闭socket</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这就导致我们只能与一个客户端进行连接，随后便进入循环，只能接收这一个客户端的消息。且由于send与recv函数都是阻塞函数，所以程序也是阻塞模式的。</p>
<p>接下来，我们需要根据select网络模型，对服务端进行升级。<br>思路大致如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>建立socket</span><br><span class="line"><span class="number">2.</span>绑定端口IP</span><br><span class="line"><span class="number">3.</span>监听端口</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="number">4.</span>使用select函数获取存在待监听事件的socket</span><br><span class="line">	<span class="number">5.</span>如果有新的连接则与新的客户端连接</span><br><span class="line">	<span class="number">6.</span>如果有待监听事件，则对其进行处理(接受与发送)</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">7.</span>关闭socket</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;按如上思路，即可将程序升级为select网络模型。实现非阻塞模式，可以实现多客户端信息接收。对于select相关的细节与总结，请看上文中的总结。相关代码在下文。</p>
<h2 id="2-客户端升级（select-多线程）"><a href="#2-客户端升级（select-多线程）" class="headerlink" title="2.客户端升级（select+多线程）"></a>2.客户端升级（select+多线程）</h2><p>在之前，我们的思路是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>建立socket</span><br><span class="line"><span class="number">2.</span>连接服务器</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="number">3.</span>发送数据</span><br><span class="line">	<span class="number">4.</span>接收数据</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">5.</span>关闭socket</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这就导致我们在与一个服务端连接后，无法被动的接收服务器端发来的消息。因为send与recv函数都是阻塞函数，程序也为阻塞模式。如果我们想要客户端能接收服务端发来的消息，那么就可以使用select模型。</p>
<p>接下来，我们需要根据select网络模型，对客户端进行升级。<br>思路大致如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>建立socket</span><br><span class="line"><span class="number">2.</span>连接服务器</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="number">3.</span>使用select函数获取服务器端是否有待处理事件</span><br><span class="line">	<span class="number">4.</span>如果有，就处理它(接收/发送)</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">5.</span>关闭socket</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;按如上思路，即可将程序升级为select网络模型。实现非阻塞模式，可以实现服务器端数据的被动接收。</p>
<p>但是，这样的程序结构也有很明显的缺点，因为scanf等数据接收函数也为阻塞函数，如果我们想要主动输入一些命令发送给服务端，就会阻塞程序运行。对此，我们可以引入多线程解决问题。<br>思路大致如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>建立socket</span><br><span class="line"><span class="number">2.</span>连接服务器</span><br><span class="line"><span class="number">3.</span>建立新线程 用于发送命令</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="number">4.</span>使用select函数获取服务器端是否有待处理事件</span><br><span class="line">	<span class="number">5.</span>如果有，就处理它(接收/发送)</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">5.</span>关闭socket</span><br><span class="line"></span><br><span class="line">新线程：</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="number">1.</span>键入数据</span><br><span class="line">	<span class="number">2.</span>发送数据</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;按如上思路，即可将程序变得更加完善。可以被动接受数据且可以主动向服务端发送键入命令。对于select相关的细节与总结以及线程方面的注意事项，请看上文中的总结。相关代码在下文。</p>
<h1 id="四、代码及其详细注释"><a href="#四、代码及其详细注释" class="headerlink" title="四、代码及其详细注释"></a>四、代码及其详细注释</h1><h2 id="1-服务端代码"><a href="#1-服务端代码" class="headerlink" title="1.服务端代码"></a>1.服务端代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;winSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//链接此动态链接库 windows特有 </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//枚举类型记录命令 </span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">cmd</span> </span><br><span class="line">&#123;</span><br><span class="line">	CMD_LOGIN,<span class="comment">//登录 </span></span><br><span class="line">	CMD_LOGINRESULT,<span class="comment">//登录结果 </span></span><br><span class="line">	CMD_LOGOUT,<span class="comment">//登出 </span></span><br><span class="line">	CMD_LOGOUTRESULT,<span class="comment">//登出结果 </span></span><br><span class="line">	CMD_NEW_USER_JOIN,<span class="comment">//新用户登入 </span></span><br><span class="line">	CMD_ERROR<span class="comment">//错误 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义数据包头 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DateHeader</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">short</span> cmd;<span class="comment">//命令</span></span><br><span class="line">	<span class="type">short</span> date_length;<span class="comment">//数据的长短	</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包1 登录 传输账号与密码</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Login</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Login</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGIN;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Login); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">	<span class="type">char</span> PassWord[<span class="number">32</span>];<span class="comment">//密码 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包2 登录结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoginResult</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LoginResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGINRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LoginResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包3 登出 传输用户名 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Logout</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Logout</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Logout); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包4 登出结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LogoutResult</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LogoutResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUTRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LogoutResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包5 新用户登入 传输通告 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NewUserJoin</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">NewUserJoin</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_NEW_USER_JOIN;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(NewUserJoin); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">vector&lt;SOCKET&gt; _clients;<span class="comment">//储存客户端socket </span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> _handle(SOCKET _temp_socket)<span class="comment">//处理数据 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//接收客户端发送的数据 </span></span><br><span class="line">	DateHeader _head = &#123;&#125;; </span><br><span class="line">	<span class="type">int</span> _buf_len = <span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_head,<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(_buf_len&lt;=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;客户端已退出\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;接收到包头，命令：%d，数据长度：%d\n&quot;</span>,_head.cmd,_head.date_length);</span><br><span class="line">	<span class="keyword">switch</span>(_head.cmd)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> CMD_LOGIN:<span class="comment">//登录 接收登录包体 </span></span><br><span class="line">		&#123;</span><br><span class="line">			Login _login;</span><br><span class="line">			<span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_login+<span class="built_in">sizeof</span>(DateHeader),<span class="built_in">sizeof</span>(Login)-<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			进行判断操作 </span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s已登录\n密码：%s\n&quot;</span>,_login.UserName,_login.PassWord); </span><br><span class="line">			LoginResult _result;	</span><br><span class="line">			_result.Result = <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">send</span>(_temp_socket,(<span class="type">char</span>*)&amp;_result,<span class="built_in">sizeof</span>(LoginResult),<span class="number">0</span>);<span class="comment">//发包体 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> CMD_LOGOUT:<span class="comment">//登出 接收登出包体 </span></span><br><span class="line">		&#123;</span><br><span class="line">			Logout _logout;</span><br><span class="line">			<span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_logout+<span class="built_in">sizeof</span>(DateHeader),<span class="built_in">sizeof</span>(Logout)-<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			进行判断操作 </span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s已登出\n&quot;</span>,_logout.UserName); </span><br><span class="line">			LogoutResult _result;</span><br><span class="line">			_result.Result = <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">send</span>(_temp_socket,(<span class="type">char</span>*)&amp;_result,<span class="built_in">sizeof</span>(LogoutResult),<span class="number">0</span>);<span class="comment">//发包体</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:<span class="comment">//错误 </span></span><br><span class="line">		&#123;</span><br><span class="line">			_head.cmd = CMD_ERROR; </span><br><span class="line">			_head.date_length = <span class="number">0</span>; </span><br><span class="line">			<span class="built_in">send</span>(_temp_socket,(<span class="type">char</span>*)&amp;_head,<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);<span class="comment">//发包头 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//启动windows socket 2,x环境 windows特有 </span></span><br><span class="line">	WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>);<span class="comment">//WinSock库版本号 </span></span><br><span class="line">	WSADATA dat;<span class="comment">//网络结构体 储存WSAStartup函数调用后返回的Socket数据 </span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span> != <span class="built_in">WSAStartup</span>(ver,&amp;dat))<span class="comment">//正确初始化后返回0 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//建立一个socket </span></span><br><span class="line">	SOCKET _mysocket = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,IPPROTO_TCP);<span class="comment">//IPV4 数据流类型 TCP类型 </span></span><br><span class="line">	<span class="keyword">if</span>(INVALID_SOCKET == _mysocket)<span class="comment">//建立失败 </span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">	<span class="comment">//绑定网络端口和IP地址 </span></span><br><span class="line">	sockaddr_in _myaddr = &#123;&#125;;<span class="comment">//建立sockaddr结构体  sockaddr_in结构体方便填写 但是下面要进行类型转换 </span></span><br><span class="line">	_myaddr.sin_family = AF_INET;<span class="comment">//IPV4</span></span><br><span class="line">	_myaddr.sin_port = <span class="built_in">htons</span>(<span class="number">8888</span>);<span class="comment">//端口 host to net unsigned short</span></span><br><span class="line">	_myaddr.sin_addr.S_un.S_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);<span class="comment">//网络地址 INADDR_ANY监听所有网卡的端口 </span></span><br><span class="line">	<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">bind</span>(_mysocket,(sockaddr*)&amp;_myaddr,<span class="built_in">sizeof</span>(sockaddr_in)))<span class="comment">//socket (强制转换)sockaddr结构体 结构体大小 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;绑定不成功&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;&quot;绑定成功&quot;&lt;&lt;endl; </span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//监听网络端口</span></span><br><span class="line">	<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">listen</span>(_mysocket,<span class="number">5</span>))<span class="comment">//套接字 最大多少人连接 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;监听失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;&quot;监听成功&quot;&lt;&lt;endl; </span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//select相关 </span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		WINSOCK_API_LINKAGE int WSAAPI select(</span></span><br><span class="line"><span class="comment">		int nfds,//是指待监听集合里的范围 即待监听数量最大值+1</span></span><br><span class="line"><span class="comment">		fd_set *readfds,//待监听的可读文件集合 </span></span><br><span class="line"><span class="comment">		fd_set *writefds,//待监听的可写文件集合  </span></span><br><span class="line"><span class="comment">		fd_set *exceptfds,//待监听的异常文件集合  </span></span><br><span class="line"><span class="comment">		const PTIMEVAL timeout);//超时设置 传入NULL为阻塞模式 传入timeval结构体为非阻塞模式</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		typedef struct fd_set//可以存放多个socket </span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">			u_int	fd_count;//记录放了多少个socket</span></span><br><span class="line"><span class="comment">			SOCKET	fd_array[FD_SETSIZE];//socket数组</span></span><br><span class="line"><span class="comment">		&#125; fd_set;</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		struct timeval//时间结构体 </span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">			long tv_sec;//秒</span></span><br><span class="line"><span class="comment">			long tv_usec;//毫秒</span></span><br><span class="line"><span class="comment">		&#125;;</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		fd_set _fdRead;<span class="comment">//建立集合 </span></span><br><span class="line">		fd_set _fdWrite;</span><br><span class="line">		fd_set _fdExcept;</span><br><span class="line">		<span class="built_in">FD_ZERO</span>(&amp;_fdRead);<span class="comment">//清空集合 </span></span><br><span class="line">		<span class="built_in">FD_ZERO</span>(&amp;_fdWrite); </span><br><span class="line">		<span class="built_in">FD_ZERO</span>(&amp;_fdExcept); </span><br><span class="line">		<span class="built_in">FD_SET</span>(_mysocket,&amp;_fdRead);<span class="comment">//放入集合 </span></span><br><span class="line">		<span class="built_in">FD_SET</span>(_mysocket,&amp;_fdWrite); </span><br><span class="line">		<span class="built_in">FD_SET</span>(_mysocket,&amp;_fdExcept);</span><br><span class="line">		timeval <span class="type">_t</span> = &#123;<span class="number">1</span>,<span class="number">0</span>&#125;;<span class="comment">//select最大响应时间 </span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> n=_clients.<span class="built_in">size</span>()<span class="number">-1</span>; n&gt;=<span class="number">0</span>; --n)<span class="comment">//把连接的客户端 放入read集合 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">FD_SET</span>(_clients[n],&amp;_fdRead);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//select函数筛选select </span></span><br><span class="line">		<span class="type">int</span> _ret = <span class="built_in">select</span>(_mysocket<span class="number">+1</span>,&amp;_fdRead,&amp;_fdWrite,&amp;_fdExcept,&amp;<span class="type">_t</span>); </span><br><span class="line">		<span class="keyword">if</span>(_ret&lt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;select任务结束\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(_mysocket,&amp;_fdRead))<span class="comment">//获取是否有新socket连接 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">FD_CLR</span>(_mysocket,&amp;_fdRead);<span class="comment">//清理</span></span><br><span class="line">			<span class="comment">//等待接收客户端连接</span></span><br><span class="line">			sockaddr_in _clientAddr = &#123;&#125;;<span class="comment">//新建sockadd结构体接收客户端数据 </span></span><br><span class="line">			<span class="type">int</span> _addr_len = <span class="built_in">sizeof</span>(sockaddr_in);<span class="comment">//获取sockadd结构体长度 </span></span><br><span class="line">			SOCKET _temp_socket = INVALID_SOCKET;<span class="comment">//声明客户端套接字 </span></span><br><span class="line">			</span><br><span class="line">			_temp_socket = <span class="built_in">accept</span>(_mysocket,(sockaddr*)&amp;_clientAddr,&amp;_addr_len);<span class="comment">//自身套接字 客户端结构体 结构体大小 </span></span><br><span class="line">			<span class="keyword">if</span>(INVALID_SOCKET == _temp_socket)<span class="comment">//接收失败 </span></span><br><span class="line">			&#123;</span><br><span class="line">				cout&lt;&lt;<span class="string">&quot;接收到无效客户端Socket&quot;</span>&lt;&lt;endl;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				cout&lt;&lt;<span class="string">&quot;新客户端加入&quot;</span>&lt;&lt;endl; </span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;IP地址为：%s \n&quot;</span>, <span class="built_in">inet_ntoa</span>(_clientAddr.sin_addr));  </span><br><span class="line">				<span class="comment">//群发所有客户端 通知新用户登录 </span></span><br><span class="line">				NewUserJoin _user_join; </span><br><span class="line">				<span class="built_in">strcpy</span>(_user_join.UserName,<span class="built_in">inet_ntoa</span>(_clientAddr.sin_addr));</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>;n&lt;_clients.<span class="built_in">size</span>();n++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">send</span>(_clients[n],(<span class="type">const</span> <span class="type">char</span>*)&amp;_user_join,<span class="built_in">sizeof</span>(NewUserJoin),<span class="number">0</span>);	</span><br><span class="line">				&#125; </span><br><span class="line">				<span class="comment">//将新的客户端加入动态数组</span></span><br><span class="line">				_clients.<span class="built_in">push_back</span>(_temp_socket); </span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;_fdRead.fd_count; ++n)<span class="comment">//在read数组里挨个处理 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="number">-1</span> == _handle(_fdRead.fd_array[n]))<span class="comment">//处理请求 客户端退出的话 </span></span><br><span class="line">			&#123;</span><br><span class="line">				vector&lt;SOCKET&gt;::iterator iter = <span class="built_in">find</span>(_clients.<span class="built_in">begin</span>(),_clients.<span class="built_in">end</span>(),_fdRead.fd_array[n]);</span><br><span class="line">				<span class="keyword">if</span>(iter != _clients.<span class="built_in">end</span>())<span class="comment">//如果找到了的话 就在动态数组里删除掉 </span></span><br><span class="line">				&#123;</span><br><span class="line">					_clients.<span class="built_in">erase</span>(iter);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;空闲时间处理其他业务\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	 </span><br><span class="line">	<span class="comment">//关闭客户端socket</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;_clients.<span class="built_in">size</span>(); ++n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">closesocket</span>(_clients[n]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭socket </span></span><br><span class="line">	<span class="built_in">closesocket</span>(_mysocket); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//清除windows socket 环境 </span></span><br><span class="line">	<span class="built_in">WSACleanup</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;任务结束，程序已退出&quot;</span>); </span><br><span class="line">	 </span><br><span class="line">	<span class="built_in">getchar</span>(); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-客户端代码"><a href="#2-客户端代码" class="headerlink" title="2.客户端代码"></a>2.客户端代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;winSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//链接此动态链接库 windows特有 </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//枚举类型记录命令 </span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">cmd</span> </span><br><span class="line">&#123;</span><br><span class="line">	CMD_LOGIN,<span class="comment">//登录 </span></span><br><span class="line">	CMD_LOGINRESULT,<span class="comment">//登录结果 </span></span><br><span class="line">	CMD_LOGOUT,<span class="comment">//登出 </span></span><br><span class="line">	CMD_LOGOUTRESULT,<span class="comment">//登出结果 </span></span><br><span class="line">	CMD_NEW_USER_JOIN,<span class="comment">//新用户登入 </span></span><br><span class="line">	CMD_ERROR<span class="comment">//错误 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义数据包头 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DateHeader</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">short</span> cmd;<span class="comment">//命令</span></span><br><span class="line">	<span class="type">short</span> date_length;<span class="comment">//数据的长短	</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包1 登录 传输账号与密码</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Login</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Login</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGIN;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Login); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">	<span class="type">char</span> PassWord[<span class="number">32</span>];<span class="comment">//密码 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包2 登录结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoginResult</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LoginResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGINRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LoginResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包3 登出 传输用户名 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Logout</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Logout</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Logout); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包4 登出结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LogoutResult</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LogoutResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUTRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LogoutResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包5 新用户登入 传输通告 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NewUserJoin</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">NewUserJoin</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_NEW_USER_JOIN;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(NewUserJoin); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> _handle(SOCKET _temp_socket)<span class="comment">//处理数据 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//接收客户端发送的数据 </span></span><br><span class="line">	DateHeader _head = &#123;&#125;; </span><br><span class="line">	<span class="type">int</span> _buf_len = <span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_head,<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(_buf_len&lt;=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;与服务器断开连接,任务结束\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;接收到包头，命令：%d，数据长度：%d\n&quot;</span>,_head.cmd,_head.date_length);</span><br><span class="line">	<span class="keyword">switch</span>(_head.cmd)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> CMD_LOGINRESULT:<span class="comment">//登录结果 接收登录包体 </span></span><br><span class="line">		&#123;</span><br><span class="line">			LoginResult _result; </span><br><span class="line">			<span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_result+<span class="built_in">sizeof</span>(DateHeader),<span class="built_in">sizeof</span>(LoginResult)-<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;登录结果:%d\n&quot;</span>,_result.Result);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> CMD_LOGOUTRESULT:<span class="comment">//登出结果 接收登出包体 </span></span><br><span class="line">		&#123;</span><br><span class="line">			LogoutResult _result; </span><br><span class="line">			<span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_result+<span class="built_in">sizeof</span>(DateHeader),<span class="built_in">sizeof</span>(LogoutResult)-<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;登录结果:%d\n&quot;</span>,_result.Result);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> CMD_NEW_USER_JOIN:<span class="comment">//新用户登录通知 </span></span><br><span class="line">		&#123;</span><br><span class="line">			NewUserJoin _result; </span><br><span class="line">			<span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_result+<span class="built_in">sizeof</span>(DateHeader),<span class="built_in">sizeof</span>(NewUserJoin)-<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;用户:%s已登录\n&quot;</span>,_result.UserName);</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> _run = <span class="literal">true</span>;<span class="comment">//当前程序是否还在运行中 </span></span><br><span class="line"><span class="type">void</span> _cmdThread(SOCKET _mysocket)<span class="comment">//命令线程 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//输入请求 </span></span><br><span class="line">		<span class="type">char</span> _msg[<span class="number">256</span>] = &#123;&#125;;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,_msg);</span><br><span class="line">		<span class="comment">//处理请求 </span></span><br><span class="line">		<span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(_msg,<span class="string">&quot;exit&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			_run = <span class="literal">false</span>; </span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;程序退出\n&quot;</span>); </span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(_msg,<span class="string">&quot;login&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//发送 </span></span><br><span class="line">			Login _login;</span><br><span class="line">			<span class="built_in">strcpy</span>(_login.UserName,<span class="string">&quot;河边小咸鱼&quot;</span>);</span><br><span class="line">			<span class="built_in">strcpy</span>(_login.PassWord,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">			<span class="built_in">send</span>(_mysocket,(<span class="type">const</span> <span class="type">char</span>*)&amp;_login,<span class="built_in">sizeof</span>(_login),<span class="number">0</span>);</span><br><span class="line">			<span class="comment">//这里就不用接收了 由select用来检测接收</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(_msg,<span class="string">&quot;logout&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//发送 </span></span><br><span class="line">			Logout _logout;</span><br><span class="line">			<span class="built_in">strcpy</span>(_logout.UserName,<span class="string">&quot;河边小咸鱼&quot;</span>);</span><br><span class="line">			<span class="built_in">send</span>(_mysocket,(<span class="type">const</span> <span class="type">char</span>*)&amp;_logout,<span class="built_in">sizeof</span>(_logout),<span class="number">0</span>);</span><br><span class="line">			<span class="comment">//这里就不用接收了 由select用来检测接收</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;不存在的命令\n&quot;</span>);</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//启动windows socket 2,x环境 windows特有 </span></span><br><span class="line">	WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>);<span class="comment">//WinSock库版本号 </span></span><br><span class="line">	WSADATA dat;<span class="comment">//网络结构体 储存WSAStartup函数调用后返回的Socket数据 </span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span> != <span class="built_in">WSAStartup</span>(ver,&amp;dat))<span class="comment">//正确初始化后返回0 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//建立一个socket </span></span><br><span class="line">	SOCKET _mysocket = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);<span class="comment">//IPV4 数据流类型 类型可以不用写 </span></span><br><span class="line">	<span class="keyword">if</span>(INVALID_SOCKET == _mysocket)<span class="comment">//建立失败 </span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//连接服务器</span></span><br><span class="line">    sockaddr_in _sin = &#123;&#125;;<span class="comment">//sockaddr结构体 </span></span><br><span class="line">    _sin.sin_family = AF_INET;<span class="comment">//IPV4</span></span><br><span class="line">    _sin.sin_port = <span class="built_in">htons</span>(<span class="number">8888</span>);<span class="comment">//想要连接的端口号 </span></span><br><span class="line">	_sin.sin_addr.S_un.S_addr =  <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);<span class="comment">//想要连接的IP </span></span><br><span class="line">	<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">connect</span>(_mysocket,(sockaddr*)&amp;_sin,<span class="built_in">sizeof</span>(sockaddr_in)))</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;连接失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">		<span class="built_in">closesocket</span>(_mysocket);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;连接成功&quot;</span>&lt;&lt;endl; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//创建新线程</span></span><br><span class="line">	<span class="function">thread <span class="title">t1</span><span class="params">(_cmdThread,_mysocket)</span></span>;</span><br><span class="line">	t<span class="number">1.</span><span class="built_in">detach</span>();<span class="comment">//线程分离 </span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(_run)</span><br><span class="line">	&#123;</span><br><span class="line">		fd_set _fdRead;<span class="comment">//建立集合 </span></span><br><span class="line">		<span class="built_in">FD_ZERO</span>(&amp;_fdRead);<span class="comment">//清空集合  </span></span><br><span class="line">		<span class="built_in">FD_SET</span>(_mysocket,&amp;_fdRead);<span class="comment">//放入集合 </span></span><br><span class="line">		timeval <span class="type">_t</span> = &#123;<span class="number">1</span>,<span class="number">0</span>&#125;;<span class="comment">//select最大响应时间 </span></span><br><span class="line">		<span class="comment">//新建seclect </span></span><br><span class="line">		<span class="type">int</span> _ret = <span class="built_in">select</span>(_mysocket<span class="number">+1</span>,&amp;_fdRead,<span class="literal">NULL</span>,<span class="literal">NULL</span>,&amp;<span class="type">_t</span>);</span><br><span class="line">		<span class="keyword">if</span>(_ret&lt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;seclect任务结束\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(_mysocket,&amp;_fdRead))<span class="comment">//获取是否有可读socket </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">FD_CLR</span>(_mysocket,&amp;_fdRead);<span class="comment">//清理计数器 </span></span><br><span class="line">			<span class="keyword">if</span>(<span class="number">-1</span> == _handle(_mysocket))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;seclect任务结束\n&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭socket</span></span><br><span class="line">	<span class="built_in">closesocket</span>(_mysocket); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//清除windows socket 环境 </span></span><br><span class="line">	<span class="built_in">WSACleanup</span>(); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++网络编程学习：跨平台支持Windows、Linux系统</title>
    <url>/2021/01/24/20210124_C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%94%AF%E6%8C%81Windows%E3%80%81Linux%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<ul>
<li>使用的语言为C&#x2F;C++</li>
<li>源码支持的平台为：Windows &#x2F; Linux</li>
</ul>
<h1 id="一、为何要进行跨平台操作"><a href="#一、为何要进行跨平台操作" class="headerlink" title="一、为何要进行跨平台操作"></a>一、为何要进行跨平台操作</h1><p>&emsp;&emsp;首先，我是想在网络编程学习渐入佳境后，自己尝试做一个网络方面的项目，其中就必须用到服务器。Linux服务器相比Windows服务器更加稳定且高效，所以对于我来说，学会如何编写出可以在Linux系统下运行的网络程序是必不可少的。<br>&emsp;&emsp;其次，就目前来说，企业中的高性能网络编程都是基于Linux的，学会跨平台的网络编程技能，可以在未来就业方面等有很大的好处。<br>&emsp;&emsp;由此，我决定在网络编程学习的第四小阶段，学习如何进行跨平台的网络编程。</p>
<span id="more"></span>

<h1 id="二、关于Win与Linux系统下网络编程的差异"><a href="#二、关于Win与Linux系统下网络编程的差异" class="headerlink" title="二、关于Win与Linux系统下网络编程的差异"></a>二、关于Win与Linux系统下网络编程的差异</h1><p><font size="5"><strong>差异一</strong></font></p>
<p>在Linux环境下，程序的头文件与定义与Win环境下存在差异。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;winSock2.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//链接此动态链接库 windows特有 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span><span class="comment">//selcet</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span><span class="comment">//uni std</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SOCKET int</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> INVALID_SOCKET (SOCKET)(~0)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SOCKET_ERROR (-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>这是更改后的程序部分。<br>可以看出：</p>
<ul>
<li>Win环境下的特有头文件 <strong>&lt;windows.h&gt;</strong> 对应Linux环境下的特有头文件 **&lt;unistd.h&gt;**。</li>
<li>Win环境下的网络头文件 <strong>&lt;winSock2.h&gt;</strong> 对应Linux环境下的特有头文件 **&lt;arpa&#x2F;inet.h&gt;**。</li>
<li>SOCKET为Win环境下的特有数据类型，其原型为<strong>unsigned __int64</strong>，所以我们在Linux下，需要简单对SOCKET进行定义。</li>
<li>Linux中同样对<strong>INVALID_SOCKET</strong>与<strong>SOCKET_ERROR</strong>也没有定义，所以我们参考Win中的定义，在Linux系统下对其定义。<br> <img src="/images/2021-01-24/1.jpg" alt="图1"> (此图为Win环境下_socket_types.h头文件中的相关定义)</li>
</ul>
<p><font size="5"><strong>差异二</strong></font></p>
<p>在Linux环境下不需要使用<strong>WSAStartup</strong>与<strong>WSACleanup</strong>搭建网络环境，这是Win环境特有的。</p>
<ul>
<li>所以我们只需要加上判断即可，当检测到系统环境为Win时执行即可：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">	<span class="comment">//启动windows socket 2,x环境 windows特有 </span></span><br><span class="line">	WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>);<span class="comment">//WinSock库版本号 </span></span><br><span class="line">	WSADATA dat;<span class="comment">//网络结构体 储存WSAStartup函数调用后返回的Socket数据 </span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span> != <span class="built_in">WSAStartup</span>(ver,&amp;dat))<span class="comment">//正确初始化后返回0 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">	<span class="comment">//清除windows socket 环境 </span></span><br><span class="line">	<span class="built_in">WSACleanup</span>(); </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><font size="5"><strong>差异三</strong></font></p>
<p>Linux环境与Win环境下，网络通信相关结构体 <strong>sockaddr_in</strong>和<strong>sockaddr</strong> 存在差异。<br>最明显的差异为存储IP的结构不太一样。</p>
<ul>
<li>所以我们这样更改即可：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">	_sin.sin_addr.S_un.S_addr =  <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);<span class="comment">//想要连接的IP </span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	_sin.sin_addr.s_addr =  <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);<span class="comment">//想要连接的IP </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><font size="5"><strong>差异四</strong></font></p>
<p>Linux环境与Win环境下，关闭套接字的函数存在差异。<br>Win下为**closesocket()<strong>，Linux下则简单粗暴为</strong>close()**。</p>
<ul>
<li>所以我们这样更改即可：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">	<span class="comment">//关闭socket</span></span><br><span class="line">	<span class="built_in">closesocket</span>(_mysocket);  </span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="comment">//关闭socket/LINUX</span></span><br><span class="line">	<span class="built_in">close</span>(_mysocket);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><font size="5"><strong>差异五</strong></font></p>
<p>Linux环境与Win环境下，服务器的accept连接函数参数存在差异。<br>Win下的最后一个参数为<strong>int</strong>型地址，Linux下则为<strong>socklen_t</strong>型地址。进行一次强制转换即可。</p>
<ul>
<li>所以我们这样更改即可：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32	</span></span><br><span class="line">	_temp_socket = <span class="built_in">accept</span>(_mysocket,(sockaddr*)&amp;_clientAddr,&amp;_addr_len);<span class="comment">//自身套接字 客户端结构体 结构体大小 </span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	_temp_socket = <span class="built_in">accept</span>(_mysocket,(sockaddr*)&amp;_clientAddr,(<span class="type">socklen_t</span>*)&amp;_addr_len);<span class="comment">//自身套接字 客户端结构体 结构体大小 </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<font size="5"><strong>差异六</strong></font></li>
</ul>
<p>Linux环境与Win环境下，<strong>fd_set</strong>结构体中的参数出现了变化，不再有储存socket数量的<strong>fd_count</strong>变量，所以我们需要对源码下<strong>select</strong>函数的第一个参数进行准确的数据传入。</p>
<p>select函数的第一个参数实际为 <strong>所有socket的最大值+1</strong>，所以我们新建一个变量，用于储存最大值。在每次对fdread集合进行导入时，找到socket的最大值，随后传入select函数即可。</p>
<ul>
<li>所以我们这样更改即可：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SOCKET _maxSock = _mysocket;<span class="comment">//最大socket</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> n=_clients.<span class="built_in">size</span>()<span class="number">-1</span>; n&gt;=<span class="number">0</span>; --n)<span class="comment">//把连接的客户端 放入read集合 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">FD_SET</span>(_clients[n],&amp;_fdRead);</span><br><span class="line">	<span class="keyword">if</span>(_maxSock &lt; _clients[n])</span><br><span class="line">	&#123;</span><br><span class="line">		_maxSock = _clients[n];<span class="comment">//找最大</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//select函数筛选select </span></span><br><span class="line"><span class="type">int</span> _ret = <span class="built_in">select</span>(_maxSock<span class="number">+1</span>,&amp;_fdRead,&amp;_fdWrite,&amp;_fdExcept,&amp;<span class="type">_t</span>);</span><br></pre></td></tr></table></figure>
<font size="5"><strong>差异七</strong></font></li>
</ul>
<p>Linux环境与Win环境下，<strong>fd_set</strong>结构体中的参数出现了变化，不再有储存socket数量的<strong>fd_count</strong>变量，所以我们需要对源码下面关于遍历socket的逻辑进行改变。</p>
<p>首先遍历 <strong>_clients</strong> 数组中的所有socket，随后使用<strong>FD_ISSET</strong>函数判定其是否存在待处理事件，如果有，即可按逻辑进行处理。</p>
<ul>
<li>所以我们这样更改即可：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;_clients.<span class="built_in">size</span>(); ++n)<span class="comment">//遍历所有socket</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(_clients[n],&amp;_fdRead))<span class="comment">//看一下是否在待处理事件列表中</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="number">-1</span> == _handle(_clients[n]))<span class="comment">//处理请求 客户端退出的话 </span></span><br><span class="line">		&#123;</span><br><span class="line">			vector&lt;SOCKET&gt;::iterator iter = _clients.<span class="built_in">begin</span>()+n;<span class="comment">//找到退出客户端的地址</span></span><br><span class="line">			<span class="keyword">if</span>(iter != _clients.<span class="built_in">end</span>())<span class="comment">//如果是合理值</span></span><br><span class="line">			&#123;</span><br><span class="line">				_clients.<span class="built_in">erase</span>(iter);<span class="comment">//移除</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="三、基于笔记三源码进行-跨平台化升级"><a href="#三、基于笔记三源码进行-跨平台化升级" class="headerlink" title="三、基于笔记三源码进行 跨平台化升级"></a>三、基于笔记三源码进行 跨平台化升级</h1><h2 id="1-客户端源码"><a href="#1-客户端源码" class="headerlink" title="1.客户端源码"></a>1.客户端源码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;winSock2.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//链接此动态链接库 windows特有 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span><span class="comment">//selcet</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span><span class="comment">//uni std</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SOCKET int</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> INVALID_SOCKET (SOCKET)(~0)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SOCKET_ERROR (-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//枚举类型记录命令 </span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">cmd</span> </span><br><span class="line">&#123;</span><br><span class="line">	CMD_LOGIN,<span class="comment">//登录 </span></span><br><span class="line">	CMD_LOGINRESULT,<span class="comment">//登录结果 </span></span><br><span class="line">	CMD_LOGOUT,<span class="comment">//登出 </span></span><br><span class="line">	CMD_LOGOUTRESULT,<span class="comment">//登出结果 </span></span><br><span class="line">	CMD_NEW_USER_JOIN,<span class="comment">//新用户登入 </span></span><br><span class="line">	CMD_ERROR<span class="comment">//错误 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义数据包头 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DateHeader</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">short</span> cmd;<span class="comment">//命令</span></span><br><span class="line">	<span class="type">short</span> date_length;<span class="comment">//数据的长短	</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包1 登录 传输账号与密码</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Login</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Login</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGIN;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Login); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">	<span class="type">char</span> PassWord[<span class="number">32</span>];<span class="comment">//密码 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包2 登录结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoginResult</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LoginResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGINRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LoginResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包3 登出 传输用户名 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Logout</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Logout</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Logout); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包4 登出结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LogoutResult</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LogoutResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUTRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LogoutResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包5 新用户登入 传输通告 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NewUserJoin</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">NewUserJoin</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_NEW_USER_JOIN;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(NewUserJoin); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> _handle(SOCKET _temp_socket)<span class="comment">//处理数据 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//接收客户端发送的数据 </span></span><br><span class="line">	DateHeader _head = &#123;&#125;; </span><br><span class="line">	<span class="type">int</span> _buf_len = <span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_head,<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(_buf_len&lt;=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;与服务器断开连接,任务结束\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;接收到包头，命令：%d，数据长度：%d\n&quot;</span>,_head.cmd,_head.date_length);</span><br><span class="line">	<span class="keyword">switch</span>(_head.cmd)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> CMD_LOGINRESULT:<span class="comment">//登录结果 接收登录包体 </span></span><br><span class="line">		&#123;</span><br><span class="line">			LoginResult _result; </span><br><span class="line">			<span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_result+<span class="built_in">sizeof</span>(DateHeader),<span class="built_in">sizeof</span>(LoginResult)-<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;登录结果:%d\n&quot;</span>,_result.Result);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> CMD_LOGOUTRESULT:<span class="comment">//登出结果 接收登出包体 </span></span><br><span class="line">		&#123;</span><br><span class="line">			LogoutResult _result; </span><br><span class="line">			<span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_result+<span class="built_in">sizeof</span>(DateHeader),<span class="built_in">sizeof</span>(LogoutResult)-<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;登录结果:%d\n&quot;</span>,_result.Result);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> CMD_NEW_USER_JOIN:<span class="comment">//新用户登录通知 </span></span><br><span class="line">		&#123;</span><br><span class="line">			NewUserJoin _result; </span><br><span class="line">			<span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_result+<span class="built_in">sizeof</span>(DateHeader),<span class="built_in">sizeof</span>(NewUserJoin)-<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;用户:%s已登录\n&quot;</span>,_result.UserName);</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> _run = <span class="literal">true</span>;<span class="comment">//当前程序是否还在运行中 </span></span><br><span class="line"><span class="type">void</span> _cmdThread(SOCKET _mysocket)<span class="comment">//命令线程 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(_run)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//输入请求 </span></span><br><span class="line">		<span class="type">char</span> _msg[<span class="number">256</span>] = &#123;&#125;;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,_msg);</span><br><span class="line">		<span class="comment">//处理请求 </span></span><br><span class="line">		<span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(_msg,<span class="string">&quot;exit&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			_run = <span class="literal">false</span>; </span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;程序退出\n&quot;</span>); </span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(_msg,<span class="string">&quot;login&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//发送 </span></span><br><span class="line">			Login _login;</span><br><span class="line">			<span class="built_in">strcpy</span>(_login.UserName,<span class="string">&quot;hbxxy&quot;</span>);</span><br><span class="line">			<span class="built_in">strcpy</span>(_login.PassWord,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">			<span class="built_in">send</span>(_mysocket,(<span class="type">const</span> <span class="type">char</span>*)&amp;_login,<span class="built_in">sizeof</span>(_login),<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(_msg,<span class="string">&quot;logout&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//发送 </span></span><br><span class="line">			Logout _logout;</span><br><span class="line">			<span class="built_in">strcpy</span>(_logout.UserName,<span class="string">&quot;hbxxy&quot;</span>);</span><br><span class="line">			<span class="built_in">send</span>(_mysocket,(<span class="type">const</span> <span class="type">char</span>*)&amp;_logout,<span class="built_in">sizeof</span>(_logout),<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;不存在的命令\n&quot;</span>);</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Welcome\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">	<span class="comment">//启动windows socket 2,x环境 windows特有 </span></span><br><span class="line">	WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>);<span class="comment">//WinSock库版本号 </span></span><br><span class="line">	WSADATA dat;<span class="comment">//网络结构体 储存WSAStartup函数调用后返回的Socket数据 </span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span> != <span class="built_in">WSAStartup</span>(ver,&amp;dat))<span class="comment">//正确初始化后返回0 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//建立一个socket </span></span><br><span class="line">	SOCKET _mysocket = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);<span class="comment">//IPV4 数据流类型 类型可以不用写 </span></span><br><span class="line">	<span class="keyword">if</span>(INVALID_SOCKET == _mysocket)<span class="comment">//建立失败 </span></span><br><span class="line">	&#123;   </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">	&#125; </span><br><span class="line">    </span><br><span class="line">   	<span class="comment">//连接服务器</span></span><br><span class="line">   	sockaddr_in _sin = &#123;&#125;;<span class="comment">//sockaddr结构体 </span></span><br><span class="line">   	_sin.sin_family = AF_INET;<span class="comment">//IPV4</span></span><br><span class="line">   	_sin.sin_port = <span class="built_in">htons</span>(<span class="number">8888</span>);<span class="comment">//想要连接的端口号 </span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">		_sin.sin_addr.S_un.S_addr =  <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);<span class="comment">//想要连接的IP </span></span><br><span class="line">	<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		_sin.sin_addr.s_addr =  <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);<span class="comment">//想要连接的IP </span></span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">connect</span>(_mysocket,(sockaddr*)&amp;_sin,<span class="built_in">sizeof</span>(sockaddr_in)))</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;连接失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">		<span class="comment">//关闭socket</span></span><br><span class="line">		<span class="built_in">closesocket</span>(_mysocket);  </span><br><span class="line">	<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		<span class="comment">//关闭socket/LINUX</span></span><br><span class="line">		<span class="built_in">close</span>(_mysocket);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;连接成功&quot;</span>&lt;&lt;endl; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//创建新线程</span></span><br><span class="line">	<span class="function">thread <span class="title">t1</span><span class="params">(_cmdThread,_mysocket)</span></span>;</span><br><span class="line">	t<span class="number">1.</span><span class="built_in">detach</span>();<span class="comment">//线程分离 </span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(_run)</span><br><span class="line">	&#123;</span><br><span class="line">		fd_set _fdRead;<span class="comment">//建立集合 </span></span><br><span class="line">		<span class="built_in">FD_ZERO</span>(&amp;_fdRead);<span class="comment">//清空集合  </span></span><br><span class="line">		<span class="built_in">FD_SET</span>(_mysocket,&amp;_fdRead);<span class="comment">//放入集合 </span></span><br><span class="line">		timeval <span class="type">_t</span> = &#123;<span class="number">1</span>,<span class="number">0</span>&#125;;<span class="comment">//select最大响应时间 </span></span><br><span class="line">		<span class="comment">//新建seclect </span></span><br><span class="line">		<span class="type">int</span> _ret = <span class="built_in">select</span>(_mysocket<span class="number">+1</span>,&amp;_fdRead,<span class="literal">NULL</span>,<span class="literal">NULL</span>,&amp;<span class="type">_t</span>);</span><br><span class="line">		<span class="keyword">if</span>(_ret&lt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;seclect任务结束\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(_mysocket,&amp;_fdRead))<span class="comment">//获取是否有可读socket </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">FD_CLR</span>(_mysocket,&amp;_fdRead);<span class="comment">//清理计数器 </span></span><br><span class="line">			<span class="keyword">if</span>(<span class="number">-1</span> == _handle(_mysocket))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;seclect任务结束\n&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">	<span class="comment">//关闭socket</span></span><br><span class="line">	<span class="built_in">closesocket</span>(_mysocket); </span><br><span class="line">	<span class="comment">//清除windows socket 环境 </span></span><br><span class="line">	<span class="built_in">WSACleanup</span>(); </span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="comment">//关闭socket/LINUX</span></span><br><span class="line">	<span class="built_in">close</span>(_mysocket);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="2-服务端源码"><a href="#2-服务端源码" class="headerlink" title="2.服务端源码"></a>2.服务端源码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;winSock2.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//链接此动态链接库 windows特有 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span><span class="comment">//selcet</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span><span class="comment">//uni std</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SOCKET int</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> INVALID_SOCKET (SOCKET)(~0)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SOCKET_ERROR (-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//枚举类型记录命令 </span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">cmd</span> </span><br><span class="line">&#123;</span><br><span class="line">	CMD_LOGIN,<span class="comment">//登录 </span></span><br><span class="line">	CMD_LOGINRESULT,<span class="comment">//登录结果 </span></span><br><span class="line">	CMD_LOGOUT,<span class="comment">//登出 </span></span><br><span class="line">	CMD_LOGOUTRESULT,<span class="comment">//登出结果 </span></span><br><span class="line">	CMD_NEW_USER_JOIN,<span class="comment">//新用户登入 </span></span><br><span class="line">	CMD_ERROR<span class="comment">//错误 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义数据包头 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DateHeader</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">short</span> cmd;<span class="comment">//命令</span></span><br><span class="line">	<span class="type">short</span> date_length;<span class="comment">//数据的长短	</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包1 登录 传输账号与密码</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Login</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Login</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGIN;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Login); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">	<span class="type">char</span> PassWord[<span class="number">32</span>];<span class="comment">//密码 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包2 登录结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoginResult</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LoginResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGINRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LoginResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包3 登出 传输用户名 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Logout</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Logout</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Logout); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包4 登出结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LogoutResult</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LogoutResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUTRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LogoutResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包5 新用户登入 传输通告 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NewUserJoin</span> : <span class="keyword">public</span> DateHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">NewUserJoin</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_NEW_USER_JOIN;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(NewUserJoin); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">vector&lt;SOCKET&gt; _clients;<span class="comment">//储存客户端socket </span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> _handle(SOCKET _temp_socket)<span class="comment">//处理数据 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//接收客户端发送的数据 </span></span><br><span class="line">	DateHeader _head = &#123;&#125;; </span><br><span class="line">	<span class="type">int</span> _buf_len = <span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_head,<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(_buf_len&lt;=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;客户端已退出\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;接收到包头，命令：%d，数据长度：%d\n&quot;</span>,_head.cmd,_head.date_length);</span><br><span class="line">	<span class="keyword">switch</span>(_head.cmd)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> CMD_LOGIN:<span class="comment">//登录 接收登录包体 </span></span><br><span class="line">		&#123;</span><br><span class="line">			Login _login;</span><br><span class="line">			<span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_login+<span class="built_in">sizeof</span>(DateHeader),<span class="built_in">sizeof</span>(Login)-<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			进行判断操作 </span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s已登录\n密码：%s\n&quot;</span>,_login.UserName,_login.PassWord); </span><br><span class="line">			LoginResult _result;	</span><br><span class="line">			_result.Result = <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">send</span>(_temp_socket,(<span class="type">char</span>*)&amp;_result,<span class="built_in">sizeof</span>(LoginResult),<span class="number">0</span>);<span class="comment">//发包体 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> CMD_LOGOUT:<span class="comment">//登出 接收登出包体 </span></span><br><span class="line">		&#123;</span><br><span class="line">			Logout _logout;</span><br><span class="line">			<span class="built_in">recv</span>(_temp_socket,(<span class="type">char</span>*)&amp;_logout+<span class="built_in">sizeof</span>(DateHeader),<span class="built_in">sizeof</span>(Logout)-<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			进行判断操作 </span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s已登出\n&quot;</span>,_logout.UserName); </span><br><span class="line">			LogoutResult _result;</span><br><span class="line">			_result.Result = <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">send</span>(_temp_socket,(<span class="type">char</span>*)&amp;_result,<span class="built_in">sizeof</span>(LogoutResult),<span class="number">0</span>);<span class="comment">//发包体</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:<span class="comment">//错误 </span></span><br><span class="line">		&#123;</span><br><span class="line">			_head.cmd = CMD_ERROR; </span><br><span class="line">			_head.date_length = <span class="number">0</span>; </span><br><span class="line">			<span class="built_in">send</span>(_temp_socket,(<span class="type">char</span>*)&amp;_head,<span class="built_in">sizeof</span>(DateHeader),<span class="number">0</span>);<span class="comment">//发包头 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">	<span class="comment">//启动windows socket 2,x环境 windows特有 </span></span><br><span class="line">	WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>);<span class="comment">//WinSock库版本号 </span></span><br><span class="line">	WSADATA dat;<span class="comment">//网络结构体 储存WSAStartup函数调用后返回的Socket数据 </span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span> != <span class="built_in">WSAStartup</span>(ver,&amp;dat))<span class="comment">//正确初始化后返回0 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//建立一个socket </span></span><br><span class="line">	SOCKET _mysocket = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,IPPROTO_TCP);<span class="comment">//IPV4 数据流类型 TCP类型 </span></span><br><span class="line">	<span class="keyword">if</span>(INVALID_SOCKET == _mysocket)<span class="comment">//建立失败 </span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">	<span class="comment">//绑定网络端口和IP地址 </span></span><br><span class="line">	sockaddr_in _myaddr = &#123;&#125;;<span class="comment">//建立sockaddr结构体  sockaddr_in结构体方便填写 但是下面要进行类型转换 </span></span><br><span class="line">	_myaddr.sin_family = AF_INET;<span class="comment">//IPV4</span></span><br><span class="line">	_myaddr.sin_port = <span class="built_in">htons</span>(<span class="number">8888</span>);<span class="comment">//端口 host to net unsigned short</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">	_myaddr.sin_addr.S_un.S_addr = INADDR_ANY;<span class="comment">//inet_addr(&quot;127.0.0.1&quot;);</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	_myaddr.sin_addr.s_addr = INADDR_ANY;<span class="comment">//想要监听的ip </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">bind</span>(_mysocket,(sockaddr*)&amp;_myaddr,<span class="built_in">sizeof</span>(sockaddr_in)))<span class="comment">//socket (强制转换)sockaddr结构体 结构体大小 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;绑定不成功&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;&quot;绑定成功&quot;&lt;&lt;endl; </span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//监听网络端口</span></span><br><span class="line">	<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">listen</span>(_mysocket,<span class="number">5</span>))<span class="comment">//套接字 最大多少人连接 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;监听失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;&quot;监听成功&quot;&lt;&lt;endl; </span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		fd_set _fdRead;<span class="comment">//建立集合 </span></span><br><span class="line">		fd_set _fdWrite;</span><br><span class="line">		fd_set _fdExcept;</span><br><span class="line">		<span class="built_in">FD_ZERO</span>(&amp;_fdRead);<span class="comment">//清空集合 </span></span><br><span class="line">		<span class="built_in">FD_ZERO</span>(&amp;_fdWrite); </span><br><span class="line">		<span class="built_in">FD_ZERO</span>(&amp;_fdExcept); </span><br><span class="line">		<span class="built_in">FD_SET</span>(_mysocket,&amp;_fdRead);<span class="comment">//放入集合 </span></span><br><span class="line">		<span class="built_in">FD_SET</span>(_mysocket,&amp;_fdWrite); </span><br><span class="line">		<span class="built_in">FD_SET</span>(_mysocket,&amp;_fdExcept);</span><br><span class="line">		timeval <span class="type">_t</span> = &#123;<span class="number">2</span>,<span class="number">0</span>&#125;;<span class="comment">//select最大响应时间 </span></span><br><span class="line">		SOCKET _maxSock = _mysocket;<span class="comment">//最大socket</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> n=_clients.<span class="built_in">size</span>()<span class="number">-1</span>; n&gt;=<span class="number">0</span>; --n)<span class="comment">//把连接的客户端 放入read集合 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">FD_SET</span>(_clients[n],&amp;_fdRead);</span><br><span class="line">			<span class="keyword">if</span>(_maxSock &lt; _clients[n])</span><br><span class="line">			&#123;</span><br><span class="line">				_maxSock = _clients[n];<span class="comment">//找最大</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//select函数筛选select </span></span><br><span class="line">		<span class="type">int</span> _ret = <span class="built_in">select</span>(_maxSock<span class="number">+1</span>,&amp;_fdRead,&amp;_fdWrite,&amp;_fdExcept,&amp;<span class="type">_t</span>); </span><br><span class="line">		<span class="keyword">if</span>(_ret&lt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;select任务结束\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(_mysocket,&amp;_fdRead))<span class="comment">//获取是否有新socket连接 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">FD_CLR</span>(_mysocket,&amp;_fdRead);<span class="comment">//清理</span></span><br><span class="line">			<span class="comment">//等待接收客户端连接</span></span><br><span class="line">			sockaddr_in _clientAddr = &#123;&#125;;<span class="comment">//新建sockadd结构体接收客户端数据 </span></span><br><span class="line">			<span class="type">int</span> _addr_len = <span class="built_in">sizeof</span>(sockaddr_in);<span class="comment">//获取sockadd结构体长度 </span></span><br><span class="line">			SOCKET _temp_socket = INVALID_SOCKET;<span class="comment">//声明客户端套接字 </span></span><br><span class="line">		<span class="meta">#<span class="keyword">ifdef</span> _WIN32	</span></span><br><span class="line">			_temp_socket = <span class="built_in">accept</span>(_mysocket,(sockaddr*)&amp;_clientAddr,&amp;_addr_len);<span class="comment">//自身套接字 客户端结构体 结构体大小 </span></span><br><span class="line">		<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">			_temp_socket = <span class="built_in">accept</span>(_mysocket,(sockaddr*)&amp;_clientAddr,(<span class="type">socklen_t</span>*)&amp;_addr_len);<span class="comment">//自身套接字 客户端结构体 结构体大小 </span></span><br><span class="line">		<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">			<span class="keyword">if</span>(INVALID_SOCKET == _temp_socket)<span class="comment">//接收失败 </span></span><br><span class="line">			&#123;</span><br><span class="line">				cout&lt;&lt;<span class="string">&quot;接收到无效客户端Socket&quot;</span>&lt;&lt;endl;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				cout&lt;&lt;<span class="string">&quot;新客户端加入&quot;</span>&lt;&lt;endl; </span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;IP地址为：%s \n&quot;</span>, <span class="built_in">inet_ntoa</span>(_clientAddr.sin_addr));  </span><br><span class="line">				<span class="comment">//群发所有客户端 通知新用户登录 </span></span><br><span class="line">				NewUserJoin _user_join; </span><br><span class="line">				<span class="built_in">strcpy</span>(_user_join.UserName,<span class="built_in">inet_ntoa</span>(_clientAddr.sin_addr));</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>;n&lt;_clients.<span class="built_in">size</span>();++n)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">send</span>(_clients[n],(<span class="type">const</span> <span class="type">char</span>*)&amp;_user_join,<span class="built_in">sizeof</span>(NewUserJoin),<span class="number">0</span>);	</span><br><span class="line">				&#125; </span><br><span class="line">				<span class="comment">//将新的客户端加入动态数组</span></span><br><span class="line">				_clients.<span class="built_in">push_back</span>(_temp_socket); </span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;_clients.<span class="built_in">size</span>(); ++n)<span class="comment">//遍历所有socket</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(_clients[n],&amp;_fdRead))<span class="comment">//看一下是否在待处理事件列表中</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="number">-1</span> == _handle(_clients[n]))<span class="comment">//处理请求 客户端退出的话 </span></span><br><span class="line">				&#123;</span><br><span class="line">					vector&lt;SOCKET&gt;::iterator iter = _clients.<span class="built_in">begin</span>()+n;<span class="comment">//找到退出客户端的地址</span></span><br><span class="line">					<span class="keyword">if</span>(iter != _clients.<span class="built_in">end</span>())<span class="comment">//如果是合理值</span></span><br><span class="line">					&#123;</span><br><span class="line">						_clients.<span class="built_in">erase</span>(iter);<span class="comment">//移除</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;空闲时间处理其他业务\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">	<span class="comment">//关闭客户端socket</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;_clients.<span class="built_in">size</span>(); ++n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">closesocket</span>(_clients[n]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//关闭socket</span></span><br><span class="line">	<span class="built_in">closesocket</span>(_mysocket); </span><br><span class="line">	<span class="comment">//清除windows socket 环境 </span></span><br><span class="line">	<span class="built_in">WSACleanup</span>(); </span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="comment">//关闭客户端socket</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;_clients.<span class="built_in">size</span>(); ++n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">close</span>(_clients[n]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//关闭socket/LINUX</span></span><br><span class="line">	<span class="built_in">close</span>(_mysocket);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;任务结束，程序已退出&quot;</span>); </span><br><span class="line">	 </span><br><span class="line">	<span class="built_in">getchar</span>(); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、移植过程中遇到的一些小问题"><a href="#四、移植过程中遇到的一些小问题" class="headerlink" title="四、移植过程中遇到的一些小问题"></a>四、移植过程中遇到的一些小问题</h1><h2 id="1-关于IP的问题"><a href="#1-关于IP的问题" class="headerlink" title="1.关于IP的问题"></a>1.关于IP的问题</h2><p>&emsp;&emsp;如果服务端在本机Windows环境下运行，客户端在VM虚拟机Linux环境下运行，则在Windows命令行上输入<strong>ipconfig</strong>命令。下面这一块数据下的IPv4地址即为客户端需要连接的IP。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">以太网适配器 VMware Network Adapter VMnet8:</span><br><span class="line"></span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">   本地链接 IPv6 地址. . . . . . . . : </span><br><span class="line">   IPv4 地址 . . . . . . . . . . . . : </span><br><span class="line">   子网掩码  . . . . . . . . . . . . : </span><br><span class="line">   默认网关. . . . . . . . . . . . . :</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果服务端在VM虚拟机Linux环境下运行，客户端在本机Windows环境下运行，则在Linux命令行上输入<strong>ifconfig</strong>命令。显示出来的数据中网卡的IP即为客户端需要连接的IP。</p>
<h2 id="2-关于端口的问题"><a href="#2-关于端口的问题" class="headerlink" title="2.关于端口的问题"></a>2.关于端口的问题</h2><p>&emsp;&emsp;如果你的服务端运行正常，客户端运行正常，本机双开客户端和服务端也运行正常，但本机与虚拟机各开一个却连接不上时，可能是服务端的端口未开放导致的。</p>
<ul>
<li>Windows环境下会主动提示，点击允许即可，如果还是不行就去网上搜。</li>
<li>Linux环境下相关命令如下：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">systemctl status firewalld 查看防火墙状态</span><br><span class="line"></span><br><span class="line">systemctl start firewalld 开启防火墙 </span><br><span class="line"></span><br><span class="line">systemctl stop firewalld 关闭防火墙 </span><br><span class="line"></span><br><span class="line">service firewalld start 开启防火墙 </span><br><span class="line"></span><br><span class="line">查看对外开放的<span class="number">8888</span>端口状态 yes/no</span><br><span class="line">firewall-cmd --query-port=<span class="number">8888</span>/tcp</span><br><span class="line"></span><br><span class="line">打开<span class="number">8888</span>端口</span><br><span class="line">firewall-cmd --add-port=<span class="number">8888</span>/tcp --permanent</span><br><span class="line"></span><br><span class="line">重载端口</span><br><span class="line">firewall-cmd --reload</span><br><span class="line"></span><br><span class="line">移除指定的<span class="number">8888</span>端口：</span><br><span class="line">firewall-cmd --permanent --remove-port=<span class="number">8888</span>/tcp</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++网络编程学习：源码的封装</title>
    <url>/2021/01/26/20210126_C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%BA%90%E7%A0%81%E7%9A%84%E5%B0%81%E8%A3%85/</url>
    <content><![CDATA[<ul>
<li>使用的语言为C&#x2F;C++</li>
<li>源码支持的平台为：Windows &#x2F; Linux</li>
</ul>
<h1 id="一、为何要进行封装操作"><a href="#一、为何要进行封装操作" class="headerlink" title="一、为何要进行封装操作"></a>一、为何要进行封装操作</h1><p>&emsp;&emsp;C++为面向对象编程语言，我们要以面向对象的思路进行源码的编写。<br>&emsp;&emsp;在对主要源码进行封装后，客户端与服务端的代码编写更加清晰明了，逻辑性更强，便于开发维护。且在今后的服务端高并发测试中，便于新建多个连接进行测试。<br>&emsp;&emsp;在本篇笔记中，我会<strong>基于笔记四的源码进行封装</strong>，并将记录我对客户端与服务端源码进行封装时的思路与步骤。最终源码为客户端封装类文件<strong>TcpClient.hpp</strong>与服务端封装类文件<strong>TcpServer.hpp</strong>，以及客户端源码<strong>client_test.cpp</strong>与服务端源码<strong>server_test.cpp</strong>。</p>
<span id="more"></span>

<h1 id="二、封装的思路与相关"><a href="#二、封装的思路与相关" class="headerlink" title="二、封装的思路与相关"></a>二、封装的思路与相关</h1><h2 id="1-封装的头文件选择"><a href="#1-封装的头文件选择" class="headerlink" title="1.封装的头文件选择"></a>1.封装的头文件选择</h2><p>&emsp;&emsp;封装类首先要在头文件中以体现封装性。在本次的封装中，为了能更方便的储存，我选择了<strong>hpp头文件</strong>。即类声明与类定义都在此文件中。</p>
<h2 id="2-客户端类的封装"><a href="#2-客户端类的封装" class="headerlink" title="2.客户端类的封装"></a>2.客户端类的封装</h2><p>&emsp;&emsp;首先，客户端的大致流程如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>建立socket</span><br><span class="line"><span class="number">2.</span>连接服务器</span><br><span class="line"><span class="number">3.</span>建立新线程 用于发送命令</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="number">4.</span>使用select函数获取服务器端是否有待处理事件</span><br><span class="line">	<span class="number">5.</span>如果有，就处理它(接收/发送)</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">6.</span>关闭socket</span><br><span class="line"></span><br><span class="line">新线程：</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="number">1.</span>键入数据</span><br><span class="line">	<span class="number">2.</span>发送数据</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;所以，我们需要封装的方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化socket</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">InitSocket</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//连接服务器 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Connect</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ip,<span class="type">unsigned</span> <span class="type">short</span> port)</span></span>;</span><br><span class="line"><span class="comment">//关闭socket</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CloseSocket</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//查询是否有待处理消息 </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">OnRun</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//判断是否工作中 </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsRun</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//发送数据 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SendData</span><span class="params">(DataHeader *_head)</span></span>;</span><br><span class="line"><span class="comment">//接收数据</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">RecvData</span><span class="params">(SOCKET _temp_socket)</span></span>;</span><br><span class="line"><span class="comment">//响应数据</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">NetMsg</span><span class="params">(DataHeader *_head)</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;按照此思路，客户端的源码思路为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span><span class="built_in">InitSocket</span>();<span class="comment">//建立socket</span></span><br><span class="line"><span class="number">2.</span><span class="built_in">Connect</span>(<span class="type">const</span> <span class="type">char</span> *ip,<span class="type">unsigned</span> <span class="type">short</span> port);<span class="comment">//连接服务器 传入IP与端口</span></span><br><span class="line"><span class="number">3.</span>建立新线程 用于发送命令</span><br><span class="line"><span class="keyword">while</span>(<span class="number">4.</span><span class="built_in">IsRun</span>())<span class="comment">//检测是否工作中</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="number">5.</span><span class="built_in">OnRun</span>();<span class="comment">//查询是否有待处理消息</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">6.</span><span class="built_in">CloseSocket</span>();<span class="comment">//关闭socket</span></span><br><span class="line"></span><br><span class="line">新线程：</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1.</span><span class="built_in">IsRun</span>())<span class="comment">//检测是否工作中</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="number">2.</span>键入数据</span><br><span class="line">	<span class="number">3.</span><span class="built_in">SendData</span>(DataHeader *_head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;其中，<strong>OnRun()</strong> 方法中使用的是select网络结构，在select筛选出待处理事件后，使用<strong>RecvData()</strong> 方法进行包头与包体的接收，随后调用<strong>NetMsg()</strong> 方法，依据包头的报文类型对包体数据进行处理。<strong>NetMsg()</strong> 方法为虚方法，在之后调用此封装类时，可以进行继承重载操作，便于对数据响应的操作进行变更。</p>
<ul>
<li>相关源码如下：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询是否有待处理消息 </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">OnRun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">IsRun</span>())<span class="comment">//如果有连接则监听事件 </span></span><br><span class="line">	&#123;</span><br><span class="line">		fd_set _fdRead;<span class="comment">//建立集合 </span></span><br><span class="line">		<span class="built_in">FD_ZERO</span>(&amp;_fdRead);<span class="comment">//清空集合  </span></span><br><span class="line">		<span class="built_in">FD_SET</span>(_sock,&amp;_fdRead);<span class="comment">//放入集合 </span></span><br><span class="line">		timeval <span class="type">_t</span> = &#123;<span class="number">1</span>,<span class="number">0</span>&#125;;<span class="comment">//select最大响应时间 </span></span><br><span class="line">		<span class="comment">//新建seclect </span></span><br><span class="line">		<span class="type">int</span> _ret = <span class="built_in">select</span>(_sock<span class="number">+1</span>,&amp;_fdRead,<span class="literal">NULL</span>,<span class="literal">NULL</span>,&amp;<span class="type">_t</span>);</span><br><span class="line">		<span class="keyword">if</span>(_ret&lt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;seclect任务结束\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(_sock,&amp;_fdRead))<span class="comment">//获取是否有可读socket </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">FD_CLR</span>(_sock,&amp;_fdRead);<span class="comment">//清理计数器 </span></span><br><span class="line">			<span class="keyword">if</span>(<span class="number">-1</span> == <span class="built_in">RecvData</span>(_sock))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">CloseSocket</span>();</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//接收数据</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">RecvData</span><span class="params">(SOCKET _temp_socket)</span><span class="comment">//处理数据 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//缓冲区 </span></span><br><span class="line">	<span class="type">char</span> buffer[<span class="number">4096</span>] = &#123;&#125;; </span><br><span class="line">	<span class="comment">//接收客户端发送的数据 </span></span><br><span class="line">	<span class="type">int</span> _buf_len = <span class="built_in">recv</span>(_temp_socket,buffer,<span class="built_in">sizeof</span>(DataHeader),<span class="number">0</span>);</span><br><span class="line">	DataHeader *_head = (DataHeader*)buffer; </span><br><span class="line">	<span class="keyword">if</span>(_buf_len&lt;=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;与服务器断开连接,任务结束\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">recv</span>(_temp_socket,buffer+<span class="built_in">sizeof</span>(DataHeader),_head-&gt;date_length-<span class="built_in">sizeof</span>(DataHeader),<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//响应数据 </span></span><br><span class="line">	<span class="built_in">NetMsg</span>(_head);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//响应数据</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">NetMsg</span><span class="params">(DataHeader *_head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;接收到包头，命令：%d，数据长度：%d\n&quot;</span>,_head-&gt;cmd,_head-&gt;date_length);</span><br><span class="line">	<span class="keyword">switch</span>(_head-&gt;cmd)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> CMD_LOGINRESULT:<span class="comment">//登录结果 接收登录包体 </span></span><br><span class="line">		&#123;</span><br><span class="line">			LoginResult *_result = (LoginResult*)_head; </span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;登录结果:%d\n&quot;</span>,_result-&gt;Result);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> CMD_LOGOUTRESULT:<span class="comment">//登出结果 接收登出包体 </span></span><br><span class="line">		&#123;</span><br><span class="line">			LogoutResult *_result = (LogoutResult*)_head; </span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;登录结果:%d\n&quot;</span>,_result-&gt;Result);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> CMD_NEW_USER_JOIN:<span class="comment">//新用户登录通知 </span></span><br><span class="line">		&#123;</span><br><span class="line">			NewUserJoin *_result = (NewUserJoin*)_head; </span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;用户:%s已登录\n&quot;</span>,_result-&gt;UserName);</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
&emsp;&emsp;另外，由于已经被封装，所以在调用方法时，可能会出现步骤错误的情况。例如还没进行新建套接字就进行connect连接操作或是关闭套接字操作、传入数据有误等等，此时就会出现问题。<br>&emsp;&emsp;我解决此类问题的方法是多加判定。例如判定套接字是否已经被建立，或是传入数据是否有误等等，随后根据情况进行处理。详细源码请看下文。</li>
</ul>
<h2 id="3-服务端类的封装"><a href="#3-服务端类的封装" class="headerlink" title="3.服务端类的封装"></a>3.服务端类的封装</h2><p>&emsp;&emsp;首先，客户端的大致流程如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>建立socket</span><br><span class="line"><span class="number">2.</span>绑定端口IP</span><br><span class="line"><span class="number">3.</span>监听端口</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="number">4.</span>使用select函数获取存在待监听事件的socket</span><br><span class="line">	<span class="number">5.</span>如果有新的连接则与新的客户端连接</span><br><span class="line">	<span class="number">6.</span>如果有待监听事件，则对其进行处理(接受与发送)</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">7.</span>关闭socket</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;所以，我们需要封装的方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化socket </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">InitSocket</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//绑定IP/端口</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Bind</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* ip,<span class="type">unsigned</span> <span class="type">short</span> port)</span></span>;</span><br><span class="line"><span class="comment">//监听端口</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Listen</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">//接受连接</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Accept</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//关闭socket </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CloseSocket</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//查询是否有待处理消息 </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">OnRun</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//判断是否工作中 </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsRun</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//发送数据 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SendData</span><span class="params">(DataHeader *_head,SOCKET _temp_socket)</span></span>;</span><br><span class="line"><span class="comment">//接收数据</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">RecvData</span><span class="params">(SOCKET _temp_socket)</span></span>;</span><br><span class="line"><span class="comment">//响应数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NetMsg</span><span class="params">(DataHeader *_head,SOCKET _temp_socket)</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;按照此思路，客户端的源码思路为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span><span class="built_in">InitSocket</span>();<span class="comment">//建立socket</span></span><br><span class="line"><span class="number">2.</span><span class="built_in">Bind</span>(<span class="type">const</span> <span class="type">char</span>* ip,<span class="type">unsigned</span> <span class="type">short</span> port);<span class="comment">//绑定端口IP</span></span><br><span class="line"><span class="number">3.L</span>isten(<span class="type">int</span> n);<span class="comment">//监听端口</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">4.</span><span class="built_in">IsRun</span>())<span class="comment">//是否工作中</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="number">5.</span><span class="built_in">OnRun</span>();<span class="comment">//查看是否有待处理消息</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">6.</span><span class="built_in">CloseSocket</span>();<span class="comment">//关闭socket</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;其中，<strong>OnRun()</strong> 方法中使用的是select网络结构。在select筛选出待处理事件后，如果为新连接，则使用<strong>Accept()</strong> 方法进行新客户端连接操作；如果为已连接客户端的待接受事件，则使用<strong>RecvData()</strong> 方法进行包头与包体的接收，随后调用<strong>NetMsg()</strong> 方法，依据包头的报文类型对包体数据进行处理。<strong>NetMsg()</strong> 方法为虚方法，在之后调用此封装类时，可以进行继承重载操作，便于对数据响应的操作进行变更。</p>
<ul>
<li>相关源码如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询是否有待处理消息 </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">OnRun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">IsRun</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		fd_set _fdRead;<span class="comment">//建立集合 </span></span><br><span class="line">		fd_set _fdWrite;</span><br><span class="line">		fd_set _fdExcept;</span><br><span class="line">		<span class="built_in">FD_ZERO</span>(&amp;_fdRead);<span class="comment">//清空集合 </span></span><br><span class="line">		<span class="built_in">FD_ZERO</span>(&amp;_fdWrite); </span><br><span class="line">		<span class="built_in">FD_ZERO</span>(&amp;_fdExcept); </span><br><span class="line">		<span class="built_in">FD_SET</span>(_sock,&amp;_fdRead);<span class="comment">//放入集合 </span></span><br><span class="line">		<span class="built_in">FD_SET</span>(_sock,&amp;_fdWrite); </span><br><span class="line">		<span class="built_in">FD_SET</span>(_sock,&amp;_fdExcept);</span><br><span class="line">		timeval <span class="type">_t</span> = &#123;<span class="number">2</span>,<span class="number">0</span>&#125;;<span class="comment">//select最大响应时间 </span></span><br><span class="line">		SOCKET _maxSock = _sock;<span class="comment">//最大socket </span></span><br><span class="line">		<span class="comment">//把连接的客户端 放入read集合 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> n=_clients.<span class="built_in">size</span>()<span class="number">-1</span>; n&gt;=<span class="number">0</span>; --n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">FD_SET</span>(_clients[n],&amp;_fdRead);</span><br><span class="line">			<span class="keyword">if</span>(_maxSock &lt; _clients[n])</span><br><span class="line">			&#123;</span><br><span class="line">				_maxSock = _clients[n];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//select函数筛选select </span></span><br><span class="line">		<span class="type">int</span> _ret = <span class="built_in">select</span>(_maxSock<span class="number">+1</span>,&amp;_fdRead,&amp;_fdWrite,&amp;_fdExcept,&amp;<span class="type">_t</span>); </span><br><span class="line">		<span class="keyword">if</span>(_ret&lt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;select任务结束\n&quot;</span>);</span><br><span class="line">			<span class="built_in">CloseSocket</span>();</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(_sock,&amp;_fdRead))<span class="comment">//获取是否有新socket连接 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">FD_CLR</span>(_sock,&amp;_fdRead);<span class="comment">//清理</span></span><br><span class="line">			<span class="built_in">Accept</span>();<span class="comment">//连接 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//遍历所有socket 查看是否有待处理事件 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;_clients.<span class="built_in">size</span>(); ++n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(_clients[n],&amp;_fdRead))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="number">-1</span> == <span class="built_in">RecvData</span>(_clients[n]))<span class="comment">//处理请求 客户端退出的话 </span></span><br><span class="line">				&#123;</span><br><span class="line">					std::vector&lt;SOCKET&gt;::iterator iter = _clients.<span class="built_in">begin</span>()+n;<span class="comment">//找到退出客户端的地址</span></span><br><span class="line">					<span class="keyword">if</span>(iter != _clients.<span class="built_in">end</span>())<span class="comment">//如果是合理值</span></span><br><span class="line">					&#123;</span><br><span class="line">						_clients.<span class="built_in">erase</span>(iter);<span class="comment">//移除</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//printf(&quot;空闲时间处理其他业务\n&quot;);</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//接收数据</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">RecvData</span><span class="params">(SOCKET _temp_socket)</span><span class="comment">//处理数据 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//缓冲区</span></span><br><span class="line">	<span class="type">char</span> buffer[<span class="number">4096</span>] = &#123;&#125;; </span><br><span class="line">	<span class="comment">//接收客户端发送的数据  </span></span><br><span class="line">	<span class="type">int</span> _buf_len = <span class="built_in">recv</span>(_temp_socket,buffer,<span class="built_in">sizeof</span>(DataHeader),<span class="number">0</span>);</span><br><span class="line">	DataHeader *_head = (DataHeader*)buffer;</span><br><span class="line">	<span class="keyword">if</span>(_buf_len&lt;=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;客户端已退出\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">recv</span>(_temp_socket,buffer+<span class="built_in">sizeof</span>(DataHeader),_head-&gt;date_length-<span class="built_in">sizeof</span>(DataHeader),<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//响应数据</span></span><br><span class="line">	<span class="built_in">NetMsg</span>(_head,_temp_socket); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//响应数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NetMsg</span><span class="params">(DataHeader *_head,SOCKET _temp_socket)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">&quot;接收到包头，命令：%d，数据长度：%d\n&quot;</span>,_head-&gt;cmd,_head-&gt;date_length);</span><br><span class="line">	<span class="keyword">switch</span>(_head-&gt;cmd)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> CMD_LOGIN:<span class="comment">//登录 接收登录包体 </span></span><br><span class="line">		&#123;</span><br><span class="line">			Login *_login = (Login*)_head;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			进行判断操作 </span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s已登录\n密码：%s\n&quot;</span>,_login-&gt;UserName,_login-&gt;PassWord); </span><br><span class="line">			LoginResult *_result = <span class="keyword">new</span> LoginResult;	</span><br><span class="line">			_result-&gt;Result = <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">SendData</span>(_result,_temp_socket);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> CMD_LOGOUT:<span class="comment">//登出 接收登出包体 </span></span><br><span class="line">		&#123;</span><br><span class="line">			Logout *_logout = (Logout*)_head;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			进行判断操作 </span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s已登出\n&quot;</span>,_logout-&gt;UserName); </span><br><span class="line">			LogoutResult *_result = <span class="keyword">new</span> <span class="built_in">LogoutResult</span>();</span><br><span class="line">			_result-&gt;Result = <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">SendData</span>(_result,_temp_socket);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:<span class="comment">//错误 </span></span><br><span class="line">		&#123;</span><br><span class="line">			_head-&gt;cmd = CMD_ERROR; </span><br><span class="line">			_head-&gt;date_length = <span class="number">0</span>; </span><br><span class="line">			<span class="built_in">SendData</span>(_head,_temp_socket); </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;另外，由于已经被封装，所以在调用方法时，可能会出现步骤错误的情况。例如还没进行新建套接字就进行bind绑定端口IP或是关闭套接字操作、传入数据有误等等，此时就会出现问题。<br>&emsp;&emsp;我解决此类问题的方法是多加判定。例如判定套接字是否已经被建立，或是传入数据是否有误等等，随后根据情况进行处理。详细源码请看下文。</p>
<h1 id="三、封装后的详细源码及其注释"><a href="#三、封装后的详细源码及其注释" class="headerlink" title="三、封装后的详细源码及其注释"></a>三、封装后的详细源码及其注释</h1><h2 id="1-客户端"><a href="#1-客户端" class="headerlink" title="1.客户端"></a>1.客户端</h2><h3 id="TcpClient-hpp"><a href="#TcpClient-hpp" class="headerlink" title="TcpClient.hpp"></a>TcpClient.hpp</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TcpClient_hpp_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TcpClient_hpp_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;winSock2.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>) </span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SOCKET int</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> INVALID_SOCKET (SOCKET)(~0)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SOCKET_ERROR (-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">//枚举类型记录命令 </span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">cmd</span> </span><br><span class="line">&#123;</span><br><span class="line">	CMD_LOGIN,<span class="comment">//登录 </span></span><br><span class="line">	CMD_LOGINRESULT,<span class="comment">//登录结果 </span></span><br><span class="line">	CMD_LOGOUT,<span class="comment">//登出 </span></span><br><span class="line">	CMD_LOGOUTRESULT,<span class="comment">//登出结果 </span></span><br><span class="line">	CMD_NEW_USER_JOIN,<span class="comment">//新用户登入 </span></span><br><span class="line">	CMD_ERROR<span class="comment">//错误 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义数据包头 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DataHeader</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">short</span> cmd;<span class="comment">//命令</span></span><br><span class="line">	<span class="type">short</span> date_length;<span class="comment">//数据的长短	</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包1 登录 传输账号与密码</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Login</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Login</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGIN;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Login); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">	<span class="type">char</span> PassWord[<span class="number">32</span>];<span class="comment">//密码 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包2 登录结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoginResult</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LoginResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGINRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LoginResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包3 登出 传输用户名 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Logout</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Logout</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Logout); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包4 登出结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LogoutResult</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LogoutResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUTRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LogoutResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包5 新用户登入 传输通告 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NewUserJoin</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">NewUserJoin</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_NEW_USER_JOIN;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(NewUserJoin); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TcpClient</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造 </span></span><br><span class="line">	<span class="built_in">TcpClient</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		_sock = INVALID_SOCKET; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//析构 </span></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">TcpClient</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//关闭socket </span></span><br><span class="line">		<span class="built_in">CloseSocket</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//初始化socket 返回1为正常 </span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">InitSocket</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">		<span class="comment">//启动windows socket 2,x环境 </span></span><br><span class="line">		WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>); </span><br><span class="line">		WSADATA dat;</span><br><span class="line">		<span class="keyword">if</span>(<span class="number">0</span> != <span class="built_in">WSAStartup</span>(ver,&amp;dat))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//-1为环境错误 </span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">		<span class="comment">//创建socket </span></span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET != _sock)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;&lt;Socket=%d&gt;关闭连接\n&quot;</span>,_sock); </span><br><span class="line">			<span class="built_in">CloseSocket</span>();<span class="comment">//如果之前有连接 就关闭连接 </span></span><br><span class="line">		&#125;</span><br><span class="line">		_sock = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,IPPROTO_TCP); </span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET == _sock)</span><br><span class="line">		&#123;   </span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//0为socket创建错误 </span></span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//连接服务器  返回1为成功 </span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Connect</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ip,<span class="type">unsigned</span> <span class="type">short</span> port)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//如果为无效套接字 则初始化 </span></span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET == _sock)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">InitSocket</span>(); </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//连接服务器</span></span><br><span class="line">	   	sockaddr_in _sin = &#123;&#125;;</span><br><span class="line">	   	_sin.sin_family = AF_INET;<span class="comment">//IPV4</span></span><br><span class="line">	   	_sin.sin_port = <span class="built_in">htons</span>(port);<span class="comment">//端口号 </span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">		_sin.sin_addr.S_un.S_addr =  <span class="built_in">inet_addr</span>(ip);<span class="comment">//IP </span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		_sin.sin_addr.s_addr =  <span class="built_in">inet_addr</span>(ip);<span class="comment">//IP </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">connect</span>(_sock,(sockaddr*)&amp;_sin,<span class="built_in">sizeof</span>(sockaddr_in)))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//连接失败 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//连接成功 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//关闭socket</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">CloseSocket</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET != _sock) </span><br><span class="line">		&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">			<span class="comment">//关闭socket</span></span><br><span class="line">			<span class="built_in">closesocket</span>(_sock); </span><br><span class="line">			<span class="comment">//清除windows socket 环境 </span></span><br><span class="line">			<span class="built_in">WSACleanup</span>(); </span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">			<span class="comment">//关闭socket/LINUX</span></span><br><span class="line">			<span class="built_in">close</span>(_sock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">			_sock = INVALID_SOCKET;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//查询是否有待处理消息 </span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">OnRun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">IsRun</span>())<span class="comment">//如果有连接则监听事件 </span></span><br><span class="line">		&#123;</span><br><span class="line">			fd_set _fdRead;<span class="comment">//建立集合 </span></span><br><span class="line">			<span class="built_in">FD_ZERO</span>(&amp;_fdRead);<span class="comment">//清空集合  </span></span><br><span class="line">			<span class="built_in">FD_SET</span>(_sock,&amp;_fdRead);<span class="comment">//放入集合 </span></span><br><span class="line">			timeval <span class="type">_t</span> = &#123;<span class="number">1</span>,<span class="number">0</span>&#125;;<span class="comment">//select最大响应时间 </span></span><br><span class="line">			<span class="comment">//新建seclect </span></span><br><span class="line">			<span class="type">int</span> _ret = <span class="built_in">select</span>(_sock<span class="number">+1</span>,&amp;_fdRead,<span class="literal">NULL</span>,<span class="literal">NULL</span>,&amp;<span class="type">_t</span>);</span><br><span class="line">			<span class="keyword">if</span>(_ret&lt;<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;seclect任务结束\n&quot;</span>);</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(_sock,&amp;_fdRead))<span class="comment">//获取是否有可读socket </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">FD_CLR</span>(_sock,&amp;_fdRead);<span class="comment">//清理计数器 </span></span><br><span class="line">				<span class="keyword">if</span>(<span class="number">-1</span> == <span class="built_in">RecvData</span>(_sock))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">CloseSocket</span>();</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;	</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//判断是否工作中 </span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">IsRun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _sock != INVALID_SOCKET; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//发送数据 </span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">SendData</span><span class="params">(DataHeader *_head)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">IsRun</span>() &amp;&amp; _head)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">send</span>(_sock,(<span class="type">const</span> <span class="type">char</span>*)_head,_head-&gt;date_length,<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//接收数据</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">RecvData</span><span class="params">(SOCKET _temp_socket)</span><span class="comment">//处理数据 </span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//缓冲区 </span></span><br><span class="line">		<span class="type">char</span> buffer[<span class="number">4096</span>] = &#123;&#125;; </span><br><span class="line">		<span class="comment">//接收客户端发送的数据 </span></span><br><span class="line">		<span class="type">int</span> _buf_len = <span class="built_in">recv</span>(_temp_socket,buffer,<span class="built_in">sizeof</span>(DataHeader),<span class="number">0</span>);</span><br><span class="line">		DataHeader *_head = (DataHeader*)buffer; </span><br><span class="line">		<span class="keyword">if</span>(_buf_len&lt;=<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;与服务器断开连接,任务结束\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="built_in">recv</span>(_temp_socket,buffer+<span class="built_in">sizeof</span>(DataHeader),_head-&gt;date_length-<span class="built_in">sizeof</span>(DataHeader),<span class="number">0</span>);</span><br><span class="line">		<span class="comment">//响应数据 </span></span><br><span class="line">		<span class="built_in">NetMsg</span>(_head);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//响应数据</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">NetMsg</span><span class="params">(DataHeader *_head)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;接收到包头，命令：%d，数据长度：%d\n&quot;</span>,_head-&gt;cmd,_head-&gt;date_length);</span><br><span class="line">		<span class="keyword">switch</span>(_head-&gt;cmd)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> CMD_LOGINRESULT:<span class="comment">//登录结果 接收登录包体 </span></span><br><span class="line">			&#123;</span><br><span class="line">				LoginResult *_result = (LoginResult*)_head; </span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;登录结果:%d\n&quot;</span>,_result-&gt;Result);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> CMD_LOGOUTRESULT:<span class="comment">//登出结果 接收登出包体 </span></span><br><span class="line">			&#123;</span><br><span class="line">				LogoutResult *_result = (LogoutResult*)_head; </span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;登录结果:%d\n&quot;</span>,_result-&gt;Result);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> CMD_NEW_USER_JOIN:<span class="comment">//新用户登录通知 </span></span><br><span class="line">			&#123;</span><br><span class="line">				NewUserJoin *_result = (NewUserJoin*)_head; </span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;用户:%s已登录\n&quot;</span>,_result-&gt;UserName);</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	SOCKET _sock;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="client-test-cpp"><a href="#client-test-cpp" class="headerlink" title="client_test.cpp"></a>client_test.cpp</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;TcpClient.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _cmdThread(TcpClient* tcp)<span class="comment">//命令线程 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(tcp-&gt;<span class="built_in">IsRun</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//输入请求 </span></span><br><span class="line">		<span class="type">char</span> _msg[<span class="number">256</span>] = &#123;&#125;;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,_msg);</span><br><span class="line">		<span class="comment">//处理请求 </span></span><br><span class="line">		<span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(_msg,<span class="string">&quot;exit&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			tcp-&gt;<span class="built_in">CloseSocket</span>();</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;程序退出\n&quot;</span>); </span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(_msg,<span class="string">&quot;login&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//发送 </span></span><br><span class="line">			Login _login;</span><br><span class="line">			<span class="built_in">strcpy</span>(_login.UserName,<span class="string">&quot;hbxxy&quot;</span>);</span><br><span class="line">			<span class="built_in">strcpy</span>(_login.PassWord,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">			tcp-&gt;<span class="built_in">SendData</span>(&amp;_login);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(_msg,<span class="string">&quot;logout&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//发送 </span></span><br><span class="line">			Logout _logout;</span><br><span class="line">			<span class="built_in">strcpy</span>(_logout.UserName,<span class="string">&quot;hbxxy&quot;</span>);</span><br><span class="line">			tcp-&gt;<span class="built_in">SendData</span>(&amp;_logout);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;不存在的命令\n&quot;</span>);</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Welcome\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//建立tcp对象 </span></span><br><span class="line">	TcpClient *tcp1 = <span class="keyword">new</span> <span class="built_in">TcpClient</span>();</span><br><span class="line">	<span class="comment">//建立一个socket </span></span><br><span class="line">	tcp1-&gt;<span class="built_in">InitSocket</span>();</span><br><span class="line">   	<span class="comment">//连接服务器</span></span><br><span class="line">   	tcp1-&gt;<span class="built_in">Connect</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8888</span>);</span><br><span class="line">	<span class="comment">//创建UI线程</span></span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(_cmdThread,tcp1)</span></span>;</span><br><span class="line">	t<span class="number">1.</span><span class="built_in">detach</span>();<span class="comment">//线程分离 </span></span><br><span class="line">	<span class="comment">//循环 </span></span><br><span class="line">	<span class="keyword">while</span>(tcp1-&gt;<span class="built_in">IsRun</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		tcp1-&gt;<span class="built_in">OnRun</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//关闭 </span></span><br><span class="line">	tcp1-&gt;<span class="built_in">CloseSocket</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h2 id="2-服务端"><a href="#2-服务端" class="headerlink" title="2.服务端"></a>2.服务端</h2><h3 id="TcpServer-hpp"><a href="#TcpServer-hpp" class="headerlink" title="TcpServer.hpp"></a>TcpServer.hpp</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TcpServer_hpp_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TcpServer_hpp_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;winSock2.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//链接此动态链接库 windows特有 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span><span class="comment">//selcet</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span><span class="comment">//uni std</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SOCKET int</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> INVALID_SOCKET (SOCKET)(~0)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SOCKET_ERROR (-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">//枚举类型记录命令 </span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">cmd</span> </span><br><span class="line">&#123;</span><br><span class="line">	CMD_LOGIN,<span class="comment">//登录 </span></span><br><span class="line">	CMD_LOGINRESULT,<span class="comment">//登录结果 </span></span><br><span class="line">	CMD_LOGOUT,<span class="comment">//登出 </span></span><br><span class="line">	CMD_LOGOUTRESULT,<span class="comment">//登出结果 </span></span><br><span class="line">	CMD_NEW_USER_JOIN,<span class="comment">//新用户登入 </span></span><br><span class="line">	CMD_ERROR<span class="comment">//错误 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义数据包头 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DataHeader</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">short</span> cmd;<span class="comment">//命令</span></span><br><span class="line">	<span class="type">short</span> date_length;<span class="comment">//数据的长短	</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包1 登录 传输账号与密码</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Login</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Login</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGIN;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Login); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">	<span class="type">char</span> PassWord[<span class="number">32</span>];<span class="comment">//密码 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包2 登录结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoginResult</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LoginResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGINRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LoginResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包3 登出 传输用户名 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Logout</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Logout</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Logout); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包4 登出结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LogoutResult</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LogoutResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUTRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LogoutResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包5 新用户登入 传输通告 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NewUserJoin</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">NewUserJoin</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_NEW_USER_JOIN;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(NewUserJoin); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TcpServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造 </span></span><br><span class="line">	<span class="built_in">TcpServer</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		_sock = INVALID_SOCKET; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//析构 </span></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">TcpServer</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//关闭socket </span></span><br><span class="line">		<span class="built_in">CloseSocket</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//初始化socket 返回1为正常 </span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">InitSocket</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">		<span class="comment">//启动windows socket 2,x环境 </span></span><br><span class="line">		WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>); </span><br><span class="line">		WSADATA dat;</span><br><span class="line">		<span class="keyword">if</span>(<span class="number">0</span> != <span class="built_in">WSAStartup</span>(ver,&amp;dat))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//-1为环境错误 </span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">		<span class="comment">//创建socket </span></span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET != _sock)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;&lt;Socket=%d&gt;关闭连接\n&quot;</span>,_sock); </span><br><span class="line">			<span class="built_in">CloseSocket</span>();<span class="comment">//如果之前有连接 就关闭连接 </span></span><br><span class="line">		&#125;</span><br><span class="line">		_sock = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,IPPROTO_TCP); </span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET == _sock)</span><br><span class="line">		&#123;   </span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//0为socket创建错误 </span></span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//绑定IP/端口</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Bind</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* ip,<span class="type">unsigned</span> <span class="type">short</span> port)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//如果为无效套接字 则初始化 </span></span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET == _sock)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">InitSocket</span>(); </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//绑定网络端口和IP地址 </span></span><br><span class="line">		sockaddr_in _myaddr = &#123;&#125;; </span><br><span class="line">		_myaddr.sin_family = AF_INET;<span class="comment">//IPV4</span></span><br><span class="line">		_myaddr.sin_port = <span class="built_in">htons</span>(port);<span class="comment">//端口</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">		<span class="keyword">if</span>(ip)<span class="comment">//ip为空则监听所有网卡 </span></span><br><span class="line">		&#123;</span><br><span class="line">			_myaddr.sin_addr.S_un.S_addr = <span class="built_in">inet_addr</span>(ip);<span class="comment">//IP</span></span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			_myaddr.sin_addr.S_un.S_addr = INADDR_ANY;<span class="comment">//IP</span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		<span class="keyword">if</span>(ip)<span class="comment">//ip为空则监听所有网卡</span></span><br><span class="line">		&#123;</span><br><span class="line">			_myaddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(ip);<span class="comment">//IP </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			_myaddr.sin_addr.s_addr = INADDR_ANY;<span class="comment">//IP </span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">bind</span>(_sock,(sockaddr*)&amp;_myaddr,<span class="built_in">sizeof</span>(sockaddr_in)))<span class="comment">//socket (强制转换)sockaddr结构体 结构体大小 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;绑定失败\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;绑定成功\n绑定端口为%d\n&quot;</span>,port);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//监听端口</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Listen</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//如果为无效套接字 则提示 </span></span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET == _sock)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;请先初始化套接字并绑定IP端口\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//监听网络端口</span></span><br><span class="line">		<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">listen</span>(_sock,n))<span class="comment">//最大连接队列 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;监听失败\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;监听成功\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//接受连接</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Accept</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//等待接收客户端连接</span></span><br><span class="line">		sockaddr_in _clientAddr = &#123;&#125;;<span class="comment">//新建sockadd结构体接收客户端数据 </span></span><br><span class="line">		<span class="type">int</span> _addr_len = <span class="built_in">sizeof</span>(sockaddr_in);<span class="comment">//获取sockadd结构体长度 </span></span><br><span class="line">		SOCKET _temp_socket = INVALID_SOCKET;<span class="comment">//声明客户端套接字 </span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32	</span></span><br><span class="line">		_temp_socket = <span class="built_in">accept</span>(_sock,(sockaddr*)&amp;_clientAddr,&amp;_addr_len);<span class="comment">//自身套接字 客户端结构体 结构体大小 	</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		_temp_socket = <span class="built_in">accept</span>(_sock,(sockaddr*)&amp;_clientAddr,(<span class="type">socklen_t</span>*)&amp;_addr_len);<span class="comment">//自身套接字 客户端结构体 结构体大小 </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET == _temp_socket)<span class="comment">//接收失败 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;&lt;Socket=%d&gt;错误,接受到无效客户端SOCKET\n&quot;</span>,_temp_socket);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123; </span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;新客户端加入\nIP地址为：%s \n&quot;</span>, <span class="built_in">inet_ntoa</span>(_clientAddr.sin_addr));  </span><br><span class="line">			<span class="comment">//群发所有客户端 通知新用户登录 </span></span><br><span class="line">			NewUserJoin _user_join; </span><br><span class="line">			<span class="built_in">strcpy</span>(_user_join.UserName,<span class="built_in">inet_ntoa</span>(_clientAddr.sin_addr));</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>;n&lt;_clients.<span class="built_in">size</span>();++n)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">send</span>(_clients[n],(<span class="type">const</span> <span class="type">char</span>*)&amp;_user_join,<span class="built_in">sizeof</span>(NewUserJoin),<span class="number">0</span>);	</span><br><span class="line">			&#125; </span><br><span class="line">			<span class="comment">//将新的客户端加入动态数组</span></span><br><span class="line">			_clients.<span class="built_in">push_back</span>(_temp_socket); </span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//关闭socket </span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">CloseSocket</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET != _sock) </span><br><span class="line">		&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">			<span class="comment">//关闭客户端socket</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;_clients.<span class="built_in">size</span>(); ++n)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">closesocket</span>(_clients[n]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//关闭socket</span></span><br><span class="line">			<span class="built_in">closesocket</span>(_sock); </span><br><span class="line">			<span class="comment">//清除windows socket 环境 </span></span><br><span class="line">			<span class="built_in">WSACleanup</span>(); </span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">			<span class="comment">//关闭客户端socket</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;_clients.<span class="built_in">size</span>(); ++n)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">close</span>(_clients[n]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//关闭socket/LINUX</span></span><br><span class="line">			<span class="built_in">close</span>(_sock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">			_sock = INVALID_SOCKET;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//查询是否有待处理消息 </span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">OnRun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">IsRun</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			fd_set _fdRead;<span class="comment">//建立集合 </span></span><br><span class="line">			fd_set _fdWrite;</span><br><span class="line">			fd_set _fdExcept;</span><br><span class="line">			<span class="built_in">FD_ZERO</span>(&amp;_fdRead);<span class="comment">//清空集合 </span></span><br><span class="line">			<span class="built_in">FD_ZERO</span>(&amp;_fdWrite); </span><br><span class="line">			<span class="built_in">FD_ZERO</span>(&amp;_fdExcept); </span><br><span class="line">			<span class="built_in">FD_SET</span>(_sock,&amp;_fdRead);<span class="comment">//放入集合 </span></span><br><span class="line">			<span class="built_in">FD_SET</span>(_sock,&amp;_fdWrite); </span><br><span class="line">			<span class="built_in">FD_SET</span>(_sock,&amp;_fdExcept);</span><br><span class="line">			timeval <span class="type">_t</span> = &#123;<span class="number">2</span>,<span class="number">0</span>&#125;;<span class="comment">//select最大响应时间 </span></span><br><span class="line">			SOCKET _maxSock = _sock;<span class="comment">//最大socket </span></span><br><span class="line">			<span class="comment">//把连接的客户端 放入read集合 </span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> n=_clients.<span class="built_in">size</span>()<span class="number">-1</span>; n&gt;=<span class="number">0</span>; --n)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">FD_SET</span>(_clients[n],&amp;_fdRead);</span><br><span class="line">				<span class="keyword">if</span>(_maxSock &lt; _clients[n])</span><br><span class="line">				&#123;</span><br><span class="line">					_maxSock = _clients[n];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//select函数筛选select </span></span><br><span class="line">			<span class="type">int</span> _ret = <span class="built_in">select</span>(_maxSock<span class="number">+1</span>,&amp;_fdRead,&amp;_fdWrite,&amp;_fdExcept,&amp;<span class="type">_t</span>); </span><br><span class="line">			<span class="keyword">if</span>(_ret&lt;<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;select任务结束\n&quot;</span>);</span><br><span class="line">				<span class="built_in">CloseSocket</span>();</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(_sock,&amp;_fdRead))<span class="comment">//获取是否有新socket连接 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">FD_CLR</span>(_sock,&amp;_fdRead);<span class="comment">//清理</span></span><br><span class="line">				<span class="built_in">Accept</span>();<span class="comment">//连接 </span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//遍历所有socket 查看是否有待处理事件 </span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;_clients.<span class="built_in">size</span>(); ++n)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(_clients[n],&amp;_fdRead))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(<span class="number">-1</span> == <span class="built_in">RecvData</span>(_clients[n]))<span class="comment">//处理请求 客户端退出的话 </span></span><br><span class="line">					&#123;</span><br><span class="line">						std::vector&lt;SOCKET&gt;::iterator iter = _clients.<span class="built_in">begin</span>()+n;<span class="comment">//找到退出客户端的地址</span></span><br><span class="line">						<span class="keyword">if</span>(iter != _clients.<span class="built_in">end</span>())<span class="comment">//如果是合理值</span></span><br><span class="line">						&#123;</span><br><span class="line">							_clients.<span class="built_in">erase</span>(iter);<span class="comment">//移除</span></span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//printf(&quot;空闲时间处理其他业务\n&quot;);</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//判断是否工作中 </span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">IsRun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _sock != INVALID_SOCKET; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//发送数据 </span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">SendData</span><span class="params">(DataHeader *_head,SOCKET _temp_socket)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">IsRun</span>() &amp;&amp; _head)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">send</span>(_temp_socket,(<span class="type">const</span> <span class="type">char</span>*)_head,_head-&gt;date_length,<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//接收数据</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">RecvData</span><span class="params">(SOCKET _temp_socket)</span><span class="comment">//处理数据 </span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//缓冲区</span></span><br><span class="line">		<span class="type">char</span> buffer[<span class="number">4096</span>] = &#123;&#125;; </span><br><span class="line">		<span class="comment">//接收客户端发送的数据  </span></span><br><span class="line">		<span class="type">int</span> _buf_len = <span class="built_in">recv</span>(_temp_socket,buffer,<span class="built_in">sizeof</span>(DataHeader),<span class="number">0</span>);</span><br><span class="line">		DataHeader *_head = (DataHeader*)buffer;</span><br><span class="line">		<span class="keyword">if</span>(_buf_len&lt;=<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;客户端已退出\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="built_in">recv</span>(_temp_socket,buffer+<span class="built_in">sizeof</span>(DataHeader),_head-&gt;date_length-<span class="built_in">sizeof</span>(DataHeader),<span class="number">0</span>);</span><br><span class="line">		<span class="comment">//响应数据</span></span><br><span class="line">		<span class="built_in">NetMsg</span>(_head,_temp_socket); </span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//响应数据</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">NetMsg</span><span class="params">(DataHeader *_head,SOCKET _temp_socket)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	 	<span class="built_in">printf</span>(<span class="string">&quot;接收到包头，命令：%d，数据长度：%d\n&quot;</span>,_head-&gt;cmd,_head-&gt;date_length);</span><br><span class="line">		<span class="keyword">switch</span>(_head-&gt;cmd)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> CMD_LOGIN:<span class="comment">//登录 接收登录包体 </span></span><br><span class="line">			&#123;</span><br><span class="line">				Login *_login = (Login*)_head;</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				进行判断操作 </span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%s已登录\n密码：%s\n&quot;</span>,_login-&gt;UserName,_login-&gt;PassWord); </span><br><span class="line">				LoginResult *_result = <span class="keyword">new</span> LoginResult;	</span><br><span class="line">				_result-&gt;Result = <span class="number">1</span>;</span><br><span class="line">				<span class="built_in">SendData</span>(_result,_temp_socket);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> CMD_LOGOUT:<span class="comment">//登出 接收登出包体 </span></span><br><span class="line">			&#123;</span><br><span class="line">				Logout *_logout = (Logout*)_head;</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				进行判断操作 </span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%s已登出\n&quot;</span>,_logout-&gt;UserName); </span><br><span class="line">				LogoutResult *_result = <span class="keyword">new</span> <span class="built_in">LogoutResult</span>();</span><br><span class="line">				_result-&gt;Result = <span class="number">1</span>;</span><br><span class="line">				<span class="built_in">SendData</span>(_result,_temp_socket);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:<span class="comment">//错误 </span></span><br><span class="line">			&#123;</span><br><span class="line">				_head-&gt;cmd = CMD_ERROR; </span><br><span class="line">				_head-&gt;date_length = <span class="number">0</span>; </span><br><span class="line">				<span class="built_in">SendData</span>(_head,_temp_socket); </span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	 </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	SOCKET _sock; </span><br><span class="line">	std::vector&lt;SOCKET&gt; _clients;<span class="comment">//储存客户端socket</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="server-test-cpp"><a href="#server-test-cpp" class="headerlink" title="server_test.cpp"></a>server_test.cpp</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;TcpServer.hpp&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Welcome\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//建立tcp对象 </span></span><br><span class="line">	TcpServer *tcp1 = <span class="keyword">new</span> <span class="built_in">TcpServer</span>();</span><br><span class="line">	<span class="comment">//建立一个socket</span></span><br><span class="line">	tcp1-&gt;<span class="built_in">InitSocket</span>();</span><br><span class="line">	<span class="comment">//绑定端口和IP</span></span><br><span class="line">	tcp1-&gt;<span class="built_in">Bind</span>(<span class="literal">NULL</span>,<span class="number">8888</span>);</span><br><span class="line">	<span class="comment">//监听</span></span><br><span class="line">	tcp1-&gt;<span class="built_in">Listen</span>(<span class="number">5</span>);</span><br><span class="line">	<span class="comment">//循环 </span></span><br><span class="line">	<span class="keyword">while</span>(tcp1-&gt;<span class="built_in">IsRun</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		tcp1-&gt;<span class="built_in">OnRun</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//关闭</span></span><br><span class="line">	tcp1-&gt;<span class="built_in">CloseSocket</span>();</span><br><span class="line">	 </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;任务结束，程序已退出&quot;</span>); </span><br><span class="line">	<span class="built_in">getchar</span>(); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>KeepAlive小项目 基于Qt/C++实现后台自动提醒休息</title>
    <url>/2021/01/29/20210129_KeepAlive%E5%B0%8F%E9%A1%B9%E7%9B%AE%E5%9F%BA%E4%BA%8EQt-C++%E5%AE%9E%E7%8E%B0%E5%90%8E%E5%8F%B0%E8%87%AA%E5%8A%A8%E6%8F%90%E9%86%92%E4%BC%91%E6%81%AF/</url>
    <content><![CDATA[<p>&emsp;&emsp;前两天在blink上发的思路，花了一天时间给实现了 。不得不说，好久没写Qt程序，手生了不少，要不应该可以更有效率的。</p>
<h1 id="一、功能"><a href="#一、功能" class="headerlink" title="一、功能"></a>一、功能</h1><p>主要实现以下功能：</p>
<ul>
<li>显示当前系统时间</li>
<li>给定一个定期提醒时间间隔，显示离提醒还有多久</li>
<li>显示程序运行以来经过的时间</li>
<li>可最小化到托盘，实现后台运行</li>
<li>当达到提醒时间间隔后，弹窗提醒</li>
</ul>
<span id="more"></span>

<p>辅助功能：</p>
<ul>
<li>可手动输入，调整时间间隔</li>
<li>可自动创建桌面快捷方式</li>
<li>关于</li>
</ul>
<h1 id="二、详细介绍"><a href="#二、详细介绍" class="headerlink" title="二、详细介绍"></a>二、详细介绍</h1><p><strong>程序主界面</strong>（下图），可见有三个菜单按钮<br><img src="/images/2021-01-29/1.jpg" alt="程序主界面"></p>
<ul>
<li><strong>在点击程序右上角退出键后</strong>，程序会进入托盘最小化，在后台运行。（如下图）<br><img src="/images/2021-01-29/2.jpg" alt="2"><br>同时会弹出通知。<br><img src="/images/2021-01-29/3.jpg" alt="在这里插入图片描述"></li>
<li>此时左键单击托盘图标，弹出提示提醒时间。<br><img src="/images/2021-01-29/4.jpg" alt="在这里插入图片描述"></li>
<li>左键双击，即可显示主窗口。</li>
<li>鼠标右键单击，显示菜单，可令程序退出。</li>
</ul>
<p><strong>第一个菜单</strong>点开后分别为：创建快捷方式、设置相关参数、退出。</p>
<ul>
<li><p><strong>创建快捷方式</strong> 点击后弹窗，点击确定后随即在桌面建立快捷方式。（如下图）<br><img src="/images/2021-01-29/5.jpg" alt="1">  <img src="/images/2021-01-29/6.jpg" alt="在这里插入图片描述"></p>
</li>
<li><p><strong>设置相关参数</strong> 点击后弹窗，可以修改时间间隔参数，范围为1~86400秒。（如下图）<br><img src="/images/2021-01-29/7.jpg" alt="设置相关参数"><br>输入不正确值后会进行提醒。（如下图）<br><img src="/images/2021-01-29/8.jpg" alt="2"><br>当输入正确值后，计时会重置。</p>
</li>
<li><p><strong>退出</strong>，点击退出后，程序彻底退出，不会进入托盘最小化。</p>
</li>
</ul>
<p>第三个菜单内容为显示切换，点击后即可进行切换操作</p>
<ul>
<li>当前系统时间<br><img src="/images/2021-01-29/9.jpg" alt="1"></li>
<li>提醒时间倒计时<br><img src="/images/2021-01-29/10.jpg" alt="在这里插入图片描述"></li>
<li>系统(软件)开启时间<br><img src="/images/2021-01-29/11.jpg" alt="在这里插入图片描述"></li>
</ul>
<p>当倒计时为0时，显示窗口进行提醒。<br><img src="/images/2021-01-29/12.jpg" alt="在这里插入图片描述"></p>
<h1 id="三、源码下载"><a href="#三、源码下载" class="headerlink" title="三、源码下载"></a>三、源码下载</h1><p><a href="https://download.csdn.net/download/qq_45698148/14956361">点我下载</a></p>
<h1 id="四、可执行文件下载"><a href="#四、可执行文件下载" class="headerlink" title="四、可执行文件下载"></a>四、可执行文件下载</h1><p><a href="https://wws.lanzoui.com/iN4jGl1q6ji">点我下载</a> 密码：6eo1</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习记录：多线程相关</title>
    <url>/2021/01/31/20210131_C++%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>&emsp;&emsp;之前学过一点C语言多线程方面的内容(<code>pthread.h</code>)，但是仅仅是会用，对多线程的实现原理什么的基本上算是不了解。接下来，我的网络编程学习要进一步对代码进行优化，其中肯定少不了对多线程的运用，所以在进行下一步之前，先系统的学习一下多线程。<br>&emsp;&emsp;本篇学习记录使用的语言为C++，调用的线程库为C++11里的<code>std::thread</code>库。</p>
<span id="more"></span>

<h1 id="零、基本概念"><a href="#零、基本概念" class="headerlink" title="零、基本概念"></a>零、基本概念</h1><p>&emsp;&emsp;一个进程可以有多个线程，而一个线程只能属于一个进程。</p>
<p>&emsp;&emsp;单核CPU的多线程执行为每条线程代码执行一段时间后进行切换，实际还是为同时进行一条线程，因为切换的速度很快，给人一种同时进行的错觉；而多核CPU的多线程执行为同时进行多条线程，当线程数量大于核数量时，也会进行线程的切换，保证线程的进行。</p>
<p>&emsp;&emsp;多线程的执行是抢占式的，即多条线程下，没有运行顺序的规律，</p>
<h1 id="一、基本线程创建-thread"><a href="#一、基本线程创建-thread" class="headerlink" title="一、基本线程创建 thread"></a>一、基本线程创建 <code>thread</code></h1><p>如下所示，新建一个thread对象，构造函数传参第一个为线程执行函数，随后为执行函数的传参。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">thread *t1 = <span class="keyword">new</span> <span class="built_in">thread</span>(work,<span class="number">1111</span>);  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>;n&lt;a;n++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如下所示，新建一个thread数组，构造函数传参第一个为线程执行函数，随后为执行函数的传参。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">thread *t[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>;n&lt;<span class="number">4</span>;n++)</span><br><span class="line">&#123;</span><br><span class="line">	t[n] = <span class="keyword">new</span> <span class="built_in">thread</span>(work,n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>;n&lt;a;n++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="二、等待-分离-join-detach"><a href="#二、等待-分离-join-detach" class="headerlink" title="二、等待&#x2F;分离 join/detach"></a>二、等待&#x2F;分离 <code>join/detach</code></h1><p>&emsp;&emsp;join是在main函数中等待线程执行完才继续执行main函数，detach则是把该线程分离出来，不管这个线程执行得怎样，往下继续执行main函数。</p>
<ul>
<li>join操作会等待线程执行完毕，然后回收该线程资源；detach操作则不会等待线程完成，线程资源的回收由init进程完成。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">thread *t[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>;n&lt;<span class="number">4</span>;n++)</span><br><span class="line">&#123;</span><br><span class="line">	t[n] = <span class="keyword">new</span> <span class="built_in">thread</span>(work,n);</span><br><span class="line">	t[n]-&gt;<span class="built_in">detach</span>();<span class="comment">//线程分离</span></span><br><span class="line">	t[n]-&gt;<span class="built_in">join</span>();<span class="comment">//线程不分离</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、锁-lock-unlock"><a href="#三、锁-lock-unlock" class="headerlink" title="三、锁 lock/unlock"></a>三、锁 <code>lock/unlock</code></h1><p>&emsp;&emsp;由于线程的执行是抢占式的，且变量资源等是共享的，对于多条线程同时执行的情况下，可能对同一段内容同时执行，其中涉及到的变量操作等就会产生错误。类似同时对一个变量进行运算操作，由于赋值前的值不同，结果也就不同，导致数据出现问题。此时就可以使用锁的操作防止此类错误发生。</p>
<ul>
<li>上锁的区域同时只能被一条线程执行，由此来解决同时执行造成错误的问题。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span><span class="comment">//锁的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">mutex m;<span class="comment">//锁的变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>;n&lt;<span class="number">4</span>;n++)</span><br><span class="line">	&#123;</span><br><span class="line">		m.<span class="built_in">lock</span>();<span class="comment">//临界区域 开始 锁掉相关区域 避免同时调用printf操作导致打印混乱</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br><span class="line">		m.<span class="built_in">unlock</span>();<span class="comment">//临界区域 结束 解锁</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
</ul>
<p>&emsp;&emsp;但是不停的上锁和解锁很容易忘记解锁，就会出现该段代码无法被执行，导致程序出现问题，且不会报错。为了避免这种情况，我们可以使用自解锁。自解锁会自动对所处区间的代码进行上锁和解锁操作，从而防止忘解锁的情况发生。</p>
<ul>
<li>自解锁的大致原理其实就是构造器进行上锁，析构器进行解锁…<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span><span class="comment">//锁的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">mutex m;<span class="comment">//锁的变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>;n&lt;<span class="number">4</span>;n++)</span><br><span class="line">	&#123;</span><br><span class="line">		lock_guard&lt;mutex&gt;<span class="built_in">lock1</span>(m); <span class="comment">//自解锁</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="四、原子操作-atomic"><a href="#四、原子操作-atomic" class="headerlink" title="四、原子操作 atomic"></a>四、原子操作 <code>atomic</code></h1><p>&emsp;&emsp;频繁的上锁解锁操作会非常耗时，如果上锁区域执行的代码很少的话会非常不划算。如果我们在多线程中需要对变量操作的话，频繁的给变量操作区域上下锁性价比很低，此时我们可以使用<strong>原子变量</strong>。</p>
<ul>
<li>原子变量同时只能被一条线程操作，相比读写锁，速度快了不止一个量级。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;atomic&gt;</span><span class="comment">//原子操作</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">atomic_int <span class="title">count</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">//原子变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>;n&lt;<span class="number">2</span>;n++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;other thread:%d\n&quot;</span>,a);</span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	thread *t[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>;n&lt;<span class="number">4</span>;n++)</span><br><span class="line">	&#123;</span><br><span class="line">		t[n] = <span class="keyword">new</span> <span class="built_in">thread</span>(work,n);</span><br><span class="line">		t[n]-&gt;<span class="built_in">join</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>;n&lt;<span class="number">2</span>;n++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;main thread\n&quot;</span>);</span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;count;</span><br><span class="line">		<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++标准库学习</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习记录：基于chrono库的高精度计时器</title>
    <url>/2021/02/05/20210205_C++%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E5%9F%BA%E4%BA%8Echrono%E5%BA%93%E7%9A%84%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%AE%A1%E6%97%B6%E5%99%A8/</url>
    <content><![CDATA[<p>&emsp;&emsp;C++11中新引入了<code>std::chrono</code>库，由此可以较为容易的实现一个计时器。同时，休眠操作也可以通过这个库来实现，从而使代码有良好的跨平台性，避免使用Windows&#x2F;Linux的系统休眠函数。<br>&emsp;&emsp;在接下来的网络编程学习中，将引入该计时器，实现对每秒收包、连接等数据的计数显示。<br>&emsp;&emsp;本篇学习记录使用的语言为C++，调用的库为C++11里的<code>std::chrono</code>库。</p>
<span id="more"></span>

<h1 id="一、简易的计时器类"><a href="#一、简易的计时器类" class="headerlink" title="一、简易的计时器类"></a>一、简易的计时器类</h1><p><code>mytimer.hpp</code>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MY_TIMER_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_TIMER_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mytimer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::chrono::steady_clock::time_point _begin;<span class="comment">//起始时间</span></span><br><span class="line">    std::chrono::steady_clock::time_point _end;<span class="comment">//终止时间</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">mytimer</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		_begin = std::chrono::steady_clock::<span class="built_in">time_point</span>();</span><br><span class="line">		_end = std::chrono::steady_clock::<span class="built_in">time_point</span>();</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">mytimer</span>()&#123;&#125;;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用update时，使起始时间等于当前时间</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">UpDate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _begin = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用getsecond方法时，经过的时间为当前时间减去之前统计过的起始时间。</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">GetSecond</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _end = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">        <span class="comment">//使用duration类型变量进行时间的储存   duration_cast是类型转换方法</span></span><br><span class="line">        std::chrono::duration&lt;<span class="type">double</span>&gt; temp = std::chrono::duration_cast&lt;std::chrono::duration&lt;<span class="type">double</span>&gt;&gt;(_end - _begin);</span><br><span class="line">       	<span class="keyword">return</span> temp.<span class="built_in">count</span>();<span class="comment">//count() 获取当前时间的计数数量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>测试该计时器的代码示例 <code>main.cpp</code> 代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;mytimer.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	mytimer _time;</span><br><span class="line">	_time.<span class="built_in">UpDate</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>;n&lt;<span class="number">100000000</span>;n++)</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	std::cout&lt;&lt;_time.<span class="built_in">GetSecond</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、基于chrono库的休眠"><a href="#二、基于chrono库的休眠" class="headerlink" title="二、基于chrono库的休眠"></a>二、基于chrono库的休眠</h1><p>使用方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::<span class="function">chrono::milliseconds <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;<span class="comment">//休眠一毫秒 </span></span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(t);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++标准库学习</tag>
      </tags>
  </entry>
  <entry>
    <title>C++网络编程学习：缓冲区溢出与粘包分包</title>
    <url>/2021/01/28/20210128_C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E4%B8%8E%E7%B2%98%E5%8C%85%E5%88%86%E5%8C%85/</url>
    <content><![CDATA[<ul>
<li>使用的语言为C&#x2F;C++</li>
<li>源码支持的平台为：Windows &#x2F; Linux</li>
</ul>
<h1 id="一、关于缓冲区溢出"><a href="#一、关于缓冲区溢出" class="headerlink" title="一、关于缓冲区溢出"></a>一、关于缓冲区溢出</h1><h2 id="1-缓冲区溢出的原因"><a href="#1-缓冲区溢出的原因" class="headerlink" title="1.缓冲区溢出的原因"></a>1.缓冲区溢出的原因</h2><p>&emsp;&emsp;之前我们所编写的服务端与客户端的数据量都是很小的，且操作也不频繁，需要键入指令发送报文。</p>
<p>&emsp;&emsp;我们可以尝试在之前客户端代码的循环里，不断发送一种数据包，且把数据包的大小加大到1000字节，会发现很快服务端和客户端就会出现问题——要么是数据接收出现问题，要么是服务端或者客户端程序直接卡掉。这里出现问题的原因就是socket内核缓冲区溢出。</p>
<span id="more"></span>

<p>&emsp;&emsp;首先，send和recv函数并不是直接通过网卡操作。在使用send函数时，send函数首先把数据写入到<strong>发送缓冲区</strong>，随后通过网卡发出；在使用recv函数时，网卡首先把接收到的消息写入<strong>接收缓冲区</strong>，recv函数再从中copy数据。<strong>注意</strong>，上文中的两个缓冲区是存在于内核中的，并不是程序中自定义的缓冲区。</p>
<p>&emsp;&emsp;我们在之前的源码中，recv的逻辑是先接收包头，随后根据包头接收包体。而当网卡接收数据太多时，我们接收一个包头的时间，网卡可能就新接收了两个完整的数据包，这就导致内核接收缓冲区里的数据量是在不断增加的，最终导致接收缓冲区溢出，造成无法正常发送以及程序阻塞的问题。</p>
<p>&emsp;&emsp;举个例子，缓冲区就像一个浴缸，而我们是一个拿盆子舀水的人。我们之前先接收一个包头就相当于舀出一个包头那么多的水，随后再舀出包体那么多的水。舀了两次仅仅舀出一个报文那么多的水。如果浴缸放水的速度比较大的话，我们很容易就会处理不过来。最终造成浴缸溢出(缓冲区溢出)。</p>
<h2 id="2-缓冲区溢出的处理方法"><a href="#2-缓冲区溢出的处理方法" class="headerlink" title="2.缓冲区溢出的处理方法"></a>2.缓冲区溢出的处理方法</h2><p>&emsp;&emsp;接着看上文的例子，我们怎么能阻止浴缸(缓冲区)溢出呢？首先我们不大可能改变浴缸的大小，因为太过麻烦以及治标不治本，只要浴缸放水的时间够长，总会溢出。接着，舀水的速度我们也不好改变，因为一时半会是改不了的。那我们就只能改变舀水的次数和数量了。</p>
<p>&emsp;&emsp;如何改变舀水的数量和次数？我们可以一次舀出足够多的水，随后再从舀出的水中分出想要数量的水，这样浴缸溢出的可能性就大大减少了。</p>
<p>&emsp;&emsp;从代码层面来看上面的思路，只要我们程序内新建一个足够大的缓冲区，一次从内核缓冲区上recv足够的数据，就可以避免内核缓冲区溢出了。</p>
<ul>
<li>大概思路如下：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> _Recv_buf[<span class="number">4096</span>];</span><br><span class="line"><span class="type">int</span> DataRecv</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//接收客户端发送的数据 </span></span><br><span class="line">	<span class="type">int</span> recv_len = <span class="built_in">recv</span>(socket, _Recv_buf, <span class="number">4096</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(recv_len &lt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">while</span>(_Recv_buf内不为空)</span><br><span class="line">	&#123;</span><br><span class="line">		处理_Recv_buf内的数据</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
&emsp;&emsp;但是这样会出现新的问题，即粘包与分包问题，请看下文。</li>
</ul>
<h1 id="二、粘包与分包"><a href="#二、粘包与分包" class="headerlink" title="二、粘包与分包"></a>二、粘包与分包</h1><h2 id="1-粘包与分包的原因"><a href="#1-粘包与分包的原因" class="headerlink" title="1.粘包与分包的原因"></a>1.粘包与分包的原因</h2><p>&emsp;&emsp;上文中处理缓冲区溢出的思路是没有问题的，但是上文中的源码写法会存在问题。</p>
<p>&emsp;&emsp;我们一次接收那么多数据，其中数据的界限是没有限定的，比如上文中是想要一次接收4096个字节。假如缓冲区内有5个1000字节大小的数据包，我们这次接收4096字节，等于说接收的数据中有4.096个数据包，其中就包含了新的问题。</p>
<p>&emsp;&emsp;<strong>首先是粘包问题</strong>。即一次接收中含有多个数据包，这就导致数据包界限不清，粘在了一起。像上文中的4.096个包，接收端是不清楚的，接收端只知道有4096字节的数据，但是它不知道一个包是多大。所以我们可以通过包头来获取一个数据包的大小，由此来处理相应大小的数据以解决粘包问题。</p>
<p>&emsp;&emsp;<strong>接着是分包问题</strong>。即一次接收中含有不完整的包。例如上文中的4096个字节，其中包含了4个完整的包，和一个包的前96个字节。对此，我们只能处理前4个完整的数据包。那么问题来了，对于上文中的缓冲区，由于recv函数每次都会覆盖这个缓冲区，这就导致缓冲区内无法存放未处理的消息。对于这个问题，我们可以新建一个缓冲区，来存放未处理的消息，实现双缓冲，即可处理分包问题。</p>
<ul>
<li>TCP是面向数据流的协议，所以会出现粘包分包问题；UDP是面向消息的协议，每一个数据段都是一条消息，所以不会出现粘包分包问题。</li>
</ul>
<h2 id="2-粘包与分包的处理方法"><a href="#2-粘包与分包的处理方法" class="headerlink" title="2.粘包与分包的处理方法"></a>2.粘包与分包的处理方法</h2><h3 id="2-1客户端升级思路"><a href="#2-1客户端升级思路" class="headerlink" title="2.1客户端升级思路"></a>2.1客户端升级思路</h3><p>&emsp;&emsp;首先是新建两个缓冲区，一个用来存放recv到的数据，一个用来存放所有待处理数据。首先第一个缓冲区recv到数据，随后把第一个缓冲区内的数据copy到第二个缓冲区内，即可实现数据的存放。随后处理数据之类的还是先获取包头，随后根据包头处理包体数据。</p>
<ul>
<li>大致思路如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接收数据</span></span><br><span class="line"><span class="type">char</span> 接收缓冲区[<span class="number">4096</span>]</span><br><span class="line"><span class="type">char</span> 消息缓冲区[<span class="number">40960</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">RecvData</span><span class="params">(SOCKET temp_socket)</span><span class="comment">//处理数据 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="comment">//接收客户端发送的数据 </span></span><br><span class="line">	<span class="type">int</span> recv_len = <span class="built_in">recv</span>(temp_socket, 接收缓冲区, <span class="number">4096</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(recv_len &lt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;与服务器断开连接,任务结束\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="number">1.</span>将接收缓冲区的数据拷贝到消息缓冲区 </span><br><span class="line">	<span class="keyword">while</span>(<span class="number">2.</span>判断消息缓冲区的数据长度是否大于等于包头长度) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="number">3.</span>选出包头数据 <span class="comment">//解决粘包问题</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="number">4.</span>判断消息缓冲区内数据长度是否大于等于报文长度) <span class="comment">//解决少包问题 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="number">5.</span>响应数据 </span><br><span class="line">			<span class="number">6.</span>将处理过的消息移出消息缓冲区</span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2服务端升级思路"><a href="#2-2服务端升级思路" class="headerlink" title="2.2服务端升级思路"></a>2.2服务端升级思路</h3><p>&emsp;&emsp;与客户端整头思路相似，但是需要注意，服务端有多个连接，如果多个连接共用一个缓冲区会存在错误，所以每一个客户端连接都需要有自己的缓冲区。对此，我们可以新建一个客户端连接类，来存放每一个客户端的socket以及它的缓冲区。</p>
<ul>
<li>大致思路如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> 客户端连接</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="number">1.</span>获取<span class="built_in">socket</span>() </span><br><span class="line">	<span class="number">2.</span>获取缓冲区()</span><br><span class="line">	<span class="number">3.</span>获取缓冲区长度()</span><br><span class="line">	<span class="number">4.</span>设置缓冲区长度()</span><br><span class="line"><span class="keyword">private</span>:	</span><br><span class="line">	<span class="number">1.</span>socket</span><br><span class="line">	<span class="number">2.</span>缓冲区</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">std::vector&lt;客户端连接*&gt; _clients;<span class="comment">//储存客户端socket</span></span><br><span class="line"><span class="type">char</span> 接收缓冲区[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line"><span class="number">0.</span>此时前面OnRun函数里的判断过程也需要改变</span><br><span class="line"><span class="comment">//遍历所有socket 查看是否有待处理事件 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;_clients.<span class="built_in">size</span>(); ++n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(_clients[n]-&gt;获取<span class="built_in">socket</span>(),&amp;fdRead))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="number">-1</span> == <span class="built_in">RecvData</span>(_clients[n]))<span class="comment">//处理请求 客户端退出的话 </span></span><br><span class="line">		&#123;</span><br><span class="line">			std::vector&lt;客户端连接*&gt;::iterator iter = _clients.<span class="built_in">begin</span>()+n;<span class="comment">//找到退出客户端的地址</span></span><br><span class="line">			<span class="keyword">if</span>(iter != _clients.<span class="built_in">end</span>())<span class="comment">//如果是合理值</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">delete</span> _clients[n];</span><br><span class="line">				_clients.<span class="built_in">erase</span>(iter);<span class="comment">//移除</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">RecvData</span><span class="params">(客户端连接* client)</span><span class="comment">//处理数据 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="comment">//接收客户端发送的数据 </span></span><br><span class="line">	<span class="type">int</span> recv_len = <span class="built_in">recv</span>(client-&gt;获取<span class="built_in">socket</span>(), 接收缓冲区, <span class="number">4096</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(recv_len &lt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;与服务器断开连接,任务结束\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="number">1.</span>将接收缓冲区的数据拷贝到传入对象的消息缓冲区 client-&gt;获取缓冲区();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">2.</span>判断消息缓冲区的数据长度是否大于等于包头长度) client-&gt;获取缓冲区长度();</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="number">3.</span>选出包头数据 <span class="comment">//解决粘包问题</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="number">4.</span>判断消息缓冲区内数据长度是否大于等于报文长度) <span class="comment">//解决少包问题 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="number">5.</span>响应数据 </span><br><span class="line">			<span class="number">6.</span>将处理过的消息移出消息缓冲区 client-&gt;设置缓冲区长度();</span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、升级后的源码及其详细注释"><a href="#三、升级后的源码及其详细注释" class="headerlink" title="三、升级后的源码及其详细注释"></a>三、升级后的源码及其详细注释</h1><h2 id="1-客户端源码-TcpClient-hpp"><a href="#1-客户端源码-TcpClient-hpp" class="headerlink" title="1.客户端源码 TcpClient.hpp"></a>1.客户端源码 TcpClient.hpp</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TcpClient_hpp_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TcpClient_hpp_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;winSock2.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>) </span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SOCKET int</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> INVALID_SOCKET (SOCKET)(~0)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SOCKET_ERROR (-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">//枚举类型记录命令 </span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">cmd</span> </span><br><span class="line">&#123;</span><br><span class="line">	CMD_LOGIN,<span class="comment">//登录 </span></span><br><span class="line">	CMD_LOGINRESULT,<span class="comment">//登录结果 </span></span><br><span class="line">	CMD_LOGOUT,<span class="comment">//登出 </span></span><br><span class="line">	CMD_LOGOUTRESULT,<span class="comment">//登出结果 </span></span><br><span class="line">	CMD_NEW_USER_JOIN,<span class="comment">//新用户登入 </span></span><br><span class="line">	CMD_ERROR<span class="comment">//错误 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义数据包头 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DataHeader</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">short</span> cmd;<span class="comment">//命令</span></span><br><span class="line">	<span class="type">short</span> date_length;<span class="comment">//数据的长短	</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包1 登录 传输账号与密码</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Login</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Login</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGIN;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Login); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">	<span class="type">char</span> PassWord[<span class="number">32</span>];<span class="comment">//密码 </span></span><br><span class="line">	<span class="type">char</span> data[<span class="number">932</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包2 登录结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoginResult</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LoginResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGINRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LoginResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">	<span class="type">char</span> Data[<span class="number">992</span>];<span class="comment">//无意义数据 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包3 登出 传输用户名 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Logout</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Logout</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Logout); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">	<span class="type">char</span> data[<span class="number">964</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包4 登出结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LogoutResult</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LogoutResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUTRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LogoutResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">	<span class="type">char</span> data[<span class="number">992</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包5 新用户登入 传输通告 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NewUserJoin</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">NewUserJoin</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_NEW_USER_JOIN;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(NewUserJoin); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RECV_BUFFER_SIZE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TcpClient</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造 </span></span><br><span class="line">	<span class="built_in">TcpClient</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		_sock = INVALID_SOCKET;</span><br><span class="line">		<span class="comment">//缓冲区相关 </span></span><br><span class="line">		_Recv_buf = <span class="keyword">new</span> <span class="type">char</span>[RECV_BUFFER_SIZE];</span><br><span class="line">		_Msg_buf = <span class="keyword">new</span> <span class="type">char</span>[RECV_BUFFER_SIZE*<span class="number">10</span>];</span><br><span class="line">		_Len_buf = <span class="number">0</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构 </span></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">TcpClient</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span>[] _Recv_buf;</span><br><span class="line">		<span class="keyword">delete</span>[] _Msg_buf;</span><br><span class="line">		<span class="comment">//关闭socket </span></span><br><span class="line">		<span class="built_in">CloseSocket</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//初始化socket 返回1为正常 </span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">InitSocket</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">		<span class="comment">//启动windows socket 2,x环境 </span></span><br><span class="line">		WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>); </span><br><span class="line">		WSADATA dat;</span><br><span class="line">		<span class="keyword">if</span>(<span class="number">0</span> != <span class="built_in">WSAStartup</span>(ver,&amp;dat))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//-1为环境错误 </span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">		<span class="comment">//创建socket </span></span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET != _sock)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;&lt;Socket=%d&gt;关闭连接\n&quot;</span>,_sock); </span><br><span class="line">			<span class="built_in">CloseSocket</span>();<span class="comment">//如果之前有连接 就关闭连接 </span></span><br><span class="line">		&#125;</span><br><span class="line">		_sock = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,IPPROTO_TCP); </span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET == _sock)</span><br><span class="line">		&#123;   </span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//0为socket创建错误 </span></span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//连接服务器  返回1为成功 </span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Connect</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ip,<span class="type">unsigned</span> <span class="type">short</span> port)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//如果为无效套接字 则初始化 </span></span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET == _sock)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">InitSocket</span>(); </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//连接服务器</span></span><br><span class="line">	   	sockaddr_in _sin = &#123;&#125;;</span><br><span class="line">	   	_sin.sin_family = AF_INET;<span class="comment">//IPV4</span></span><br><span class="line">	   	_sin.sin_port = <span class="built_in">htons</span>(port);<span class="comment">//端口号 </span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">		_sin.sin_addr.S_un.S_addr =  <span class="built_in">inet_addr</span>(ip);<span class="comment">//IP </span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		_sin.sin_addr.s_addr =  <span class="built_in">inet_addr</span>(ip);<span class="comment">//IP </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">connect</span>(_sock,(sockaddr*)&amp;_sin,<span class="built_in">sizeof</span>(sockaddr_in)))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//连接失败 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//连接成功 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//关闭socket</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">CloseSocket</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET != _sock) </span><br><span class="line">		&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">			<span class="comment">//关闭socket</span></span><br><span class="line">			<span class="built_in">closesocket</span>(_sock); </span><br><span class="line">			<span class="comment">//清除windows socket 环境 </span></span><br><span class="line">			<span class="built_in">WSACleanup</span>(); </span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">			<span class="comment">//关闭socket/LINUX</span></span><br><span class="line">			<span class="built_in">close</span>(_sock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">			_sock = INVALID_SOCKET;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//查询是否有待处理消息 </span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">OnRun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">IsRun</span>())<span class="comment">//如果有连接则监听事件 </span></span><br><span class="line">		&#123;</span><br><span class="line">			fd_set _fdRead;<span class="comment">//建立集合 </span></span><br><span class="line">			<span class="built_in">FD_ZERO</span>(&amp;_fdRead);<span class="comment">//清空集合  </span></span><br><span class="line">			<span class="built_in">FD_SET</span>(_sock,&amp;_fdRead);<span class="comment">//放入集合 </span></span><br><span class="line">			timeval <span class="type">_t</span> = &#123;<span class="number">1</span>,<span class="number">0</span>&#125;;<span class="comment">//select最大响应时间 </span></span><br><span class="line">			<span class="comment">//新建seclect </span></span><br><span class="line">			<span class="type">int</span> _ret = <span class="built_in">select</span>(_sock<span class="number">+1</span>,&amp;_fdRead,<span class="literal">NULL</span>,<span class="literal">NULL</span>,&amp;<span class="type">_t</span>);</span><br><span class="line">			<span class="keyword">if</span>(_ret&lt;<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;seclect任务结束\n&quot;</span>);</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(_sock,&amp;_fdRead))<span class="comment">//获取是否有可读socket </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">FD_CLR</span>(_sock,&amp;_fdRead);<span class="comment">//清理计数器 </span></span><br><span class="line">				<span class="keyword">if</span>(<span class="number">-1</span> == <span class="built_in">RecvData</span>(_sock))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">CloseSocket</span>();</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;	</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//判断是否工作中 </span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">IsRun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _sock != INVALID_SOCKET; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//发送数据 </span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">SendData</span><span class="params">(DataHeader *_head)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">IsRun</span>() &amp;&amp; _head)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">send</span>(_sock,(<span class="type">const</span> <span class="type">char</span>*)_head,_head-&gt;date_length,<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//接收数据</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">RecvData</span><span class="params">(SOCKET temp_socket)</span><span class="comment">//处理数据 </span></span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		<span class="comment">//接收客户端发送的数据 </span></span><br><span class="line">		<span class="type">int</span> recv_len = <span class="built_in">recv</span>(temp_socket, _Recv_buf, RECV_BUFFER_SIZE, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(recv_len &lt;= <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;与服务器断开连接,任务结束\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="comment">//将接收缓冲区的数据拷贝到消息缓冲区 </span></span><br><span class="line">		<span class="built_in">memcpy</span>(_Msg_buf+_Len_buf, _Recv_buf, recv_len); </span><br><span class="line">		<span class="comment">//消息缓冲区的数据末尾后移 </span></span><br><span class="line">		_Len_buf += recv_len; </span><br><span class="line">		<span class="comment">//判断消息缓冲区的数据长度是否大于等于包头长度 </span></span><br><span class="line">		<span class="keyword">while</span>(_Len_buf &gt;= <span class="built_in">sizeof</span>(DataHeader))<span class="comment">//处理粘包问题 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//选出包头数据 </span></span><br><span class="line">			DataHeader* header = (DataHeader*)_Msg_buf; </span><br><span class="line">			<span class="comment">//判断消息缓冲区内数据长度是否大于等于报文长度 避免少包问题 </span></span><br><span class="line">			<span class="keyword">if</span>(_Len_buf &gt;= header-&gt;date_length)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//计算出消息缓冲区内剩余未处理数据的长度</span></span><br><span class="line">				<span class="type">int</span> size = _Len_buf - header-&gt;date_length; </span><br><span class="line">				<span class="comment">//响应数据 </span></span><br><span class="line">				<span class="built_in">NetMsg</span>(header);</span><br><span class="line">				<span class="comment">//将消息缓冲区剩余未处理的数据前移</span></span><br><span class="line">				<span class="built_in">memcpy</span>(_Msg_buf, _Msg_buf + header-&gt;date_length, size);</span><br><span class="line">				<span class="comment">//消息缓冲区的数据末尾前移</span></span><br><span class="line">				_Len_buf = size; </span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//消息缓冲区数据不足 </span></span><br><span class="line">				<span class="keyword">break</span>; </span><br><span class="line">			&#125; </span><br><span class="line">		&#125; </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//响应数据</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">NetMsg</span><span class="params">(DataHeader *_head)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;接收到包头，命令：%d，数据长度：%d\n&quot;</span>,_head-&gt;cmd,_head-&gt;date_length);</span><br><span class="line">		<span class="keyword">switch</span>(_head-&gt;cmd)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> CMD_LOGINRESULT:<span class="comment">//登录结果 接收登录包体 </span></span><br><span class="line">			&#123;</span><br><span class="line">				LoginResult *_result = (LoginResult*)_head; </span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;登录结果:%d\n&quot;</span>,_result-&gt;Result);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> CMD_LOGOUTRESULT:<span class="comment">//登出结果 接收登出包体 </span></span><br><span class="line">			&#123;</span><br><span class="line">				LogoutResult *_result = (LogoutResult*)_head; </span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;登录结果:%d\n&quot;</span>,_result-&gt;Result);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> CMD_NEW_USER_JOIN:<span class="comment">//新用户登录通知 </span></span><br><span class="line">			&#123;</span><br><span class="line">				NewUserJoin *_result = (NewUserJoin*)_head; </span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;用户:%s已登录\n&quot;</span>,_result-&gt;UserName);</span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> CMD_ERROR:<span class="comment">//错误 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;错误数据\n&quot;</span>); </span><br><span class="line">				<span class="built_in">getchar</span>();</span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;未知数据\n&quot;</span>); </span><br><span class="line">				<span class="built_in">getchar</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	SOCKET _sock;</span><br><span class="line">	<span class="comment">//缓冲区相关 </span></span><br><span class="line">	<span class="type">char</span> *_Recv_buf;<span class="comment">//接收缓冲区 </span></span><br><span class="line">	<span class="type">char</span> *_Msg_buf;<span class="comment">//消息缓冲区 </span></span><br><span class="line">	<span class="type">int</span> _Len_buf;<span class="comment">//缓冲区数据尾部变量 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="2-服务端源码-TcpServer-hpp"><a href="#2-服务端源码-TcpServer-hpp" class="headerlink" title="2.服务端源码 TcpServer.hpp"></a>2.服务端源码 TcpServer.hpp</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TcpServer_hpp_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TcpServer_hpp_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;winSock2.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//链接此动态链接库 windows特有 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span><span class="comment">//selcet</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span><span class="comment">//uni std</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SOCKET int</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> INVALID_SOCKET (SOCKET)(~0)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SOCKET_ERROR (-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">//枚举类型记录命令 </span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">cmd</span> </span><br><span class="line">&#123;</span><br><span class="line">	CMD_LOGIN,<span class="comment">//登录 </span></span><br><span class="line">	CMD_LOGINRESULT,<span class="comment">//登录结果 </span></span><br><span class="line">	CMD_LOGOUT,<span class="comment">//登出 </span></span><br><span class="line">	CMD_LOGOUTRESULT,<span class="comment">//登出结果 </span></span><br><span class="line">	CMD_NEW_USER_JOIN,<span class="comment">//新用户登入 </span></span><br><span class="line">	CMD_ERROR<span class="comment">//错误 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义数据包头 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DataHeader</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">short</span> cmd;<span class="comment">//命令</span></span><br><span class="line">	<span class="type">short</span> date_length;<span class="comment">//数据的长短	</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包1 登录 传输账号与密码</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Login</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Login</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGIN;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Login); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">	<span class="type">char</span> PassWord[<span class="number">32</span>];<span class="comment">//密码 </span></span><br><span class="line">	<span class="type">char</span> data[<span class="number">932</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包2 登录结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoginResult</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LoginResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGINRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LoginResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">	<span class="type">char</span> Data[<span class="number">992</span>];<span class="comment">//无意义数据 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包3 登出 传输用户名 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Logout</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Logout</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Logout); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">	<span class="type">char</span> data[<span class="number">964</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包4 登出结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LogoutResult</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LogoutResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUTRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LogoutResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">	<span class="type">char</span> data[<span class="number">992</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包5 新用户登入 传输通告 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NewUserJoin</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">NewUserJoin</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_NEW_USER_JOIN;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(NewUserJoin); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RECV_BUFFER_SIZE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClientSocket</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造 </span></span><br><span class="line">	<span class="built_in">ClientSocket</span>(SOCKET sockfd = INVALID_SOCKET)</span><br><span class="line">	&#123;</span><br><span class="line">		_sockfd = sockfd;</span><br><span class="line">		<span class="comment">//缓冲区相关 </span></span><br><span class="line">		_Msg_buf = <span class="keyword">new</span> <span class="type">char</span>[RECV_BUFFER_SIZE*<span class="number">10</span>];</span><br><span class="line">		_Len_buf = <span class="number">0</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构 </span></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">ClientSocket</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span>[] _Msg_buf;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//获取socket </span></span><br><span class="line">	<span class="function">SOCKET <span class="title">GetSockfd</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _sockfd;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//获取缓冲区 </span></span><br><span class="line">	<span class="function"><span class="type">char</span>* <span class="title">MsgBuf</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _Msg_buf;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//获取缓冲区尾部变量 </span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetLen</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _Len_buf;	</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//设置缓冲区尾巴变量</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetLen</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		_Len_buf = len;</span><br><span class="line">	&#125; </span><br><span class="line">		</span><br><span class="line"><span class="keyword">private</span>:	</span><br><span class="line">	SOCKET _sockfd;</span><br><span class="line">	<span class="comment">//缓冲区相关 </span></span><br><span class="line">	<span class="type">char</span> *_Msg_buf;<span class="comment">//消息缓冲区 </span></span><br><span class="line">	<span class="type">int</span> _Len_buf;<span class="comment">//缓冲区数据尾部变量</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TcpServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造 </span></span><br><span class="line">	<span class="built_in">TcpServer</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		_sock = INVALID_SOCKET; </span><br><span class="line">		<span class="comment">//缓冲区相关 </span></span><br><span class="line">		_Recv_buf = <span class="keyword">new</span> <span class="type">char</span>[RECV_BUFFER_SIZE];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//析构 </span></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">TcpServer</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span>[] _Recv_buf;</span><br><span class="line">		<span class="comment">//关闭socket </span></span><br><span class="line">		<span class="built_in">CloseSocket</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//初始化socket 返回1为正常 </span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">InitSocket</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">		<span class="comment">//启动windows socket 2,x环境 </span></span><br><span class="line">		WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>); </span><br><span class="line">		WSADATA dat;</span><br><span class="line">		<span class="keyword">if</span>(<span class="number">0</span> != <span class="built_in">WSAStartup</span>(ver,&amp;dat))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//-1为环境错误 </span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">		<span class="comment">//创建socket </span></span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET != _sock)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;&lt;Socket=%d&gt;关闭连接\n&quot;</span>,_sock); </span><br><span class="line">			<span class="built_in">CloseSocket</span>();<span class="comment">//如果之前有连接 就关闭连接 </span></span><br><span class="line">		&#125;</span><br><span class="line">		_sock = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,IPPROTO_TCP); </span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET == _sock)</span><br><span class="line">		&#123;   </span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//0为socket创建错误 </span></span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//绑定IP/端口</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Bind</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* ip,<span class="type">unsigned</span> <span class="type">short</span> port)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//如果为无效套接字 则初始化 </span></span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET == _sock)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">InitSocket</span>(); </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//绑定网络端口和IP地址 </span></span><br><span class="line">		sockaddr_in _myaddr = &#123;&#125;; </span><br><span class="line">		_myaddr.sin_family = AF_INET;<span class="comment">//IPV4</span></span><br><span class="line">		_myaddr.sin_port = <span class="built_in">htons</span>(port);<span class="comment">//端口</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">		<span class="keyword">if</span>(ip)<span class="comment">//ip为空则监听所有网卡 </span></span><br><span class="line">		&#123;</span><br><span class="line">			_myaddr.sin_addr.S_un.S_addr = <span class="built_in">inet_addr</span>(ip);<span class="comment">//IP</span></span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			_myaddr.sin_addr.S_un.S_addr = INADDR_ANY;<span class="comment">//IP</span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		<span class="keyword">if</span>(ip)<span class="comment">//ip为空则监听所有网卡</span></span><br><span class="line">		&#123;</span><br><span class="line">			_myaddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(ip);<span class="comment">//IP </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			_myaddr.sin_addr.s_addr = INADDR_ANY;<span class="comment">//IP </span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">bind</span>(_sock,(sockaddr*)&amp;_myaddr,<span class="built_in">sizeof</span>(sockaddr_in)))<span class="comment">//socket (强制转换)sockaddr结构体 结构体大小 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;绑定失败\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;绑定成功\n绑定端口为%d\n&quot;</span>,port);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//监听端口</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Listen</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//如果为无效套接字 则提示 </span></span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET == _sock)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;请先初始化套接字并绑定IP端口\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//监听网络端口</span></span><br><span class="line">		<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">listen</span>(_sock,n))<span class="comment">//最大连接队列 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;监听失败\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;监听成功\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//接受连接</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Accept</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//等待接收客户端连接</span></span><br><span class="line">		sockaddr_in clientAddr = &#123;&#125;;<span class="comment">//新建sockadd结构体接收客户端数据 </span></span><br><span class="line">		<span class="type">int</span> addr_len = <span class="built_in">sizeof</span>(sockaddr_in);<span class="comment">//获取sockadd结构体长度 </span></span><br><span class="line">		SOCKET temp_socket = INVALID_SOCKET;<span class="comment">//声明客户端套接字 </span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32	</span></span><br><span class="line">		temp_socket = <span class="built_in">accept</span>(_sock,(sockaddr*)&amp;clientAddr,&amp;addr_len);<span class="comment">//自身套接字 客户端结构体 结构体大小 	</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		temp_socket = <span class="built_in">accept</span>(_sock,(sockaddr*)&amp;clientAddr,(<span class="type">socklen_t</span>*)&amp;addr_len);<span class="comment">//自身套接字 客户端结构体 结构体大小 </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET == temp_socket)<span class="comment">//接收失败 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;&lt;Socket=%d&gt;错误,接受到无效客户端SOCKET\n&quot;</span>,temp_socket);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123; </span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;新客户端加入\nIP地址为：%s \n&quot;</span>, <span class="built_in">inet_ntoa</span>(clientAddr.sin_addr));  </span><br><span class="line">			<span class="comment">//群发所有客户端 通知新用户登录 </span></span><br><span class="line">			NewUserJoin *user_join = <span class="keyword">new</span> <span class="built_in">NewUserJoin</span>(); </span><br><span class="line">			<span class="built_in">strcpy</span>(user_join-&gt;UserName,<span class="built_in">inet_ntoa</span>(clientAddr.sin_addr));</span><br><span class="line">			<span class="built_in">SendDataToAll</span>(user_join);</span><br><span class="line">			<span class="comment">//将新的客户端加入动态数组</span></span><br><span class="line">			_clients.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">ClientSocket</span>(temp_socket));</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//关闭socket </span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">CloseSocket</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET != _sock) </span><br><span class="line">		&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">			<span class="comment">//关闭客户端socket</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;_clients.<span class="built_in">size</span>(); ++n)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">closesocket</span>(_clients[n]-&gt;<span class="built_in">GetSockfd</span>());</span><br><span class="line">				<span class="keyword">delete</span> _clients[n];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//关闭socket</span></span><br><span class="line">			<span class="built_in">closesocket</span>(_sock); </span><br><span class="line">			<span class="comment">//清除windows socket 环境 </span></span><br><span class="line">			<span class="built_in">WSACleanup</span>(); </span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">			<span class="comment">//关闭客户端socket</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;_clients.<span class="built_in">size</span>(); ++n)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">close</span>(_clients[n]-&gt;<span class="built_in">GetSockfd</span>());</span><br><span class="line">				<span class="keyword">delete</span> _clients[n];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//关闭socket/LINUX</span></span><br><span class="line">			<span class="built_in">close</span>(_sock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">			_sock = INVALID_SOCKET;</span><br><span class="line">			_clients.<span class="built_in">clear</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//查询是否有待处理消息 </span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">OnRun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">IsRun</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			fd_set fdRead;<span class="comment">//建立集合 </span></span><br><span class="line">			fd_set fdWrite;</span><br><span class="line">			fd_set fdExcept;</span><br><span class="line">			<span class="built_in">FD_ZERO</span>(&amp;fdRead);<span class="comment">//清空集合 </span></span><br><span class="line">			<span class="built_in">FD_ZERO</span>(&amp;fdWrite); </span><br><span class="line">			<span class="built_in">FD_ZERO</span>(&amp;fdExcept); </span><br><span class="line">			<span class="built_in">FD_SET</span>(_sock,&amp;fdRead);<span class="comment">//放入集合 </span></span><br><span class="line">			<span class="built_in">FD_SET</span>(_sock,&amp;fdWrite); </span><br><span class="line">			<span class="built_in">FD_SET</span>(_sock,&amp;fdExcept);</span><br><span class="line">			timeval <span class="type">s_t</span> = &#123;<span class="number">2</span>,<span class="number">0</span>&#125;;<span class="comment">//select最大响应时间 </span></span><br><span class="line">			SOCKET maxSock = _sock;<span class="comment">//最大socket </span></span><br><span class="line">			<span class="comment">//把连接的客户端 放入read集合 </span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> n=_clients.<span class="built_in">size</span>()<span class="number">-1</span>; n&gt;=<span class="number">0</span>; --n)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">FD_SET</span>(_clients[n]-&gt;<span class="built_in">GetSockfd</span>(),&amp;fdRead);</span><br><span class="line">				<span class="keyword">if</span>(maxSock &lt; _clients[n]-&gt;<span class="built_in">GetSockfd</span>())</span><br><span class="line">				&#123;</span><br><span class="line">					maxSock = _clients[n]-&gt;<span class="built_in">GetSockfd</span>();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//select函数筛选select </span></span><br><span class="line">			<span class="type">int</span> ret = <span class="built_in">select</span>(maxSock<span class="number">+1</span>,&amp;fdRead,&amp;fdWrite,&amp;fdExcept,&amp;<span class="type">s_t</span>); </span><br><span class="line">			<span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;select任务结束\n&quot;</span>);</span><br><span class="line">				<span class="built_in">CloseSocket</span>();</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(_sock,&amp;fdRead))<span class="comment">//获取是否有新socket连接 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">FD_CLR</span>(_sock,&amp;fdRead);<span class="comment">//清理</span></span><br><span class="line">				<span class="built_in">Accept</span>();<span class="comment">//连接 </span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//遍历所有socket 查看是否有待处理事件 </span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;_clients.<span class="built_in">size</span>(); ++n)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(_clients[n]-&gt;<span class="built_in">GetSockfd</span>(),&amp;fdRead))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(<span class="number">-1</span> == <span class="built_in">RecvData</span>(_clients[n]))<span class="comment">//处理请求 客户端退出的话 </span></span><br><span class="line">					&#123;</span><br><span class="line">						std::vector&lt;ClientSocket*&gt;::iterator iter = _clients.<span class="built_in">begin</span>()+n;<span class="comment">//找到退出客户端的地址</span></span><br><span class="line">						<span class="keyword">if</span>(iter != _clients.<span class="built_in">end</span>())<span class="comment">//如果是合理值</span></span><br><span class="line">						&#123;</span><br><span class="line">							<span class="keyword">delete</span> _clients[n];</span><br><span class="line">							_clients.<span class="built_in">erase</span>(iter);<span class="comment">//移除</span></span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//printf(&quot;空闲时间处理其他业务\n&quot;);</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//判断是否工作中 </span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">IsRun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _sock != INVALID_SOCKET; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//发送数据 </span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">SendData</span><span class="params">(DataHeader *head,SOCKET temp_socket)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">IsRun</span>() &amp;&amp; head)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">send</span>(temp_socket,(<span class="type">const</span> <span class="type">char</span>*)head,head-&gt;date_length,<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//向所有人发送数据</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SendDataToAll</span><span class="params">(DataHeader *head)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>;n&lt;_clients.<span class="built_in">size</span>();++n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">SendData</span>(head, _clients[n]-&gt;<span class="built_in">GetSockfd</span>());	</span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//接收数据</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">RecvData</span><span class="params">(ClientSocket *t_client)</span><span class="comment">//处理数据 </span></span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		<span class="comment">//接收客户端发送的数据  </span></span><br><span class="line">		<span class="type">int</span> buf_len = <span class="built_in">recv</span>(t_client-&gt;<span class="built_in">GetSockfd</span>(), _Recv_buf, RECV_BUFFER_SIZE, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(buf_len&lt;=<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;客户端已退出\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125; </span><br><span class="line">		</span><br><span class="line">		<span class="comment">//将接收缓冲区的数据拷贝到消息缓冲区 </span></span><br><span class="line">		<span class="built_in">memcpy</span>(t_client-&gt;<span class="built_in">MsgBuf</span>() + t_client-&gt;<span class="built_in">GetLen</span>(), _Recv_buf, buf_len); </span><br><span class="line">		<span class="comment">//消息缓冲区的数据末尾后移 </span></span><br><span class="line">		t_client-&gt;<span class="built_in">SetLen</span>(t_client-&gt;<span class="built_in">GetLen</span>() + buf_len);</span><br><span class="line">		<span class="comment">//判断消息缓冲区的数据长度是否大于等于包头长度 </span></span><br><span class="line">		<span class="keyword">while</span>(t_client-&gt;<span class="built_in">GetLen</span>() &gt;= <span class="built_in">sizeof</span>(DataHeader))<span class="comment">//处理粘包问题 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//选出包头数据 </span></span><br><span class="line">			DataHeader* header = (DataHeader*)t_client-&gt;<span class="built_in">MsgBuf</span>(); </span><br><span class="line">			<span class="comment">//判断消息缓冲区内数据长度是否大于等于报文长度 避免少包问题 </span></span><br><span class="line">			<span class="keyword">if</span>(t_client-&gt;<span class="built_in">GetLen</span>() &gt;= header-&gt;date_length)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//计算出消息缓冲区内剩余未处理数据的长度</span></span><br><span class="line">				<span class="type">int</span> size = t_client-&gt;<span class="built_in">GetLen</span>() - header-&gt;date_length; </span><br><span class="line">				<span class="comment">//响应数据 </span></span><br><span class="line">				<span class="built_in">NetMsg</span>(header,t_client-&gt;<span class="built_in">GetSockfd</span>());</span><br><span class="line">				<span class="comment">//将消息缓冲区剩余未处理的数据前移</span></span><br><span class="line">				<span class="built_in">memcpy</span>(t_client-&gt;<span class="built_in">MsgBuf</span>(), t_client-&gt;<span class="built_in">MsgBuf</span>() + header-&gt;date_length, size);</span><br><span class="line">				<span class="comment">//消息缓冲区的数据末尾前移</span></span><br><span class="line">				t_client-&gt;<span class="built_in">SetLen</span>(size); </span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//消息缓冲区数据不足 </span></span><br><span class="line">				<span class="keyword">break</span>; </span><br><span class="line">			&#125; </span><br><span class="line">		&#125;  </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//响应数据</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">NetMsg</span><span class="params">(DataHeader *head,SOCKET temp_socket)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	 	<span class="built_in">printf</span>(<span class="string">&quot;接收到包头，命令：%d，数据长度：%d\n&quot;</span>,head-&gt;cmd,head-&gt;date_length);</span><br><span class="line">		<span class="keyword">switch</span>(head-&gt;cmd)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> CMD_LOGIN:<span class="comment">//登录 接收登录包体 </span></span><br><span class="line">			&#123;</span><br><span class="line">				Login *login = (Login*)head;</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				进行判断操作 </span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				<span class="comment">//printf(&quot;%s已登录\n密码：%s\n&quot;,login-&gt;UserName,login-&gt;PassWord); </span></span><br><span class="line">				LoginResult *result = <span class="keyword">new</span> LoginResult;	</span><br><span class="line">				result-&gt;Result = <span class="number">1</span>;</span><br><span class="line">				<span class="built_in">SendData</span>(result,temp_socket);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> CMD_LOGOUT:<span class="comment">//登出 接收登出包体 </span></span><br><span class="line">			&#123;</span><br><span class="line">				Logout *logout = (Logout*)head;</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				进行判断操作 </span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				<span class="comment">//printf(&quot;%s已登出\n&quot;,logout-&gt;UserName); </span></span><br><span class="line">				LogoutResult *result = <span class="keyword">new</span> <span class="built_in">LogoutResult</span>();</span><br><span class="line">				result-&gt;Result = <span class="number">1</span>;</span><br><span class="line">				<span class="built_in">SendData</span>(result,temp_socket);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:<span class="comment">//错误 </span></span><br><span class="line">			&#123;</span><br><span class="line">				head-&gt;cmd = CMD_ERROR; </span><br><span class="line">				head-&gt;date_length = <span class="number">0</span>; </span><br><span class="line">				<span class="built_in">SendData</span>(head,temp_socket); </span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	 </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	SOCKET _sock; </span><br><span class="line">	std::vector&lt;ClientSocket*&gt; _clients;<span class="comment">//储存客户端</span></span><br><span class="line">	<span class="comment">//缓冲区相关 </span></span><br><span class="line">	<span class="type">char</span> *_Recv_buf;<span class="comment">//接收缓冲区 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++网络编程学习：对socket select网络模型的优化</title>
    <url>/2021/02/20/20210220_C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%AF%B9socket%20select%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<ul>
<li>使用的语言为C&#x2F;C++</li>
<li>源码支持的平台为：Windows &#x2F; Linux</li>
<li>东西不多，简单记录一下，今后可能会补充</li>
</ul>
<h1 id="零、思路与流程"><a href="#零、思路与流程" class="headerlink" title="零、思路与流程"></a>零、思路与流程</h1><p>select网络模型的大概流程如下：<br>1.获取一个至三个<code>fd_set</code>集合，获取一个<code>timeval</code><br>2.<code>select</code>函数对<code>fd_set</code>集合进行选择筛选<br>3.<code>FD_ISSET</code>函数依据<code>fd_set</code>集合遍历查找待处理事件</p>
<span id="more"></span>

<p><a href="&emsp;https://blog.csdn.net/qq_45698148/article/details/113061122">select相关详细内容点我</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">WINSOCK_API_LINKAGE <span class="type">int</span> WSAAPI <span class="title">select</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="type">int</span> nfds,<span class="comment">//是指待监听集合里的范围 即待监听数量最大值+1</span></span></span></span><br><span class="line"><span class="params"><span class="function">		fd_set *readfds,<span class="comment">//待监听的可读文件集合 </span></span></span></span><br><span class="line"><span class="params"><span class="function">		fd_set *writefds,<span class="comment">//待监听的可写文件集合  </span></span></span></span><br><span class="line"><span class="params"><span class="function">		fd_set *exceptfds,<span class="comment">//待监听的异常文件集合  </span></span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="type">const</span> PTIMEVAL timeout)</span></span>;<span class="comment">//超时设置 传入NULL为阻塞模式 传入timeval结构体为非阻塞模式</span></span><br><span class="line"></span><br><span class="line">	返回值为满足条件的待监听socket数量和，如果出错返回<span class="number">-1</span>，如果超时返回<span class="number">0</span>。</span><br></pre></td></tr></table></figure>
<h1 id="一、对fd-set的优化"><a href="#一、对fd-set的优化" class="headerlink" title="一、对fd_set的优化"></a>一、对<code>fd_set</code>的优化</h1><p>&emsp;&emsp;首先，我们可以对<code>fd_set</code>的相关操作进行优化。<br>&emsp;&emsp;之前，我们每进行一次<code>select</code>操作，都要使用循环把所有的已连接socket放到<code>fd_set</code>集合中，随后进行选择操作。但是当连接数很大、select操作频繁时，不断的新建<code>fd_set</code>并用循环放入socket，很明显会大大增大系统的消耗。<br>&emsp;&emsp;由于<code>fd_set</code>集合中一定存放的是当前所有的socket，由此，我们可以建立两个<code>fd_set</code>集合与一个<code>bool</code>变量。<code>bool</code>变量用来表示socket的组成是否发生了变化，当有客户端加入或断开时，该变量为true，否则为false。<br>&emsp;&emsp;我们使用一个<code>fd_set</code>集合储存”老的”socket集合，当socket集合没有发生变化时，我们另一个新<code>fd_set</code>集合直接使用<code>memcpy</code>函数复制老集合中的内容，从而避免从头循环放入。当socket集合发生变化时，新集合直接循环从头录入，随后老集合使用<code>memcpy</code>函数把新集合内的内容复制过去，方便下一次使用。<br>&emsp;&emsp;这样，我们即可大大减少关于<code>fd_set</code>集合初始化的消耗。</p>
<h1 id="二、对select函数的优化"><a href="#二、对select函数的优化" class="headerlink" title="二、对select函数的优化"></a>二、对<code>select</code>函数的优化</h1><p>&emsp;&emsp;当前我的代码只对read可读集合进行操作，并没有write可写集合与except异常集合的操作，所以我的select目前第三、第四个参数都传了空。这样可以增加一点select的效率。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">select</span>(_sock<span class="number">+1</span>,&amp;fdRead,<span class="number">0</span>,<span class="number">0</span>,&amp;<span class="type">s_t</span>); </span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;其余因为select函数被封装了，目前就我的水平来言应该没法做进一步的优化，可能以后会有吧。</p>
<h1 id="三、对FD-ISSET的优化"><a href="#三、对FD-ISSET的优化" class="headerlink" title="三、对FD_ISSET的优化"></a>三、对<code>FD_ISSET</code>的优化</h1><p>&emsp;&emsp;这是select架构里吃资源的大头，当socket连接数很大时，显而易见的是这种O(N^2)的查询方法会极大的消耗资源。对此我们可以引入map加快查找操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::map&lt;socket,Client&gt; _clients;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;socket当键，客户端对象当值。根据select处理后的<code>fd_set</code>集合内的socket进行查找。效率提高为O(lgN)。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++网络编程学习：服务端多线程分离业务处理高负载</title>
    <url>/2021/02/07/20210207_C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%86%E7%A6%BB%E4%B8%9A%E5%8A%A1%E5%A4%84%E7%90%86%E9%AB%98%E8%B4%9F%E8%BD%BD/</url>
    <content><![CDATA[<ul>
<li>使用的语言为C&#x2F;C++</li>
<li>源码支持的平台为：Windows &#x2F; Linux</li>
</ul>
<h1 id="一、思路与准备"><a href="#一、思路与准备" class="headerlink" title="一、思路与准备"></a>一、思路与准备</h1><p>之前的服务端思路大概是如下的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>建立socket</span><br><span class="line"><span class="number">2.</span>绑定端口IP</span><br><span class="line"><span class="number">3.</span>监听端口</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="number">4.</span>使用select函数获取存在待监听事件的socket</span><br><span class="line">	<span class="number">5.</span>如果有新的连接则与新的客户端连接</span><br><span class="line">	<span class="number">6.</span>如果有待监听事件，则对其进行处理(接受与发送)</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">7.</span>关闭socket</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;但是，这样的架构在select处理事件较多时，很容易效率低下。对于这类问题，我们可以引入<strong>生产者与消费者模式</strong>，来处理此类并发问题。</p>
<span id="more"></span>

<p>&emsp;&emsp;主线程为<strong>生产者</strong>线程，用来处理新客户端加入事件，把新客户端分配至<strong>消费者</strong>线程中。<strong>消费者</strong>线程便是我们建立的新线程，专门用来处理客户端发送的报文。这样就实现了事件处理的分离，从而使服务端处理效率更高。当过多客户端同时涌入时，可以更快的建立连接(因为有专门的线程用来处理这一事件)；而当客户端发送报文频率很快时，多线程处理报文也会大大提高效率。</p>
<ul>
<li>大致改进思路如下，红色的为此次需要加入的核心，黑色为原本架构<br><img src="/images/2021-02-07/1.jpg" alt="核心思路图"></li>
</ul>
<p>&emsp;&emsp;所以我们首先需要新建一个线程类，用来封装关于<strong>消费者</strong>线程的内容，从而建立多线程架构。随后，在本次的改进中，我决定加入<strong>计时器</strong>用来统计数据以及显示数据，主要需要统计的数据为：当前客户端连接数量、数据包的每秒接收数量。同时，我也对报文类型进行了分离，把报文类型放在单独的头文件里，这样既方便更改也方便引用。</p>
<ul>
<li><a href="https://blog.csdn.net/qq_45698148/article/details/113702354">1.计时器相关请点这里</a> &emsp;&emsp; <a href="https://blog.csdn.net/qq_45698148/article/details/113465259">2.多线程相关请点这里</a></li>
</ul>
<h1 id="二、代码的改进"><a href="#二、代码的改进" class="headerlink" title="二、代码的改进"></a>二、代码的改进</h1><h2 id="1-新建子线程类"><a href="#1-新建子线程类" class="headerlink" title="1.新建子线程类"></a>1.新建子线程类</h2><ul>
<li>首先是新建线程类<code>CellServer</code>，其中包含的基础方法以及相关变量如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CellServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造 </span></span><br><span class="line">	<span class="built_in">CellServer</span>(SOCKET sock = INVALID_SOCKET);</span><br><span class="line">	<span class="comment">//析构</span></span><br><span class="line">	~<span class="built_in">CellServer</span>();</span><br><span class="line">	<span class="comment">//关闭socket </span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">CloseSocket</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//判断是否工作中 </span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">IsRun</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//查询是否有待处理消息 </span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">OnRun</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//接收数据</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">RecvData</span><span class="params">(ClientSocket *t_client)</span></span>;</span><br><span class="line">	<span class="comment">//响应数据</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">NetMsg</span><span class="params">(DataHeader *head,SOCKET temp_socket)</span></span>;</span><br><span class="line">	<span class="comment">//增加客户端 </span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">addClient</span><span class="params">(ClientSocket* client)</span></span>;</span><br><span class="line">	<span class="comment">//启动线程</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>; </span><br><span class="line">	<span class="comment">//获取该线程内客户端数量</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetClientCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span></span><br><span class="line"><span class="function"><span class="keyword">private</span>:</span></span><br><span class="line"><span class="function">	//缓冲区相关 </span></span><br><span class="line"><span class="function">	char *_Recv_buf;</span><span class="comment">//接收缓冲区 </span></span><br><span class="line">	<span class="comment">//socket相关 </span></span><br><span class="line">	SOCKET _sock; </span><br><span class="line">	<span class="comment">//正式客户队列 </span></span><br><span class="line">	std::vector&lt;ClientSocket*&gt; _clients;<span class="comment">//储存客户端</span></span><br><span class="line">	<span class="comment">//客户缓冲区队列</span></span><br><span class="line">	std::vector&lt;ClientSocket*&gt; _clientsBuf; </span><br><span class="line">	std::mutex _mutex;<span class="comment">//锁</span></span><br><span class="line">	<span class="comment">//线程 </span></span><br><span class="line">	std::thread* _pThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	std::atomic_int _recvCount;<span class="comment">//接收包的数量 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>大致处理思路如下：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">线程外：</span><br><span class="line"><span class="built_in">Start</span>() 首先调用该方法启动线程</span><br><span class="line"></span><br><span class="line">新客户端加入：</span><br><span class="line"><span class="built_in">GetClientCount</span>() 首先主线程使用这个方法获取各个线程内客户端数量</span><br><span class="line"><span class="comment">//这个添加客户端的方法内涉及到临界区，需要上锁</span></span><br><span class="line"><span class="built_in">addClient</span>(ClientSocket* client) 主线程找到客户端数量最少的线程，使用该线程添加客户端至缓冲队列</span><br><span class="line"></span><br><span class="line">线程内：</span><br><span class="line"><span class="built_in">OnRun</span>()<span class="comment">//运行线程</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">IsRun</span>())<span class="comment">//判断是否工作中</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="number">1.</span>将缓冲队列中的客户数据加入正式队列</span><br><span class="line">		<span class="number">2.</span>正式客户队列为空的话，<span class="keyword">continue</span>本次循环</span><br><span class="line">		<span class="number">3.</span>select选择出待处理事件，错误的话就关闭所有连接<span class="built_in">CloseSocket</span>()</span><br><span class="line">		<span class="number">4.</span>对待处理事件进行接收<span class="built_in">RecvData</span>()，接收包的数量加一，随后处理<span class="built_in">NetMsg</span>()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-客户端主线程类的更改"><a href="#2-客户端主线程类的更改" class="headerlink" title="2.客户端主线程类的更改"></a>2.客户端主线程类的更改</h2><p>&emsp;&emsp;由于我们处理事件都改为在子线程中，所以首先主线程中是不需要处理报文消息了，所以类中接收消息和处理消息的方法都可以删除了。同时我们加入<code>Start</code>方法用来启动子线程，加入<code>time4msg</code>方法用来显示子线程中的客户端数量、每秒收包数等数据。</p>
<ul>
<li>主线程类<code>TcpServer</code>，更改后如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TcpServer</span> : INetEvent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造 </span></span><br><span class="line">	<span class="built_in">TcpServer</span>();</span><br><span class="line">	<span class="comment">//析构 </span></span><br><span class="line">	~<span class="built_in">TcpServer</span>();</span><br><span class="line">	<span class="comment">//初始化socket 返回1为正常 </span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">InitSocket</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//绑定IP/端口</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Bind</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* ip,<span class="type">unsigned</span> <span class="type">short</span> port)</span></span>;</span><br><span class="line">	<span class="comment">//监听端口</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Listen</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line">	<span class="comment">//接受连接</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Accept</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//添加客户端至服务端  </span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">AddClientToServer</span><span class="params">(ClientSocket* pClient)</span></span>;</span><br><span class="line">	<span class="comment">//线程启动 </span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//关闭socket </span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">CloseSocket</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//判断是否工作中 </span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">IsRun</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//查询是否有待处理消息 </span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">OnRun</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//显示各线程数据信息 </span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">time4msg</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//socket相关 </span></span><br><span class="line">	SOCKET _sock; </span><br><span class="line">	std::vector&lt;ClientSocket*&gt; _clients;<span class="comment">//储存客户端</span></span><br><span class="line">	std::vector&lt;CellServer*&gt; _cellServers;<span class="comment">//子线程们 </span></span><br><span class="line">	<span class="comment">//计时器</span></span><br><span class="line">	mytimer _time; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>大致处理思路如下：<a href="https://blog.csdn.net/qq_45698148/article/details/113702354">计时器相关请点这里</a><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">调用TcpServer封装类建立服务端的流程：</span><br><span class="line"><span class="number">1.</span><span class="built_in">InitSocket</span>() 建立一个socket</span><br><span class="line"><span class="number">2.</span><span class="built_in">Bind</span>(<span class="type">const</span> <span class="type">char</span>* ip,<span class="type">unsigned</span> <span class="type">short</span> port) 绑定端口和IP</span><br><span class="line"><span class="number">3.L</span>isten(<span class="type">int</span> n) 监听</span><br><span class="line"><span class="number">4.</span><span class="built_in">Start</span>() 线程启动</span><br><span class="line"><span class="keyword">while</span>(<span class="number">5.</span><span class="built_in">IsRun</span>()) 主线程循环 </span><br><span class="line">&#123;</span><br><span class="line">	<span class="number">6.</span><span class="built_in">OnRun</span>() 开始select选择处理事件</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">7.</span><span class="built_in">CloseSocket</span>() 关闭socket</span><br><span class="line"></span><br><span class="line">主线程内：</span><br><span class="line"><span class="built_in">OnRun</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">time4msg</span>()显示数据 </span><br><span class="line">	select选择出新客户端加入事件</span><br><span class="line">	如果有新客户端加入，调用<span class="built_in">Accept</span>()接受连接</span><br><span class="line">	<span class="built_in">Accept</span>()连接成功后，调用<span class="built_in">AddClientToServer</span>(ClientSocket* pClient)分配客户端到子线程中</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">AddClientToServer</span>()内：</span><br><span class="line">首先调用子线程的<span class="built_in">GetClientCount</span>()方法获取各条子线程中的客户端数量</span><br><span class="line">随后调用子线程的<span class="built_in">addClient</span>(ClientSocket* client)方法，把新客户端添加至客户端最少的线程中</span><br><span class="line"></span><br><span class="line"><span class="built_in">time4msg</span>()内：</span><br><span class="line">首先<span class="built_in">GetSecond</span>()获取计时器的计时</span><br><span class="line">如果大于一秒，就统计客户端的情况：子线程内_recvCount为收包数，主线程内_clients.<span class="built_in">size</span>()获取客户端数量</span><br><span class="line">显示后<span class="built_in">UpDate</span>()重置计时器，并且重置收包数，从而达到统计每秒收包数的作用</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-引入接口，实现子线程向主线程通信"><a href="#3-引入接口，实现子线程向主线程通信" class="headerlink" title="3.引入接口，实现子线程向主线程通信"></a>3.引入接口，实现子线程向主线程通信</h2><p>&emsp;&emsp;通过前两步的实现，多线程服务端已经初步完成，接下来需要进行一些完善。<br>&emsp;&emsp;我们很容易可以发现，子线程对象是在主线程<code>Start()</code>方法被创建的，随后被加入容器<code>_cellServers</code>储存。这就导致主线程中可以调用子线程类中的方法与成员变量，但是子线程中却无法调用主线程的方法与成员变量。从而导致当子线程中有客户端退出时，主线程无法了解。<br>&emsp;&emsp;对于这种情况，我们可以创建一个接口，让主线程类继承这个接口，子线程即可通过这个接口调用主线程中的特定方法。</p>
<ul>
<li>接口类<code>INetEvent</code>如下：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">INetEvent</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//有客户端退出 </span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnLeave</span><span class="params">(ClientSocket* pClient)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span>:	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>主线程类与子线程类中的相关实现：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>首先是主线程类继承该接口：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TcpServer</span> : INetEvent</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>随后实现接口中的虚方法：</span><br><span class="line"><span class="comment">//客户端退出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnLeave</span><span class="params">(ClientSocket* pClient)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//找到退出的客户端 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;_clients.<span class="built_in">size</span>(); n++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(_clients[n] == pClient)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">auto</span> iter = _clients.<span class="built_in">begin</span>() + n;</span><br><span class="line">			<span class="keyword">if</span>(iter != _clients.<span class="built_in">end</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				_clients.<span class="built_in">erase</span>(iter);<span class="comment">//移除 </span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line">即可实现调用该方法，移除客户端容器中指定客户端</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>随后在子线程类中添加私有成员变量： </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	INetEvent* _pNetEvent; </span><br><span class="line">创建接口对象</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>创建方法，让接口对象指向主线程类</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setEventObj</span><span class="params">(INetEvent* event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_pNetEvent = event; </span><br><span class="line">&#125;</span><br><span class="line">event传进去主线程即可，接口对象即指向主线程</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>主线程创建、启动子线程类时，调用该方法，传入自身<span class="keyword">this</span></span><br><span class="line">子线程对象-&gt;<span class="built_in">setEventObj</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span>随后即可通过子线程调用主线程的<span class="built_in">OnLeave</span>()方法删除客户端</span><br><span class="line">_pNetEvent-&gt;<span class="built_in">OnLeave</span>(要删除的客户端);</span><br></pre></td></tr></table></figure>
<h1 id="三、详细代码实现"><a href="#三、详细代码实现" class="headerlink" title="三、详细代码实现"></a>三、详细代码实现</h1><h2 id="1-计时器头文件-mytimer-hpp"><a href="#1-计时器头文件-mytimer-hpp" class="headerlink" title="1.计时器头文件 mytimer.hpp"></a>1.计时器头文件 <code>mytimer.hpp</code></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MY_TIMER_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_TIMER_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mytimer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::chrono::steady_clock::time_point _begin;<span class="comment">//起始时间</span></span><br><span class="line">    std::chrono::steady_clock::time_point _end;<span class="comment">//终止时间</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">mytimer</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		_begin = std::chrono::steady_clock::<span class="built_in">time_point</span>();</span><br><span class="line">		_end = std::chrono::steady_clock::<span class="built_in">time_point</span>();</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">mytimer</span>()&#123;&#125;;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用update时，使起始时间等于当前时间</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">UpDate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _begin = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用getsecond方法时，经过的时间为当前时间减去之前统计过的起始时间。</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">GetSecond</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _end = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">        <span class="comment">//使用duration类型变量进行时间的储存   duration_cast是类型转换方法</span></span><br><span class="line">        std::chrono::duration&lt;<span class="type">double</span>&gt; temp = std::chrono::duration_cast&lt;std::chrono::duration&lt;<span class="type">double</span>&gt;&gt;(_end - _begin);</span><br><span class="line">       	<span class="keyword">return</span> temp.<span class="built_in">count</span>();<span class="comment">//count() 获取当前时间的计数数量</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="2-命令头文件-CMD-h"><a href="#2-命令头文件-CMD-h" class="headerlink" title="2.命令头文件 CMD.h"></a>2.命令头文件 <code>CMD.h</code></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//枚举类型记录命令 </span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">cmd</span> </span><br><span class="line">&#123;</span><br><span class="line">	CMD_LOGIN,<span class="comment">//登录 </span></span><br><span class="line">	CMD_LOGINRESULT,<span class="comment">//登录结果 </span></span><br><span class="line">	CMD_LOGOUT,<span class="comment">//登出 </span></span><br><span class="line">	CMD_LOGOUTRESULT,<span class="comment">//登出结果 </span></span><br><span class="line">	CMD_NEW_USER_JOIN,<span class="comment">//新用户登入 </span></span><br><span class="line">	CMD_ERROR<span class="comment">//错误 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义数据包头 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DataHeader</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">short</span> cmd;<span class="comment">//命令</span></span><br><span class="line">	<span class="type">short</span> date_length;<span class="comment">//数据的长短	</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包1 登录 传输账号与密码</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Login</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Login</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGIN;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Login); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">	<span class="type">char</span> PassWord[<span class="number">32</span>];<span class="comment">//密码 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包2 登录结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoginResult</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LoginResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGINRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LoginResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包3 登出 传输用户名 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Logout</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Logout</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(Logout); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包4 登出结果 传输结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LogoutResult</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LogoutResult</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_LOGOUTRESULT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(LogoutResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//包5 新用户登入 传输通告 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NewUserJoin</span> : <span class="keyword">public</span> DataHeader </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">NewUserJoin</span>()<span class="comment">//初始化包头 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cmd = CMD_NEW_USER_JOIN;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date_length = <span class="built_in">sizeof</span>(NewUserJoin); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> UserName[<span class="number">32</span>];<span class="comment">//用户名 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-服务端头文件-TcpServer-hpp"><a href="#3-服务端头文件-TcpServer-hpp" class="headerlink" title="3.服务端头文件 TcpServer.hpp"></a>3.服务端头文件 <code>TcpServer.hpp</code></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TcpServer_hpp_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TcpServer_hpp_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> FD_SETSIZE 10240 </span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;winSock2.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//链接此动态链接库 windows特有 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span><span class="comment">//selcet</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span><span class="comment">//uni std</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SOCKET int</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> INVALID_SOCKET (SOCKET)(~0)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SOCKET_ERROR (-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;CMD.h&quot;</span><span class="comment">//命令 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;mytimer.hpp&quot;</span><span class="comment">//计时器 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//缓冲区大小 </span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> RECV_BUFFER_SIZE</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> RECV_BUFFER_SIZE 4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程数量 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _THREAD_COUNT 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端类 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClientSocket</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造 </span></span><br><span class="line">	<span class="built_in">ClientSocket</span>(SOCKET sockfd = INVALID_SOCKET)</span><br><span class="line">	&#123;</span><br><span class="line">		_sockfd = sockfd;</span><br><span class="line">		<span class="comment">//缓冲区相关 </span></span><br><span class="line">		_Msg_buf = <span class="keyword">new</span> <span class="type">char</span>[RECV_BUFFER_SIZE*<span class="number">10</span>];</span><br><span class="line">		_Len_buf = <span class="number">0</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构 </span></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">ClientSocket</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span>[] _Msg_buf;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//获取socket </span></span><br><span class="line">	<span class="function">SOCKET <span class="title">GetSockfd</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _sockfd;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//获取缓冲区 </span></span><br><span class="line">	<span class="function"><span class="type">char</span>* <span class="title">MsgBuf</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _Msg_buf;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//获取缓冲区尾部变量 </span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetLen</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _Len_buf;	</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//设置缓冲区尾巴变量</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetLen</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		_Len_buf = len;</span><br><span class="line">	&#125; </span><br><span class="line">		</span><br><span class="line"><span class="keyword">private</span>:	</span><br><span class="line">	SOCKET _sockfd;</span><br><span class="line">	<span class="comment">//缓冲区相关 </span></span><br><span class="line">	<span class="type">char</span> *_Msg_buf;<span class="comment">//消息缓冲区 </span></span><br><span class="line">	<span class="type">int</span> _Len_buf;<span class="comment">//缓冲区数据尾部变量</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">//事件接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">INetEvent</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//有客户端退出 </span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnLeave</span><span class="params">(ClientSocket* pClient)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span>:	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CellServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造 </span></span><br><span class="line">	<span class="built_in">CellServer</span>(SOCKET sock = INVALID_SOCKET)</span><br><span class="line">	&#123;</span><br><span class="line">		_sock = sock; </span><br><span class="line">		_pThread = <span class="literal">nullptr</span>;</span><br><span class="line">		_pNetEvent = <span class="literal">nullptr</span>;</span><br><span class="line">		_recvCount = <span class="number">0</span>; </span><br><span class="line">		<span class="comment">//缓冲区相关 </span></span><br><span class="line">		_Recv_buf = <span class="keyword">new</span> <span class="type">char</span>[RECV_BUFFER_SIZE];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构</span></span><br><span class="line">	~<span class="built_in">CellServer</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span>[] _Recv_buf;</span><br><span class="line">		<span class="comment">//关闭socket </span></span><br><span class="line">		<span class="built_in">CloseSocket</span>();</span><br><span class="line">		_sock = INVALID_SOCKET;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//处理事件 </span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setEventObj</span><span class="params">(INetEvent* event)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		_pNetEvent = event; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//关闭socket </span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">CloseSocket</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET != _sock) </span><br><span class="line">		&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">			<span class="comment">//关闭客户端socket</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;_clients.<span class="built_in">size</span>(); ++n)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">closesocket</span>(_clients[n]-&gt;<span class="built_in">GetSockfd</span>());</span><br><span class="line">				<span class="keyword">delete</span> _clients[n];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//关闭socket</span></span><br><span class="line">			<span class="built_in">closesocket</span>(_sock); </span><br><span class="line">			<span class="comment">//清除windows socket 环境 </span></span><br><span class="line">			<span class="built_in">WSACleanup</span>(); </span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">			<span class="comment">//关闭客户端socket</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;_clients.<span class="built_in">size</span>(); ++n)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">close</span>(_clients[n]-&gt;<span class="built_in">GetSockfd</span>());</span><br><span class="line">				<span class="keyword">delete</span> _clients[n];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//关闭socket/LINUX</span></span><br><span class="line">			<span class="built_in">close</span>(_sock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">			_sock = INVALID_SOCKET;</span><br><span class="line">			_clients.<span class="built_in">clear</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//判断是否工作中 </span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">IsRun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _sock != INVALID_SOCKET; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//查询是否有待处理消息 </span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">OnRun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">IsRun</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//将缓冲队列中的客户数据加入正式队列 </span></span><br><span class="line">			<span class="keyword">if</span>(_clientsBuf.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;<span class="comment">//上锁 </span></span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">auto</span> client :_clientsBuf)</span><br><span class="line">				&#123;</span><br><span class="line">					_clients.<span class="built_in">push_back</span>(client);</span><br><span class="line">				&#125;</span><br><span class="line">				_clientsBuf.<span class="built_in">clear</span>();</span><br><span class="line">			&#125; </span><br><span class="line">			<span class="comment">//如果没有需要处理的客户端就跳过 </span></span><br><span class="line">			<span class="keyword">if</span>(_clients.<span class="built_in">empty</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				std::<span class="function">chrono::milliseconds <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;<span class="comment">//休眠一毫秒 </span></span><br><span class="line">				std::this_thread::<span class="built_in">sleep_for</span>(t);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			fd_set fdRead;<span class="comment">//建立集合 </span></span><br><span class="line">			<span class="built_in">FD_ZERO</span>(&amp;fdRead);<span class="comment">//清空集合 </span></span><br><span class="line">			SOCKET maxSock = _clients[<span class="number">0</span>]-&gt;<span class="built_in">GetSockfd</span>();<span class="comment">//最大socket </span></span><br><span class="line">			<span class="comment">//把连接的客户端 放入read集合 </span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> n=_clients.<span class="built_in">size</span>()<span class="number">-1</span>; n&gt;=<span class="number">0</span>; --n)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">FD_SET</span>(_clients[n]-&gt;<span class="built_in">GetSockfd</span>(),&amp;fdRead);</span><br><span class="line">				<span class="keyword">if</span>(maxSock &lt; _clients[n]-&gt;<span class="built_in">GetSockfd</span>())</span><br><span class="line">				&#123;</span><br><span class="line">					maxSock = _clients[n]-&gt;<span class="built_in">GetSockfd</span>();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//select函数筛选select </span></span><br><span class="line">			<span class="type">int</span> ret = <span class="built_in">select</span>(maxSock<span class="number">+1</span>,&amp;fdRead,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>); </span><br><span class="line">			<span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;select任务结束\n&quot;</span>);</span><br><span class="line">				<span class="built_in">CloseSocket</span>();</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//遍历所有socket 查看是否有待处理事件 </span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;_clients.<span class="built_in">size</span>(); ++n)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(_clients[n]-&gt;<span class="built_in">GetSockfd</span>(),&amp;fdRead))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(<span class="number">-1</span> == <span class="built_in">RecvData</span>(_clients[n]))<span class="comment">//处理请求 客户端退出的话 </span></span><br><span class="line">					&#123;</span><br><span class="line">						std::vector&lt;ClientSocket*&gt;::iterator iter = _clients.<span class="built_in">begin</span>()+n;<span class="comment">//找到退出客户端的地址</span></span><br><span class="line">						<span class="keyword">if</span>(iter != _clients.<span class="built_in">end</span>())<span class="comment">//如果是合理值</span></span><br><span class="line">						&#123;</span><br><span class="line">							<span class="keyword">if</span>(_pNetEvent)<span class="comment">//主线程中删除客户端 </span></span><br><span class="line">							&#123;</span><br><span class="line">								_pNetEvent-&gt;<span class="built_in">OnLeave</span>(_clients[n]);</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">delete</span> _clients[n];</span><br><span class="line">							_clients.<span class="built_in">erase</span>(iter);<span class="comment">//移除</span></span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//printf(&quot;空闲时间处理其他业务\n&quot;);</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//接收数据</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">RecvData</span><span class="params">(ClientSocket *t_client)</span><span class="comment">//处理数据 </span></span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		_recvCount++;<span class="comment">//收包数量加一 </span></span><br><span class="line">		<span class="comment">//接收客户端发送的数据  </span></span><br><span class="line">		<span class="type">int</span> buf_len = <span class="built_in">recv</span>(t_client-&gt;<span class="built_in">GetSockfd</span>(), _Recv_buf, RECV_BUFFER_SIZE, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(buf_len&lt;=<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;客户端已退出\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125; </span><br><span class="line">		</span><br><span class="line">		<span class="comment">//将接收缓冲区的数据拷贝到消息缓冲区 </span></span><br><span class="line">		<span class="built_in">memcpy</span>(t_client-&gt;<span class="built_in">MsgBuf</span>() + t_client-&gt;<span class="built_in">GetLen</span>(), _Recv_buf, buf_len); </span><br><span class="line">		<span class="comment">//消息缓冲区的数据末尾后移 </span></span><br><span class="line">		t_client-&gt;<span class="built_in">SetLen</span>(t_client-&gt;<span class="built_in">GetLen</span>() + buf_len);</span><br><span class="line">		<span class="comment">//判断消息缓冲区的数据长度是否大于等于包头长度 </span></span><br><span class="line">		<span class="keyword">while</span>(t_client-&gt;<span class="built_in">GetLen</span>() &gt;= <span class="built_in">sizeof</span>(DataHeader))<span class="comment">//处理粘包问题 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//选出包头数据 </span></span><br><span class="line">			DataHeader* header = (DataHeader*)t_client-&gt;<span class="built_in">MsgBuf</span>(); </span><br><span class="line">			<span class="comment">//判断消息缓冲区内数据长度是否大于等于报文长度 避免少包问题 </span></span><br><span class="line">			<span class="keyword">if</span>(t_client-&gt;<span class="built_in">GetLen</span>() &gt;= header-&gt;date_length)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//计算出消息缓冲区内剩余未处理数据的长度</span></span><br><span class="line">				<span class="type">int</span> size = t_client-&gt;<span class="built_in">GetLen</span>() - header-&gt;date_length; </span><br><span class="line">				<span class="comment">//响应数据 </span></span><br><span class="line">				<span class="built_in">NetMsg</span>(header,t_client-&gt;<span class="built_in">GetSockfd</span>());</span><br><span class="line">				<span class="comment">//将消息缓冲区剩余未处理的数据前移</span></span><br><span class="line">				<span class="built_in">memcpy</span>(t_client-&gt;<span class="built_in">MsgBuf</span>(), t_client-&gt;<span class="built_in">MsgBuf</span>() + header-&gt;date_length, size);</span><br><span class="line">				<span class="comment">//消息缓冲区的数据末尾前移</span></span><br><span class="line">				t_client-&gt;<span class="built_in">SetLen</span>(size); </span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//消息缓冲区数据不足 </span></span><br><span class="line">				<span class="keyword">break</span>; </span><br><span class="line">			&#125; </span><br><span class="line">		&#125;  </span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//响应数据</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">NetMsg</span><span class="params">(DataHeader *head,SOCKET temp_socket)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		</span><br><span class="line">	 	<span class="comment">//printf(&quot;接收到包头，命令：%d，数据长度：%d\n&quot;,head-&gt;cmd,head-&gt;date_length);</span></span><br><span class="line">		<span class="keyword">switch</span>(head-&gt;cmd)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> CMD_LOGIN:<span class="comment">//登录 接收登录包体 </span></span><br><span class="line">			&#123;</span><br><span class="line">				Login *login = (Login*)head;</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				进行判断操作 </span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				<span class="comment">//printf(&quot;%s已登录\n密码：%s\n&quot;,login-&gt;UserName,login-&gt;PassWord); </span></span><br><span class="line">				LoginResult *result = <span class="keyword">new</span> LoginResult;	</span><br><span class="line">				result-&gt;Result = <span class="number">1</span>;</span><br><span class="line">				<span class="comment">//SendData(result,temp_socket);</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> CMD_LOGOUT:<span class="comment">//登出 接收登出包体 </span></span><br><span class="line">			&#123;</span><br><span class="line">				Logout *logout = (Logout*)head;</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				进行判断操作 </span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				<span class="comment">//printf(&quot;%s已登出\n&quot;,logout-&gt;UserName); </span></span><br><span class="line">				LogoutResult *result = <span class="keyword">new</span> <span class="built_in">LogoutResult</span>();</span><br><span class="line">				result-&gt;Result = <span class="number">1</span>;</span><br><span class="line">				<span class="comment">//SendData(result,temp_socket);</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:<span class="comment">//错误 </span></span><br><span class="line">			&#123;</span><br><span class="line">				head-&gt;cmd = CMD_ERROR; </span><br><span class="line">				head-&gt;date_length = <span class="number">0</span>; </span><br><span class="line">				<span class="comment">//SendData(head,temp_socket); </span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//增加客户端 </span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">addClient</span><span class="params">(ClientSocket* client)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">		<span class="comment">//_mutex.lock();</span></span><br><span class="line">		_clientsBuf.<span class="built_in">push_back</span>(client);	</span><br><span class="line">		<span class="comment">//_mutex.unlock();</span></span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//启动线程</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		_pThread = <span class="keyword">new</span> std::<span class="built_in">thread</span>(std::<span class="built_in">mem_fun</span>(&amp;CellServer::OnRun),<span class="keyword">this</span>);</span><br><span class="line">		 </span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//获取该线程内客户端数量</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetClientCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _clients.<span class="built_in">size</span>() + _clientsBuf.<span class="built_in">size</span>();	</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//缓冲区相关 </span></span><br><span class="line">	<span class="type">char</span> *_Recv_buf;<span class="comment">//接收缓冲区 </span></span><br><span class="line">	<span class="comment">//socket相关 </span></span><br><span class="line">	SOCKET _sock; </span><br><span class="line">	<span class="comment">//正式客户队列 </span></span><br><span class="line">	std::vector&lt;ClientSocket*&gt; _clients;<span class="comment">//储存客户端</span></span><br><span class="line">	<span class="comment">//客户缓冲区</span></span><br><span class="line">	std::vector&lt;ClientSocket*&gt; _clientsBuf; </span><br><span class="line">	std::mutex _mutex;<span class="comment">//锁</span></span><br><span class="line">	<span class="comment">//线程 </span></span><br><span class="line">	std::thread* _pThread;</span><br><span class="line">	<span class="comment">//退出事件接口 </span></span><br><span class="line">	INetEvent* _pNetEvent; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	std::atomic_int _recvCount;<span class="comment">//接收包的数量 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务端类 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TcpServer</span> : INetEvent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造 </span></span><br><span class="line">	<span class="built_in">TcpServer</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		_sock = INVALID_SOCKET; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//析构 </span></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">TcpServer</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//关闭socket </span></span><br><span class="line">		<span class="built_in">CloseSocket</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//初始化socket 返回1为正常 </span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">InitSocket</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">		<span class="comment">//启动windows socket 2,x环境 </span></span><br><span class="line">		WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>); </span><br><span class="line">		WSADATA dat;</span><br><span class="line">		<span class="keyword">if</span>(<span class="number">0</span> != <span class="built_in">WSAStartup</span>(ver,&amp;dat))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//-1为环境错误 </span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">		<span class="comment">//创建socket </span></span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET != _sock)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;&lt;Socket=%d&gt;关闭连接\n&quot;</span>,_sock); </span><br><span class="line">			<span class="built_in">CloseSocket</span>();<span class="comment">//如果之前有连接 就关闭连接 </span></span><br><span class="line">		&#125;</span><br><span class="line">		_sock = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,IPPROTO_TCP); </span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET == _sock)</span><br><span class="line">		&#123;   </span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//0为socket创建错误 </span></span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//绑定IP/端口</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Bind</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* ip,<span class="type">unsigned</span> <span class="type">short</span> port)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//如果为无效套接字 则初始化 </span></span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET == _sock)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">InitSocket</span>(); </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//绑定网络端口和IP地址 </span></span><br><span class="line">		sockaddr_in _myaddr = &#123;&#125;; </span><br><span class="line">		_myaddr.sin_family = AF_INET;<span class="comment">//IPV4</span></span><br><span class="line">		_myaddr.sin_port = <span class="built_in">htons</span>(port);<span class="comment">//端口</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">		<span class="keyword">if</span>(ip)<span class="comment">//ip为空则监听所有网卡 </span></span><br><span class="line">		&#123;</span><br><span class="line">			_myaddr.sin_addr.S_un.S_addr = <span class="built_in">inet_addr</span>(ip);<span class="comment">//IP</span></span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			_myaddr.sin_addr.S_un.S_addr = INADDR_ANY;<span class="comment">//IP</span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		<span class="keyword">if</span>(ip)<span class="comment">//ip为空则监听所有网卡</span></span><br><span class="line">		&#123;</span><br><span class="line">			_myaddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(ip);<span class="comment">//IP </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			_myaddr.sin_addr.s_addr = INADDR_ANY;<span class="comment">//IP </span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">bind</span>(_sock,(sockaddr*)&amp;_myaddr,<span class="built_in">sizeof</span>(sockaddr_in)))<span class="comment">//socket (强制转换)sockaddr结构体 结构体大小 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;绑定失败\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;绑定成功\n绑定端口为%d\n&quot;</span>,port);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//监听端口</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Listen</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//如果为无效套接字 则提示 </span></span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET == _sock)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;请先初始化套接字并绑定IP端口\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//监听网络端口</span></span><br><span class="line">		<span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">listen</span>(_sock,n))<span class="comment">//最大连接队列 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;监听失败\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;监听成功\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//接受连接</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Accept</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//等待接收客户端连接</span></span><br><span class="line">		sockaddr_in clientAddr = &#123;&#125;;<span class="comment">//新建sockadd结构体接收客户端数据 </span></span><br><span class="line">		<span class="type">int</span> addr_len = <span class="built_in">sizeof</span>(sockaddr_in);<span class="comment">//获取sockadd结构体长度 </span></span><br><span class="line">		SOCKET temp_socket = INVALID_SOCKET;<span class="comment">//声明客户端套接字 </span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32	</span></span><br><span class="line">		temp_socket = <span class="built_in">accept</span>(_sock,(sockaddr*)&amp;clientAddr,&amp;addr_len);<span class="comment">//自身套接字 客户端结构体 结构体大小 	</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		temp_socket = <span class="built_in">accept</span>(_sock,(sockaddr*)&amp;clientAddr,(<span class="type">socklen_t</span>*)&amp;addr_len);<span class="comment">//自身套接字 客户端结构体 结构体大小 </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET == temp_socket)<span class="comment">//接收失败 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;&lt;Socket=%d&gt;错误,接受到无效客户端SOCKET\n&quot;</span>,temp_socket);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123; </span><br><span class="line">			<span class="comment">//printf(&quot;新客户端加入 count: %d\nIP地址为：%s \n&quot;, _clients.size(), inet_ntoa(clientAddr.sin_addr));  </span></span><br><span class="line">			<span class="comment">//群发所有客户端 通知新用户登录 </span></span><br><span class="line">			<span class="comment">//NewUserJoin *user_join = new NewUserJoin(); </span></span><br><span class="line">			<span class="comment">//strcpy(user_join-&gt;UserName,inet_ntoa(clientAddr.sin_addr));</span></span><br><span class="line">			<span class="comment">//SendDataToAll(user_join);</span></span><br><span class="line">			<span class="comment">//将新的客户端加入动态数组</span></span><br><span class="line">			<span class="built_in">AddClientToServer</span>(<span class="keyword">new</span> <span class="built_in">ClientSocket</span>(temp_socket));</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//添加客户端至服务端  </span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">AddClientToServer</span><span class="params">(ClientSocket* pClient)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		_clients.<span class="built_in">push_back</span>(pClient);</span><br><span class="line">		<span class="comment">//找出客户端最少的线程 然后加入 </span></span><br><span class="line">		<span class="keyword">auto</span> pMinServer = _cellServers[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> pCellServer : _cellServers)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(pMinServer-&gt;<span class="built_in">GetClientCount</span>() &gt; pCellServer-&gt;<span class="built_in">GetClientCount</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				pMinServer = pCellServer;</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">		pMinServer-&gt;<span class="built_in">addClient</span>(pClient);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//线程启动 </span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;_THREAD_COUNT; n++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//线程加入容器 </span></span><br><span class="line">			<span class="keyword">auto</span> ser = <span class="keyword">new</span> <span class="built_in">CellServer</span>(_sock); </span><br><span class="line">			_cellServers.<span class="built_in">push_back</span>(ser);</span><br><span class="line">			ser-&gt;<span class="built_in">setEventObj</span>(<span class="keyword">this</span>);</span><br><span class="line">			ser-&gt;<span class="built_in">Start</span>(); </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//关闭socket </span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">CloseSocket</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(INVALID_SOCKET != _sock) </span><br><span class="line">		&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">			<span class="comment">//关闭客户端socket</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;_clients.<span class="built_in">size</span>(); ++n)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">closesocket</span>(_clients[n]-&gt;<span class="built_in">GetSockfd</span>());</span><br><span class="line">				<span class="keyword">delete</span> _clients[n];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//关闭socket</span></span><br><span class="line">			<span class="built_in">closesocket</span>(_sock); </span><br><span class="line">			<span class="comment">//清除windows socket 环境 </span></span><br><span class="line">			<span class="built_in">WSACleanup</span>(); </span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">			<span class="comment">//关闭客户端socket</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;_clients.<span class="built_in">size</span>(); ++n)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">close</span>(_clients[n]-&gt;<span class="built_in">GetSockfd</span>());</span><br><span class="line">				<span class="keyword">delete</span> _clients[n];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//关闭socket/LINUX</span></span><br><span class="line">			<span class="built_in">close</span>(_sock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">			_sock = INVALID_SOCKET;</span><br><span class="line">			_clients.<span class="built_in">clear</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//判断是否工作中 </span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">IsRun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _sock != INVALID_SOCKET; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//查询是否有待处理消息 </span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">OnRun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">IsRun</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">time4msg</span>();<span class="comment">//查看各线程数据信息 </span></span><br><span class="line">			fd_set fdRead;<span class="comment">//建立集合 </span></span><br><span class="line">			<span class="comment">//fd_set fdWrite;</span></span><br><span class="line">			<span class="comment">//fd_set fdExcept;</span></span><br><span class="line">			<span class="built_in">FD_ZERO</span>(&amp;fdRead);<span class="comment">//清空集合 </span></span><br><span class="line">			<span class="comment">//FD_ZERO(&amp;fdWrite); </span></span><br><span class="line">			<span class="comment">//FD_ZERO(&amp;fdExcept); </span></span><br><span class="line">			<span class="built_in">FD_SET</span>(_sock,&amp;fdRead);<span class="comment">//放入集合 </span></span><br><span class="line">			<span class="comment">//FD_SET(_sock,&amp;fdWrite); </span></span><br><span class="line">			<span class="comment">//FD_SET(_sock,&amp;fdExcept);</span></span><br><span class="line">			timeval <span class="type">s_t</span> = &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;<span class="comment">//select最大响应时间 </span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">//select函数筛选select </span></span><br><span class="line">			<span class="type">int</span> ret = <span class="built_in">select</span>(_sock<span class="number">+1</span>,&amp;fdRead,<span class="number">0</span>,<span class="number">0</span>,&amp;<span class="type">s_t</span>); </span><br><span class="line">			<span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;select任务结束\n&quot;</span>);</span><br><span class="line">				<span class="built_in">CloseSocket</span>();</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(_sock,&amp;fdRead))<span class="comment">//获取是否有新socket连接 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">FD_CLR</span>(_sock,&amp;fdRead);<span class="comment">//清理</span></span><br><span class="line">				<span class="built_in">Accept</span>();<span class="comment">//连接 </span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//显示各线程数据信息 </span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">time4msg</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">auto</span> t1 = _time.<span class="built_in">GetSecond</span>();</span><br><span class="line">		<span class="keyword">if</span>(<span class="number">1.0</span> &lt;= t1)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> recvCount = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> ser: _cellServers)</span><br><span class="line">			&#123;</span><br><span class="line">				recvCount += ser-&gt;_recvCount;</span><br><span class="line">				ser-&gt;_recvCount = <span class="number">0</span>; </span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//时间间隔  本机socket连接序号  客户端数量  每秒收包数 </span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;time&lt;%lf&gt;,socket&lt;%d&gt;,clients&lt;%d&gt;,recvCount&lt;%d&gt;\n&quot;</span>, t1, _sock, _clients.<span class="built_in">size</span>(),(<span class="type">int</span>)(recvCount/t1));</span><br><span class="line">			_time.<span class="built_in">UpDate</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//发送数据 </span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">SendData</span><span class="params">(DataHeader *head,SOCKET temp_socket)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">IsRun</span>() &amp;&amp; head)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">send</span>(temp_socket,(<span class="type">const</span> <span class="type">char</span>*)head,head-&gt;date_length,<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//向所有人发送数据</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SendDataToAll</span><span class="params">(DataHeader *head)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>;n&lt;_clients.<span class="built_in">size</span>();++n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">SendData</span>(head, _clients[n]-&gt;<span class="built_in">GetSockfd</span>());	</span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//客户端退出</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">OnLeave</span><span class="params">(ClientSocket* pClient)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//找到退出的客户端 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;_clients.<span class="built_in">size</span>(); n++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(_clients[n] == pClient)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">auto</span> iter = _clients.<span class="built_in">begin</span>() + n;</span><br><span class="line">				<span class="keyword">if</span>(iter != _clients.<span class="built_in">end</span>())</span><br><span class="line">				&#123;</span><br><span class="line">					_clients.<span class="built_in">erase</span>(iter);<span class="comment">//移除 </span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	 </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//socket相关 </span></span><br><span class="line">	SOCKET _sock; </span><br><span class="line">	std::vector&lt;ClientSocket*&gt; _clients;<span class="comment">//储存客户端</span></span><br><span class="line">	std::vector&lt;CellServer*&gt; _cellServers;<span class="comment">//线程处理 </span></span><br><span class="line">	<span class="comment">//计时器</span></span><br><span class="line">	mytimer _time; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="4-服务端样例代码-server-cpp"><a href="#4-服务端样例代码-server-cpp" class="headerlink" title="4.服务端样例代码  server.cpp"></a>4.服务端样例代码  <code>server.cpp</code></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;TcpServer.hpp&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Welcome\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//建立tcp对象 </span></span><br><span class="line">	TcpServer *tcp1 = <span class="keyword">new</span> <span class="built_in">TcpServer</span>();</span><br><span class="line">	<span class="comment">//建立一个socket</span></span><br><span class="line">	tcp1-&gt;<span class="built_in">InitSocket</span>();</span><br><span class="line">	<span class="comment">//绑定端口和IP</span></span><br><span class="line">	tcp1-&gt;<span class="built_in">Bind</span>(<span class="literal">NULL</span>,<span class="number">8888</span>);</span><br><span class="line">	<span class="comment">//监听</span></span><br><span class="line">	tcp1-&gt;<span class="built_in">Listen</span>(<span class="number">5</span>);</span><br><span class="line">	<span class="comment">//线程启动</span></span><br><span class="line">	tcp1-&gt;<span class="built_in">Start</span>(); </span><br><span class="line">	<span class="comment">//循环 </span></span><br><span class="line">	<span class="keyword">while</span>(tcp1-&gt;<span class="built_in">IsRun</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		tcp1-&gt;<span class="built_in">OnRun</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//关闭</span></span><br><span class="line">	tcp1-&gt;<span class="built_in">CloseSocket</span>();</span><br><span class="line">	 </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;任务结束，程序已退出&quot;</span>); </span><br><span class="line">	<span class="built_in">getchar</span>(); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++网络编程学习：消息接收与发送分离</title>
    <url>/2021/02/21/20210221_C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%B6%88%E6%81%AF%E6%8E%A5%E6%94%B6%E4%B8%8E%E5%8F%91%E9%80%81%E5%88%86%E7%A6%BB/</url>
    <content><![CDATA[<ul>
<li>使用的语言为C&#x2F;C++</li>
<li>源码支持的平台为：Windows &#x2F; Linux</li>
</ul>
<h1 id="一、思路与准备"><a href="#一、思路与准备" class="headerlink" title="一、思路与准备"></a>一、思路与准备</h1><p>&emsp;&emsp;在之前的 <a href="https://blog.csdn.net/qq_45698148/article/details/113704768">C++网络编程学习：服务端多线程分离业务处理高负载</a> 笔记中，我将业务处理相关内容从主线程中分离，大大提高了服务端的效率。随着服务端的进一步完善，我会把各个模块进行分离，从而使代码的结构更加便于修改与完善，同时也可以提高代码的运行效率。<br>&emsp;&emsp;本篇笔记中，我会记录自己如何把消息发送的相关内容从业务处理线程中分离出来。</p>
<span id="more"></span>

<p>首先下面是我的思路图。</p>
<ul>
<li>大致思路如下：<strong>处理事件线程 &gt;&gt; 发送线程缓冲区 &gt;&gt; 发送线程</strong><br><img src="/images/2021-02-21/1.jpg" alt="在这里插入图片描述"></li>
</ul>
<p>&emsp;&emsp;我会在新建业务子线程时创建一条发送子线程。其中由主线程创建子线程对象，子线程对象中包含两条子线程，一条为业务子线程，一条为发送子线程。这样两条线程可以在一个对象中进行相关操作，便于实现。同时，主线程只需声明一个对象即可，封装性良好且低耦合。<br>&emsp;&emsp;在业务线程需要发送消息时，首先创建一个消息发送对象，其中包含发送的目标和内容。随后把该对象加入缓冲区。在发送线程中，首先把缓冲区内的对象提取到正式发送队列中，随后把正式发送队列中的待发送事件挨个进行处理即可。</p>
<h1 id="二、代码实现"><a href="#二、代码实现" class="headerlink" title="二、代码实现"></a>二、代码实现</h1><h2 id="1-发送线程类文件相关"><a href="#1-发送线程类文件相关" class="headerlink" title="1.发送线程类文件相关"></a>1.发送线程类文件相关</h2><p>&emsp;&emsp;首先，我们得新建两个类，一个是发送任务基类，一个是发送线程类。<br>&emsp;&emsp;发送任务基类中，含有一个虚方法<code>DoTask</code>用来执行发送任务。该方法在服务端源码中被重载。<br>&emsp;&emsp;发送线程类中，含有一条发送线程，同时有一个<code>Start</code>方法用来启动该线程。含有两条链表，一条为缓冲区链表，一条为正式消息链表，同时有一个<code>addTask</code>方法用来把消息任务加入缓冲区。线程执行<code>OnRun</code>方法把缓冲区中的任务加入正式队列并执行该任务的<code>DoTask</code>方法。</p>
<ul>
<li>发送线程类文件 <code>celltask.hpp</code> 大致代码如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _CELL_Task_hpp_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CELL_Task_hpp_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//任务基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CellTask</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//执行任务 </span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DoTask</span><span class="params">()</span> </span>= <span class="number">0</span>; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送线程类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CellTaskServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CellTaskServer</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">CellTaskServer</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//添加任务 </span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">addTask</span><span class="params">(CellTask* ptask)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::lock_guard&lt;std::mutex&gt;<span class="built_in">lock</span>(_mutex);</span><br><span class="line">		_tasksBuf.<span class="built_in">push_back</span>(ptask);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">//启动服务</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//线程</span></span><br><span class="line">		<span class="function">std::thread <span class="title">t</span><span class="params">(std::mem_fn(&amp;CellTaskServer::OnRun),<span class="keyword">this</span>)</span></span>; </span><br><span class="line">		t.<span class="built_in">detach</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">//工作函数 </span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">OnRun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//将缓冲区内数据加入 </span></span><br><span class="line">			<span class="keyword">if</span>(!_tasksBuf.<span class="built_in">empty</span>())<span class="comment">//不为空 </span></span><br><span class="line">			&#123;</span><br><span class="line">				std::lock_guard&lt;std::mutex&gt;<span class="built_in">lock</span>(_mutex);</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">auto</span> pTask : _tasksBuf)</span><br><span class="line">				&#123;</span><br><span class="line">					_tasks.<span class="built_in">push_back</span>(pTask);	</span><br><span class="line">				&#125; </span><br><span class="line">				_tasksBuf.<span class="built_in">clear</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//如果无任务</span></span><br><span class="line">			<span class="keyword">if</span>(_tasks.<span class="built_in">empty</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//休息一毫秒 </span></span><br><span class="line">				std::<span class="function">chrono::milliseconds <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">				std::this_thread::<span class="built_in">sleep_for</span>(t);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125; </span><br><span class="line">			<span class="comment">//处理任务</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> pTask:_tasks)</span><br><span class="line">			&#123;</span><br><span class="line">				pTask-&gt;<span class="built_in">DoTask</span>();</span><br><span class="line">				<span class="keyword">delete</span> pTask;	</span><br><span class="line">			&#125; </span><br><span class="line">			<span class="comment">//清空任务 </span></span><br><span class="line">			_tasks.<span class="built_in">clear</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//任务数据 </span></span><br><span class="line">	std::list&lt;CellTask*&gt;_tasks;</span><br><span class="line">	<span class="comment">//任务数据缓冲区 </span></span><br><span class="line">	std::list&lt;CellTask*&gt;_tasksBuf;</span><br><span class="line">	<span class="comment">//锁 锁数据缓冲区 </span></span><br><span class="line">	std::mutex _mutex; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>其中的缓冲区加入操作涉及到临界操作，所以加个自解锁。</li>
<li>因为缓冲区以及正式队列涉及到频繁进出，所以用的是链表<code>list</code>。</li>
<li>当没有发送任务时，会进行一毫秒的休息，防止消耗太多的内存。</li>
</ul>
<h2 id="2-主文件相关"><a href="#2-主文件相关" class="headerlink" title="2.主文件相关"></a>2.主文件相关</h2><p>&emsp;&emsp;在导入上述<code>celltask.hpp</code>头文件后，我们需要重载<code>DoTask</code>方法，从而实现把主文件内的相关类型数据进行发送。<br>&emsp;&emsp;我们可以创建一个新类，使他继承<code>CellTask</code>任务基类。其中导入主文件内的相关类型。例如下面的例子中就导入了<code>ClientSocket</code>客户端类与<code>DataHeader</code>报文结构体。同时重写了<code>DoTask</code>方法，使其调用<code>ClientSocket</code>客户端类的<code>SendData</code>方法发送报文。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//网络消息发送任务</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CellSendMsgTask</span> : <span class="keyword">public</span> CellTask</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CellSendMsgTask</span>(ClientSocket* pClient,DataHeader* pHead)</span><br><span class="line">	&#123;</span><br><span class="line">		_pClient = pClient;</span><br><span class="line">		_pHeader = pHead;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//执行任务</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DoTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		_pClient-&gt;<span class="built_in">SendData</span>(_pHeader);</span><br><span class="line">		<span class="keyword">delete</span> _pHeader;</span><br><span class="line">	&#125;  </span><br><span class="line">	</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	ClientSocket* _pClient;</span><br><span class="line">	DataHeader* _pHeader;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;而当我们想要发送报文时，只需要新建上述<code>CellSendMsgTask</code>对象，并调用<code>CellTaskServer</code>任务线程类的<code>addTask</code>方法添加至发送队列即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//向 pClient 客户端发送 pHead 报文</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddSendTask</span><span class="params">(ClientSocket* pClient,DataHeader* pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CellSendMsgTask* ptask = <span class="keyword">new</span> <span class="built_in">CellSendMsgTask</span>(pClient,pHead);</span><br><span class="line">	_taskServer.<span class="built_in">addTask</span>(ptask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习记录：内存池设计与实现 及其详细代码</title>
    <url>/2021/03/01/20210301_C++%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E5%86%85%E5%AD%98%E6%B1%A0%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20%E5%8F%8A%E5%85%B6%E8%AF%A6%E7%BB%86%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>&emsp;&emsp;这是我在VS2019上写的第一个项目，使用VS2019的目的是想在更为规范的IDE上写出更加规范的代码。<br>&emsp;&emsp;使用内存池可以减少程序运行中产生的内存碎片，且可以提高程序内存分配效率从而提升程序效率。在这篇笔记中，我将记录下自己关于这个内存池项目的思路与详细代码。同时，在我的<strong>C++网络编程学习</strong>相关内容的下一步改进中，我将引入这个内存池提高服务端的运行效率。</p>
<span id="more"></span>

<h1 id="一、内存池设计思路"><a href="#一、内存池设计思路" class="headerlink" title="一、内存池设计思路"></a>一、内存池设计思路</h1><p>&emsp;&emsp;首先，为什么要使用内存池？<br>&emsp;&emsp;我是这样理解的：不断的使用<code>new/malloc</code>从堆中申请内存，会在内存中留下一些“缝隙”。例如我们申请三份8个字节大小的内存A、B、C，由于内存地址是连续的，则ABC的地址值每个相差8(正常情况)。此时我们<code>delete/free</code>掉B内存，A与C内存之间此时就有了8个字节的空白。假如我们今后申请的内存都比8个字节大，则A与C之间这块内存就会一直为空白，这就是内存碎片。<br>&emsp;&emsp;过多的内存碎片会影响程序的内存分配效率，为了降低内存碎片的影响，我们可以引入内存池来尝试解决它。</p>
<p>&emsp;&emsp;我们可以在程序启动时(或是其他合适的时机)，预先申请足够的、大小相同的内存，把这些内存放在一个容器内。在需要申请内存时，直接从容器中取出一块内存使用；而释放内存时，把这块内存放回容器中即可。这个容器就被称为<strong>内存池</strong>。而这样操作也可以大大减少内存碎片出现的可能性，提高内存申请&#x2F;释放的效率。</p>
<p>这个项目中内存池的思路图如下：<br><img src="/images/2021-03-01/1.jpg" alt="思路图"><br>我们需要新建三个类：</p>
<ul>
<li>首先是底层的<strong>内存块类</strong>，其中包含了该内存块的信息：<strong>内存块编号、引用情况、所属内存池、下一块的位置</strong>等。</li>
<li>其次是<strong>内存池类</strong>，它对成组的内存块进行管理，可以实现<strong>把内存块从内存池中取出</strong>以及<strong>把内存块放回内存池</strong>。</li>
<li>最后是<strong>内存管理工具类</strong>，其中包含一个或多个内存池，所以它要根据用户申请的内存大小找到合适的内存池，调用内存池类的方法申请&#x2F;释放内存。</li>
</ul>
<p>还需要进行的操作：</p>
<ul>
<li>对<code>new/delete</code>进行重载，使其直接调用内存管理工具类申请&#x2F;释放内存。</li>
</ul>
<p>&emsp;&emsp;上面的工作完成后，我们仍是以<code>new/delete</code>来申请&#x2F;释放内存，但是已经是通过内存池来实现的了，这个内存池项目也就暂时结束。下面我将详细记录实现的过程与思路。</p>
<h1 id="二、内存块类MemoryBlock-设计与实现"><a href="#二、内存块类MemoryBlock-设计与实现" class="headerlink" title="二、内存块类MemoryBlock 设计与实现"></a>二、内存块类<code>MemoryBlock</code> 设计与实现</h1><p>先扔出来思路图：<br><img src="/images/2021-03-01/2.jpg" alt="思路图"><br>&emsp;&emsp;首先，在内存池中每一块内存是由一个内存头以及其可用内存组成的，其中<strong>内存头</strong>里储存了这块内存的相关信息，<strong>可用内存</strong>即为数据域，类似链表中节点的结构。而一块块内存之间正是一种类似链表的结构，即通过内存头中的一个指针进行连接。内存头中包含的信息大概如下：</p>
<ul>
<li>1、内存块编号</li>
<li>2、引用情况</li>
<li>3、所属内存池</li>
<li>4、下一块位置</li>
<li>5、是否在内存池内</li>
</ul>
<p>则我们可以通过上面的思路新建内存块类<code>MemoryBlock</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">由于内存头中要标记所属内存池，所以我们先预声明内存池类，在之后再进行实现。</span><br><span class="line">建立完成后，内存池内一块内存的大小为：<span class="built_in">sizeof</span>(MemoryBlock) + 可用内存的大小</span><br><span class="line"></span><br><span class="line"><span class="comment">//预声明内存池类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemoryAlloc</span>;</span><br><span class="line"><span class="comment">//内存块类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemoryBlock</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//内存块编号</span></span><br><span class="line">	<span class="type">int</span> _nID;</span><br><span class="line">	<span class="comment">//引用情况</span></span><br><span class="line">	<span class="type">int</span> _nRef;</span><br><span class="line">	<span class="comment">//所属内存池</span></span><br><span class="line">	MemoryAlloc* _pAlloc;</span><br><span class="line">	<span class="comment">//下一块位置</span></span><br><span class="line">	MemoryBlock* _pNext;</span><br><span class="line">	<span class="comment">//是否在内存池内</span></span><br><span class="line">	<span class="type">bool</span> _bPool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="三、内存池类MemoryAlloc-设计与实现"><a href="#三、内存池类MemoryAlloc-设计与实现" class="headerlink" title="三、内存池类MemoryAlloc 设计与实现"></a>三、内存池类<code>MemoryAlloc</code> 设计与实现</h1><p>还是先扔出来<strong>内存池申请&#x2F;释放内存</strong>的思路图：<br><img src="/images/2021-03-01/3.jpg" alt="思路图"><br>&emsp;&emsp;由图可知，整个内存池的管理基本为链表结构，内存池对象一直指向头部内存单元。在申请内存时移除头部单元，类似链表头结点的移除；在释放内存时，类似链表的头插法，把回收回来的内存单元放在内存池链表的头部。</p>
<p>内存池类中大概包含这些东西：</p>
<p>1、方法</p>
<ul>
<li>1.成员变量初始化 —— 对内存单元可用内存大小以及内存单元数量进行设定</li>
<li>2.初始化 —— 依据内存单元的大小与数量，对内存池内的内存进行<code>malloc</code>申请，完善每一个内存单元的信息</li>
<li>3.申请内存 —— 从内存池链表中取出一块可用内存</li>
<li>4.释放内存 —— 将一块内存放回内存池链表中</li>
</ul>
<p>2、成员变量</p>
<ul>
<li>1.内存池地址 —— 指向内存池内的总内存</li>
<li>2.头部内存单元 —— 指向头部内存单元</li>
<li>3.内存块大小 —— 内存单元的可用内存大小</li>
<li>4.内存块数量 —— 内存单元的数量</li>
</ul>
<p>则我们可以通过上面的思路新建内存块类<code>MemoryAlloc</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入内存块头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;MemoryBlock.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemoryAlloc</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MemoryAlloc</span>();</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">MemoryAlloc</span>();</span><br><span class="line">	<span class="comment">//设置初始化</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setInit</span><span class="params">(<span class="type">size_t</span> nSize,<span class="type">size_t</span> nBlockSize)</span></span>;<span class="comment">//传入的为内存块可用内存大小和内存块数量</span></span><br><span class="line">	<span class="comment">//初始化</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">initMemory</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//申请内存</span></span><br><span class="line">	<span class="function"><span class="type">void</span>* <span class="title">allocMem</span><span class="params">(<span class="type">size_t</span> nSize)</span></span>;<span class="comment">//传入的为申请可用内存的大小</span></span><br><span class="line">	<span class="comment">//释放内存</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">freeMem</span><span class="params">(<span class="type">void</span>* p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">//内存池地址</span></span><br><span class="line">	<span class="type">char</span>* _pBuf;</span><br><span class="line">	<span class="comment">//头部内存单元</span></span><br><span class="line">	MemoryBlock* _pHeader;</span><br><span class="line">	<span class="comment">//内存块大小</span></span><br><span class="line">	<span class="type">size_t</span> _nSize;</span><br><span class="line">	<span class="comment">//内存块数量</span></span><br><span class="line">	<span class="type">size_t</span> _nBlockSize;</span><br><span class="line">	<span class="comment">//多线程锁</span></span><br><span class="line">	std::mutex _mutex;<span class="comment">//锁上申请内存方法和释放内存方法即可实现多线程操作</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="四、内存管理工具类MemoryMgr-设计与实现"><a href="#四、内存管理工具类MemoryMgr-设计与实现" class="headerlink" title="四、内存管理工具类MemoryMgr 设计与实现"></a>四、内存管理工具类<code>MemoryMgr</code> 设计与实现</h1><p>仍然是先放思路图：<br><img src="/images/2021-03-01/4.jpg" alt="思路图"><br>&emsp;&emsp;首先，内存管理工具类用的是单例对象模式，从而能简易的对内存池进行管理。在这次的实现里，我使用的是<strong>饿汉式</strong>单例对象。其次，为了更简单的判断出申请内存时所需要调用的内存池，我建立了一个数组映射内存池。在工具类构造函数内，首先是对内存池进行初始化，随后便是将其映射到数组上。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">映射：</span><br><span class="line">假如申请一个<span class="number">64</span>字节内存池，申请一个<span class="number">128</span>字节内存池</span><br><span class="line">我们新建一个指针数组test，使下标<span class="number">0</span>~<span class="number">64</span>指向<span class="number">64</span>字节内存池，下标<span class="number">65</span>~<span class="number">128</span>指向<span class="number">128</span>字节内存池</span><br><span class="line">则我们通过 test[要申请的内存大小] 即可确定合适的内存池</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在随后的申请过程中，我们首先判断申请内存大小是否超过内存池最大可用内存，若没超过，则通过映射数组指向的内存池进行内存申请；若超过了，则直接使用<code>malloc</code>申请，记得多申请一个内存头大小的内存。随后完善内存头内的资料。<br>&emsp;&emsp;在随后的释放过程中，我们通过内存头判断这块内存是否使属于内存池的内存，如果是，则通过其所属内存池进行内存回收；若不是，则直接进行<code>free</code>释放。</p>
<p>内存管理工具类中大概包含这些东西：</p>
<p>1、方法</p>
<ul>
<li>饿汉式单例模式 —— 调用返回单例对象</li>
<li>申请内存 —— 调用获取一块内存</li>
<li>释放内存 —— 调用释放一块内存</li>
<li>内存初始化 —— 将内存池映射到数组上</li>
</ul>
<p>2、成员变量</p>
<ul>
<li>映射数组 —— 映射内存池</li>
<li>内存池1</li>
<li>内存池2</li>
<li>内存池…</li>
</ul>
<p>则我们可以通过上面的思路新建内存管理工具类<code>MemoryMgr</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//内存池最大申请</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_MEMORY_SIZE 128</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//导入内存池模板类</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;MemoryAlloc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemoryMgr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//饿汉式单例模式</span></span><br><span class="line">	<span class="function"><span class="type">static</span> MemoryMgr* <span class="title">Instance</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//申请内存</span></span><br><span class="line">	<span class="function"><span class="type">void</span>* <span class="title">allocMem</span><span class="params">(<span class="type">size_t</span> nSize)</span></span>;</span><br><span class="line">	<span class="comment">//释放内存</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">freeMem</span><span class="params">(<span class="type">void</span>* p)</span></span>;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">MemoryMgr</span>();</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">MemoryMgr</span>();</span><br><span class="line">	<span class="comment">//内存映射初始化</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init_szAlloc</span><span class="params">(<span class="type">int</span> begin,<span class="type">int</span> end,MemoryAlloc* pMem)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//映射数组</span></span><br><span class="line">	MemoryAlloc* _szAlloc[MAX_MEMORY_SIZE + <span class="number">1</span>];</span><br><span class="line">	<span class="comment">//64字节内存池</span></span><br><span class="line">	MemoryAlloc _mem64;</span><br><span class="line">	<span class="comment">//128字节内存池</span></span><br><span class="line">	MemoryAlloc _mem128;</span><br><span class="line">	<span class="comment">//内存池...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="五、重载new-delete"><a href="#五、重载new-delete" class="headerlink" title="五、重载new/delete"></a>五、重载<code>new/delete</code></h1><p>重载<code>new/delete</code>就不多说了，直接放代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* p)</span></span>;</span><br><span class="line"><span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span> size);</span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span>* p);</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">mem_alloc</span><span class="params">(<span class="type">size_t</span> size)</span></span>;<span class="comment">//malloc</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mem_free</span><span class="params">(<span class="type">void</span>* p)</span></span>;<span class="comment">//free</span></span><br></pre></td></tr></table></figure>

<h1 id="六、项目代码及其注释"><a href="#六、项目代码及其注释" class="headerlink" title="六、项目代码及其注释"></a>六、项目代码及其注释</h1><h2 id="1-项目图片"><a href="#1-项目图片" class="headerlink" title="1.项目图片"></a>1.项目图片</h2><p><img src="/images/2021-03-01/5.jpg" alt="图片">)</p>
<h2 id="2-重载new-delete"><a href="#2-重载new-delete" class="headerlink" title="2.重载new/delete"></a>2.重载<code>new/delete</code></h2><h3 id="2-1-Alloctor-h"><a href="#2-1-Alloctor-h" class="headerlink" title="2.1 Alloctor.h"></a>2.1 Alloctor.h</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _Alloctor_h_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _Alloctor_h_</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* p)</span></span>;</span><br><span class="line"><span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span> size);</span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span>* p);</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">mem_alloc</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mem_free</span><span class="params">(<span class="type">void</span>* p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-Alloctor-cpp"><a href="#2-2-Alloctor-cpp" class="headerlink" title="2.2 Alloctor.cpp"></a>2.2 Alloctor.cpp</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Alloctor.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;MemoryMgr.h&quot;</span><span class="comment">//内存管理工具</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> MemoryMgr::<span class="built_in">Instance</span>()-&gt;<span class="built_in">allocMem</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MemoryMgr::<span class="built_in">Instance</span>()-&gt;<span class="built_in">freeMem</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> MemoryMgr::<span class="built_in">Instance</span>()-&gt;<span class="built_in">allocMem</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span>* p)</span><br><span class="line">&#123;</span><br><span class="line">	MemoryMgr::<span class="built_in">Instance</span>()-&gt;<span class="built_in">freeMem</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">mem_alloc</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> MemoryMgr::<span class="built_in">Instance</span>()-&gt;<span class="built_in">allocMem</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mem_free</span><span class="params">(<span class="type">void</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MemoryMgr::<span class="built_in">Instance</span>()-&gt;<span class="built_in">freeMem</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-内存池类MemoryAlloc"><a href="#3-内存池类MemoryAlloc" class="headerlink" title="3.内存池类MemoryAlloc"></a>3.内存池类<code>MemoryAlloc</code></h2><h3 id="3-1-MemoryAlloc-h"><a href="#3-1-MemoryAlloc-h" class="headerlink" title="3.1 MemoryAlloc.h"></a>3.1 MemoryAlloc.h</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">内存池类</span></span><br><span class="line"><span class="comment">对内存块进行管理</span></span><br><span class="line"><span class="comment">2021/2/26</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> Memory_Alloc_h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Memory_Alloc_h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//导入内存块头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;MemoryBlock.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemoryAlloc</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MemoryAlloc</span>();</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">MemoryAlloc</span>();</span><br><span class="line">	<span class="comment">//设置初始化</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setInit</span><span class="params">(<span class="type">size_t</span> nSize,<span class="type">size_t</span> nBlockSize)</span></span>;</span><br><span class="line">	<span class="comment">//初始化</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">initMemory</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//申请内存</span></span><br><span class="line">	<span class="function"><span class="type">void</span>* <span class="title">allocMem</span><span class="params">(<span class="type">size_t</span> nSize)</span></span>;</span><br><span class="line">	<span class="comment">//释放内存</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">freeMem</span><span class="params">(<span class="type">void</span>* p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">//内存池地址</span></span><br><span class="line">	<span class="type">char</span>* _pBuf;</span><br><span class="line">	<span class="comment">//头部内存单元</span></span><br><span class="line">	MemoryBlock* _pHeader;</span><br><span class="line">	<span class="comment">//内存块大小</span></span><br><span class="line">	<span class="type">size_t</span> _nSize;</span><br><span class="line">	<span class="comment">//内存块数量</span></span><br><span class="line">	<span class="type">size_t</span> _nBlockSize;</span><br><span class="line">	<span class="comment">//多线程锁</span></span><br><span class="line">	std::mutex _mutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-MemoryAlloc-cpp"><a href="#3-2-MemoryAlloc-cpp" class="headerlink" title="3.2 MemoryAlloc.cpp"></a>3.2 MemoryAlloc.cpp</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;MemoryAlloc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MemoryAlloc::<span class="built_in">MemoryAlloc</span>()</span><br><span class="line">&#123;</span><br><span class="line">	_pBuf = <span class="literal">nullptr</span>;</span><br><span class="line">	_pHeader = <span class="literal">nullptr</span>;</span><br><span class="line">	_nSize = <span class="number">0</span>;</span><br><span class="line">	_nBlockSize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MemoryAlloc::~<span class="built_in">MemoryAlloc</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (_pBuf)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">free</span>(_pBuf);</span><br><span class="line">		<span class="comment">//现在有一个问题就是内存池外申请的内存不会被主动释放</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MemoryAlloc::setInit</span><span class="params">(<span class="type">size_t</span> nSize, <span class="type">size_t</span> nBlockSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*补全nSize</span></span><br><span class="line"><span class="comment">	const size_t n = sizeof(void*)</span></span><br><span class="line"><span class="comment">	_nSize = (nSize/n) * n + (nSize % n ? n : 0);</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	_pBuf = <span class="literal">nullptr</span>;</span><br><span class="line">	_pHeader = <span class="literal">nullptr</span>;</span><br><span class="line">	_nSize = nSize;</span><br><span class="line">	_nBlockSize = nBlockSize;</span><br><span class="line">	<span class="built_in">initMemory</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MemoryAlloc::initMemory</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//断言</span></span><br><span class="line">	<span class="built_in">assert</span>(<span class="literal">nullptr</span> == _pBuf);</span><br><span class="line">	<span class="comment">//若已申请则返回</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">nullptr</span> != _pBuf)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//计算内存池的大小  (块大小+块头) * 块数量</span></span><br><span class="line">	<span class="type">size_t</span> temp_size = _nSize + <span class="built_in">sizeof</span>(MemoryBlock);<span class="comment">//需要偏移的真正大小</span></span><br><span class="line">	<span class="type">size_t</span> bufSize = temp_size * _nBlockSize;</span><br><span class="line">	<span class="comment">//向系统申请池内存</span></span><br><span class="line">	_pBuf = (<span class="type">char</span>*)<span class="built_in">malloc</span>(bufSize);</span><br><span class="line">	<span class="comment">//初始化内存池</span></span><br><span class="line">	_pHeader = (MemoryBlock*)_pBuf;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">nullptr</span> != _pHeader)</span><br><span class="line">	&#123;</span><br><span class="line">		_pHeader-&gt;_bPool = <span class="literal">true</span>;<span class="comment">//在池中</span></span><br><span class="line">		_pHeader-&gt;_nID = <span class="number">0</span>;<span class="comment">//第0块</span></span><br><span class="line">		_pHeader-&gt;_nRef = <span class="number">0</span>;<span class="comment">//引用次数为0</span></span><br><span class="line">		_pHeader-&gt;_pAlloc = <span class="keyword">this</span>;<span class="comment">//属于当前内存池</span></span><br><span class="line">		_pHeader-&gt;_pNext = <span class="literal">nullptr</span>;<span class="comment">//下一块</span></span><br><span class="line">		MemoryBlock* pTemp1 = _pHeader;</span><br><span class="line">		<span class="comment">//遍历内存块进行初始化</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">size_t</span> n = <span class="number">1</span>; n &lt; _nBlockSize; n++)</span><br><span class="line">		&#123;</span><br><span class="line">			MemoryBlock* pTemp2 = (MemoryBlock*)(_pBuf + (n * temp_size));<span class="comment">//指针偏移到下一块</span></span><br><span class="line">			pTemp2-&gt;_bPool = <span class="literal">true</span>;<span class="comment">//在池中</span></span><br><span class="line">			pTemp2-&gt;_nID = n;<span class="comment">//第n块</span></span><br><span class="line">			pTemp2-&gt;_nRef = <span class="number">0</span>;</span><br><span class="line">			pTemp2-&gt;_pAlloc = <span class="keyword">this</span>;</span><br><span class="line">			pTemp2-&gt;_pNext = <span class="literal">nullptr</span>;</span><br><span class="line">			pTemp1-&gt;_pNext = pTemp2;</span><br><span class="line">			pTemp1 = pTemp2;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">MemoryAlloc::allocMem</span><span class="params">(<span class="type">size_t</span> nSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//自解锁</span></span><br><span class="line">	<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">	<span class="comment">//若内存池不存在则初始化</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">nullptr</span> == _pBuf)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">initMemory</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	MemoryBlock* pReturn = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">nullptr</span> == _pHeader)<span class="comment">//如内存池已满 重新申请</span></span><br><span class="line">	&#123;</span><br><span class="line">		pReturn = (MemoryBlock*)<span class="built_in">malloc</span>(nSize+<span class="built_in">sizeof</span>(MemoryBlock));</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">nullptr</span> != pReturn)</span><br><span class="line">		&#123;</span><br><span class="line">			pReturn-&gt;_bPool = <span class="literal">false</span>;<span class="comment">//不在池中</span></span><br><span class="line">			pReturn-&gt;_nID = <span class="number">-1</span>;</span><br><span class="line">			pReturn-&gt;_nRef = <span class="number">1</span>;</span><br><span class="line">			pReturn-&gt;_pAlloc = <span class="keyword">this</span>;</span><br><span class="line">			pReturn-&gt;_pNext = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span><span class="comment">//否则直接使用内存池</span></span><br><span class="line">	&#123;</span><br><span class="line">		pReturn = _pHeader;</span><br><span class="line">		_pHeader = _pHeader-&gt;_pNext;</span><br><span class="line">		<span class="built_in">assert</span>(<span class="number">0</span> == pReturn-&gt;_nRef);</span><br><span class="line">		pReturn-&gt;_nRef = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//debug打印</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">nullptr</span> != pReturn)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">xPrintf</span>(<span class="string">&quot;NEW - allocMem:%p,id=%d,size=%d\n&quot;</span>, pReturn, pReturn-&gt;_nID, nSize);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> ((<span class="type">char</span>*)pReturn + <span class="built_in">sizeof</span>(MemoryBlock));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MemoryAlloc::freeMem</span><span class="params">(<span class="type">void</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//传进来的是消息区 需要加上信息头</span></span><br><span class="line">	MemoryBlock* pBlock = (MemoryBlock*)((<span class="type">char</span>*)p - <span class="built_in">sizeof</span>(MemoryBlock));</span><br><span class="line">	<span class="built_in">assert</span>(<span class="number">1</span> == pBlock-&gt;_nRef);</span><br><span class="line">	<span class="comment">//判断是否被多次引用</span></span><br><span class="line">	<span class="keyword">if</span> (--pBlock-&gt;_nRef != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//判断是否在内存池中</span></span><br><span class="line">	<span class="keyword">if</span> (pBlock-&gt;_bPool)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//自解锁</span></span><br><span class="line">		<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">		<span class="comment">//把内存块放入内存池首位</span></span><br><span class="line">		pBlock-&gt;_pNext = _pHeader;</span><br><span class="line">		_pHeader = pBlock;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">free</span>(pBlock);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-内存块类MemoryBlock"><a href="#4-内存块类MemoryBlock" class="headerlink" title="4.内存块类MemoryBlock"></a>4.内存块类<code>MemoryBlock</code></h2><h3 id="4-1-MemoryBlock-h"><a href="#4-1-MemoryBlock-h" class="headerlink" title="4.1 MemoryBlock.h"></a>4.1 MemoryBlock.h</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">内存块类</span></span><br><span class="line"><span class="comment">内存管理的最小单位</span></span><br><span class="line"><span class="comment">2021/2/26</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> Memory_Block_h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Memory_Block_h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明内存池类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemoryAlloc</span>;</span><br><span class="line"><span class="comment">//最底层导入内存头文件/断言头文件/锁头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="comment">//如果为debug模式则加入调试信息</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> xPrintf(...) printf(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> xPrintf(...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemoryBlock</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//内存块编号</span></span><br><span class="line">	<span class="type">int</span> _nID;</span><br><span class="line">	<span class="comment">//引用情况</span></span><br><span class="line">	<span class="type">int</span> _nRef;</span><br><span class="line">	<span class="comment">//所属内存池</span></span><br><span class="line">	MemoryAlloc* _pAlloc;</span><br><span class="line">	<span class="comment">//下一块位置</span></span><br><span class="line">	MemoryBlock* _pNext;</span><br><span class="line">	<span class="comment">//是否在内存池内</span></span><br><span class="line">	<span class="type">bool</span> _bPool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="4-2-MemoryBlock-cpp"><a href="#4-2-MemoryBlock-cpp" class="headerlink" title="4.2 MemoryBlock.cpp"></a>4.2 MemoryBlock.cpp</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;MemoryBlock.h&quot;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="5-内存管理工具类MemoryMgr"><a href="#5-内存管理工具类MemoryMgr" class="headerlink" title="5.内存管理工具类MemoryMgr"></a>5.内存管理工具类<code>MemoryMgr</code></h2><h3 id="5-1-MemoryMgr-h"><a href="#5-1-MemoryMgr-h" class="headerlink" title="5.1 MemoryMgr.h"></a>5.1 MemoryMgr.h</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">内存管理工具类</span></span><br><span class="line"><span class="comment">对内存池进行管理</span></span><br><span class="line"><span class="comment">2021/2/26</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> Memory_Mgr_h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Memory_Mgr_h</span></span><br><span class="line"><span class="comment">//内存池最大申请</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_MEMORY_SIZE 128</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//导入内存池模板类</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;MemoryAlloc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemoryMgr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//饿汉式单例模式</span></span><br><span class="line">	<span class="function"><span class="type">static</span> MemoryMgr* <span class="title">Instance</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//申请内存</span></span><br><span class="line">	<span class="function"><span class="type">void</span>* <span class="title">allocMem</span><span class="params">(<span class="type">size_t</span> nSize)</span></span>;</span><br><span class="line">	<span class="comment">//释放内存</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">freeMem</span><span class="params">(<span class="type">void</span>* p)</span></span>;</span><br><span class="line">	<span class="comment">//增加内存块引用次数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">addRef</span><span class="params">(<span class="type">void</span>* p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">MemoryMgr</span>();</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">MemoryMgr</span>();</span><br><span class="line">	<span class="comment">//内存映射初始化</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init_szAlloc</span><span class="params">(<span class="type">int</span> begin,<span class="type">int</span> end,MemoryAlloc* pMem)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//映射数组</span></span><br><span class="line">	MemoryAlloc* _szAlloc[MAX_MEMORY_SIZE + <span class="number">1</span>];</span><br><span class="line">	<span class="comment">//64字节内存池</span></span><br><span class="line">	MemoryAlloc _mem64;</span><br><span class="line">	<span class="comment">//128字节内存池</span></span><br><span class="line">	MemoryAlloc _mem128;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="5-2-MemoryMgr-cpp"><a href="#5-2-MemoryMgr-cpp" class="headerlink" title="5.2 MemoryMgr.cpp"></a>5.2 MemoryMgr.cpp</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;MemoryMgr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MemoryMgr::<span class="built_in">MemoryMgr</span>()</span><br><span class="line">&#123;</span><br><span class="line">	_mem<span class="number">64.</span><span class="built_in">setInit</span>(<span class="number">64</span>, <span class="number">10</span>);</span><br><span class="line">	<span class="built_in">init_szAlloc</span>(<span class="number">0</span>, <span class="number">64</span>, &amp;_mem64);</span><br><span class="line">	_mem<span class="number">128.</span><span class="built_in">setInit</span>(<span class="number">128</span>, <span class="number">10</span>);</span><br><span class="line">	<span class="built_in">init_szAlloc</span>(<span class="number">65</span>, <span class="number">128</span>, &amp;_mem128);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MemoryMgr::~<span class="built_in">MemoryMgr</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MemoryMgr::init_szAlloc</span><span class="params">(<span class="type">int</span> begin, <span class="type">int</span> end, MemoryAlloc* pMem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//begin到end大小的内存申请都映射到相关的内存池上</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = begin; i &lt;= end; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		_szAlloc[i] = pMem;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//饿汉式单例模式</span></span><br><span class="line"><span class="function">MemoryMgr* <span class="title">MemoryMgr::Instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> MemoryMgr myMemoryMgr;</span><br><span class="line">	<span class="comment">//单例对象</span></span><br><span class="line">	<span class="keyword">return</span> &amp;myMemoryMgr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//申请内存</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">MemoryMgr::allocMem</span><span class="params">(<span class="type">size_t</span> nSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//若申请的内存大小正常，则直接申请</span></span><br><span class="line">	<span class="keyword">if</span> (nSize &lt;= MAX_MEMORY_SIZE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> _szAlloc[nSize]-&gt;<span class="built_in">allocMem</span>(nSize);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span><span class="comment">//否则用malloc申请一个</span></span><br><span class="line">	&#123;</span><br><span class="line">		MemoryBlock* pReturn = (MemoryBlock*)<span class="built_in">malloc</span>(nSize + <span class="built_in">sizeof</span>(MemoryBlock));</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">nullptr</span> != pReturn)</span><br><span class="line">		&#123;</span><br><span class="line">			pReturn-&gt;_bPool = <span class="literal">false</span>;<span class="comment">//不在池中</span></span><br><span class="line">			pReturn-&gt;_nID = <span class="number">-1</span>;</span><br><span class="line">			pReturn-&gt;_nRef = <span class="number">1</span>;</span><br><span class="line">			pReturn-&gt;_pAlloc = <span class="literal">nullptr</span>;</span><br><span class="line">			pReturn-&gt;_pNext = <span class="literal">nullptr</span>;</span><br><span class="line">			<span class="comment">//debug打印</span></span><br><span class="line">			<span class="built_in">xPrintf</span>(<span class="string">&quot;NEW - allocMem:%p,id=%d,size=%d\n&quot;</span>,pReturn,pReturn-&gt;_nID,nSize);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ((<span class="type">char</span>*)pReturn + <span class="built_in">sizeof</span>(MemoryBlock));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放内存</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MemoryMgr::freeMem</span><span class="params">(<span class="type">void</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//传进来的是消息区 需要加上信息头</span></span><br><span class="line">	MemoryBlock* pBlock = (MemoryBlock*)((<span class="type">char</span>*)p - <span class="built_in">sizeof</span>(MemoryBlock));</span><br><span class="line">	<span class="comment">//debug打印</span></span><br><span class="line">	<span class="built_in">xPrintf</span>(<span class="string">&quot;DELETE - allocMem:%p,id=%d\n&quot;</span>, pBlock, pBlock-&gt;_nID);</span><br><span class="line">	<span class="comment">//内存池内的内存块/内存池外的内存块 不同的处理方式</span></span><br><span class="line">	<span class="keyword">if</span> (pBlock-&gt;_bPool == <span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		pBlock-&gt;_pAlloc-&gt;<span class="built_in">freeMem</span>(p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (--pBlock-&gt;_nRef == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">free</span>(pBlock);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加内存块引用次数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MemoryMgr::addRef</span><span class="params">(<span class="type">void</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MemoryBlock* pBlock = (MemoryBlock*)((<span class="type">char</span>*)p - <span class="built_in">sizeof</span>(MemoryBlock));</span><br><span class="line">	++pBlock-&gt;_nRef;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="6-main文件"><a href="#6-main文件" class="headerlink" title="6.main文件"></a>6.<code>main</code>文件</h2><h3 id="6-1-main-cpp"><a href="#6-1-main-cpp" class="headerlink" title="6.1 main.cpp"></a>6.1 main.cpp</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Alloctor.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span>* data2 = <span class="keyword">new</span> <span class="type">char</span>;</span><br><span class="line">	<span class="keyword">delete</span> data2;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span>* data1 = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">129</span>];</span><br><span class="line">	<span class="keyword">delete</span>[] data1;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span>* data3 = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">65</span>];</span><br><span class="line">	<span class="keyword">delete</span>[] data3;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;--------------------------\n&quot;</span>);</span><br><span class="line">	<span class="type">char</span>* data[<span class="number">15</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		data[i] = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">64</span>];</span><br><span class="line">		<span class="keyword">delete</span>[] data[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="七、小结"><a href="#七、小结" class="headerlink" title="七、小结"></a>七、小结</h1><ul>
<li>在申请与释放内存时，返回给用户和用户传进来的都是可用内存的地址，并不是内存头的地址。我们需要对地址进行偏移，从而返回&#x2F;接收正确的地址。具体为可用内存地址向前偏移一个内存头大小即为内存头地址；内存头地址向后偏移一个内存头大小即为可用内存地址。</li>
<li>内存池初始化时，申请总地址大小为：(可用地址大小+内存头大小) * 内存单元数量</li>
<li>内存池外申请的内存，不会在内存池析构函数内被释放，需要手动释放。（不过一般触发析构函数的时候，也不用手动释放了）</li>
<li>在这次的项目中，我对地址、内存等有了更深刻的理解，同时也能熟练使用VS的调试功能。希望未来能有更大的发展。</li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++学习记录：深入理解三种传参方式</title>
    <url>/2021/08/23/20210823_C_C++%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B8%89%E7%A7%8D%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>&emsp;&emsp;之前对传参这方面的东西一直是知其然不知所以然。概念用法怎么用都知道，但是其真正的内部操作流程确实是理解不足。这两天一直在总结shell脚本的笔记，写累了正好研究一下传参这方面的内容。<br>&emsp;&emsp;这篇笔记中记录了关于这方面我的理解过程和心得。关于本篇笔记的深度，也是到<strong>汇编</strong>为止不再深入，就我个人理解来看已经是足够了。</p>
<span id="more"></span>

<h1 id="一、关于三种传参方式"><a href="#一、关于三种传参方式" class="headerlink" title="一、关于三种传参方式"></a>一、关于三种传参方式</h1><h2 id="1-值传参"><a href="#1-值传参" class="headerlink" title="1. 值传参"></a>1. 值传参</h2><h3 id="1-1-简单总结"><a href="#1-1-简单总结" class="headerlink" title="1.1 简单总结"></a>1.1 简单总结</h3><p>&emsp;&emsp;这是我在编程中最早接触的传参方式，也是一开始使用最多的传参方式。它的特点很明确就是简便，非常明了。当然缺点也是被说了很多次，就是<strong>慢+占用空间+不能修改实参</strong>。因为所谓的值传参是把实参的值复制了一遍，所以会有上面的特点。</p>
<h3 id="1-2-我的疑问"><a href="#1-2-我的疑问" class="headerlink" title="1.2 我的疑问"></a>1.2 我的疑问</h3><p>&emsp;&emsp;总是说值传参的执行过程会复制实参的值，那么它的流程是怎么样的？</p>
<h2 id="2-引用传参"><a href="#2-引用传参" class="headerlink" title="2. 引用传参"></a>2. 引用传参</h2><h3 id="2-1-简单总结"><a href="#2-1-简单总结" class="headerlink" title="2.1 简单总结"></a>2.1 简单总结</h3><p>&emsp;&emsp;这是C++里的概念，C里是没有的。它解决了值<strong>传参不能修改实参的问题，另外也比传值要快</strong>。就我目前接触到的C++代码中，里面均常常用到<code>&amp;</code>和<code>const &amp;</code>，例如stl的源码。</p>
<h3 id="2-2-我的疑问"><a href="#2-2-我的疑问" class="headerlink" title="2.2 我的疑问"></a>2.2 我的疑问</h3><p>&emsp;&emsp;我看网上说传引用其实也是传的指针，所以一直对引用的流程很有兴趣。如果真的也是传指针，那么它的意义就是更简单明了的传指针吗？另外很多源码中都使用<code>const &amp;</code>，我一直很好奇传引用究竟能比传值快多少。</p>
<h2 id="3-指针传参"><a href="#3-指针传参" class="headerlink" title="3. 指针传参"></a>3. 指针传参</h2><h3 id="3-1-简单总结"><a href="#3-1-简单总结" class="headerlink" title="3.1 简单总结"></a>3.1 简单总结</h3><p>&emsp;&emsp;第一次接触传指针，还是在当时学习链表的时候。在此之前，我对于指针作用的印象仅仅是文件指针和一丢丢字符串的内容，而对于学习中碰到的那些什么<code>*p,&amp;p</code>的完全没有实际应用中的感受，甚至产生了疑问，为何大伙都说指针牛p？<br>&emsp;&emsp;在接触到链表头结点的指针后，我首次发现原来传值是不能改变内容的(<del>太菜了当时</del>)，得传指针，所以链表函数传参时，节点得取个地址传进去，由此我打开了新世界的大门，感受到了指针的牛p。以至于后面再接触java的时候感觉浑身难受，感受到了一种局限感，所以后面我决定以C&#x2F;C++为方向。<br>&emsp;&emsp;对我而言，指针传参相当于是一种 **”降维打击”**，相当于“你收拾不了他就去找他爹收拾他”。总而言之，向下层操作性很大(提领指针的内容)，可以修改实参并且速度也很快。但是，传指针相当于把传值的内容改为指针，所以指针层面也是不能被修改的(虽然我也没见过要修改最高层指针)，由于指针的大小是固定的而且很小，传指针的速度也会很快。</p>
<h3 id="3-2-我的疑问"><a href="#3-2-我的疑问" class="headerlink" title="3.2 我的疑问"></a>3.2 我的疑问</h3><p>&emsp;&emsp;底层流程是什么？是先获取地址，再走值传递那一套流程吗？</p>
<h1 id="二、汇编层面剖析"><a href="#二、汇编层面剖析" class="headerlink" title="二、汇编层面剖析"></a>二、汇编层面剖析</h1><h2 id="1-操作"><a href="#1-操作" class="headerlink" title="1. 操作"></a>1. 操作</h2><p>&emsp;&emsp;我的理解方式是通过vs2019的反汇编功能查看低层汇编代码进行比对分析，而下面是我的操作过程。<br>&emsp;&emsp;首先是实验源码如下，可以看到我声明了三个函数，分别用了三种传参方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 三种传参方式测试</span></span><br><span class="line"><span class="comment">* 2021/8/22</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//值传参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_value</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x = <span class="number">22</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引用传参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_ref</span><span class="params">(<span class="type">int</span>&amp; x_ref)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x_ref = <span class="number">2222</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针传参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_ptr</span><span class="params">(<span class="type">int</span>* x_ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	*x_ptr = <span class="number">22222</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> test_arg = <span class="number">222</span>;</span><br><span class="line">	<span class="comment">//值传参</span></span><br><span class="line">	<span class="built_in">func_value</span>(test_arg);</span><br><span class="line">	<span class="comment">//引用传参</span></span><br><span class="line">	<span class="built_in">func_ref</span>(test_arg);</span><br><span class="line">	<span class="comment">//指针传参</span></span><br><span class="line">	<span class="built_in">func_ptr</span>(&amp;test_arg);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;接着，我开启调试反汇编，查看调用三个函数时的汇编源码，结果如下：<br><img src="/images/2021-08-23-01/1.jpg" alt="1"></p>
<h2 id="2-总结"><a href="#2-总结" class="headerlink" title="2. 总结"></a>2. 总结</h2><p>&emsp;&emsp; 说实话，我没想到传引用和传指针的汇编源码竟然完全一样…而传值和另外两者的唯一区别就是第一条汇编指令。其中传值用的是<code>汇编指令mov</code>，而传引用和传指针用的都是<code>汇编指令lea</code>。<br>&emsp;&emsp;然后我搜了下，<code>mov</code>是把<strong>内容</strong>复制到寄存器eax，而<code>lea</code>是把<strong>地址</strong>复制到寄存器里。所以这里传值是把变量<code>test_arg</code>的内容复制到寄存器，而后两者是把变量<code>test_arg</code>的地址复制到寄存器。而内容复制一般复制量都比地址复制要大，这也就造成了效率上的差距。且传值修改的是复制的内容，所以实参不会受影响；但后两者修改的是传入指针里的内容，这两个指针(传参和实参指针)指向的内容是一致的，所以实参会收到影响。</p>
<ul>
<li>所以总结下，函数传参的流程如下：</li>
</ul>
<ol>
<li>执行<code>lea</code>或<code>mov</code>指令将内容或指针拷贝到寄存器上。</li>
<li>执行<code>push</code>指令把寄存器里的内容push进栈。</li>
<li>执行<code>call</code>指令调用函数。</li>
<li>执行<code>add</code>指令确保堆栈平衡，相当于执行pop操作把前面push的内容弹出。而add的值跟参数个数有关(之前push的值)。</li>
</ol>
<h1 id="三、运行时间对比实践"><a href="#三、运行时间对比实践" class="headerlink" title="三、运行时间对比实践"></a>三、运行时间对比实践</h1><p>&emsp;&emsp;一直好奇三者之间运行时间的差异，正好借着这次实践测试一下。</p>
<h2 id="1-传参类型偏小"><a href="#1-传参类型偏小" class="headerlink" title="1. 传参类型偏小"></a>1. 传参类型偏小</h2><p>&emsp;&emsp;首先是测试传参类型偏小的情况吧。这里选择的传参类型是int，在32位环境下，<code>int</code>和<code>int*</code>大小是一致的4字节。根据上面的汇编源码来看，我个人认为<code>mov</code>4字节和<code>lea</code>一个地址时间消耗可能是五五开的，于是我进行了以下的测试。</p>
<p>&emsp;&emsp;测试代码如下，其中我使用到了一个自己实现的计时器，计时器内容在这篇博客里<a href="https://blog.csdn.net/qq_45698148/article/details/113702354?spm=1001.2014.3001.5501">C++学习记录：基于chrono库的高精度计时器</a>。<br><img src="/images/2021-08-23-01/2.jpg" alt="test1"></p>
<h3 id="1-1-函数内单运算操作"><a href="#1-1-函数内单运算操作" class="headerlink" title="1.1 函数内单运算操作"></a>1.1 函数内单运算操作</h3><p>&emsp;&emsp;这部分我在函数内均仅进行单运算操作，如下。<br><img src="/images/2021-08-23-01/3.jpg" alt="test1.1"><br>&emsp;&emsp;函数执行一定次数<code>TIME</code>后的结果如下。果然在传参实际传入大小差不多的情况下，实际时间消耗也是差不多的。<strong>在我理解上，其实引用和指针传参可能也是算一种值传参吧，只不过它们传的值是指针。所以在传值大小相似的情况下时间消耗也相似。</strong><br><img src="/images/2021-08-23-01/4.jpg" alt="test1"></p>
<h3 id="1-2-函数内多运算操作"><a href="#1-2-函数内多运算操作" class="headerlink" title="1.2 函数内多运算操作"></a>1.2 函数内多运算操作</h3><p>&emsp;&emsp;然后我想到，不同的传参方式，操作传参的时间消耗一致吗？于是在函数内新增了几条运算。既然该情况下传参速度相同，如果执行速度也相同，则说明操作传参的时间消耗一致。</p>
<p>&emsp;&emsp;函数内均修改为如下操作：<br><img src="/images/2021-08-23-01/5.jpg" alt="test1.2"><br>&emsp;&emsp;函数执行一定次数<code>TIME</code>后的结果如下。果然在操作增多的情况下，实际时间消耗也是差不多的。<strong>这说明操作传参的时间消耗是一致的。</strong><br><img src="/images/2021-08-23-01/6.jpg" alt="test1.3"></p>
<h2 id="2-传参类型偏大"><a href="#2-传参类型偏大" class="headerlink" title="2. 传参类型偏大"></a>2. 传参类型偏大</h2><p><em>“在我理解上，其实引用和指针传参可能也是算一种值传参吧，只不过它们传的值是指针。所以在传值大小相似的情况下时间消耗也相似。”</em></p>
<p>&emsp;&emsp;为了证明我的这个猜测，我对传参类型进行了改变，这次选择使用的数据类型是c++的数据结构<code>std::string</code>。在32位环境下，<code>std::string</code>的大小是28字节，<code>std::string*</code>的大小还是4字节，即两者大小是七倍的关系。则如果时间消耗差距较大的话，则说明真正影响传参速度是传的大小，就说明我的猜测算是对的吧。</p>
<p>&emsp;&emsp;测试代码如下，还是用到了上文中提到的计时器。<br><img src="/images/2021-08-23-01/7.jpg" alt="test2"><br>&emsp;&emsp;这部分函数的操作如下，仅仅是简单的<code>sizeof</code>操作。<br><img src="/images/2021-08-23-01/8.jpg" alt="test2.1"><br>&emsp;&emsp;运行结果如下，可以看到时间如下，果然时间差距是非常的大。说明传参时间根本上还是受传参大小影响。不过我好奇的是为何时间差距这么大，我猜测可能是内存分配时间不同或是调用了<code>std::string</code>的构造参数吧。<br><img src="/images/2021-08-23-01/9.jpg" alt="s"></p>
<h1 id="四、体会"><a href="#四、体会" class="headerlink" title="四、体会"></a>四、体会</h1><p>&emsp;&emsp;随着和C&#x2F;C++打交道的时间越来越长，我探索的内容也越发深入、复杂。但是当真正理解了之前疑惑的内容，说实话还是很开心的。<br>&emsp;&emsp;另外吐槽下csdn上鱼龙混杂，发的大部分都是很基础没有营养的东西，或者不知道哪抄的错误百出的内容，当然也有很多大佬的内容让我受益匪浅(深表感谢orz)，现在我搜个东西都得“发掘”半天。但是从某种意义上来讲我是有一点开心的，这说明我至少已经算入门了嘛XD</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++标准库学习</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 蓝桥杯 Java实现 10月C组省赛</title>
    <url>/2021/03/01/20210301-02_2020%E8%93%9D%E6%A1%A5%E6%9D%AFJava%E5%AE%9E%E7%8E%B010%E6%9C%88C%E7%BB%84%E7%9C%81%E8%B5%9B/</url>
    <content><![CDATA[<ul>
<li>几个月没写题了，先找找手感，从简单的C组开始吧。</li>
</ul>
<p><strong>2020 蓝桥杯 Java实现 10月C组省赛 题目 &amp; 题解</strong></p>
<span id="more"></span>

<h1 id="试题-A-约数个数"><a href="#试题-A-约数个数" class="headerlink" title="试题 A: 约数个数"></a>试题 A: 约数个数</h1><p>本题总分：5 分</p>
<p><strong>问题：</strong><br>对于一个整数，能整除这个整数的数称为这个数的约数。<br>例如：1, 2, 3, 6 都是 6 的约数。<br>请问 78120 有多少个约数。</p>
<p><strong>思路：</strong> 暴力</p>
<p><strong>答案：</strong> 96</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.printf(<span class="string">&quot;%d&quot;</span>,func(<span class="number">78120</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> a)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1</span>;now&lt;=a;now++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="number">0</span> == a%now)</span><br><span class="line">			&#123;</span><br><span class="line">				temp++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> temp; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="试题-B-寻找-2020"><a href="#试题-B-寻找-2020" class="headerlink" title="试题 B: 寻找 2020"></a>试题 B: 寻找 2020</h1><p>本题总分：5 分</p>
<p><code>附件在本篇末尾</code></p>
<p><strong>问题：</strong></p>
<p>小蓝有一个数字矩阵，里面只包含数字 0 和 2。小蓝很喜欢 2020，他想找到这个数字矩阵中有多少个 2020 。<br>小蓝只关注三种构成 2020 的方式：</p>
<p>同一行里面连续四个字符从左到右构成 2020。<br>同一列里面连续四个字符从上到下构成 2020。<br>在一条从左上到右下的斜线上连续四个字符，从左上到右下构成 2020。<br>例如，对于下面的矩阵：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">220000</span></span><br><span class="line"><span class="number">000000</span></span><br><span class="line"><span class="number">002202</span></span><br><span class="line"><span class="number">000000</span></span><br><span class="line"><span class="number">000022</span></span><br><span class="line"><span class="number">002020</span></span><br></pre></td></tr></table></figure>
<p>一共有 5 个 2020。其中 1 个是在同一行里的，1 个是在同一列里的，3 个是斜线上的。<br>小蓝的矩阵比上面的矩阵要大，由于太大了，他只好将这个矩阵放在了一个文件里面，在试题目录下有一个文件 2020.txt，里面给出了小蓝的矩阵。<br>请帮助小蓝确定在他的矩阵中有多少个 2020。</p>
<p><strong>思路：</strong> 暴力</p>
<p><strong>答案：</strong> 16120</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:/demo/1.txt&quot;</span>)));</span><br><span class="line">		<span class="type">char</span>[][] map = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">300</span>][];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">300</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			map[i] = in.readLine().toCharArray();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">0</span>;y&lt;<span class="number">300</span>;y++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;x&lt;<span class="number">300</span>;x++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//横排</span></span><br><span class="line">				<span class="keyword">if</span>(x&lt;=<span class="number">296</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(map[y][x]==<span class="string">&#x27;2&#x27;</span>&amp;&amp;map[y][x+<span class="number">1</span>]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;map[y][x+<span class="number">2</span>]==<span class="string">&#x27;2&#x27;</span>&amp;&amp;map[y][x+<span class="number">3</span>]==<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						ans++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//竖排</span></span><br><span class="line">				<span class="keyword">if</span>(y&lt;=<span class="number">296</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(map[y][x]==<span class="string">&#x27;2&#x27;</span>&amp;&amp;map[y+<span class="number">1</span>][x]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;map[y+<span class="number">2</span>][x]==<span class="string">&#x27;2&#x27;</span>&amp;&amp;map[y+<span class="number">3</span>][x]==<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						ans++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//斜排</span></span><br><span class="line">				<span class="keyword">if</span>(y&lt;=<span class="number">296</span>&amp;&amp;x&lt;=<span class="number">296</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(map[y][x]==<span class="string">&#x27;2&#x27;</span>&amp;&amp;map[y+<span class="number">1</span>][x+<span class="number">1</span>]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;map[y+<span class="number">2</span>][x+<span class="number">2</span>]==<span class="string">&#x27;2&#x27;</span>&amp;&amp;map[y+<span class="number">3</span>][x+<span class="number">3</span>]==<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						ans++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	    System.out.print(ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="试题-C-跑步锻炼"><a href="#试题-C-跑步锻炼" class="headerlink" title="试题 C: 跑步锻炼"></a>试题 C: 跑步锻炼</h1><p>本题总分：10 分</p>
<p><strong>问题：</strong><br>小蓝每天都锻炼身体。<br>正常情况下，小蓝每天跑 1 千米。如果某天是周一或者月初（1 日），为了激励自己，小蓝要跑 2 千米。如果同时是周一或月初，小蓝也是跑 2 千米。<br>小蓝跑步已经坚持了很长时间，从 2000 年 1 月 1 日周六（含）到 2020 年10 月 1 日周四（含）。请问这段时间小蓝总共跑步多少千米？</p>
<p><strong>思路：</strong> 根据平年闰年进行暴力</p>
<p><strong>答案：</strong> 8879</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">judge</span><span class="params">(<span class="type">int</span> year)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>((year%<span class="number">4</span>==<span class="number">0</span> &amp;&amp; year%<span class="number">100</span>!=<span class="number">0</span>) || year%<span class="number">400</span>==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span>[] p = &#123;<span class="number">0</span>,<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;<span class="comment">//平年1月到12月</span></span><br><span class="line">		<span class="type">int</span>[] r = &#123;<span class="number">0</span>,<span class="number">31</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;<span class="comment">//闰年1月到12月</span></span><br><span class="line">		<span class="comment">//起始日期</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> <span class="number">2000</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">xq</span> <span class="operator">=</span> <span class="number">6</span>;<span class="comment">//星期6</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//公里</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(year==<span class="number">2020</span> &amp;&amp; month==<span class="number">10</span> &amp;&amp; day==<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				ans+=<span class="number">2</span>;<span class="comment">//10月1号也算上</span></span><br><span class="line">				System.out.print(ans);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(day==<span class="number">1</span> || xq==<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				ans+=<span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				ans++;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			xq = ++xq % <span class="number">7</span>;</span><br><span class="line">			day+=<span class="number">1</span>;</span><br><span class="line">			</span><br><span class="line">			<span class="type">int</span> <span class="variable">state</span> <span class="operator">=</span> judge(year);<span class="comment">//1为闰年 0为平年</span></span><br><span class="line">			<span class="keyword">if</span>(state == <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(day&gt;r[month])</span><br><span class="line">				&#123;</span><br><span class="line">					day=<span class="number">1</span>;</span><br><span class="line">					month++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(day&gt;p[month])</span><br><span class="line">				&#123;</span><br><span class="line">					day=<span class="number">1</span>;</span><br><span class="line">					month++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(month&gt;<span class="number">12</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				month=<span class="number">1</span>;</span><br><span class="line">				year++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="试题-D-平面分割"><a href="#试题-D-平面分割" class="headerlink" title="试题 D: 平面分割"></a>试题 D: 平面分割</h1><p>本题总分：10 分</p>
<p><strong>问题：</strong><br>20 个圆和 20 条直线最多能把平面分成多少个部分？</p>
<p><strong>思路：</strong> 数学题…不会啊，放一个知乎大佬的回答</p>
<p><strong>答案：</strong> 1391<br><a href="https://www.zhihu.com/question/426034179">大佬在这 点我去看大佬</a></p>
<h1 id="试题-E-七段码"><a href="#试题-E-七段码" class="headerlink" title="试题 E: 七段码"></a>试题 E: 七段码</h1><p>本题总分：15 分</p>
<p><strong>问题：</strong><br>小蓝要用七段码数码管来表示一种特殊的文字。<br><img src="/images/2021-03-01/02-1.jpg" alt="图"><br>上图给出了七段码数码管的一个图示，数码管中一共有 7 段可以发光的二极管，分别标记为 a, b, c, d, e, f, g。<br>小蓝要选择一部分二极管（至少要有一个）发光来表达字符。在设计字符的表达时，要求所有发光的二极管是连成一片的。</p>
<p>例如：b 发光，其他二极管不发光可以用来表达一种字符。<br>例如：c 发光，其他二极管不发光可以用来表达一种字符。这种方案与上<br>一行的方案可以用来表示不同的字符，尽管看上去比较相似。</p>
<p>例如：a, b, c, d, e 发光，f, g 不发光可以用来表达一种字符。<br>例如：b, f 发光，其他二极管不发光则不能用来表达一种字符，因为发光的二极管没有连成一片。<br>请问，小蓝可以用七段码数码管表达多少种不同的字符？</p>
<p><strong>思路：</strong> dfs出所有情况，然后用并查集判断是否属于同一子集</p>
<p><strong>答案：</strong> 80</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span>[] jl = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span>[][] map = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span>[] father = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//储存关系 a~g对应1~7</span></span><br><span class="line">		map[<span class="number">1</span>][<span class="number">2</span>] = map[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">1</span>;<span class="comment">//a b</span></span><br><span class="line">		map[<span class="number">1</span>][<span class="number">6</span>] = map[<span class="number">6</span>][<span class="number">1</span>] = <span class="number">1</span>;<span class="comment">//a f</span></span><br><span class="line">		map[<span class="number">2</span>][<span class="number">7</span>] = map[<span class="number">7</span>][<span class="number">2</span>] = <span class="number">1</span>;<span class="comment">//b g</span></span><br><span class="line">		map[<span class="number">2</span>][<span class="number">3</span>] = map[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">1</span>;<span class="comment">//b c</span></span><br><span class="line">		map[<span class="number">3</span>][<span class="number">4</span>] = map[<span class="number">4</span>][<span class="number">3</span>] = <span class="number">1</span>;<span class="comment">//c d </span></span><br><span class="line">		map[<span class="number">3</span>][<span class="number">7</span>] = map[<span class="number">7</span>][<span class="number">3</span>] = <span class="number">1</span>;<span class="comment">//c g</span></span><br><span class="line">		map[<span class="number">4</span>][<span class="number">5</span>] = map[<span class="number">5</span>][<span class="number">4</span>] = <span class="number">1</span>;<span class="comment">//d e</span></span><br><span class="line">		map[<span class="number">5</span>][<span class="number">6</span>] = map[<span class="number">6</span>][<span class="number">5</span>] = <span class="number">1</span>;<span class="comment">//e f</span></span><br><span class="line">		map[<span class="number">5</span>][<span class="number">7</span>] = map[<span class="number">7</span>][<span class="number">5</span>] = <span class="number">1</span>;<span class="comment">//e g </span></span><br><span class="line">		map[<span class="number">6</span>][<span class="number">7</span>] = map[<span class="number">7</span>][<span class="number">6</span>] = <span class="number">1</span>;<span class="comment">//f g</span></span><br><span class="line">		<span class="comment">//dfs遍历所有情况</span></span><br><span class="line">		dfs(<span class="number">0</span>);</span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		System.out.print(ans);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//当7个灯都有状态时 进行判定</span></span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">7</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//把亮着的灯统计下来</span></span><br><span class="line">			ArrayList&lt;Integer&gt; a = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">7</span>;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(jl[i]==<span class="number">1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					a.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(i));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//判断</span></span><br><span class="line">			<span class="keyword">if</span>(a.size()!=<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(judge(a)==<span class="number">1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					ans++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			a.clear();</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//否则dfs灯情况</span></span><br><span class="line">		jl[n+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">		dfs(n+<span class="number">1</span>);</span><br><span class="line">		jl[n+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">		dfs(n+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">judge</span><span class="params">(ArrayList&lt;Integer&gt; a)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//System.out.println(++js);</span></span><br><span class="line">		<span class="comment">//并查集父集重置</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			father[i] = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//并集</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.size();i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> ii=<span class="number">0</span>;ii&lt;a.size();ii++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//如果两边相连的话 进行并集操作</span></span><br><span class="line">				<span class="keyword">if</span>(map[a.get(i).intValue()][a.get(ii).intValue()]==<span class="number">1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="type">int</span> <span class="variable">fx</span> <span class="operator">=</span> find(a.get(i).intValue());</span><br><span class="line">					<span class="type">int</span> <span class="variable">fy</span> <span class="operator">=</span> find(a.get(ii).intValue());	</span><br><span class="line">					<span class="keyword">if</span>(fx!=fy)</span><br><span class="line">					&#123;</span><br><span class="line">						father[fx] = fy;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;	</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//查看是否都属于一个集合</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> find(a.get(<span class="number">0</span>).intValue());</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;a.size();i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(find(a.get(i).intValue())!=temp)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//查集</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> father[x]==x ? x : (father[x] = find(father[x]));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>以下题目部分能通过<a href="https://www.acwing.com/problem/">AcWing</a>和<a href="https://www.lanqiao.cn/problems/">蓝桥杯竞赛</a>的数据测试（有的题没有被录入，无法测试）</li>
</ul>
<h1 id="试题-F-成绩统计"><a href="#试题-F-成绩统计" class="headerlink" title="试题 F: 成绩统计"></a>试题 F: 成绩统计</h1><p>时间限制: 1.0s 内存限制: 512.0MB<br>本题总分：15 分</p>
<p><strong>问题：</strong><br>小蓝给学生们组织了一场考试，卷面总分为 100 分，每个学生的得分都是一个 0 到 100 的整数。<br>如果得分至少是 60 分，则称为及格。如果得分至少为 85 分，则称为优秀。<br>请计算及格率和优秀率，用百分数表示，百分号前的部分四舍五入保留整数。</p>
<p><strong>输入：</strong><br>输入的第一行包含一个整数 n，表示考试人数。<br>接下来 n 行，每行包含一个 0 至 100 的整数，表示一个学生的得分。</p>
<p><strong>输出：</strong><br>输出两行，每行一个百分数，分别表示及格率和优秀率。百分号前的部分四舍五入保留整数。</p>
<p><strong>样例输入：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">80</span></span><br><span class="line"><span class="number">92</span></span><br><span class="line"><span class="number">56</span></span><br><span class="line"><span class="number">74</span></span><br><span class="line"><span class="number">88</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>
<p><strong>样例输出：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">71</span>%</span><br><span class="line"><span class="number">43</span>%</span><br></pre></td></tr></table></figure>
<p><strong>评测用例规模与约定：</strong><br>对于 50% 的评测用例，1 ≤ n ≤ 100。<br>对于所有评测用例，1 ≤ n ≤ 10000。</p>
<p><strong>思路：</strong> 送分题，记得四舍五入保留整数</p>
<p><strong>AC代码：</strong> <a href="https://www.acwing.com/problem/content/2874/">OJ链接</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">double</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextDouble();</span><br><span class="line">		<span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;n;now++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">			<span class="keyword">if</span>(temp&gt;=<span class="number">60</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				a++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(temp&gt;=<span class="number">85</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				b++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println((<span class="type">int</span>)(a/n*<span class="number">100</span>+<span class="number">0.5</span>)+<span class="string">&quot;%&quot;</span>);</span><br><span class="line">		System.out.println((<span class="type">int</span>)(b/n*<span class="number">100</span>+<span class="number">0.5</span>)+<span class="string">&quot;%&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="试题-G-单词分析"><a href="#试题-G-单词分析" class="headerlink" title="试题 G: 单词分析"></a>试题 G: 单词分析</h1><p>时间限制: 1.0s 内存限制: 512.0MB<br>本题总分：20 分</p>
<p><strong>问题：</strong><br>小蓝正在学习一门神奇的语言，这门语言中的单词都是由小写英文字母组成，有些单词很长，远远超过正常英文单词的长度。小蓝学了很长时间也记不住一些单词，他准备不再完全记忆这些单词，而是根据单词中哪个字母出现得最多来分辨单词。<br>现在，请你帮助小蓝，给了一个单词后，帮助他找到出现最多的字母和这个字母出现的次数。</p>
<p><strong>输入：</strong><br>输入一行包含一个单词，单词只由小写英文字母组成。</p>
<p><strong>问题：</strong><br>输出两行，第一行包含一个英文字母，表示单词中出现得最多的字母是哪个。如果有多个字母出现的次数相等，输出字典序最小的那个。<br>第二行包含一个整数，表示出现得最多的那个字母在单词中出现的次数。</p>
<p><strong>样例输入：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lanqiao</span><br></pre></td></tr></table></figure>
<p><strong>样例输出：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><strong>样例输入：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">longlonglongistoolong</span><br></pre></td></tr></table></figure>
<p><strong>样例输出：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">o</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>
<p><strong>评测用例规模与约定：</strong><br>对于所有的评测用例，输入的单词长度不超过 1000。</p>
<p><strong>思路：</strong> 暴力统计即可</p>
<p><strong>代码：</strong> <a href="https://www.lanqiao.cn/problems/504/learning/">OJ链接</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">		<span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">30</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">0</span>;now&lt;s.length();now++)</span><br><span class="line">		&#123;</span><br><span class="line">			ans[(<span class="type">int</span>)(s.charAt(now)-<span class="string">&#x27;a&#x27;</span>)+<span class="number">1</span>]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1</span>;now&lt;=<span class="number">26</span>;now++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(ans[end]&lt;ans[now])</span><br><span class="line">			&#123;</span><br><span class="line">				end = now;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println((<span class="type">char</span>)(<span class="string">&#x27;a&#x27;</span>+end-<span class="number">1</span>));</span><br><span class="line">		System.out.println(ans[end]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="试题-H-数字三角形"><a href="#试题-H-数字三角形" class="headerlink" title="试题 H: 数字三角形"></a>试题 H: 数字三角形</h1><p>时间限制: 1.0s 内存限制: 512.0MB<br>本题总分：20 分<br><img src="/images/2021-03-01/02-2.jpg" alt="图"><br><strong>问题：</strong><br>上图给出了一个数字三角形。从三角形的顶部到底部有很多条不同的路径。<br>对于每条路径，把路径上面的数加起来可以得到一个和，你的任务就是找到最大的和。<br>路径上的每一步只能从一个数走到下一层和它最近的左边的那个数或者右边的那个数。此外，向左下走的次数与向右下走的次数相差不能超过 1。</p>
<p><strong>输入：</strong><br>输入的第一行包含一个整数 N (1 &lt; N ≤ 100)，表示三角形的行数。下面的N 行给出数字三角形。数字三角形上的数都是 0 至 100 之间的整数。</p>
<p><strong>输出：</strong><br>输出一个整数，表示答案。</p>
<p><strong>样例输入：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">3</span> <span class="number">8</span></span><br><span class="line"><span class="number">8</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">2</span> <span class="number">7</span> <span class="number">4</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">2</span> <span class="number">6</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p><strong>样例输出：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">27</span></span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong> C组这题是简化过的，数据量少了，也多了条件，所以直接dfs暴力就好。当左右差减一大于剩下行数时，说明走到末尾时必定相差超过1，可以进行剪枝。</p>
<p><strong>AC代码：</strong><br><a href="https://www.lanqiao.cn/problems/505/learning/">OJ链接1</a> <code>链接里是本题版本，用DFS写</code><br><a href="https://www.acwing.com/problem/content/900/">OJ链接2</a> <code>链接里是未简化的版本，用DP写</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span>[][] map = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">510</span>][<span class="number">510</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		num = sc.nextInt();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=num;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> ii=<span class="number">1</span>;ii&lt;=i;ii++)</span><br><span class="line">			&#123;</span><br><span class="line">				map[i][ii]=sc.nextInt();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		dfs(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>+map[<span class="number">1</span>][<span class="number">1</span>],<span class="number">0</span>);</span><br><span class="line">		System.out.print(ans);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> y,<span class="type">int</span> x,<span class="type">int</span> he,<span class="type">int</span> cha)</span><span class="comment">//y x 和  左右差</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(x&lt;=<span class="number">0</span>||x&gt;y)<span class="comment">//剪枝 越界</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(Math.abs(cha)-<span class="number">1</span>&gt;(num-y))<span class="comment">//剪枝 左右差大于剩下行数 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(y==num)<span class="comment">//到达最底层</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(he&gt;ans&amp;&amp;Math.abs(cha)&lt;=<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				ans = he;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		dfs(y+<span class="number">1</span>,x,he+map[y+<span class="number">1</span>][x],cha-<span class="number">1</span>);<span class="comment">//左下</span></span><br><span class="line">		dfs(y+<span class="number">1</span>,x+<span class="number">1</span>,he+map[y+<span class="number">1</span>][x+<span class="number">1</span>],cha+<span class="number">1</span>);<span class="comment">//右下</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="试题-I-作物杂交"><a href="#试题-I-作物杂交" class="headerlink" title="试题 I: 作物杂交"></a>试题 I: 作物杂交</h1><p>时间限制: 1.0s 内存限制: 512.0MB<br>本题总分：25 分</p>
<p><strong>问题：</strong><br>作物杂交是作物栽培中重要的一步。已知有 N 种作物 (编号 1 至 N )，第i 种作物从播种到成熟的时间为 Ti。作物之间两两可以进行杂交，杂交时间取两种中时间较长的一方。如作物 A 种植时间为 5 天，作物 B 种植时间为 7 天，则 AB 杂交花费的时间为 7 天。作物杂交会产生固定的作物，新产生的作物仍然属于 N 种作物中的一种。<br>初始时，拥有其中 M 种作物的种子 (数量无限，可以支持多次杂交)。同时可以进行多个杂交过程。求问对于给定的目标种子，最少需要多少天能够得到。<br>如存在 4 种作物 ABCD，各自的成熟时间为 5 天、7 天、3 天、8 天。初始拥有 AB 两种作物的种子，目标种子为 D，已知杂交情况为 A × B → C，<br>A × C → D。则最短的杂交过程为：</p>
<p>第 1 天到第 7 天 (作物 B 的时间)，A × B → C。<br>第 8 天到第 12 天 (作物 A 的时间)，A × C → D。<br>花费 12 天得到作物 D 的种子。</p>
<p><strong>输入：</strong><br>输入的第 1 行包含 4 个整数 N, M, K, T，N 表示作物种类总数 (编号 1 至N)，M 表示初始拥有的作物种子类型数量，K 表示可以杂交的方案数，T 表示目标种子的编号。<br>第 2 行包含 N 个整数，其中第 i 个整数表示第 i 种作物的种植时间Ti(1 ≤ Ti ≤ 100)。<br>第 3 行包含 M 个整数，分别表示已拥有的种子类型 Kj(1 ≤ Kj ≤ M)，Kj两两不同。<br>第 4 至 K + 3 行，每行包含 3 个整数 A, B,C，表示第 A 类作物和第 B 类作物杂交可以获得第 C 类作物的种子。</p>
<p><strong>输出：</strong><br>输出一个整数，表示得到目标种子的最短杂交时间。</p>
<p><strong>样例输入：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">2</span> <span class="number">4</span> <span class="number">6</span></span><br><span class="line"><span class="number">5</span> <span class="number">3</span> <span class="number">4</span> <span class="number">6</span> <span class="number">4</span> <span class="number">9</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p><strong>样例输出：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure>
<p><strong>样例说明：</strong><br>第 1 天至第 5 天，将编号 1 与编号 2 的作物杂交，得到编号 3 的作物种子。<br>第 6 天至第 10 天，将编号 1 与编号 3 的作物杂交，得到编号 4 的作物种子。<br>第 6 天至第 9 天，将编号 2 与编号 3 的作物杂交，得到编号 5 的作物种子。<br>第 11 天至第 16 天，将编号 4 与编号 5 的作物杂交，得到编号 6 的作物种子。<br>总共花费 16 天。</p>
<p><strong>评测用例规模与约定：</strong><br>对于所有评测用例，1 ≤ N ≤ 2000, 2 ≤ M ≤ N, 1 ≤ K ≤ 100000, 1 ≤ T ≤ N,保证目标种子一定可以通过杂交得到。</p>
<p><strong>思路：</strong> 暴力…感觉应该是过不了全部样例，但是网上也没有判题数据…</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> i,<span class="type">int</span> j)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; arr.length; k++) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (i==arr[k]||j==arr[k]) </span><br><span class="line">			&#123;</span><br><span class="line">				count++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> count&gt;=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">K</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">T</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span> time[]=<span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        <span class="type">int</span> Ztime= <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> M;</span><br><span class="line">        <span class="type">int</span> start[]=<span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        <span class="type">int</span> ZJtime[][]=<span class="keyword">new</span> <span class="title class_">int</span>[K][<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;N; i++) </span><br><span class="line">        &#123;</span><br><span class="line">			time[i]=scanner.nextInt();</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; M; i++) </span><br><span class="line">        &#123;</span><br><span class="line">			start[i]=scanner.nextInt();</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; K; i++) </span><br><span class="line">        &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) </span><br><span class="line">			&#123;</span><br><span class="line">				ZJtime[i][j]=scanner.nextInt();</span><br><span class="line">			&#125;  </span><br><span class="line">		&#125; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;K; i++) </span><br><span class="line">        &#123;</span><br><span class="line">			<span class="keyword">if</span>(f(start, ZJtime[i][<span class="number">0</span>],ZJtime[i][<span class="number">1</span>]))</span><br><span class="line">			&#123;</span><br><span class="line">				start[s]=ZJtime[i][<span class="number">2</span>];</span><br><span class="line">				s++;</span><br><span class="line">				<span class="keyword">if</span> (time[ZJtime[i][<span class="number">0</span>]-<span class="number">1</span>]&gt;time[ZJtime[i][<span class="number">1</span>]-<span class="number">1</span>]) </span><br><span class="line">				&#123;</span><br><span class="line">					Ztime+=time[ZJtime[i][<span class="number">0</span>]-<span class="number">1</span>];</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					Ztime+=time[ZJtime[i][<span class="number">1</span>]-<span class="number">1</span>];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; start.length; j++) </span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (ZJtime[i][<span class="number">2</span>]==T) </span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        System.out.println(Ztime);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="试题-J-子串分值"><a href="#试题-J-子串分值" class="headerlink" title="试题 J: 子串分值"></a>试题 J: 子串分值</h1><p>时间限制: 1.0s 内存限制: 512.0MB<br>本题总分：25 分</p>
<p><strong>问题：</strong><br>对于一个字符串 S，我们定义 S 的分值 f(S ) 为 S 中恰好出现一次的字符个数。例如 f(”aba”) &#x3D; 1，f(”abc”) &#x3D; 3, f(”aaa”) &#x3D; 0。<br>现在给定一个字符串 S [0…n - 1]（长度为 n），请你计算对于所有 S 的非空子串 S [i… j] (0 ≤ i ≤ j &lt; n)，f(S [i… j]) 的和是多少。</p>
<p><strong>输入：</strong><br>输入一行包含一个由小写字母组成的字符串 S。</p>
<p><strong>输出：</strong><br>输出一个整数表示答案。</p>
<p><strong>样例输入：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ababc</span><br></pre></td></tr></table></figure>
<p><strong>样例输出：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">21</span></span><br></pre></td></tr></table></figure>
<p><strong>样例说明：</strong></p>
<p>子串 	f值<br>a		1<br>ab		2<br>aba 	1<br>abab 	0<br>ababc 	1<br>b 		1<br>ba 		2<br>bab 	1<br>babc 	2<br>a 		1<br>ab 		2<br>abc 	3<br>b 		1<br>bc 		2<br>c 		1</p>
<p><strong>评测用例规模与约定：</strong><br>对于 20% 的评测用例，1 ≤ n ≤ 10；<br>对于 40% 的评测用例，1 ≤ n ≤ 100；<br>对于 50% 的评测用例，1 ≤ n ≤ 1000；<br>对于 60% 的评测用例，1 ≤ n ≤ 10000；<br>对于所有评测用例，1 ≤ n ≤ 100000。</p>
<p><strong>思路：</strong> 这题还是有点难度的。根据题意，我们可以发现每一个字母所提供的f值(权值)，为与上一个相同字母之间的差值乘以与后一个相同字母之间的差值。例如样例中的ababc:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ababc</span><br><span class="line">字母a : 无前一个相同字母，前差值为<span class="number">1</span></span><br><span class="line">		与下一个字母a之间的差值为<span class="number">2</span>，后差值为<span class="number">2</span></span><br><span class="line">		总权值为：<span class="number">1</span>*<span class="number">2</span> = <span class="number">2</span></span><br><span class="line">字母b : 无前一个相同字母，前差值为<span class="number">2</span></span><br><span class="line">		与下一个字母b之间的差值为<span class="number">2</span>，后差值为<span class="number">2</span></span><br><span class="line">		总权值为：<span class="number">2</span>*<span class="number">2</span> = <span class="number">4</span></span><br><span class="line">字母a : 与前一个字母a之间的差值为<span class="number">2</span>，前差值为<span class="number">2</span></span><br><span class="line">		无下一个相同字母，后差值为<span class="number">3</span></span><br><span class="line">		总权值为：<span class="number">2</span>*<span class="number">3</span> = <span class="number">6</span></span><br><span class="line">字母b : 与前一个字母b之间的差值为<span class="number">2</span>，前差值为<span class="number">2</span></span><br><span class="line">		无下一个相同字母，后差值为<span class="number">2</span></span><br><span class="line">		总权值为：<span class="number">2</span>*<span class="number">2</span> = <span class="number">4</span></span><br><span class="line">字母c : 无前一个相同字母，前差值为<span class="number">5</span></span><br><span class="line">		无下一个相同字母，后差值为<span class="number">1</span></span><br><span class="line">		总权值为：<span class="number">5</span>*<span class="number">1</span> = <span class="number">5</span></span><br><span class="line">则答案(权值和)为：<span class="number">2</span>+<span class="number">4</span>+<span class="number">6</span>+<span class="number">4</span>+<span class="number">5</span> = <span class="number">21</span></span><br></pre></td></tr></table></figure>
<p>根据这个思路即可较为容易的解出本题，记得最后要用long类型转换，要不会爆int…</p>
<p><strong>代码：</strong> <a href="https://www.acwing.com/problem/content/2871/">OJ链接</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//前数组</span></span><br><span class="line">		<span class="type">int</span>[] piror = <span class="keyword">new</span> <span class="title class_">int</span>[s.length()+<span class="number">10</span>];</span><br><span class="line">		<span class="comment">//后数组</span></span><br><span class="line">		<span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[s.length()+<span class="number">10</span>];</span><br><span class="line">		<span class="comment">//答案值</span></span><br><span class="line">		<span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//中间值数组 用来储存每个字母的前后值位置</span></span><br><span class="line">		<span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//初始化</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length()+<span class="number">10</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			piror[i] = <span class="number">1</span>;</span><br><span class="line">			next[i] = s.length()+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//找每个位置字符的上一位</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s.length();i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> s.charAt(i-<span class="number">1</span>)-<span class="string">&#x27;a&#x27;</span>;<span class="comment">//计算出数组位置</span></span><br><span class="line">			piror[i] = i-temp[t];<span class="comment">//计算出与上一位相同字母位置的差值</span></span><br><span class="line">			temp[t] = i;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//初始化中间值数组</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			temp[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//找每个位置字符的下一位</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s.length();i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> s.charAt(i-<span class="number">1</span>)-<span class="string">&#x27;a&#x27;</span>;<span class="comment">//计算出数组位置</span></span><br><span class="line">			<span class="keyword">if</span>(temp[t]==<span class="number">0</span>)<span class="comment">//说明是第一次碰到</span></span><br><span class="line">			&#123;</span><br><span class="line">				temp[t] = i;<span class="comment">//标记</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span><span class="comment">//不是第一次碰到 说明上一个的下一位找到了</span></span><br><span class="line">			&#123;</span><br><span class="line">				next[temp[t]] = i;</span><br><span class="line">				temp[t] = i;<span class="comment">//标记</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//计算答案 前差值*后差值等于当前字符的权值 累加即可</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s.length();i++)</span><br><span class="line">		&#123;</span><br><span class="line">			ans += (<span class="type">long</span>)piror[i] * (<span class="type">long</span>)(next[i]-i);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="试题-B-寻找-2020-附件"><a href="#试题-B-寻找-2020-附件" class="headerlink" title="试题 B: 寻找 2020 附件"></a>试题 B: 寻找 2020 附件</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">002000000220202000222000202200222220202202020002220002020022202200220220202002002220020200000000220022200202222022220222000022220220020020222020022220022220220000022022002020220002200220020020022200020222020200200000020220020022002202000202222020220020020022020000202022220222200022220000000020020020</span></span><br><span class="line"><span class="number">000020002002200002022222200222002020000200020220000022020002020200000222000000202202220222000222202200202202200200222222220202022020022002220200022020200222002220202202022202222002000220202200202202022000000222220222200200022220202200200020202222202222220022202220020002000000200022222202020020222220</span></span><br><span class="line"><span class="number">220002002202200022020020202000220002000020220202222020000020022222002000002222220022022020002022200020022020202020022200022200202202220200000202020220022200222020020222020020022200222220222000020202000020022220222022202222002002002000002020202200220200222202002002202002020202222220020002020220200000</span></span><br><span class="line"><span class="number">022200022002022002220002002222022020220002222200002002222002222222022200002022002002200220020002220002020002222222022020220020200000022022022220220222002222220000022200002002020000000022220202020020222202222200200220200220222220020202020002022002222022022022222002200220202202002022000022200020220000</span></span><br><span class="line"><span class="number">202222202222222000000022222022202022220000222002002000022202022002220220220022002002200000222200222002222002220000220022002202220222220222002002220200222200020222000202200022022020002222020022202002000200000222200020222020002020022222222222220202002200200200220020002020200000020022000202002000022000</span></span><br><span class="line"><span class="number">020200222020020222002020000022220022020220002220220220200222222000222222002202002200002000220022220020002200020020220002000020002002200200200000200200220202002020022202002002222222222200222020020000020220002222020202202222220202220200202002202220020220200000022020222002222020200200022202202202200002</span></span><br><span class="line"><span class="number">020222000220220200222000000202020022200022002020222220220200202000200200202222020020200220002200000020000002022000020020002220202002222220222000220220222222000002000000000002220022000220022202202202020222202202200002220200022222002000020020220200002200202220022220020002220020002222220220220200022000</span></span><br><span class="line"><span class="number">022002200222022222020022202000002222200002022002020220000220200000002002022000000022000022202022200002000000020200000020002202200020200002200000202002222002220020220200020222002000022002022020000020200000202020200020222200020022222222000222202020200200222000202020020000200022020202202222002020200002</span></span><br><span class="line"><span class="number">202020200000020002020022202222022220002222022222022200200002002220020220220222202000220022002220020022000202022022222200220020022202020202202222002202222000202200020020222222200202200220002222200220002202202220222022222200002220022002222000220002020220000220220022000020200220200022000202020220200222</span></span><br><span class="line"><span class="number">220002222000220022000222020020202220220002000002200222220002000020000000000202202002222022202220220200020202202200220202202022022222020220202202020002222200002020220202022200002222222200020022022202220000020002022020222020022022222022202220222002020000002022000020220020220222200200002202002220222002</span></span><br><span class="line"><span class="number">200222022022022200200220202202200200220222220022022000022000022022020200222020220000220220020020000020222022222002020220020220222000202200222222200020022002220222222002222200020002000202022202220222202020000020022202022002200020220002022022002002000022020202002020022000000220202200022022200020022220</span></span><br><span class="line"><span class="number">002002202022020200022222220022000022202220002202200000220000020220000020022200200020020222000000200022000202002022200222200222000000000202222200222022020202200020020202220022200200022200222022202202002202020222022002022002222222020202022220202020202002222222022220220002220022022002220022202002222002</span></span><br><span class="line"><span class="number">220022002222002220222000220000002200220020022000220022222220202200020022000222022202220220022202222020002020200202202002222022222020220200020000020022020022200000000000022202022022200220222022220222020000020222000200022202202220202002002222000220202220200220000220202022000202222020222000200000000000</span></span><br><span class="line"><span class="number">002220020002202202002220022220222002220002200022200002222002200020200202000000222222220022222200202220002222220000000220220022200002200022202022020200200002202000022202200002220220020220020022220022200000000220200200020022020222200202002200220222222202220202220002022020022020020200002022200222222020</span></span><br><span class="line"><span class="number">002200202020202220200020220220002002022022020022200202000220202220220222200002000020222022000002220020002002022022200002200000222222200022002222000200000220220220022022020022000200220022220002002200002022020200220000020000002002002020222202000202022220000220200200200020002002200220202000220002222002</span></span><br><span class="line"><span class="number">200200202222000020022220222022022002222220200002022222000020002222220200020220222220022220222220220000202022020222022220202000002222000200220202002202200022020220002220020022002202022022000000222020220002222222002020222000022222220200020000000200020200020220220222220020000222000220222222222200222202</span></span><br><span class="line"><span class="number">000200202020220002002020022020022020000202220202022222220020202220220202022220200002000222200000200200220002222202022200022020222022202002000022002200222222000222000202002022222020220202200020022220222022000002020022002000220220022202220202002200202000200222002000202200202222220222222002202200002220</span></span><br><span class="line"><span class="number">020220002002020000002002220020022022020220022022202202220202222222200020020020222222022020000000220222000220020202022202002020200002002202200200222022022020022000020002000222022000200000020000020002022020020200202200222222022222022000002002220220002202022020222000202002222000022022000000200020022022</span></span><br><span class="line"><span class="number">002002002002022220000022220020022222220002200222002200020202000202222002020020222020002200020002002202022220002022020000020022222200002202000020222220020000022000020220002220000202000220020202002220022000022002202000000220020202002202200202220220022002002202222222020220222222020020000222000000002022</span></span><br><span class="line"><span class="number">000202222220222222002202200200200220002022022000002200020202002020200002002202000220000222002020022020002000022020222000000202220220002022220022222220222002200220222220002020202202022002222202222202222002222200020000220020222002000022002222202220020222202202200202000000002200200222020022220220220202</span></span><br><span class="line"><span class="number">022200200022222020002022002000222000020002002222020002002222222020200022020002022220000200000002000020202002020220200020020002200020222000202200202222220020200020202222220200220200222202222002202200200202002222002002200022200022002200222002002000022022022002220002002002202022002222220020220022000022</span></span><br><span class="line"><span class="number">020020200200000000222202222220222020202202220200220022222202002200022022220002002200000202002002020000000220200222222020022220002000200022220202000002022220200002000000222220200020200002202002200200022220002220002220022202002202020220220200002222002020202020220220202000200020222200200222222000222020</span></span><br><span class="line"><span class="number">022200200200000002220002202002022202202220000222202222220220022002022220022002000022002202202000202002220200002002002000000220202200220202220002200002020000222220222020020202000222200202202020200000022002000022220000200020000202222200222200222022020200220200222200222202022202020222020020020200020222</span></span><br><span class="line"><span class="number">000022022222220222222220222000202200022022002000200022022220002020222222202222020200220200222202220002200002000200202022022022020222020200202020000000020000000220000002002200202200202022020200020000220000200000222002002000022220022220022200202202020002022200202220020222020222002222220020202000202222</span></span><br><span class="line"><span class="number">000022202020202002000222002222222200002220222202222022020200000200202002002202022220000202202020200222022220000202022020020022002220222022020000000020022222022020020200220022220020202202022002220202202202222222200002222020000022022220022200022200002202020022200200020202222000002022200000002222002022</span></span><br><span class="line"><span class="number">000200020020220002020022020020202022022200200020000200222202222000000002000200020222000020002020000202202202000000220202002222200202200222202002220222202002020222000202022022022020000022202200220220222000220020220000020000200200222220000222020002222020220020202020022002202002002022022020200220002000</span></span><br><span class="line"><span class="number">000000020200020200020020002202022020220022202002020022002020020020000202020022022200202202200000202220022222000002020020220202002022002222200200000222022022202000020000220000200200000220220200202200222220220202000200020200020200200202020020002000022000200220222020222022002000022202202222222200220020</span></span><br><span class="line"><span class="number">222200222020220220000202200000002020200202002202020200022002222022022000202022200202200020020202020020222200222200000220002200200000202220020202200222000222202000200020202022222000200022020200202220000220000222202202022020022200022002202020022200200000220002220200002222220200000220202222220020222000</span></span><br><span class="line"><span class="number">202222202000020222222220000022000222022020200000020222020220222222220202002222002200020022002200020002020000220000220200002202202200220220202002020222222000220020202200222002020002020222220222202002020202202200200002202202200022220222002222222000020222022000002022222000022200002000000220200200002000</span></span><br><span class="line"><span class="number">002020200202220222202020222220200222000002202022002200202202200220000222000202022002002200200000200202000200000220200020222222202202002222220000020222202222220002002222002222202222020000220222000200200220020020002022222002000002020220022000022220000022220222222000020000020220022002222202220022202022</span></span><br><span class="line"><span class="number">022000200200000002022222200022220222022220000222202002020222200220020020000220002202022022002222200002002020202220022222000200222002200000002222202202000022000000000222022000020200020200000200000020020002200222220202022222000020022202200202000000220000200200022220200222002000202220002000002020020002</span></span><br><span class="line"><span class="number">002022200002022002202002020220002020202222202220022022020202202200002200220022220202022202000220002002200020222222220020200222020200222020020022220200002022202022200200020002020200222200000020222202020000202022220222222222220200020202000202222220000202222220000200000202222222000222220220200220022202</span></span><br><span class="line"><span class="number">000202200220020002222000002200220222022200000202202220202220022220002002022202022222220002002002002000202002020200202202002022202222020202020000020020220000202202202222200000002022200222220000020000022200202022002202022002020200002020022202022222202020000220022220202002200022202000202000200220202222</span></span><br><span class="line"><span class="number">200022020220002222020000222002022022000020220000220200222022000202000002222200020222202022222000000202020002202202002000200222220002020222220020002200000220222222000222002022222002020200022002000222202220202020202020022200020222002200002222002202222000200020222222002222202000020200022022220020222220</span></span><br><span class="line"><span class="number">202020020000222000022220200022200002220200000220000200002002202022202222022020220000220202000020222022222222000020220020200002222002200202002200000020200202020222020020020002222200022002220200200022002022220022222222002220220000222022020222202000200000000220002002000200022022200002202002002220000022</span></span><br><span class="line"><span class="number">002022220022220220200020220020202022022220000020202002222000222222022002222200220020002222020020020220002200220202222222000202222220022002222220222022002222020222200000022002000220200220222000002022002020222202000020020200022000002200200222202202000020220220202220002222020000020200220200020200020022</span></span><br><span class="line"><span class="number">022002202022220000202020220002020002200220222002002220222000022022200000020020022002020000220202202002000002020020222000022000220000200002020202020022022200020022022202022000020020022000200222222020000220202222200022000200202002020022002000202002202220022020022022220020220220200002202022222022002002</span></span><br><span class="line"><span class="number">200200200020000002200222002202200020200202002220000022200200002020220222200000022200022002000000000002222222202220220220202022000002002222222020220202002222020200020020002220000022020022202002002202220020200222202222002200020222222202220200020202020002002202020002220220002000200200020020022000202202</span></span><br><span class="line"><span class="number">020000022220222222220000200222202220220020222202220000200020200020220202200222200220020200200020202020222202220202020000200220220220000002000200222002002002000022202022202222222002020020220000000220002220022202220002000002002000202220000220000222020200020220020000200020222020002222220200200200022202</span></span><br><span class="line"><span class="number">000202222222222002202202200200200002022020000202000200200002222002200020202020220020222200000000020000222222222202000002020002000020020000000000022000220220000200202202000200020002000202020022020200220202222202000020002002020002220222000202000022200000222222022020200222220002020202220202000020022000</span></span><br><span class="line"><span class="number">020022002020000002220000000002220200000000000002020022200220020002220220022002020200220020000222020020020222200000222002022202020020222020020202202202220200222020022200222000220202202202000222200200220000222200200200022022000022022000202000222222022022220002020202202022202002000220200202022020022000</span></span><br><span class="line"><span class="number">000002002002220220222002200000002000002002000222202220022222020202202200220002022002002202222002202200200220022022200020020022020020000220220002220002220022022222220200200022222020000020000000022002002020002220000220202000222200200000202002220020202002220200222002000220000000022220002222200002200002</span></span><br><span class="line"><span class="number">222222002000202020002022022200022002200220202020002220000002000202020200002002020000002002020002220020222002020200000020000022000022022222002202020020202022222220022000022200222022002000220000220202202002000202200222200220222202002220222220200022222002220200202002020002022020020222000220202222022202</span></span><br><span class="line"><span class="number">000220220020200000220202200222022222202000220202022220220000020202222222022202200202220002022002002202220200002000202022020002202222202220222022022222202222002220002020022022022022000022000202220022220220222202022222002202220022222020222002202200022002220022022020022002202000002220222222022002220000</span></span><br><span class="line"><span class="number">200022200020202220222022202022002022202200000000000202000022202200020002022200000222020000222002002002002200220202002000000202222002000200220222202220020020002220222000002202200022220022020202002220222002200222022220002022000222222000000000000000202220000222000200022202000202200222022000220202202002</span></span><br><span class="line"><span class="number">222002000022200202022222220202020000020000022022022200020220202200002220000222000200002202222220220002222022020222020200020020000020222020202022200020002200222002022200002220202022220022022020200020202020000020022200020000002222200022220022000222022020020020222222220222002202020020202222020002022220</span></span><br><span class="line"><span class="number">202202022002000220022020200220220220020002202222202220222002202200222200020022022200020222202202202200200222000202000002222220202020000202002220200200222020002200022000200020202200220002202222020002000020002000002202202220202220002022222222020220000000022200202002022000202002202200022022002202020020</span></span><br><span class="line"><span class="number">020022020000022202022200000200200022000220020022002022002200220002200200000222200202002000022202200022020022020200222220222200002000200200222000200200222022020022222222200002202200222022000000002000022000002220202020202002222020202000020020002022000200002002000200202222020222202200000222222220022220</span></span><br><span class="line"><span class="number">002202000200002022222022222002022222220020202222222020022220220002222022022022200202000000202002000020202200202200000022022200200220002220020020002200022022220000200002202002002200200222002000220020200200022002202020000202020002002222002220200200200200222022000002002022220002202002002002220000022222</span></span><br><span class="line"><span class="number">220002202020220002002200002020022220000220200222002022202220202202200222202220200222202202202022222020022200200220000022220000000220020022222222002022202022200202222020200022202220222200020022202222222020202200022002222000220002202022020000200222022220022200202002200020202222202000000000222200022002</span></span><br><span class="line"><span class="number">002002020000020022000222202202200220000220220000022200020220200200022000000022022000222022022200020202220002002200200220202200002022220200020222020200202022022002220202000220000202222200020002202022022200222222222020200022222002222200022002222222000202020222022200220002000020000022020000202202002200</span></span><br><span class="line"><span class="number">222202002222220222220220020000020022200220022220222202222202200220222220022222222020222000002202022200200222000000222220002002002222020200022220020020002002202200022222220000222200200202000202200202222202202202222200022200200020020220022202220000202020000020000000000220200020220000000002202000020022</span></span><br><span class="line"><span class="number">022020020020020020202020220202022022200002022022002200002202220202002022002002202200000200202200220222220020200220222000022202222022022020202200222000020020220220202222000220002200000000202202002002022200222200022220002022020002000202000000002002022002020220022020000022200200000000000000202202020000</span></span><br><span class="line"><span class="number">000022022000202020000020022222222002202202202000002000222020022002022020020222220202002000022200202222002000200222002220020202000022000002002202000002002002000222022200000202220020202222000220020000222200200222022000200200222222022220002020000202220222220202220002222022020002022220000022200202220002</span></span><br><span class="line"><span class="number">220022002000220222000002200222202220200200020022222000220020200002022222202002220022000022200220202000220000020020020000220002220202220002002002220020002020000200022020002022220202020220022202022200000220222220002200222022000020020020020200200022200220222222220022002200000220000220000022022020222002</span></span><br><span class="line"><span class="number">002002022000000200022220222020202022202022220000200022022220022222000200022000220020202200202222222020002000220222202002000020222220022020002020020222200020002002020022022200002200020020202202220202022020202020202022222202000202022002022002002022200202022000020202000022022022002222200220200222220200</span></span><br><span class="line"><span class="number">202020020022222020220000000000220222220220202220222000220020220022002222200000200020020202202020002022000000002202200222022020002000202000222022202000020002020220222200200202022202222020022002202022022200020002220222002000220220202220022222002200200000222202202222020000222202220222220202222022222200</span></span><br><span class="line"><span class="number">020200020022200020002202002000002220000202220200002202022200000200202220202200220022022020002200022000002202200000022222022222002022022220202022200220220200020022202202020000002022020000202200200000222020020220002000222200220200220000220220200020202000220020222022220020202000222020022000020220020000</span></span><br><span class="line"><span class="number">002220022222020022200022200020022202000020000200202202220200020002000220000000000220020020002202002222022020200022022000020002220022020020222020002220000222200000020022022020022220220200202022202020200022022020220202000020020220020022220202200000220220002000020000200222020220000222020022220022220200</span></span><br><span class="line"><span class="number">022022200000002020002022222000020220020020200022000020022002220200222202002022020002020202002002202020222002202202002020200020202022200220020200222002222222022200022022200222222220020000002220222000002002022200022020002000202222200200002202202000020200202000020002220002222200022020022202200200020220</span></span><br><span class="line"><span class="number">000002022022200222002220020202222220002002222222022000220220200020220220222202220200202222220000000000202022000020000220220202202200022222200000220200222000200222020220202022200020022000000002200220000220222202000002022222022002020222202202220022220022200022222220022202022202000202022202002020020220</span></span><br><span class="line"><span class="number">022202202022220220222220220000202200202002020000022202222020000002002000200002002000022200200220020022002020200202200200020022020202220202202220200002020200002220002000022200000000220220220022202000002000022202220202202202020002220000002202202220022202020022002200202000022022222002000202222202200222</span></span><br><span class="line"><span class="number">022222202022022222000022020222020020022020022202000020002202220200020200220202022222020202222220022220200202022022200022022002222222002220200222222202200222020202002002222022202222000222222202020200022000222000222200202200000020202020200222220000002002002200002020220220220002022202000020000020220020</span></span><br><span class="line"><span class="number">200220222000200002002002202022220220220222200000022200202222000022002202200000000002200022220000202000000002222200222000020200020000020202022220022002000000002022000002002200022000222220220220202220022022222200002222022222000020200022000000020002020202000222002022220020222002202220200020000022200220</span></span><br><span class="line"><span class="number">202002222000222002000200000002222020202222222220020000202000000220202200202020220020020200022002222220222200222020222222202020220220220202022000020020022220000002220200200002000020220002002000222200220222002222200222000220002020022000220200200200222020220220022222020222220200022002022200022020220002</span></span><br><span class="line"><span class="number">002200222222020222200020202222222200220222202022200222000020020022000000200020200000222002022000200000020022002202222002022020202002020000000022222222222202002222020202002020222000202222222020022220002000200220020202022022202202200020020000222220002202002002000222002200002020022222022202002002222022</span></span><br><span class="line"><span class="number">200222020202220002000020000020202200000022022200000220020202202200202200022200000202200200022202222220220020202020000000202222022222020020000022202022020020222020220020022202000022220020002002202200000220222202022200200220222200220220000020202220202200222000022002020002022200202222022002222220220022</span></span><br><span class="line"><span class="number">220022222000020220022222022220222000002022000222020202200200002022022200202000002000020200002002000000202002202222022200202022002202200222022202002222202022202020202020200222000220022220022000020020200200202200020222000200220020020020020220222022020222000002002220202220020222200020000202222002020022</span></span><br><span class="line"><span class="number">202220022020000022220022222002000022220202220000200022022020002200002222222000022020020222002202200220220022000002002000220200002020000020220020220200020200202200000200220002020020202202020222022022002220020022202202000222222202022022020022202222002020002022022200022200222022022020222020222002202222</span></span><br><span class="line"><span class="number">020020200220202002000000222002000002000202020022222000022002020002222020020020200222000022000220022000022220020002022002220002000002002002202202020222020202202022000202222220022220220222000002000002222200220222222200020020002222000000002002022202020020200220002022202200202220220220020202202002022200</span></span><br><span class="line"><span class="number">202222220202022222002200022002200200222202000202222000020000200000202002022220220220000200022002020220000200022020020222020202220220222220000200002022222002202020222202002020000000200002022222202220022222220200222000202000202222222002202022002202202220020002202220002202222002022220020000002220200022</span></span><br><span class="line"><span class="number">200200220202220022220022022222002220220002020000000002222020222200002022222220220220222222000200002022220200022220220200000002200202220222002002200002220222000020002002220022022202222200000220200000000202220002022202222000222200222020000222000002000222022202022220202022220002020220002222000220002002</span></span><br><span class="line"><span class="number">000222022222020022220022220222002000222000022200020020002020222222020202002200020002202200022022200022200200200200222202200220002200020002220022220222220020220200222222000222220220020000220022222202202022020020022200000022200022022002020220000000000020200200202220022002200020000222200000022002222000</span></span><br><span class="line"><span class="number">220200002000220220000002022202202200022200202000022202000002000002002000022002222000220200022222220202002202000202200002022200202000202000200220000000020200222000002200000020022202022000020020202020222202200022020022002002202220200202200220202202020222220222000000002002000022222200222002202020222220</span></span><br><span class="line"><span class="number">020002000222022200202020022200220200020022202022222202022222022002022220222000202222200220202000220220222222000220022002202022020202000222222222200002020002202020002002002020022220200220020202020220222202222202222222020220020002200000020002222200222200002000220000002200000222020022022220220000002222</span></span><br><span class="line"><span class="number">022002220022222200020222220202202020020220022220200020000200002220220222220000000022000002202022202022002022222022220220000002020200022000220020022200220000202002202020222220022202222000222202022220000220220020222220222222202202020220202220200002200000222020022220200000200022020000020200002220002000</span></span><br><span class="line"><span class="number">202000202202222222022022000000220202202222000020000022022222020222020022020002000200220202200202202202200000200000000200000202202002022220222200002202220222222200200222022020222220222220020222000202020200020022020000222020202002002000202020202200220022202220222000000022000022220222220020002222200222</span></span><br><span class="line"><span class="number">020202000222202222020220000022200000020200202220220200020002002000220222220222020222222202220020222222020002000020020220002220222200002220002020220220200220200020002200220202200220200200000002202020022022222220200222220000220022222222222000222002220020202020002002000020020020200222020220000002002022</span></span><br><span class="line"><span class="number">022222200000202200000222220202020220020220222202022202000002202022220200000220200222200000220222220000220202002220202000020222202200020000200222200200020220002022202020002202222220200000022022222222222002202002202020200202202200220000222020000002200222222002220000220220000202220222220202002200002020</span></span><br><span class="line"><span class="number">022200002022222222202000020202220200200000222200000222002202222222200000220000000022220020222022020020202002022000000002202200220222202200222222200200020000220002222222222202002002022000200200222220222020022000022222002002202222022202000020220020020002022000222202000000002200222020002022200000020222</span></span><br><span class="line"><span class="number">200202202022000022002002200020000022202002022002000202202200002022022000200220000222220222002200020202220220000220202022002200020200222002202220222200202022202002222000022222200220220202002220200002000200000000202002200000222000220000022020220002022202000000022000202222200022020022202000002002002202</span></span><br><span class="line"><span class="number">000200000002222002202022200202202002222002220200222220020222000222020020002222000200002220000002000202000002000222200200020002220202220222200020222220220202200200200020202000202200022020200220222222002202000002000200220222020000200002000200020000222202220202222202002022022202000000022222200220200022</span></span><br><span class="line"><span class="number">000202000222000022202000020222000000002022220202002222222002220220222020020222222222002202002000000202020202220200200022022000200222022220002000000202200020000022002022220020200200222200020022022000000000002002022202022020002202020202202000000220002220200222202022200200002002002200220000200202222220</span></span><br><span class="line"><span class="number">002202220002002220202222002002000020022020022220200220022000022002222220002020222000002022000200020022200022022222000222222220220200002000022222222022200000000220220202200002202002202022202220200020002222220020222022000002020220222002200222220202002202002222000200220200002222020202200022000202202002</span></span><br><span class="line"><span class="number">222220202022202020200020220200222022220022020022202002202002220200020200002222000222002200202202220020022000020000002220220200202202222020002220220200002202222020000020222000222022020000002220200002020000200000222022200000202222002002220020002022002220022000202000220000222002202000000002222202202200</span></span><br><span class="line"><span class="number">000002000000222222000222200222200000022022020202002202220000002020000022000202000200020022002022020200222002022222200202200002022200020202000222202222002002222222202200220220202200020000022222002000200202020002002000222222202002002200202020000022220200000220222000000200000002202222220222022220202020</span></span><br><span class="line"><span class="number">022222002000020220222000002220000200222022202222200220020000202220202222020222000000022220022020000002002020220002222022200000202222002022222200200202200002202002002020200222002202000002000022022200022022220002200200022002220222000022000022202200222022220200220020002200202002220000200202220022222222</span></span><br><span class="line"><span class="number">200222022020222000200002220000020220220222000222200022220202002002002020020200020200220222200002200200222020000000222202202000200220220200202220202222000000022022220022222200000222002022222200202002000200220000222000202000022222002220000202222002000002002020200220002002022020220222000202020020000022</span></span><br><span class="line"><span class="number">000022002020200202022000022000000202002220220202002022222002202000022220020202022022000220202222202000200000002002200022202022002020000222022022002002202000200000000220220002002220202202222000020000200200002220002002020020020202202002202202020222000022000020002220220220000022020220220020220022202020</span></span><br><span class="line"><span class="number">202220020020200222200020020002020222000200202000020200020000000202220020200222220022022020222022002002222020000220220002000222202022020200002202020002020002220022022002222200220002202000220022220020002220022020220220200200222222022220220000222220002000020002020220000202222020002200022202220200000000</span></span><br><span class="line"><span class="number">202002000022200022200220020020220000200020002022220002220002002222022222220222222022020222200202022200000220220002020200002022200002002020002022200222222200000200220200200020020200022020000022220020020222222202002000220222000202002020202220020220022222000220022220220020020220022202000022020200220220</span></span><br><span class="line"><span class="number">220200222200020222220000200022002000200220020002002002220000022202020202022020220202002022200220202202002222220020022200222202002222002200202200222000022200022000000022022020222002220002202202022202020022022202222202022222200002200202022002000200002200202022220200200020200020220202000000222020220222</span></span><br><span class="line"><span class="number">002222222002020002202020220220000002022200200202020200202002022020002022220222002020022222002222202000202002202020200220002220000000222002200020220020202000020002200200022022020002200000000200220222222020222202002022002200022000200002220022022200020220200022002020202220000202002202022020000000000200</span></span><br><span class="line"><span class="number">220222022000002202220000002200020022020000022022220000222022020002222022000202020220202200220200002022020002000022202202022202002000200220002220020222020220222202002020200022000200220002002020022222220220020002200222000200022000020022200222022222220022022222202020220222200200020202020220200020000022</span></span><br><span class="line"><span class="number">220000020202022200000202222222220200202202000020200002202220220000002220020200020020002020200000022202022002020000202022022002002020202200200002222022002020000000002020220002022002220002020002222002020222000202020220000002022202000000022222002200220220002200200000002200222222000000002020002002022202</span></span><br><span class="line"><span class="number">220020202020222222022000000022200020000220220200200200000220020222000202000020000220220220220222220202222000002022020022020000020020222220000000000002202022022002200220220200222202000200020002022222202200200002020202220002222020022022200000220220002022222020020000202022200020000000222222200200020002</span></span><br><span class="line"><span class="number">022020222000022202002020220000220222000000200220000202022022222202222022022200220022222202022000002222000220200222020200002020022202220020200000022202022202222200200222002020222000020020202022220202222202220200002220200022202222202000002202000022220020000020020022020202200000000020022200222200000202</span></span><br><span class="line"><span class="number">022202022000020020202000200002022202200020200200020000200222222000000202020220000022222002000222002220222220000002002220202022020020220020000222220222020000222200002022022222202020220002022002020220002220020020202002202022200220020020002220022200020220002000002020020020020200200002222000020202220002</span></span><br><span class="line"><span class="number">222000000022202002200220222002202022202000202202220000222020202002022022000020002020022220200202202220000000022020222020000000200200002022022200000200222002220202220222002020200020022202002020002222002222020022022000200022000002000222020002202020202200020002000000000000020220220022220000220200002002</span></span><br><span class="line"><span class="number">222200000020222000000020000022202200220022020022220200000020020020022000020022222202022002202200000200022000002022220202020202000022200200002000000000200022002202002022220222000002220000020002022022000200222200020000020000022200222220200000002222200022202202220002002220202000202200220020222000222000</span></span><br><span class="line"><span class="number">020200022202022222222220220020202200200022200020202222202002202020202000022222002222202222000002200202022222000022022020220000000022222200002220000020022202202000022222202020000000220202220020200020002220202202020220222000002020202022202200220020000200000200222200000200022020200002200222022022002000</span></span><br><span class="line"><span class="number">022020202222002202200002202000200220200220220220000222022222200020220022200200220022022200202222202022002222202202202020202020002000002200200222000220022220220202000220222002200000022000000022022200202000002202000220020020000200022002020020200220020222002002202022002000220200000020020000222200200020</span></span><br><span class="line"><span class="number">202200002002022222020200222222020220222200022020022222022222202020222002000200020000220000222022222222220020220220220200202002202002000200220200020022002220222022202020200020020200202002220020000202220020002020222020200220022020202222202220202222020020200002200022002202020000222200022222000222200202</span></span><br><span class="line"><span class="number">022020202002002202002202022222200200022020002020022002222202202022202002222220020222000000000022222222020022000002002002202222002222002222222022220000222002020222022002222020000202202020020222220022020000220220022200002002222222002222002222202222220022202000222222022002200022020020022202000222002000</span></span><br><span class="line"><span class="number">220222000222000200022000202002220022222222200020022202222002000022200000222202202020002222222202200020220222020022202000002222202002222000200002222002022220202022220202000200200020202222220022022220022000020020002022002202202222220000200202002222200220020022000002222020200000200220202200020002200222</span></span><br><span class="line"><span class="number">022222220202222020220222002200000222002220200220000022002202020020200200220202222020202000222020022222020220222020220002220200200022002000022020200020020222222222022200022220000002202220200020202020002022022000002202222002202200222020222202220022200200000002202022222200220200200200220222000202020220</span></span><br><span class="line"><span class="number">202202200002002020000200202202202202022020222020202022000202000022000002202022002220000002202020220200220222022200002002002220200200020200002202020202000022002020000000222022220220022002222000222200222002220020000222222020220220222202220202000022000002202002220022000202022020202000000020022202202020</span></span><br><span class="line"><span class="number">220200222020222000222022200020200200020200022020202002002200200200020222000002220200200220200200002202222020020002002020020022220020222002202220222202002022000202020202020222200002220222002022022222222202022000222000020222000022222202220002220202220020220202002022002022220000200200200202220220002002</span></span><br><span class="line"><span class="number">202000000002222202020022000002220002220000022220200202200022022022020002002220002220200202002002220222020220000000220202222002002020202220000022020220222000000020002222000020002222222022022202222020002002022022002002202202000002022020200222022222020020200022220200222002002022022020202220020000022200</span></span><br><span class="line"><span class="number">200220020002200022020222222020022000220202000200202202020220000000002200220000200202020020202202200020222002202000202200002222022020002220002002002202002202202202202202022000222220200002022020220220000222222222222022222020222022020202002202202020202202002200020200222222000022200022222022220022002202</span></span><br><span class="line"><span class="number">220202022220000200022022222002002002020002000000002000220222222202022222202220200002222202202222202022002222022000022020222022222022222200020222220202002020022022202220202202000020000020020200202002222000020022220220020020002220220200220020022220002202002002020202222200220022002200020200220002200002</span></span><br><span class="line"><span class="number">020000222200200222220020222000220200200000022220000002000020000000222002222022220022202200020022022022222220000222200000222002220200022200220222202002020200220020000220002000222220202200020000020202022000200020200202202000020020020002002002220202200222020222202220222222222002020200220202000202020200</span></span><br><span class="line"><span class="number">202202200200222000222220222222202220000000200022202000020202222202020220200222220222222200002200000220000020200200222200202002022220000220022220222200002222020220222202220220002000000202202200202002222022022002020200202202000222200020200200000222020022002000220002002200002000200202022020222222022020</span></span><br><span class="line"><span class="number">220200022022022002022222022202202200002020022202022220002200020220020222020222222002222002202002000002022200022200022020020002020020002202220202022202000220022002222002020022002022200222202200220002200202222002220200222000222222022002020202022022000220202002000000200000202000220022222222220002200002</span></span><br><span class="line"><span class="number">200022000220222020222200000220220022222000220000022022202220222200020002202220020000022000220200020222220222202022000202220222200202000002220200202220022000200002202200200020000202000222020220222002200202202200200220222022220002202000200220000222022220202200220022200020002200002202000222200022200022</span></span><br><span class="line"><span class="number">220202000020000200202022020220000220200022022020022000222200200200200002000022002000000000222002020002000000220002002022200020022202020022022220002202000020020000202000200002222202002200200002020020002200200020220222000002002000202200202020202002020002220020200000220200200202200220022002222200002022</span></span><br><span class="line"><span class="number">000200020000020020200022002000022000000222202200020200200022022220222200022222220202022200200022000222200000022000222202200020202200222002002002220222002222222222000002002020222020222202202220202000202002020220002000002200222202000000022002200000200000000200020020202020220020202222200000020020222022</span></span><br><span class="line"><span class="number">022220220000022020220022000220002022020000002000220020202002202002200020020000020222220020020220000202200202022222222202022222020200020002220002222222022220000000200002022202222202022222020222220220220002200000022220200020022022020000220202002002002022222022000202020020022020020222220002020000220222</span></span><br><span class="line"><span class="number">220200200200020020002020002200022002020202022022020000200200020220202220200222222200222220000002022200000022002222000220020200020202000022002220220220022020220000002222022220022202000022220020200000220000020202020022200202202222022200000022220200002222200222222020222202020000222000002022200220222220</span></span><br><span class="line"><span class="number">202002022220202222000002222202020200000222000220002220000002022220220022200222000220200020202022002002022002202002200002220022002220222020002002200000200020000202220000000002222002000002000220202000000022222022202022020022000022022022200000022000022002222020000022020220020200220222000202020002200022</span></span><br><span class="line"><span class="number">200000222222220200000220222020022000200220200200000002220220020222022022200200202200220022000022002020022222002202022222220220222002200202220000200002202200222200202000200020220002222022002020000220022002000000022222000002020222020002202000000220200022200000000202000020000200000002202220022222222200</span></span><br><span class="line"><span class="number">202020020000220000022200002000022020020222222020002200200002222000022002020220200202000022220000200222000022022220000022020222000202202020020220022000200000200002202000220020202220022022020022200202002000202000202220022202220022202022002022202002202020220202220222220220000002220222020002220022202000</span></span><br><span class="line"><span class="number">200222002202200200000000202202200022222022202222222222002022202200222200222200200220200200000000022002200022220200002200002202202002022022000222200220000200000022222202000020220000022020200202222202022020020020222002220022200020020222200200202202222220202020020200222220002002000222222020022022020000</span></span><br><span class="line"><span class="number">200220000022002202222220202220002200002202222222020220000020002022202000202000220002220222022022022202002022200020200000222022202000222022222202200200000002202200222022022222220022200020022222000200220202000220022020222200000000022020022020200000220020220020222220002202022020022202220000202200022000</span></span><br><span class="line"><span class="number">220000202020022002020022200000222020002022222002000220202022202220002000020202020020220020022002002202022000002022222200220020020000022020002002222022200020200220002222220022222020200222202000202000002200200200202022000222200000020020220200020222020022022002222222002002200200202000000002000200002200</span></span><br><span class="line"><span class="number">002002200020002220202200020200002020220022202220020002222200020222200000202002000200202200020220220222020222202020220020222022220200202020220002222202202020220200202200020202202222022022000200000022000020022020202000202220022020020202022000222200020002202020202220002222202022200202222022000200202000</span></span><br><span class="line"><span class="number">000202020000000020002002000022020020202000022202020020022200202220200200002202020202200002020022200022200020200000002202000002220002000020000002200022222000020202000202002000002022222002202202200222022220022020020002220220222202200000022222222000202220200002202000020022000200220222020020002202002220</span></span><br><span class="line"><span class="number">222022202002020200000020022020200222020220220222202022202220002002000220222022200020222000002202220200022022022200222000002200020202022222200222002000020002022202002002000200220022000220000202020200202202000022200002202020200202222220202202020002020020220200220220020200202202202022200002000000200022</span></span><br><span class="line"><span class="number">220020200222222202220222002202020000000020002202222202022202220002222220202222022220002002022020022020222002202022020222202020200000002020202002002202220202022022200200222222222022202200220220000000020222222202200220000000020022222020222000000200220000200020200020202022002022222222202020200002002222</span></span><br><span class="line"><span class="number">200000222000000020000020200222220202020222222222022002222220200222002200000222000220222020000222200000222022220022020220020020000220220222202220020202222222002002022002000220200002002000220022002222200002002200000002202200022202202202022202000202200220000000220202220022220022202022222202202020202020</span></span><br><span class="line"><span class="number">022202200200000200220220020200202220020202202002220220220220200220020020200200202222002220220020022000022222200020002022002222002020020200222020202202020222022002020022020220222202220222220222000000202000000002220220000002020222022222220000200002000000000200020020020220002022022022202002020222020202</span></span><br><span class="line"><span class="number">000200002222202000202220000202220002000022020222202020222220202022222200020202002202000220020000020220222202220202020220222222200020022022002222202202022202022020000020222002202022202000000022022020202020002202022022022000000202202020022220222202020220202220020002222020202020002220202022020202022200</span></span><br><span class="line"><span class="number">000002222220202002200002222220002222002220222002000222000022202222000222022002002200200000222222202020020020022020202220220220222020022222200200000000020200022022000000200202200022222000202022000222200020222020002000222222222220200000200202020202220020000202002022000022020222022020220220020002202222</span></span><br><span class="line"><span class="number">220200000002202200000202022002000200002220002002222002200022202222020200220020220200220220200222202222022220020020020202222200022020002000222020020220002202000022020220000002202202202002002202222020222022220000002020002220022000202200002002200020020002020220020022202220200020222200000022222000020202</span></span><br><span class="line"><span class="number">020022200220202022200020202020002200020222220020202222222002200000220222222020200222222000220022202002020020222200220002020220002002220020220220200022020222200220222220202222200202002020002202220202200022200002222002002022200020222020200022000202222202220220222222000020000022000202202022002220020022</span></span><br><span class="line"><span class="number">222002002200000022020022200200000002220222200000220000202020002220000002202022022002000222020222220022020020200222222200202222020000200002222200202002202022000022022222020200220002202022000002200020202202022022000022200002000200020020202000202202002000020000222002000002000022020202020022020002022020</span></span><br><span class="line"><span class="number">000002022222200020202022020220202020002222202200002202000000200222222222002200202022220002000002000220000200020222220020200200020202200020200020200022202020200002000200222020020202022022020202222002020022222200002022000202222222000002002020200000020222022000022020222200200000200202200002000020200222</span></span><br><span class="line"><span class="number">222000220220002200200222200202000222022002022222020000020222000020220200022200220002020002020000200200202202220000202022220022022002200222002000222002200222220002200220022222000022202202220020020002222220220002200020002202220220020222200200200202202020000222220222200222202202200220220020220200002002</span></span><br><span class="line"><span class="number">002020202200000200220200222200222002020202022220200020020022222022222022200222020002200022020200222222022002002220200020202000200000020002202002202020202200202020000020002222202222220222202200002200202202002020002220222020022020222002222220220220000200220022202222222202200222202000022000200220020220</span></span><br><span class="line"><span class="number">002220020222200020002202000202200222202020222202022000220020022200022202222222022200222220000220222022020220222000020020022020200002222220220222020200020220220220220202022220200022220202022002020020200002202002000222220200222002020200200020220202222002022200200002020200002002222000000220022002222022</span></span><br><span class="line"><span class="number">200220000220200220220222002022002222020202222022202220022222220200020200200002202202000002220002220202202022220200202022222202022220202202002020020202002202020020222000202200000220222220002200200200200202220202202202200220000202202020202020220222202202202002002002220200200202022202020002002220022020</span></span><br><span class="line"><span class="number">222220220222202200222020000220002020220022022220000222000000202002022000002000200000220020020002000220220020002020222202020222000220222020202020002202200222220220020202020220022020222020002002022220220220000020220200002220002202202200020020000202000202222220002200002020002202020222200220222022020222</span></span><br><span class="line"><span class="number">222022200222002222002220222220002002000220000222222000200202000002022022200220220000002220220202222022022202002002222002020020200002020002202222202202020002022200222000000020222202222002222020220022000000220000220200000222002200000222202022020022202220202002202200222200002222222002022000220200000202</span></span><br><span class="line"><span class="number">022220222202200202000022022002200022200202020022002222020002202220020200020202020022200002202202220222022200022022222222200000002202002002022002222020222022022000002000002200022022022022202200002022002020222200022220002020200220220202020220020202200020020222002020022002220220220002220000222002002000</span></span><br><span class="line"><span class="number">020022002022222200002200200000020020222020002222220002202220022022200222022020020200022200222020022222002200002020222200020002222200220000220000002202000220022022202200220020200002020222202002202022022022002200020200020222022002200020220000020000202000202020002020202200002022000020200002002200020000</span></span><br><span class="line"><span class="number">200202220002022022222202022020022000200202222220000222222200002202202202020220022200220000200002222020000002000002202222220202002200200202202020202020022200000000200202002000000020000220002200220020222020022222222002220222002220020002220000020200200000200000222222002202022202002222000002222220022202</span></span><br><span class="line"><span class="number">202200200002202002202222222220220000200000220202000200220002222020200020220000202202022200200000200000200022020022000022020220002202000222202222000222022022022222220002020000200200002022020020200020020022220220000202202000200022000000000202222022222202022022002202222220000002200000222222220022220222</span></span><br><span class="line"><span class="number">002202202202222022222020022022022022220202020022000220222002020222000002000220002000200020200000222202200000220200220020020002000200002022002222200222202002000002200000220000020002000020202220020202222220202200200202022000020200222200020200002000222022222022200200002222000020000002202000022002022002</span></span><br><span class="line"><span class="number">200020222202000222202202002000002200002000220202220020020000002220022020222000200022000200220022000022000200220200022022200222202002022200202022020222020002222220222000000022022202022020000202000020202222020020202002200022020222020220222022202222000202202200002000222000202020022222200002220020000220</span></span><br><span class="line"><span class="number">222000202022222222220220020000220222222222220202220220220002020020020000002220020000002002000000000202020200200022000220200022220020002200002222200002200222022000000022222220220000200000002222222220200002220202000202222202202220000202220202000220002202002222022200202220002220000020002020220222202000</span></span><br><span class="line"><span class="number">022202020000022022202002002222000002002000220222020220002022020002022200002000202022000222020002000020222022202220200022022000002222202000222200020222222022222002000220222022020202020000222220200000200000022222020020000002022222002202000202220020000020222200202022222220202000020200200202200222222002</span></span><br><span class="line"><span class="number">000202220020200022022222220200202000222020200002022202220220220200222222222020000220220202000000222202222022200022220200222002202220002222022200022000200222020202222200200222200222000002002022220200022220002200022000020022022002002000022022002020220202000000200200022202200222002022000220220002020202</span></span><br><span class="line"><span class="number">222202220000022222022220002020002002000220002020222000202222022220020020220020002202200200022222222002222222022000022202000200200000002200202200202200022002202222220220220020200220220020200002220020220022002202022000002022020202022220022222202002220000222000020002202000020020000020002202020222202020</span></span><br><span class="line"><span class="number">022202020202200202222002200202000022220020220020020000022222220002200002022202202202200000020202200222022200020002022000000222220220200200022000020222000220202020022220220200020200220220202202222220220202220222022002202222022200020022000202200202002000020020022220000000220022202002000200020202202020</span></span><br><span class="line"><span class="number">002022002002022200000222020200220022222002200200202000002000020020000000000022222022200200200220002220022202200220202002022022202002222020200020022002202222220220200020022220222020220200000202200202200000220202020222000222022022022220222202220022022222200202022022202202202002020020222002222002022000</span></span><br><span class="line"><span class="number">022022020222022020000222002002022020200202220202202202222002222000000020022022022200202222220000002020220222202202220022200220002202020200000220200200000220222200200022200200202220200202222020002002022022202022220222002202002200022002022020202222022020022000002020222200002202222022222200200022002002</span></span><br><span class="line"><span class="number">222220202202220222222202202002002200222222000202022220220002020020220022022000200200222200200020202222022200000222220000002202002200002202222022220220200202000000022200020020000220020222200202222000200000000220202000020220200200002200202002200002220220020202002200022220022220222220202020022020002220</span></span><br><span class="line"><span class="number">200022020022220000000222200200222202202020220200222222020200002202020020022202002020022202220202222222002202220200202002022002200000200202020002020020202000020200200200222000220222202220222222220002220000020020202022000202222002220200200022202022222020220220202220002000020002022020222200222002002000</span></span><br><span class="line"><span class="number">202222202202200022202020002020020200020022000000220222222202020002022220002000020000002220022202200002222020220000002202202022000200020020220220002220200222022000022200000002202002020222002002222200022020200222020022002020000022000000200022220202022000020022000022002002020220222022222220002000202002</span></span><br><span class="line"><span class="number">220202222022222020020222220000220020200220220020020022200220022002202022022002202200202200022202202020000222002020020022002000022222202200022202020022220222000022202020200220000000222000200220000000002020022002202022020202002022202220022000200220222222002022200202022222220220222200222002000020220200</span></span><br><span class="line"><span class="number">020002000222022000220200222022020000202022002002200000222200020220202222022220202222202000220002202022020222220220022200200000002022000202020022222022000222000200000000022022000000002222220002000002222202020220000022200002222220222202202002000000022200020022222200202002220022220000220020222020002002</span></span><br><span class="line"><span class="number">220002202222000200002222202002000202020022022002020220220020222220020020020220200020020220022000002020000220002000202000000000022002022222200000022002020020222220220222022020200022222200200220200202220220222022222002020200000000022222200202000202200202022000220000002220002220002202022000202222220000</span></span><br><span class="line"><span class="number">222220022020202222220020002202222002222202202000002000222202020022202202022002200222000020220020200000202002220020200202220000020000022222000002222002222222020022020222002002222202000220220002220020202000022200000020020220200200202200000022202002020000020202022002202222200220020020020000220202022020</span></span><br><span class="line"><span class="number">000022220002220222002202022020000200200002202202202002020202200020222000200022222202200002220202220002200202022002222202220000202020022000022022200220020202022200222222222022220200202222022202220022222002002222220202220220000202222022200000002202200200200220002200000020022220000022020220020022222022</span></span><br><span class="line"><span class="number">220202222000200202002200220002200000222022202022000002000220202022020000202222002200002000200000222020222220222020220002200022222022000002222000200220202202022020022020222220022002200222202220022200020200222000222002000000020202000002020020202020220000202000200022020022200222002002202000202000220200</span></span><br><span class="line"><span class="number">222200222022222220202200002020000022222200202002002222200022002222020202022222220000220222022220002000002202202220000220220202022002200002200220000222220220002202220200002220020000020220020020000202002022022202220200202222222220002202020022022200020220020022220020002002220200022020022020202200022022</span></span><br><span class="line"><span class="number">020000202020000202200020202202220000000220000202002202220200002020220220220200000000020220222222220000220220020200022202222020220220002000002022202220202020220200000202000002200022000222200020000220022220000222202022002222020222022022222222200200002020002222200020022022222202200202220002022022020220</span></span><br><span class="line"><span class="number">200222220002222202000200202022200202202000022020002022002202220202220002200020002020222002220200002222200202022022222220000002222000222002022222220000020202220222002000022200000200222222222000222022020000202000200022002202000222200000202002202200022000002002000000020020220002020002020002222020000002</span></span><br><span class="line"><span class="number">202200020202020222020220002000200002002000020220020002020002222020002022200220022022020202200020002220020220202200202202002002220002000202222002000022020220202202022000222000000002020022022202022222202220002202022200200020220220222000202022202220220000020222002200020200200220000202002020002220222000</span></span><br><span class="line"><span class="number">022220002222020022020220200222202200220222022022022000002222020002002000002220200022000022200222002220022222020000220222000022000000020222000000222022222200200202202222000202022222022020000022020202002222022020022200020222022000222200220222000222002022222002022000022222020020222002220002002222000002</span></span><br><span class="line"><span class="number">222020022200000020002020002202202000022200200222222002020020200000200200200000020002200202022020002202020002220022202220202222220002220020222222020220022222000022002002220220200202202020002000020200022220002202220200220202022000200200000222022000220020220000002002200202222022002002000002002002220022</span></span><br><span class="line"><span class="number">202002202200002020220002220020202002202020002002000022202020222220200002202222000022200000002020000202020020220002020200220222200020020202200000222002202020000220202000020220022220222200202222000200022220020002002002222000020002222222002202200002222022002000000220222020022002000202220020200002202222</span></span><br><span class="line"><span class="number">220220002022000200022000022202002000202002020222220002200020220000022220022020022222220222020200200222020020022020022000000002000002202000202202002200202222222200022000020220200200222022020022022022022202222202022202222000000000222000202222020200002202222222002020220000202202020000000202022002202022</span></span><br><span class="line"><span class="number">002200020002200000202022202220000002222002000200202200202220000002022020000222020220020200000220222022020220200000000222220220000202220020002000220220000020022222220200222002000020022022020200220022222000000022202000000002002202002202202222200200200020022002000002222222002222000022202020020222020002</span></span><br><span class="line"><span class="number">020020020020200020222202020022020220022200222000220202020022020022220000202200220200000220222202202000020022022202222022020200220200222222220222022202002200200200202222020002020002022022020000200020000202202222202000220020202222000222220002002000022200222022000002200220022202022002222202002002200020</span></span><br><span class="line"><span class="number">202020002020222202000020220222022022222202200222002002202222000000202002022202202020220202020220022002022022002000222222220002002222222022020002000022022222222202220022202222002200202222222200020220000002020202220200022200002020222022202002020020020222022000002202000200022020020220002200022000202220</span></span><br><span class="line"><span class="number">022000000202000022222000202202220222020202020022220200000202202200022022022022000000022220220020222202220020022020222022222222220022022220020002022222202020020200202020020022000220200022202202200222000200020220200200002000202222200000220022002020202220200220220222002222200200220200220022022022000202</span></span><br><span class="line"><span class="number">200222020022002000002202202020022202000202022220000200020222020000222200000000000000022200002200220020022022022220020022000222022020222222222202000200202202222000002020222000222202022222002200022202200022022222022022200000220020222000202002022202020002220220000220000000002000022000200002220002022222</span></span><br><span class="line"><span class="number">020220202002000200222222200022002002020022200220022000200020222002022002002022000202002002202200202220200200022200220002222002022220022020022220202222200002222220222020220022200200220000020222222202220200202002020220222202202022002202002022222022222002202200000202022220222200220002200002020200222020</span></span><br><span class="line"><span class="number">200202002200000200022222220200222200020202002202022020022020222222222220000220220202200222020222200022002022022200222200022000002002020000220020002002022022020222200202020020020202220202222020202202222222200200022202222020022022202200020022220200000222002222200002002022200200022220020000002222022222</span></span><br><span class="line"><span class="number">220200022020000220022220220000002022222222000020202220020022020020222020000002020002022200202202200220020202222200000002200020200000022022222200200200220002222022222022200022020200220222000000020202022200220002002000002222220202220200020002000220200222220202200022202020020020022000020022022220220202</span></span><br><span class="line"><span class="number">000202022222020002002200020020020002220200202022020202202200222222220022200000002020200200002220020002022020200022222020202000220020202022220020222022222000022220002000020202220202202220222022020200000202022200022222002022020020002002202020002000220002000020202022022200202002220000000200222022000202</span></span><br><span class="line"><span class="number">220220202200000002022022002002020000000200220002220022220220200002222200202000000220200202002022020220222022220020222222200200220200202200002220202200020022220022200022200200022222022022022222022000200022202222220202020200022202200000202202200020200000202222220200202202220002022200222220200002220020</span></span><br><span class="line"><span class="number">202020222222220000022222200002200200002200202000200200200020220002000220202202022200200002020022000200020002002000020220220000000222020222022222022222020022022020222020222020020022202022220220020202222202022222002020202000000020202002220000002200002202200220002002020020222202002020020020222022002202</span></span><br><span class="line"><span class="number">022002202202022220002002222202000200202220202000220000000222020200222220022002202002020002200202000202200000000022200000222022022222002222020222000220022222200222200020200002202022200220000022000200200002200200002222202020000002220220022000002002002200222000000220202022020220022200220000000022022222</span></span><br><span class="line"><span class="number">022002022202220220000200222222200220002202220020222020202200002000022020020002020020000202020020002002220200002000202020020222002002022022000000022200002202200200200220220220202022022002002202202002220200000202022000000022022000002220222200002222220020220220002222202002022000020200200220200000200002</span></span><br><span class="line"><span class="number">000222202020020022222002222022200000200220020222020222222022220022220220002200200222022222000002022002220020020000020200222222202200002222202200022020222022222002202020022000000022000202020020000022222222020020220220000022220222220002022000022020222002002000220202020202020220200022000200220200200222</span></span><br><span class="line"><span class="number">202200222200220000020022000202222200002220022222022022002022002220200002222002002002222220022202220020222020202220020022000220000220020002002222222020022000002000022020202200220020220220200220020222220202000020020200200202222202200022222002020020202202200220002200000222002222200002002000200200020202</span></span><br><span class="line"><span class="number">000020200200222220200022202222202200202202020000002202020002202222220002222000200200020000222020202000220202220000222220020002022000000020020020022222200222020202202222022020202000020000022220020222200022222002002200202200020020002222002020200022220200202020222002022022222202222000220002220220200220</span></span><br><span class="line"><span class="number">002000022222220020022222202222022202202002002200202222002022000020222222200002002022022222020020022002200022022220222222222002000020202002002220222002022000022002022020222022202200022220200002222222020000022022000000220020002022220000020020002202202002002022222220222000022000202020220000022002002020</span></span><br><span class="line"><span class="number">200202202000022222020222200022220022220022022020200000200202202022222002020022000202200200022200022022220002000200022020020020000002202200020220200222020202022202000020222000022020022222020000202022022220222200020202022002200022200202200202020222022020200022200222022000200222020000000000002200002220</span></span><br><span class="line"><span class="number">222220000020020022020222002022002222002200020202020200022200020220222200000220002000022200200222002002000000000000022002222022020220002002222220220220200202200222000022020002020220222020000220022200000020022022020000000200222200202000000202022002022020000200200220022002020200022002202202200000000020</span></span><br><span class="line"><span class="number">222002222000220202002022220200200220222000000220202220222002022022022220202202020220202220000022222202200020002000000222020222202022222202022020002022222022000220002222022222000202020002202222220200020200020020200002020020200020200222202200022020202020222022002222022222022000020200002202200002002222</span></span><br><span class="line"><span class="number">222222000222022200222222200222222022200220202020022222202022202020002022000202200222200002222002222202000200222020200220202200002202220220022222202220002222002020220202220022002020002200200220202022202002200202020020002022222200220002220222022200000200200020002200202222200202002022222200020200202202</span></span><br><span class="line"><span class="number">022002222202002220202020002200200220220202200220002022200202022000220200222020022222000020200202002222000200202020000202222220000220222000202220022000222002222022022202000200200020222222002222002022002220002022220002002000200020200002200020200020020200000202022022220022000022022000200000020220000202</span></span><br><span class="line"><span class="number">220022222222200220200200222200002222200000222200220222002000022222022200200222002222000020200022000222000002000022002222222022022022200222222000020222220022000000020000020202222200222220202222000020200220222202202222222222020202202202022002020200220020220202002202220222022000220022002220022222202222</span></span><br><span class="line"><span class="number">200000000002002200220222222202220022002020200020000000000200222220220202220002200220002222022220000202222202000022000202002020000002000200222222202202220220200002002222022222222000002020222022000202200000202220220202000022002202000020020022002200020202222002222200200202222220000020222000200000022020</span></span><br><span class="line"><span class="number">022000022202020222020022022020202202020000220220222202022020000020220020022202022022022222022000000200002000020202202022202000022022202220220022200202200200202000020000220220022202200220202220200022020022002000220022020202000000222202202002022000022200000000200000022022020000002000002002200220222020</span></span><br><span class="line"><span class="number">202220000002200002020200220020222020022020200202020202000200222000222020002022022022022220200220202200022222022220000000022002000222220002002000002200220022022202020200020220220000020000222002220020202222200220200020002220220202202020020022200200202002000000022000000200000020222200202002220202202000</span></span><br><span class="line"><span class="number">200000020020200220020022020200000000202202222022200220200222020200002202202022020200222022200200020002202200222202002020220022022222222220220000222002200200220022202220022020200020020222000002000220202020022000022200200202222020202222002220222220200022220022002000022220020222020020222222020200020022</span></span><br><span class="line"><span class="number">200000000020220022000020222202222202220000022222000002222202222200020200220220022020002002222222220020000220202202220020020220202022220222020220022002202200000202202002002220002020200022200022000022220202220000200200020022020200002002000202020022220222022220022202202020202202200222000202002002022002</span></span><br><span class="line"><span class="number">222002002222200002002222202020220000220020202020220020020202000202022000002202222020220002000202022222220202222000022200200200222022202002000002200022202002002222020222200220222000022202020020200022222020220202222000222220200020022022202020220020000222222002220200020222022022022220000200022220000220</span></span><br><span class="line"><span class="number">022200000002002200222202002222002222222022020020000020020202022202022020202200002220202222200220020000220220202202000002000202220222222000222022202200200000220202022022202200200000020022202200200202202222222202220202200202220020000020022200002222220222202220220222020022000222002200022002200220202200</span></span><br><span class="line"><span class="number">202220002022220002200202022000022000020220202020220222022200200022202022000002022022222020222220220022022200002000000222222220222002200022222002220220022222020200202002000020022022002200220222222002002020002200220000002222002022020022002220222000220020222002200000020222020002002002020220200220022022</span></span><br><span class="line"><span class="number">202002022000222202200200222022222020002000220202222000222202002020020202220222222020020020022202000022222022220202200020000000022202200222202200202220002002022202022222220002002022220220000020020200222022022022222002000002000220202200002202222000020020200002220222222202002020020020022220200022202222</span></span><br><span class="line"><span class="number">000000220202202022220220222020022022220222020002000220202000220000002020202222020002200200222022022202022000222002002200000000022002022000202020222022200020200200202220000020002220202020000022022222022022222220000022202200202022020200200222002222000022000000200022002020000002220220220022022222000020</span></span><br><span class="line"><span class="number">200200220022202222202020200000220222000000222020220022002022222220000000202022002002202202200202222200000002220202220020220222020002200020022222000222200022202022022002002220020222000020220000000002020022202220002222220022002200222220202222200002222202202220022200002020020202202200220022002000220220</span></span><br><span class="line"><span class="number">200002020022020202220222200222000202020022202022002222022222002020020202022022002220000200200000220202222200000000200000200002220022220200220222020022222200022202220202200220002002022200020000000020000022222022200002022020002220020200020202202020020020002002000002000020020002000022002000200200222020</span></span><br><span class="line"><span class="number">202222202002000222002220220220202202002220020220202022200220002222202020200220222222202220002200200202202000200200020020000222000002222000222200202202020220022222220202200202200202220200202000222000000200002000200220222020222222002222220022022222022222020222002000202022020222022202222020202020200002</span></span><br><span class="line"><span class="number">220200222000020020220200202202222222202020002202022222222000222200000202220022002020020000000002002002002220020002222220200220002000022002220000002020200002222000220220220020220200020200222000002200220200022000020000222202000020220000200202222020220200002220220000200200220000020200222220222022200200</span></span><br><span class="line"><span class="number">002022000222200200000220202002000202022222000222020022002222202222002022220202200000202222220220002002220002200200220000202002002220222220020202222222200202200020200220000200000200220020022202200220202020220220220002200020200002000020222020000222222220022000220022200222220220202220002002202202022022</span></span><br><span class="line"><span class="number">000202200020222022200220222222002222200002020202000200022202002220022200000220220220020222000222022200022222220002000222222022020220002200200020200020220220200200200020000202022000202020222000200020022200202022002220000002222222000220202200020202200000022222200200222200000002000022220202002020000202</span></span><br><span class="line"><span class="number">220000220202020022000000220000022222200200000022200220220220000020202202202020022200000200222020200022020000022020002022002022200220222220200022022000002220220002000200200220222022200222200222002222022220222002202002200202022022020020002022000000020000202222220000022022202220200000020000202220022202</span></span><br><span class="line"><span class="number">200002022002000200022220002200002202000222220202020202220222200000202002222020202200222222002200020002022202022222020202022022000200020220222002020202220000002220222020222220222022000022002020022200222200200220000222022002002222002020002020022220220022202000222020222022202202200222222202202002222020</span></span><br><span class="line"><span class="number">020020222200002022200220200000022020002002020220222222002202220220022200000220000202222220222022222000000002220022222202202200202222020222222022000002220020020220020020202002020022020220020002022002200222202200222200020022202002200002220020000202202220220200200202222222020200022020222000002020202200</span></span><br><span class="line"><span class="number">000222020222202002000000222002022000000022000202020200022002020002020000200022220200220020002200222020200022002220200002022020020220000220002022202222020220022022020220222220002000222200220022202020000002202002222000200200002000020020202020020220202202222200202220222200002200220222220202002222220022</span></span><br><span class="line"><span class="number">200202220222220020202022200200200000022220000220022000022220022200000022200222000002000020022020020020200000022200200222002202000220200000000220020202220200000200220000220202202020220222202220202222222022022202220000202022000222220002220220200220222020200002220022000000202000222202020222000020002020</span></span><br><span class="line"><span class="number">200020020200020002220002222220222020202000022020002202200020002002000220022222002022200022200222222022000022002222200222022222222000000202200000222022000020002202022020000220020200220202020020022222002202222200222202000022220022220000200000000222022220022202220020220202222022000002000022000200222020</span></span><br><span class="line"><span class="number">220020022002202022220202222022022202000000000200000020222020202222202020200020022022022022200022000020202202000220222002200202222022202222022222200202022200022202002200000202002020222000222020220002002200200202022022000220202222222200220002202000020000200022220000200220220200020220000220000200222220</span></span><br><span class="line"><span class="number">020022020200222002200220220220002220200020202202222220200220220022002022202000020200220220220020222202020000200002220000222222220220220222220222022002222020000002200022020222202220200222220020222020202222200022222202002000200022200002002202002002202200000000202020020220022000202220020202200022000202</span></span><br><span class="line"><span class="number">002020002000022022200202002202002020022222200000200002202220000202002202220202000002000000220002000220222022222202220000002020220200000200222022002002220020220202022200222022220200202000020222220220000022022222000000220020020222020002220220020202020220002220002202002000202222202020200220002200020220</span></span><br><span class="line"><span class="number">200020220220002200000200022220202022220220000200020002000022022022022222020202002200202200002022022002022020202000000220222020200202222220002220022020022000222022000020020200222000002222022000022000000020002222020022022002200220222000222020222000000020020200220202222220020020000200200022000000222220</span></span><br><span class="line"><span class="number">002222022020222222220000202020220200002000002202200202200200000220202020222020022000020020020000022002200202002022020022220002220200222202000002000000022222220000020002020000222200022022022220002020022000200200220022022002222200002200022000022000222200220022002000200000200022022000202200002220200022</span></span><br><span class="line"><span class="number">202002220020020222000020220002022022202222200002220200020222020220000000000000202022002202202200220222020202222220220022202022022220022220202200020220200022020222220000220020200222000200200202200000022200000022002022002222022200220000220222002220220200222022220222022002202202222202202200202022020220</span></span><br><span class="line"><span class="number">002022022000000000002200020220222220200222000020202002000000202000202202022002000220200202222220020200022000020202202220002002002002222020200022200200202200022222202020220002220022020200000200202202022202202202000020220202200222002222220222222020022220220222000202022000000200022200200200000022222022</span></span><br><span class="line"><span class="number">222222222000220022200220002002002020200002002002222000202220000022022220220200202222002202000220000220222000220222000000200200202220022220022002200020000020220002022222000002222020022020200222200202222222022020022222220022220002020002222022222220202222220222002002220202222002222202022000022000220200</span></span><br><span class="line"><span class="number">202220200022022220022020020222220202222202020202220200002220220000000022200002020202202200022202020220222202220020202002000022020202222002020202222220222020220002000020000222000020000020002202222022000220200200200002022200220022000220220022202020020000002200220220002020202002000022002000022202002220</span></span><br><span class="line"><span class="number">220200000002202002200222000002200222002002000200020000002222000220022000022200222020200222200200220022220202200202220022202020200202200000222000022200220022200020220202000200222022222002200000222022220222222222202002022000020002000200202220202002002200202002020020000020200202002020222000002222020200</span></span><br><span class="line"><span class="number">202020002222000000002220220020002000222220222020020200020220020000020002000200022020222222020022220200220200200002202222002022000200022002200020020020002202200202002002202200200000220020022220022220020020202200020200222200200220220222220200020000022020200220200200022202002200000002220220022000200000</span></span><br><span class="line"><span class="number">022000002220222022202020002000200002020222220220002020022002220200222020020022022022220020202022020220022222200202002220020002220220000222022002020020202220000000220022220002000222002002222200222220200222220220002202220220200022222202220022202022020002200002200022222222202000002200020020202002220220</span></span><br><span class="line"><span class="number">202000220002202220002200020002002022002020200020022020022000000020202020000202020202022000000020000200222000220020022000220002022000022000220022000022000200022200222222002200220220022200220000000202002220220022200020002000200220002000020222020202202002022000020000020200202220222220220020220002222222</span></span><br><span class="line"><span class="number">222220002020020002200200020000200020222220200022202220002002000202022022000022200202000202200222200202020022202000020200022202222222222222000220222002002022000220000200022000222002220002222000022002220202202022222200000000220000002202000222000000222222200200220002222002220002020020202202222002022220</span></span><br><span class="line"><span class="number">002002222000200220200220220000220002222222200202202220220020200002202022002200200000002000202000222020020220020220202222020002200000020222002202020202000202220200200222022020020020220002202022200202000200200002222022220200020022222000220222022020020002222002222200000002220022000022202222200200200220</span></span><br><span class="line"><span class="number">020020220022202200220000222022002222020020202200222220222222022022020200002022202020000222200202202202220222022002200202022200222000022002202202000022220220000200020020022000000202222020000022220222000000202220200200000220000200000200222202020020200020000202022222000022202200202022002002220020200222</span></span><br><span class="line"><span class="number">000220220022002020020022222200020200222000000022020200022220000000202220222222202220202220200200200000220222200022200200000000002200002022202202020200222022020220020220020222202000202020000000220202000200202020000202222022200002222202202200222000002020002220020200020002022022220022002200000022200022</span></span><br><span class="line"><span class="number">202022020000020200202002220220000200020022222020220022022200200220002000202022002202022202200022022202002202000000200000022002002222000220200222022020222222022000220220020020200220020002002000202000000002220220220200000020020222222200200022200220202020002022020202222022002002202200020020020220022220</span></span><br><span class="line"><span class="number">222022200020022202222220222220222020020220202202002200000020000020022222022000200222002020020200022202022000022220020022222202220220020022022022022020000222220000220220000000222002200022002220202022202000022020220200020222002220222022002020000222020020222220220000002222002022220200000220222220022220</span></span><br><span class="line"><span class="number">200222000222202022200220202022000220022220022002022222200220202022002002202000200220022022002000000020200200000020220222200022222222020022202000000200000022002002202202200222020020022222002220202022020202222022002022200222200022020220020222022220020200022222202000200222020000220000000200022002200200</span></span><br><span class="line"><span class="number">000222020202002020022000002000002000022000002220222200220200022022220022000002000220200002002002202022222222002202200020220000200200202020002202220000020222020022022200022220222022000020222022000000020202220020222020000222202222222022220202022020200202220220222002220200022202002202000000220202220202</span></span><br><span class="line"><span class="number">000000202200202200002000022002002202202022000022022002220002220022002200022022022220020020022000222022022002020022000000220200220022220020220202202222222200002000000200020202002000202200220000002022002220020000222022002222202022022020222222200202200000020220000222022202220000202022222020000202222022</span></span><br><span class="line"><span class="number">222200000202220202222002022002202220000222000222000220002022002020200200202222000022020202020200200202022202220200002202200000022200020220002202202222222000222002022020002002000222200002000000200220022020000220022022220022002002022202022000202222022022022222200202002200202000222002222020222200000200</span></span><br><span class="line"><span class="number">020220202022200002202002020202222220022022220000222202220222202000002200002200020020202200202200002200002020002020200020220220202220200022220020000000200000000200022202002220020022022202220020000222020200000002000020202200202200002000222002222022202202020020020020200020202202020222222220222222200222</span></span><br><span class="line"><span class="number">222022002202002202020020202220222200222202222200022022022220000220000220002202002020222020002202000220200020200022000000220202022202000022220002020202022022200022000000002222000200002000020020202222202202022022002020000222202002020202200020000222202020020220220022000200020020222222220220000020020220</span></span><br><span class="line"><span class="number">202200220000220202002020022000202002002000000002222000020222220020000220002220002222002020220002202220202000022222020002222222000022020022202220220200222020220020220202020020002202220222202200002000022222222022202220200022220222020222202002002022222200202022000002202002200002022000200002022020200022</span></span><br><span class="line"><span class="number">202020020020020222220002002200200200022200220200222220222202202200000222200020222000020200220202020220022002022022020020020202200222022222222220202220202220220222002020020200220002022020220022020220220222202020220020002202002002222202000220000022222020220200202022020022000002202222200020020002022220</span></span><br><span class="line"><span class="number">222200222202202222200200202202002200000200202022202220202220202202202020220222022220022202200200020200020022022220002002000000002200220200002200020200200222202002222222020202202022002020202220022000020020022202020002202002220220202020220200002200002222200222002202222202000220202002200022200002022202</span></span><br><span class="line"><span class="number">220202020000022202220020202202000222200222200002002020020220002220022002020220002202222200222000202222000000202222200202000000220200022202000002022220200000000222220022200020020202222220200020200200000000202022000022002220220022002220222020222200222200202222002002002200200202022020200000022200220202</span></span><br><span class="line"><span class="number">002200022020222020200000200002022020202002002202222002002002220000200022000000022220200020022222020000022220002222022222200202202222022222020202202000200002020200000202200022222002020022002202002002200222200022202020022022002202222202202022202222200202220200000002002022000000222220200002000000222022</span></span><br><span class="line"><span class="number">000022000002000020222200200022202202200220220222020000022022222020200220022220000222220000200000022220222220200220022000002000220002020020022202202222222020000002220000200020000222200002022020200002200220220222200222002020020022000002222022020202000220000022202200022002222222000002002022220022222222</span></span><br><span class="line"><span class="number">200020022220202220202222202222220220222002200000202020000022220220002002202022222200222202202220000202200022022202000222022222020220222022020002222020022002022020200222020202000002000220020020202002002222002200220000202020002022200222022002220200000000220202200020202200020220220000202222020002020002</span></span><br><span class="line"><span class="number">202220222020202200002222220200002020222202020000200000000000202220202022202000000222202000000222202222202000000022200000200202200220002022202002200220222000022222002200200020002222202002000202000220000222022020002020000000222022022022022202022020202202002022020002000020202020222220220200222202002002</span></span><br><span class="line"><span class="number">000002222222020002200000222220222220002202020022002020022020202222020220002020000002020222200220000202022002220002022202022202200202000002220020200222000020222200022020020022220200222200202200020022202022222000002220200002020000022222202020222002002022022202200000222020200000220222002222200200000022</span></span><br><span class="line"><span class="number">200022020000022020202220022022200002000202020202020220002220200022002222000022002000022202220200000022000002022220202220020000220200000202020220222200022220000202220002222000202222200222202222022002020002000020020200222200202022220200020000000022220200220202222000022002202022002222220202202020200020</span></span><br><span class="line"><span class="number">220220222000002220022000202202220022020000220000000022000200222200020020200002022202222222200222022022202220020002222002022022000222220022020000220000200202220200220202020020000222220202022000022200000020022000002200220222000020220220200222002200202000000022202000000220022000000200020022000020200002</span></span><br><span class="line"><span class="number">222220022022200202200200022222020022020200002022220220202220022222002202200002002022220200200202000222000020222220202200202220202220220020022002020000222202020200222020222002200200022022000200022220020002222220220220022020222200202002022022222020220200022220022200222202222020202020220020002220220020</span></span><br><span class="line"><span class="number">002020022220220220022202200000020222200202000002220022202202022020220022022202022002000220020220020000220200200202222002020000020022022002202202220222222002200022002002220202202022000222220002202222020200200002222220002220022022222222222000000002000200200202020022222022000000020200202022000020202220</span></span><br><span class="line"><span class="number">220222000222220020220002022022002000220202200002000022002220200000002000202220202020222022002020222000200222022202202220220220022202002020222220000200000000222202200002000200220200002000222202220202220200202002200002200220202202220202020200002000202020222202200200200222222022202200022022022022220002</span></span><br><span class="line"><span class="number">020002000000022020220200222222200222000220002000222022222022022202000222200222200020202220200220222202220200020222000000202202202220002022202000000000022002002002202202222020020222202022202202222000022002220202020200220200002222222220222200000000002022222020222022220220222222222220022200200222202202</span></span><br><span class="line"><span class="number">002022202220222022202020220020202200202000002022220222022020222000200022202022220002222200000020020202200000222020202000202022220220022220220022020222222000222222222000202222222222222020220002200220222000200220022020202200220222200020220220200002222200022020002020220200020220202002002000202200020220</span></span><br><span class="line"><span class="number">002200022200202002002022200002202200222200002202202220020022220020022202022200000020020000222020202002020002022022200202202020020220022222222022022000200200022002222222022222022022200002000220000020202002002200222020022022002000022002002202200220020002220220220020220222200200222000222000220020000000</span></span><br><span class="line"><span class="number">202202220000020222220222222220022022020222000222200202022200002202222202022000220202022000202200022022200222222220000222000002222002222000000022022202020222020020002220022002200202020222000222222022202020202222022020222222022020222000220200022020202222220222220022220020000022002020220202020000000220</span></span><br><span class="line"><span class="number">022220002200020022022200222200202002022022202002200002200200002022000200000202220000022000202202022020222020020220200022200202000020002022200200220202222200202002200020000002022200202020000200222220202000000020002002202000222020022022002000202222022202020020222002000002000200020020000002000022000222</span></span><br><span class="line"><span class="number">020220020020020022220022202000220000200200002020000022002000220000020200022002002220022000220020020220022002022222000200000020022000222202220002220202000200020002020022020002002222222222202022220002002220222020002222200020222200022022022022002200202022022222202000022022202200200002000220220222000200</span></span><br><span class="line"><span class="number">022222002002220000220020202022000200022002200020000222020022200000022222222222222202000222200022202220002022202002200020022200202002022000022022220002202020000000202020222220222220020020002220200202002222000222200022202222002000000200222000020020200020202220220222220200020202020002220222002200022020</span></span><br><span class="line"><span class="number">002222000202020000220020020202220202020222220220002220222222000002220000220022200020020220220200000000200022002020220202000020222020000202002020022022200220020202200200200220222002000002000200022002002200002220220020002220200002002002002202200022202022222000000202020222202022000202202200020222002220</span></span><br><span class="line"><span class="number">022202220202002200222002000020222022220222022222002002000202000222020000000020200222222220002202022020022202022002002220020022002020220220220020222220002020002222202202220022200220220022020022002200222002202222200002202022022220002002220020220020202200000200002222022202202200022202202200020020220000</span></span><br><span class="line"><span class="number">000002222002002200020022222222022220022222000202020202022000020202022220220222020022202222022022202202000020200002002222200000000220000222002022202222020000020000022020000000220202000000020220000200222000020020020002202022222202022022220202002202002222220020002202200222000220220222002220020000222202</span></span><br><span class="line"><span class="number">222002022022002202200022022200220202202220022002020222202020222022000022000202202202202200020022222022020000222002022022022000222220000000222002020200222022002222020220000222200202200022020002000202002002200002000202200002002002020000020220002202200222220000222222200220220000000022020002020002202000</span></span><br><span class="line"><span class="number">020202220002000200002220220002000000020202002220022000022200222002020020222202200020000220002202022002220202000002022222222200002220022022022020222220220022200002002002200222200200222220002220200202202220022222220020022200020020002220202000222022002202200202002222020000202220200020202202020020022000</span></span><br><span class="line"><span class="number">202022200222202000002220222002020020002200000000020202220000022000002220022000000022202020200020002200222022220222220020222202002022002200002022000000200000200220222220220002200220000200002000002002200200000220000000020200022222002020002202200022222200000222022022000020202220000220220222022002002220</span></span><br><span class="line"><span class="number">000000222200002202202022202002202000002002002000002220002202220220200220002000222202020222220222222222200202220200222222222002022220220020020220220220220202020200202020020002222020020022002222002000202022020022022002002222202202002200200000220202200200022220002000020020020202002200022220220200200202</span></span><br><span class="line"><span class="number">000022200222002222222202002022022020002200002220000222020020222022202022222222022020022020200220020222220002202222222222222202002020222222220020022202020222220220000000022002002002022222022200020220022020020220200000202022022220002202000022022202200022000220202022220022222022002022222022022022200020</span></span><br><span class="line"><span class="number">002222202000220202000022200220222200002202200020022202202200000020000222020222202000200000202000222000020020222020000222220002202000222000220022022200200022222002200002000202202220220000022200220202222020000002022000220022220002200202022200222220220220222200222000202000222022022000220222020222202220</span></span><br><span class="line"><span class="number">020222020000202020200220002020002222200200000222002200020022220220220220202202220002200200000000220022002222200222200222220020020200022022022020022222202220000200020202020002020000222202220020000220000022202220022200220202002202000000020222022200200002022022220200000220020222020220200002220222022020</span></span><br><span class="line"><span class="number">220020002222002220220202002000202020020202020202020000002022202020022020022022020002202020022220202022220020020022000002200202200000202202020220220000020200222222222200200000200202000200022200220200220022000002222202220220202002020222020022222222002002200020020222022202022200020002022220222020200200</span></span><br><span class="line"><span class="number">002202202020002000020220022002020020002220222000200022022200200202000220000022002202222200002002000020222200002000200000202000020000002220202220220002220222002022022222000222202000202222002020002222202202000202002200220020020222002220022222002002222220000020000022020020000202020002200200202220220002</span></span><br><span class="line"><span class="number">002020222222020020222202002202222200020220200222022200002200202200222200200202220202022200220200020000220202022200020220022220200220222222000220000020220002220002220220002022220222202202002000202220222022200222222222200220220222002022000020020202220020022220222000220020220200020222000222200002222220</span></span><br><span class="line"><span class="number">220020020220000200202202020002020202220020020200202022220220200220220000202002222200200222022220222202200020200222200020220000220000202220020002222222020222020000022220200220220202220022220220022000202200002022020020222020202022022002020200022002002022020202220202020002200220202200022000000020002220</span></span><br><span class="line"><span class="number">020002200000000220222222000200022222022020002220020222022202000002202222002002022220202202022220222000222000002220020220002002202220200222222020020002200022000220202000000222022000000020022200200202220200200200002000202202000000222222222202020022220222200200202002002220000002222200202200022202200020</span></span><br><span class="line"><span class="number">200202020002220220022222222002200222200200002022222020000020022020200002002000220000220002220000000220002020002022202020002022020220200220002002020000200200000200222202002202022020222220002000020222222022022202222022022220002202200220220022020202202002202220220020202000202002000202222020202222000222</span></span><br><span class="line"><span class="number">022220002222222200200200220002022222022220002000202002002020222000222222002002000220002020220022002202022220020000022022202000002002200020000002020020000022220020200020220220020220002022220222002000202220202200202020000020202000000220000202202020020002220020022000000022000202200000002002200020202022</span></span><br><span class="line"><span class="number">022000020002000022200000002020202220022200022200002202002222220202020202200000222222022022002222020200200200222020002022220222220200220202200200022202222022022002020000200200200002222220002202000022220022002002222222222002220000222202022222222000002200022220202220222220202020000220022022222222020022</span></span><br><span class="line"><span class="number">222022002220022200000200200202000220020000002222000020000022220202220022222220222020202022200022020000220200022002000202220222220002200202022000022200022022202222222000020202000000000220222202022222200202002202020200220220202220022000000200002200020200000002020200200200202020022220220220000222222000</span></span><br><span class="line"><span class="number">202202222022220200222022022200002200200022000002200022200222020220022200202202202200020200200220000020200000202220022020002220020200222022002200000020200002220202000000002200200002020002200022220220220022222202220202222200022020022202222220220022002000022020020202022020222222220000000000002022000020</span></span><br><span class="line"><span class="number">202022020200022202000000020220000222022202200220202020020002002002220220222200000222002022022022200022002222020220000020002022022000020002200020202000222022220222220202002222220020002222200220202002002202002220002222202002202220002000000200220202020222222202000020000020220222220002020020220200020200</span></span><br><span class="line"><span class="number">220220002022220000220222022002002222200200002020002202200200002200200222220202000202002200022220022020222020002202000020022000000200220000220000022220200220000020000200022222020022200020202002202222020020002202022222022220202222022022222202022002000020002202020022002002200020002022000002020002020202</span></span><br><span class="line"><span class="number">020202200022200220000220022220220202202202002220200022202200220220220220200200020020200022222022000202000220200002220222202000022020220002000220020222220000220000022022220000202000222202220020020222002222000000022220020220200022002002200200220022222022022200202222020222220200220200202220202202002222</span></span><br><span class="line"><span class="number">202200222020220202002020200020020022000220220002002022200000002020020020220002000022020222020020002220002200020020020200020200022002000020220202200202022022222200022022222022202020220000022220022020222000020220220202200022220022200220022220000220222020022000222022222022022002002020200020202002020022</span></span><br><span class="line"><span class="number">202000000220000200200022222022222000002200200000002220220222000022222222022020002020220202200222020002002202000200200220202002022020002202000000202020000022002220022002202200002022202000022220222202222202022020000200200222202220022020200222202220020220200020202000200200000222202222020000022002020200</span></span><br><span class="line"><span class="number">002022020222222202222020000002000220000000202200022202022202000000022002020022002002000220222002000222002000022020000220222222000202220002202200202000220000220020000022000200222020222222222000020200002222020000000200200200000022202222020000202220000200202222222002202000200022022002222000200022220222</span></span><br><span class="line"><span class="number">022000220020002000002222200202222222202000222020002000022200002200020222200022222022200020002020000202020000222020200222000022200222022022200020000020220000220000200022022200022220002220220222020200000020202022002220222002002220020002220002202202202200002002200222002220222000220000200000220200202200</span></span><br><span class="line"><span class="number">000022200000200220222200220000002002020020220220002222220002220020022020200222222222220202202202000220022002220222200002222220022000022200202222022200200222222020002002002220002202022220002022222022222022022220022000022200202220000000202022002022202002222020002202022202022202200222222220202200022222</span></span><br><span class="line"><span class="number">002222220220002020022220220202020200002002220020220022022002000202202002200202002020200000200022222222022022220000002200022002020200000220222022200020002202020220002200202220220002020000002020000020022020000200022202000002200202022200200200000022200220022002020020202022200000000002222020222002020222</span></span><br><span class="line"><span class="number">022022020220000202200220202020200200002000002000000020200220222002222220222000002200002222022200222222002222200020220020000200222222000020022000220000002220200000202002020220200220000202220222202222000200200000222222220022222002020002020022020000020000200222222020202220022200220220002200222202022002</span></span><br><span class="line"><span class="number">020200000220002000022200002020000222200200220200000200000002002020200202000202222002222200020220000202222202220020222220202222000222022202022202002000000020020022222200202002000022220222220020000020200020220020222022202200202002202002002002222202222222202222202002022020000200002222002000200000002202</span></span><br><span class="line"><span class="number">200020020200000200000220200022202020202220220020222200020202022022022202020202002200220002000200022222220022220000200000220222000002200020202022200002000020200222220002222220202202000200202220222022022200200000200020200000002000220200000020222022220220200222000200002222000222020200200202200202220222</span></span><br><span class="line"><span class="number">002200202002200202202222222002020220020000000202200000222200220000000000022200022000220202020222022022220220220202200020200222222022020020000002222202002222200000202020200220200200002020002022222002020000202222200202200002222200200000222200202022000202022220200002002220222202200002202220200222020002</span></span><br><span class="line"><span class="number">020222002000000202222220020000000000022002022002020202202002002200222200020222222002200000022000222200200222202000200000202022002222020220002222020000000002022220202000202202222200002222200022002000000002222200222222220000220200020020220202022020022222222002002200200002002200000002202220222200222000</span></span><br><span class="line"><span class="number">000000002022022020022202202200000200020220022220000022022002000020002022220200220220222020022200002022222222002200020222020002222220200002202002020022220022022002220222220002022020022022202002002222020020022202200222200000200022002220202000200222200202020022002220202200022002000200002202020002022000</span></span><br><span class="line"><span class="number">022220000002200200202022000202222022202222222202022002222200022200222220020200222020002022222220022202000002220020220002022222022022002022202222222000022002020002202002022000022000202200000220200022200020220222000022202222000222222022202022222022200002202220222000202000200002220200000200202002202202</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构与算法</tag>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
</search>
